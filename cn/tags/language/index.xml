<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>language on</title><link>https://gohalo.github.io/cn/tags/language/</link><description>Recent content in language on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 09 Nov 2024 20:45:52 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/language/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 并行执行库 Rayon 详解</title><link>https://gohalo.github.io/cn/blog/rust-third-rayon/</link><pubDate>Sat, 09 Nov 2024 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-rayon/</guid><description/></item><item><title>Rust 高级语法之 PhantomData</title><link>https://gohalo.github.io/cn/blog/rust-advanced-phantomdata/</link><pubDate>Thu, 29 Aug 2024 23:45:55 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-phantomdata/</guid><description>&lt;p>这个名字很直接，幽灵数据，不过使用时经常会有些疑问。&lt;/p></description></item><item><title>Rust 调用 C 使用示例</title><link>https://gohalo.github.io/cn/blog/rust-ffi-rust-invoke-c/</link><pubDate>Mon, 24 Jun 2024 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-ffi-rust-invoke-c/</guid><description>&lt;p>简单介绍 Rust 调用 C 常用的示例代码。&lt;/p></description></item><item><title>C 调用 Rust 使用示例</title><link>https://gohalo.github.io/cn/blog/rust-ffi-c-invoke-rust/</link><pubDate>Thu, 20 Jun 2024 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-ffi-c-invoke-rust/</guid><description>&lt;p>整理 C 调用 Rust 时需要注意的事项。&lt;/p></description></item><item><title>Rust Pin Unpin 使用介绍</title><link>https://gohalo.github.io/cn/blog/rust-pin-introduce/</link><pubDate>Mon, 26 Feb 2024 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-pin-introduce/</guid><description/></item><item><title>人工神经网络</title><link>https://gohalo.github.io/cn/blog/artificial-neural-network/</link><pubDate>Tue, 13 Feb 2024 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/artificial-neural-network/</guid><description/></item><item><title>Rust Java JNI 调用简介</title><link>https://gohalo.github.io/cn/blog/rust-java-binding-jni/</link><pubDate>Fri, 26 Jan 2024 20:39:48 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-java-binding-jni/</guid><description>&lt;p>JNI 是 Java 提供的一套与其它语言相互调用的标准，主要是 C 语言，所以，从理论上只要支持 C ABI 的语言都可以和 Java 语言相互调用，而 Rust 就是其中之一。&lt;/p></description></item><item><title>SIMD Intrinsic 指令详细介绍</title><link>https://gohalo.github.io/cn/blog/simd-intrinsic-introduce/</link><pubDate>Sun, 24 Dec 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-intrinsic-introduce/</guid><description>&lt;p>不同的平台、CPU 支持的 SIMD 指令不同，这里简单整理使用过程中常用的技巧。&lt;/p></description></item><item><title>Rust Tokio 简介</title><link>https://gohalo.github.io/cn/blog/rust-async-tokio-introduce/</link><pubDate>Sat, 16 Dec 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-async-tokio-introduce/</guid><description>&lt;p>Tokio 是当前 Rust 异步编程使用最广泛的多线程解决方案，除了异步运行态，还包括了各种周边的实现，例如 HTTP 实现 hyper、gRPC 实现 tonic、trace 实现 tracing 等等。&lt;/p></description></item><item><title>SIMD 多平台动态转发</title><link>https://gohalo.github.io/cn/blog/simd-multi-version/</link><pubDate>Sun, 12 Nov 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-multi-version/</guid><description>&lt;p>对于 SIMD 优化来说，不同平台支持不同的指令，如果使用宏定义，那么必然会导致多个发行二进制版本，可以通过如下方式实现单个二进制发行包。&lt;/p></description></item><item><title>Rust 迭代器的生命周期管理</title><link>https://gohalo.github.io/cn/blog/rust-advanced-iterator-lifetime/</link><pubDate>Thu, 26 Oct 2023 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-iterator-lifetime/</guid><description>&lt;p>很多场景下可以通过迭代器简化代码编写。&lt;/p></description></item><item><title>Rust 序列化、反序列化实现</title><link>https://gohalo.github.io/cn/blog/rust-third-serde/</link><pubDate>Mon, 23 Oct 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-serde/</guid><description>&lt;p>Serde 是序列化和反序列化 Rust 数据结构的库，支持 JSON、BSON、YAML 等多种常用格式，并且可以自定义序列化和反序列化方式。&lt;/p></description></item><item><title>OpenTelemetry 标准详解</title><link>https://gohalo.github.io/cn/blog/monitor-opentelemetry-introduce/</link><pubDate>Sat, 21 Oct 2023 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/monitor-opentelemetry-introduce/</guid><description>&lt;p>OpenTelemetry, OTel 是一个中立开源的可观测性框架，用于仪表化、生成、收集和导出诸如跟踪、度量、日志等遥测数据。&lt;/p></description></item><item><title>Rust Trait 详解</title><link>https://gohalo.github.io/cn/blog/rust-advanced-syntax-trait/</link><pubDate>Mon, 16 Oct 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-syntax-trait/</guid><description>&lt;p>Rust 中的 Trait 有点像其它语言的接口，不过实际上略有不同。&lt;/p></description></item><item><title>Rust 宏编程详解</title><link>https://gohalo.github.io/cn/blog/rust-advanced-syntax-macro/</link><pubDate>Mon, 16 Oct 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-syntax-macro/</guid><description>&lt;p>也可以称为元数据编程，&lt;/p></description></item><item><title>SIMD 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/simd-basic-concept-introduce/</link><pubDate>Tue, 03 Oct 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-basic-concept-introduce/</guid><description/></item><item><title>Rust 异步流式编程详解</title><link>https://gohalo.github.io/cn/blog/rust-async-stream-program/</link><pubDate>Sat, 16 Sep 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-async-stream-program/</guid><description/></item><item><title>Rust 命令行参数解析库</title><link>https://gohalo.github.io/cn/blog/rust-third-clap/</link><pubDate>Sun, 10 Sep 2023 18:39:45 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-clap/</guid><description>&lt;p>当使用命令行时，参数管理通常比较复杂，尤其是随着子参数增多，通过 clap 三方库可以很方便进行管理。&lt;/p></description></item><item><title>Linux Perf 工具使用介绍</title><link>https://gohalo.github.io/cn/blog/performance-perf-introduce/</link><pubDate>Tue, 01 Aug 2023 22:19:04 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/performance-perf-introduce/</guid><description>&lt;p>Perf 全名是 Performance Event，在 Linux 2.6.31 以后内建的系统性能分析工具，由内核社区维护和发展，不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>Rust 生命周期管理</title><link>https://gohalo.github.io/cn/blog/rust-life-time/</link><pubDate>Thu, 15 Jun 2023 20:02:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-life-time/</guid><description>&lt;p>所有权 Ownership 是 Rust 的核心功能之一，使得 Rust 无需垃圾回收，却仍然可以保证内存安全。&lt;/p></description></item><item><title>Linux Trace 工具使用介绍</title><link>https://gohalo.github.io/cn/blog/performance-trace-introduce/</link><pubDate>Sun, 21 May 2023 22:19:04 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/performance-trace-introduce/</guid><description>&lt;p>这部分内容是内核 hacker 的最爱，能够支持 &lt;code>tracepoints&lt;/code>、&lt;code>kprobes&lt;/code>、&lt;code>uprobes&lt;/code> 等实现,提供了跟踪常见的一些能力，包括事件追踪, 可选择过滤器和参数; 事件计数和时间采样，内核概览；基于函数的路径追踪等。&lt;/p></description></item><item><title>SIMD 编译器优化</title><link>https://gohalo.github.io/cn/blog/simd-compiler-optimize/</link><pubDate>Sun, 23 Apr 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-compiler-optimize/</guid><description/></item><item><title>Rust 并发编程简介</title><link>https://gohalo.github.io/cn/blog/rust-concurrency-introduce/</link><pubDate>Sun, 26 Feb 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-concurrency-introduce/</guid><description>&lt;p>除了常规的多线程并发之外，同时还会介绍一些与 Rust 相关的并发编程技巧。&lt;/p></description></item><item><title>Rust 异步编程简介</title><link>https://gohalo.github.io/cn/blog/rust-async-program-introduce/</link><pubDate>Sun, 26 Feb 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-async-program-introduce/</guid><description>&lt;p>异步编程是一个并发编程模型，当前大部分语言都已经支持，只是实现方式略有不同。&lt;/p></description></item><item><title>CPU 硬件介绍</title><link>https://gohalo.github.io/cn/blog/concurrency-hardware-introduce/</link><pubDate>Sun, 19 Feb 2023 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-hardware-introduce/</guid><description>&lt;p>CPU 的发展因为受制于制造工艺和成本限制，CPU 的频率、内存的访问速度都没有太多质的突破，但是两者直接的访问处理速度相差越来越大。所以，目前在 CPU 和内存之间包含了多级缓存，用来提高 CPU 的处理速度。&lt;/p>
&lt;p>现在的多数 CPU 都集成了几层的 Cache ，为了维持与主存的关系，经常能够看到 2-ways 4-ways Cache，它是什么意思呢？Cache 和内存地址是怎么对应起来的呢？&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>SIMD 常用示例</title><link>https://gohalo.github.io/cn/blog/simd-some-examples/</link><pubDate>Thu, 12 Jan 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-some-examples/</guid><description/></item><item><title>PyTorch 使用简介</title><link>https://gohalo.github.io/cn/blog/python-pytorch-package-introduce/</link><pubDate>Tue, 13 Dec 2022 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-pytorch-package-introduce/</guid><description/></item><item><title>梯度下降算法</title><link>https://gohalo.github.io/cn/blog/math-gradient-descent-optimize-method/</link><pubDate>Tue, 13 Dec 2022 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-gradient-descent-optimize-method/</guid><description>梯度下降法 # 所谓的梯度实际上就是多元函数的 导数，对于 $n$ 元函数 $f(x_1,x_2, \cdots, x_n)$ 的梯度是一个长度为 $n$ 的向量，其中向量中第 $k$ 个元素为函数 $f$ 对 $x_k$ 的偏导数。
$$ \nabla f(x_1, x_2, \cdots, x_n) = \left( \frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, \cdots, \frac{\partial f}{\partial x_n} \right) $$
从几何意义上来说，这个向量的指向是函数变化最快的方向。
import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def Rosenbrock(x, y): return (1 - x) ** 2 + 100 * (y - x ** 2) ** 2 step = 0.</description></item><item><title>Tokio 源码解析</title><link>https://gohalo.github.io/cn/blog/rust-async-tokio-source-code/</link><pubDate>Sat, 10 Dec 2022 20:02:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-async-tokio-source-code/</guid><description>Runtime # 在使用时需要提供异步运行时环境，创建的任务会在这个环境里运行，可以选择单线程或者多线程，而且可以同时存在。对于 IO 类型任务建议使用多线程，但是多线程间的通信会变的复杂，从而加重了线程间切换的开销，可能导致某些场景下性能可能降低。
用户态的协程实现是基于协作时的调度策略，详细可以参考 Making the Tokio scheduler 10x faster 中的介绍。
在代码内部，会通过 scheduler::Handle::current() 获取当前 Handle 实现，相关代码调用逻辑如下。
// runtime/scheduler/mod.rs use crate::runtime::context; impl Handle { pub(crate) fn current() -&amp;gt; Handle { match context::with_current(Clone::clone) { Ok(handle) =&amp;gt; handle, Err(e) =&amp;gt; panic!(&amp;#34;{}&amp;#34;, e), } } } // runtime/context/current.rs pub(crate) fn with_current&amp;lt;F, R&amp;gt;(f: F) -&amp;gt; Result&amp;lt;R, TryCurrentError&amp;gt; where F: FnOnce(&amp;amp;scheduler::Handle) -&amp;gt; R, { match CONTEXT.try_with(|ctx| ctx.current.handle.borrow().as_ref().map(f)) { Ok(Some(ret)) =&amp;gt; Ok(ret), Ok(None) =&amp;gt; Err(TryCurrentError::new_no_context()), Err(_access_error) =&amp;gt; Err(TryCurrentError::new_thread_local_destroyed()), } } 其中 CONTEXT 是一个 TLS 变量，会在 runtime.</description></item><item><title>RCU 详解</title><link>https://gohalo.github.io/cn/blog/concurrency-rcu-introduce/</link><pubDate>Mon, 05 Dec 2022 19:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-rcu-introduce/</guid><description>&lt;p>RCU 的本质是用空间换时间，是对读写锁的一种优化加强。&lt;/p></description></item><item><title>原子操作使用介绍</title><link>https://gohalo.github.io/cn/blog/concurrency-atomic-operation/</link><pubDate>Mon, 05 Dec 2022 19:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-atomic-operation/</guid><description>&lt;p>实际上目前大部分的语言都提供了原子操作的能力，包括了 GoLang、JAVA、C/C++、Rust 等等，当然这些能力大部分都需要硬件平台的支撑。&lt;/p>
&lt;p>这里简单介绍 GCC 以及 C/C++ 中提供的一些原子操作指令。&lt;/p></description></item><item><title>Python 调用动态库</title><link>https://gohalo.github.io/cn/blog/python-dynamic-library-usage/</link><pubDate>Sun, 27 Nov 2022 18:39:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-dynamic-library-usage/</guid><description>&lt;p>通过 Python 可以直接调用动态库，通常有两种方式，使用 ctypes 进行封装，还可以对 C/C++ 库直接封装成动态库，这样可以直接使用。&lt;/p>
&lt;p>这里不再介绍 ctypes 的相关使用，详细介绍下如何直接使用动态库。&lt;/p></description></item><item><title>CRC 循环校验详解</title><link>https://gohalo.github.io/cn/blog/crc-basic-introduce/</link><pubDate>Sun, 20 Nov 2022 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/crc-basic-introduce/</guid><description>&lt;p>Cyclic Redundancy Check, CRC 循环冗余校验，通常用于网络、文件等校验，校验码的长度固定，而且从检错的正确率与速度成本之间比较好的平衡，使其称为当前最常见的数据校验方式。&lt;/p></description></item><item><title>Rust Chrono</title><link>https://gohalo.github.io/cn/blog/rust-third-chrono/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-chrono/</guid><description/></item><item><title>Rust 常用日志三方库介绍</title><link>https://gohalo.github.io/cn/blog/rust-third-log/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-log/</guid><description>&lt;p>类似于 JAVA 中的 &lt;code>slf4j&lt;/code> 库，Rust 中对应了 &lt;code>log&lt;/code> 库，其提供了基本的标准接口，由官方进行维护，这里简单介绍。&lt;/p></description></item><item><title>Thrift 简介</title><link>https://gohalo.github.io/cn/blog/thrift-format-introduce/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/thrift-format-introduce/</guid><description/></item><item><title>Cargo 包管理工具</title><link>https://gohalo.github.io/cn/blog/rust-cargo-package-management/</link><pubDate>Wed, 26 Oct 2022 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-cargo-package-management/</guid><description>&lt;p>Rust 提供了 Cargo 的构建系统和软件包管理器，可以用来构建代码、下载库或依赖项等等，在安装 Rust 时会同时安装 Cargo 相关的程序。&lt;/p>
&lt;p>这里详细介绍 Cargo 的使用方式。&lt;/p></description></item><item><title>GoLang 常用模块</title><link>https://gohalo.github.io/cn/blog/golang-basic-module/</link><pubDate>Wed, 26 Oct 2022 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-module/</guid><description>&lt;p>简单介绍常见的模块，例如 fmt、unsafe、signal、container 等。&lt;/p></description></item><item><title>线程本地变量介绍</title><link>https://gohalo.github.io/cn/blog/concurrency-thread-local-storage/</link><pubDate>Fri, 21 Oct 2022 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-thread-local-storage/</guid><description>在多线程程序中，所有线程共享程序中的变量，对于全局变量，所有线程都可以访问修改，如果希望么个线程单独使用，那么就需要 Thread Local Storage, TLS 了。
简言之，表面是一个全局变量，所有线程都可以使用它，而实际实现时，它的值在每一个线程中又是单独存储的。
示例 # TSD 的使用方法简单介绍如下：
声明一个类型为 pthread_key_t 类型的全局变量，后续所有的操作都会用到该变量； 在创建线程前调用 pthread_key_create() 创建该变量，入参为上面的变量以及清理函数(为 NULL 时调用默认的清理函数)； 启动线程，在不同的线程中分别通过 pthread_setspcific() 和 pthread_getspecific() 函数设置以及获取变量。 使用的函数声明如下。
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*)); int pthread_setspecific(pthread_key_t key, const void *value); void *pthread_getspecific(pthread_key_t key); 如下是一个简单示例。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; pthread_key_t key; struct test_struct { // 用于测试的结构 int i; float k; }; void *child1(void *arg) { struct test_struct struct_data; struct_data.i = 10; struct_data.</description></item><item><title>Rust Iced 使用详解</title><link>https://gohalo.github.io/cn/blog/rust-third-iced/</link><pubDate>Wed, 19 Oct 2022 23:49:58 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-iced/</guid><description/></item><item><title>原子操作内存序介绍</title><link>https://gohalo.github.io/cn/blog/concurrency-atomic-memory-order/</link><pubDate>Sat, 01 Oct 2022 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-atomic-memory-order/</guid><description>&lt;p>当多个线程同时访问一个变量时，会导致数据竞争问题，会导致结果未定义。而且从实现来说，即时是一条语句，从硬件层面仍不能保证读写操作是原子的，例如变量在寄存器中，修改后才写入内存。&lt;/p>
&lt;p>通常使用的是 Mutex 操作，不过常用的还有原子操作。&lt;/p></description></item><item><title>Rust 高级语法</title><link>https://gohalo.github.io/cn/blog/rust-advanced-syntax/</link><pubDate>Thu, 29 Sep 2022 23:45:55 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-syntax/</guid><description>&lt;p>这里简单介绍基本常用的语法。&lt;/p></description></item><item><title>BoltDB 数据库详细介绍</title><link>https://gohalo.github.io/cn/blog/golang-boltdb-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-boltdb-introduce/</guid><description>&lt;p>ETCD 后端存储采用的是 BBolt 存储引擎，其前身是 BoltDB ，这是一款 golang 实现的嵌入式 KV 存储引擎，参考的是 LMDB，支持事务、ACID、MVCC、ZeroCopy、BTree等特性。&lt;/p></description></item><item><title>CrossTerm 使用详解</title><link>https://gohalo.github.io/cn/blog/rust-third-crossterm/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-crossterm/</guid><description/></item><item><title>Rust 基本语法</title><link>https://gohalo.github.io/cn/blog/rust-basic-syntax/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-basic-syntax/</guid><description>&lt;p>这里简单介绍基本常用的语法。&lt;/p></description></item><item><title>Rust 字符串详解</title><link>https://gohalo.github.io/cn/blog/rust-string-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-string-introduce/</guid><description>&lt;p>很多语言中的字符串非常简单，但 Rust 与常规的语言有所区别。&lt;/p></description></item><item><title>Rust 常用特征详解</title><link>https://gohalo.github.io/cn/blog/rust-advanced-some-trait/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-some-trait/</guid><description/></item><item><title>Rust 智能指针</title><link>https://gohalo.github.io/cn/blog/rust-smart-pointer-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-smart-pointer-introduce/</guid><description>&lt;p>Rust 中有所有权的概念，常见的赋值、函数传参、函数返回值等场景，都可能会发生所有权的转移，而某些场景下，只是想使用一下，所以就有了引用。&lt;/p></description></item><item><title>Rust 类型转换</title><link>https://gohalo.github.io/cn/blog/rust-type-conversion-cast/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-type-conversion-cast/</guid><description/></item><item><title>Rust 中的错误处理</title><link>https://gohalo.github.io/cn/blog/rust-handle-error/</link><pubDate>Fri, 16 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-handle-error/</guid><description>&lt;p>Rust 中将错误分成了正常的业务错误 Resut 以及崩溃 panic 处理。&lt;/p></description></item><item><title>GoLang 国际化</title><link>https://gohalo.github.io/cn/blog/golang-i18n-introduce/</link><pubDate>Fri, 17 Jun 2022 23:19:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-i18n-introduce/</guid><description>简介 # 有两个容易混淆的概念：A) 本地化 L10n，将软件翻译为本地语言的过程，通常是翻译人员的职责；B) 国际化 i18n，使得软件可以被本地化，通常是开发人员的职责。
代码中有很多需要与人交互的内容，一般需要做一些国际化的处理，通常步骤如下：
从源码中获取需要翻译的字符串。 翻译字符串，有很多的平台支持，甚至有些是免费的。 应用已经翻译的字符串，可以是通过数据库、配置文件方式读取，也可以编译成二进制甚至生成代码。 使用已经翻译字符，包括了 Web 使用 Accept-Language 以及主机上的 LANGUAGE 环境变量。 实际上已经有个 https://golang.org/x/text 代码包支持，官方声明如下。
a repository of text-related packages related to internationalization (i18n) and localization (l10n) 。
其中的 message 库主要用于上述的步骤三，以类似 fmt 的接口来输出已经翻译的字符串，如下是简单示例。
package main import ( &amp;#34;golang.org/x/text/message&amp;#34; &amp;#34;golang.org/x/text/language&amp;#34; ) func main() { p := message.NewPrinter(language.BritishEnglish) p.Printf(&amp;#34;There are %v flowers in our garden.\n&amp;#34;, 1500) p = message.NewPrinter(language.Greek) p.Printf(&amp;#34;There are %v flowers in our garden.</description></item><item><title>Rust 模块文件配置</title><link>https://gohalo.github.io/cn/blog/rust-module-introduce/</link><pubDate>Sat, 16 Apr 2022 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-module-introduce/</guid><description/></item><item><title>Rust 测试</title><link>https://gohalo.github.io/cn/blog/rust-testing-introduce/</link><pubDate>Sat, 16 Apr 2022 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-testing-introduce/</guid><description>&lt;p>Rust 支持常规的单元测试、集成测试等，甚至还支持文档测试。&lt;/p></description></item><item><title>Rust 模式匹配详解</title><link>https://gohalo.github.io/cn/blog/rust-syntax-match/</link><pubDate>Tue, 29 Mar 2022 23:05:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-syntax-match/</guid><description>&lt;p>在 Rust 中没有 &lt;code>switch&lt;/code> 语句，但是提供了匹配器 &lt;code>matcher&lt;/code>，相比其它语言中的 &lt;code>switch&lt;/code> 要更强大。&lt;/p></description></item><item><title>Linux Core 文件详细介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-core-introduce/</link><pubDate>Thu, 17 Mar 2022 22:19:04 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-core-introduce/</guid><description>Core 文件又称为 Core Dump 文件，对于线上的服务而言，也就意味着进程异常；而且，如果进程占用内存很大，但是 dump 到磁盘上，也会花很长时间。
当然，Core 虽然会终止掉当前进程，但是也会保留下第一手的现场数据，包括了进程被终止时内存、CPU寄存器等信息，可以供后续开发人员进行调试。
接下来，看看 MySQL 中 Core 文件的处理。
简介 # 在开发一个程序时，程序可能会在运行过程中异常终止或者崩溃，这时操作系统就会把程序挂掉时的内存状态记录下来，并写入一个叫做 Core 的文件中，这种行为就叫做 Core Dump 操作，通过这个文件可以方便的进行调试。
在使用半导体作为内存的材料前，人类使用的是线圈作为内存的材料，线圈叫做 Core，用线圈制作的内存就是 Core Memory。
除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息 (包括程序指针、栈指针等)、内存管理信息、其他处理器和操作系统状态和信息；而这些信息对于编程人员诊断和调试程序是非常有帮助。
A core dump is the recorded state of the working memory of a computer program at a specific time, generally when the program has terminated abnormally (crashed). In practice, other key pieces of program state are usually dumped at the same time, including the processor registers, which may include the program counter and stack pointer, memory management information, and other processor and operating system flags and information.</description></item><item><title>Rust 常用标准库介绍</title><link>https://gohalo.github.io/cn/blog/rust-standard-library/</link><pubDate>Sat, 19 Feb 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-standard-library/</guid><description/></item><item><title>Rust 安装部署以及版本管理</title><link>https://gohalo.github.io/cn/blog/rust-basic-introduce/</link><pubDate>Wed, 26 Jan 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-basic-introduce/</guid><description/></item><item><title>字符编码详解</title><link>https://gohalo.github.io/cn/blog/charsets-encoding/</link><pubDate>Wed, 26 Jan 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/charsets-encoding/</guid><description>&lt;p>是不是还分不清什么是字符集，什么是编码，两者到底有什么区别？ 什么是 GB2312、GB18030、BIG5？ Unicode 和 UTF-8、UTF-16、UTF-32 到底什么关系？ BMP、UCS、emoji 又是什么？ 为什么会出现乱码？&lt;/p>
&lt;p>OK，接下来我们介绍一下他们之间剪不断理还乱的关系 &amp;hellip; &amp;hellip;&lt;/p></description></item><item><title>Bash 使用常见错误以及规避措施</title><link>https://gohalo.github.io/cn/blog/bash-pitfalls/</link><pubDate>Tue, 04 Jan 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-pitfalls/</guid><description>&lt;p>简单介绍下 Linux 中 Bash 编程所需要注意的内容，以及常见的规避措施。&lt;/p></description></item><item><title>Rust 与不同语言调用</title><link>https://gohalo.github.io/cn/blog/rust-external-ffi/</link><pubDate>Sat, 18 Sep 2021 20:02:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-external-ffi/</guid><description>&lt;p>简单介绍 Rust 和 C 之间的相互代码调用。&lt;/p></description></item><item><title>Rust 内存管理</title><link>https://gohalo.github.io/cn/blog/rust-memory-manage/</link><pubDate>Sat, 18 Sep 2021 20:02:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-memory-manage/</guid><description>&lt;p>Rust 中的内存管理跟其它语言基本类似，提供了浅复制和深复制两种方式，使用时略有区别，这里简单介绍。&lt;/p></description></item><item><title>Java 常用工具详解</title><link>https://gohalo.github.io/cn/blog/java-tools-introduce/</link><pubDate>Sun, 29 Aug 2021 20:38:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/java-tools-introduce/</guid><description>&lt;p>Java 安装包中除了 JVM 虚拟机之外，还提供了一些常用的命令行，这里简单介绍常用的命令。&lt;/p></description></item><item><title>树状数组详解</title><link>https://gohalo.github.io/cn/blog/binary-indexed-tree/</link><pubDate>Sun, 23 May 2021 17:30:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/binary-indexed-tree/</guid><description>&lt;p>树状数组 Binary Indexed Tree 或以作者名字命名为 Fenwick Tree，最早由 Peter M. Fenwick 在 1994 年发表的 &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8917">A New Data Structure for Cumulative Frequency Tables&lt;/a>，起初是为了解决 Cumulative Frequency 的计算，现在也用于高效计算数列的前缀和、区间和。&lt;/p>
&lt;p>这里详细介绍其原理以及实现方式。&lt;/p></description></item><item><title>Python 打包详解</title><link>https://gohalo.github.io/cn/blog/python-package-distribute/</link><pubDate>Sat, 03 Apr 2021 20:49:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-package-distribute/</guid><description>&lt;p>之前介绍了如何通过 &lt;code>pip&lt;/code> 安装包，主要是以用户的角度介绍，这里则从开发角度介绍如何打包、分发。&lt;/p></description></item><item><title>Casbin 使用详细介绍</title><link>https://gohalo.github.io/cn/blog/casbin-access-control/</link><pubDate>Sun, 14 Feb 2021 22:39:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/casbin-access-control/</guid><description>&lt;p>Casbin 是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型，注意，其只负责权限控制，没有用户管理的实现。&lt;/p></description></item><item><title>Java 常用技巧</title><link>https://gohalo.github.io/cn/blog/java-some-tips/</link><pubDate>Tue, 26 Jan 2021 20:39:48 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/java-some-tips/</guid><description>&lt;p>这里总结一些常用的技巧。&lt;/p></description></item><item><title>Rust PyO3 使用</title><link>https://gohalo.github.io/cn/blog/rust-python-binding-pyo3/</link><pubDate>Tue, 26 Jan 2021 20:39:48 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-python-binding-pyo3/</guid><description>&lt;p>Python 有强于 Bash 的语法检查，但是，不适合一些高性能的场景，所以，很多时候会作为胶水语言使用。而且，由于 CPython 作为事实标准，使得其兼容 C/C++ 要容易的多，所以，通常高性能场景下会通过 C/C++ 进行重构。&lt;/p>
&lt;p>这里介绍 Python 如何调用 Rust 的实现。&lt;/p></description></item><item><title>Python 包管理机制详解介绍</title><link>https://gohalo.github.io/cn/blog/python-package-management/</link><pubDate>Sun, 20 Dec 2020 19:59:28 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-package-management/</guid><description>&lt;p>Python 中可以通过 PIP 来自动管理依赖包，当然，也可以下载源码或者二进制包，有些源码包需要编译环境，最好直接下载安装二进制包。&lt;/p></description></item><item><title>Rust 结构体详解</title><link>https://gohalo.github.io/cn/blog/rust-syntax-structure-details/</link><pubDate>Thu, 26 Nov 2020 20:49:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-syntax-structure-details/</guid><description>&lt;p>结构体是 Rust 中最常用的，同样使用起来也相对更加复杂。&lt;/p></description></item><item><title>在 Python 中如何连接 MySQL 数据库</title><link>https://gohalo.github.io/cn/blog/python-third-package-mysql/</link><pubDate>Mon, 23 Nov 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-third-package-mysql/</guid><description>&lt;p>在 Python 中多种方式可以访问 MySQL 服务端，这里介绍几种常用的库。&lt;/p></description></item><item><title>C++ 命令行解析包 gflags 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-gflags-usage/</link><pubDate>Sun, 22 Nov 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-gflags-usage/</guid><description>&lt;p>gflags 是 Google 提供的一个命令行参数处理的开源库，目前已经独立开源，比传统的 &lt;code>getopt()&lt;/code> 功能更加强大，可以将不同的参数定义分布到各个源码文件中，不需要集中管理。&lt;/p>
&lt;p>提供了 C++ 和 Python 两个版本，这里仅详细介绍 C++ 版本的使用方式。&lt;/p></description></item><item><title>详细介绍 C++ 的强制转换方法</title><link>https://gohalo.github.io/cn/blog/cpp-cast-methods-introduce/</link><pubDate>Fri, 20 Nov 2020 23:18:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-cast-methods-introduce/</guid><description>&lt;p>在 C 中提供了强制类型转换，不过其实现很简单，而且没有区分具体的使用场景，所以，在编译或者运行阶段可能会出现一些异常，尤其是一旦不注意极易发生异常。&lt;/p>
&lt;p>为此，C++ 对于不同的场景进行了划分，由于 C++ 支持面向对象编程，也因此对这一场景进行了优化。&lt;/p>
&lt;p>本文详细介绍其使用场景。&lt;/p></description></item><item><title>关于 Python 函数声明以及调用方式</title><link>https://gohalo.github.io/cn/blog/python-parameter-methods/</link><pubDate>Fri, 13 Nov 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-parameter-methods/</guid><description>&lt;p>Python 提供了非常灵活的参数声明以及调用方式，除了最常用的位置参数，还包括了默认值以及关键词匹配方式，而且对于列表、字典很方便展开。&lt;/p>
&lt;p>这里详细介绍 Python 的参数声明、调用方式。&lt;/p></description></item><item><title>终端音乐播放器 CMUS 详细介绍</title><link>https://gohalo.github.io/cn/blog/cmus-music-player/</link><pubDate>Tue, 03 Nov 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmus-music-player/</guid><description>&lt;p>CMUS 是一个可以在终端上使用的音乐播放器，可以运行在多数类 Unix 的系统上，例如 Linux、Unix、Mac 等，而且支持绝大多数格式的音乐文件。&lt;/p>
&lt;p>不过目前已经不再维护了，这里详细介绍其使用方法。&lt;/p></description></item><item><title>Python With 语句详细介绍</title><link>https://gohalo.github.io/cn/blog/python-basic-syntax-with/</link><pubDate>Fri, 30 Oct 2020 22:48:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-basic-syntax-with/</guid><description>&lt;p>通常会有一些任务，开始需要进行设置，处理任务，事后做清理工作，对于这种场景，Python 的 with 语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。&lt;/p>
&lt;p>这里详细介绍其实现的内部原理。&lt;/p></description></item><item><title>详细介绍 glibc 特性宏的使用</title><link>https://gohalo.github.io/cn/blog/glibc-feature-macros-usage/</link><pubDate>Fri, 23 Oct 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/glibc-feature-macros-usage/</guid><description>&lt;p>GNU C Library 也就是 glibc 库，是目前 Linux 上最为基本的 C 语言库，不过其实现的不只是标准的 C 定义，还包括了其它的一些标准协议，不同场景下用户可以使用不同的接口。&lt;/p>
&lt;p>这些特性的开启都是通过宏来实现的，这里详细介绍其使用方式。&lt;/p></description></item><item><title>C++ Mock 工具 gmock 使用</title><link>https://gohalo.github.io/cn/blog/cpp-gmock-usage/</link><pubDate>Fri, 25 Sep 2020 19:30:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-gmock-usage/</guid><description>&lt;p>所谓的 mock 方法，是单元测试中常见的一种测试方式，用来模拟对象、隔离边界等，例如单元测试时模拟三方接口，这样服务可以独立测试；开发阶段不需要依赖其它类的开发进度等等。&lt;/p>
&lt;p>在 C++ 中，比较常用的是 Google 的 GMock 工具，可以用来模拟构造接口，并返回 mock 数据。&lt;/p>
&lt;p>这里我们从一个简单的示例开始，一步步详细介绍其使用方法，以及一些常用的技巧。&lt;/p></description></item><item><title>C++ 单测工具 gtest 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-google-test-introduce/</link><pubDate>Wed, 16 Sep 2020 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-google-test-introduce/</guid><description>&lt;p>这是 Google 提供的一个跨平台的测试、Mock 框架，很简单几乎没有依赖，但是提供了丰富的断言机制，尤其是提供了大部分其它语言测试框架没有的死亡测试。&lt;/p>
&lt;p>这里就详细介绍如何使用这一单元测试工具。&lt;/p></description></item><item><title>离散化数组介绍</title><link>https://gohalo.github.io/cn/blog/discretization-array/</link><pubDate>Mon, 10 Aug 2020 21:38:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/discretization-array/</guid><description>&lt;p>有时候需要用数组的值作为下标，有可能会是一个很大的值，那么就导致内存中保存不了，但实际上数组大小是有限的，那么此时就可以通过数组离散化进行处理。&lt;/p>
&lt;p>简单来说，离散化关心的是相对大小，而不是某个数具体多大。&lt;/p></description></item><item><title>GoLang INI 配置文件解析</title><link>https://gohalo.github.io/cn/blog/golang-ini-config-parse/</link><pubDate>Sun, 09 Aug 2020 21:59:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-ini-config-parse/</guid><description>&lt;p>INI 是 Initialization File 的缩写，也就是初始化文件，原来是 Windows 系统配置文件所采用的存储格式，不过因为其使用简单，所以后来被广泛应用。&lt;/p>
&lt;p>这里介绍如何通过 GoLang 解析。&lt;/p></description></item><item><title>Python 内置模块和内置命名空间介绍</title><link>https://gohalo.github.io/cn/blog/python-builtins-module-and-builtin-namespace/</link><pubDate>Sat, 01 Aug 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-builtins-module-and-builtin-namespace/</guid><description>&lt;p>在 CPython 的实现中有一个内置的 &lt;code>builtins&lt;/code> 模块，同时还包含了一个内置的命名空间，其 Key 被称为 &lt;code>__builtins__&lt;/code>，两者在查找时会相互关联，不过在不同模块中实现又不相同。&lt;/p>
&lt;p>这里详细介绍其区别。&lt;/p></description></item><item><title>GoLang WebSocket 编程</title><link>https://gohalo.github.io/cn/blog/golang-websocket-program/</link><pubDate>Tue, 28 Jul 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-websocket-program/</guid><description/></item><item><title>Bash 命令注入以及预防策略</title><link>https://gohalo.github.io/cn/blog/bash-security-commands-injection/</link><pubDate>Wed, 08 Jul 2020 19:18:35 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-security-commands-injection/</guid><description>&lt;p>所谓的命令注入，简单来说，就是利用任何会调用系统命令的应用，通过构造特殊命令字符串的方式，执行恶意代码。常见的例如 SQL 命令注入、页面命令注入等。&lt;/p>
&lt;p>这里介绍一下 Bash 的命令注入以及预防策略。&lt;/p></description></item><item><title>树基本介绍</title><link>https://gohalo.github.io/cn/blog/structure-tree/</link><pubDate>Tue, 16 Jun 2020 18:43:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-tree/</guid><description>&lt;p>通过树可以用来描述层级结构数据，基本上有序列的地方就可以应用树，因为树结构即是一种序列索引结构。&lt;/p>
&lt;p>这里简单介绍常见的树结构。&lt;/p></description></item><item><title>浮点数的前世今生</title><link>https://gohalo.github.io/cn/blog/computer-floating-point-introduce/</link><pubDate>Mon, 08 Jun 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/computer-floating-point-introduce/</guid><description>&lt;p>在计算机中，所有的信息都是通过二进制进行保存的，对于浮点数也不例外，但是，因为字节长度有限，这样就很难保证能表示所有的实数。&lt;/p>
&lt;p>这也就是造成了 &lt;code>0.1 + 0.2&lt;/code> 的结果不太符合预期，这里一步步介绍这一问题产生的原因。&lt;/p></description></item><item><title>Lua 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/lua-basic-introduce/</link><pubDate>Thu, 30 Apr 2020 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-basic-introduce/</guid><description>&lt;p>Lua 历史可以从 1993 年开始，到现在为止，在很多场景都可以看到 Lua 的影子，如游戏开发、Web 应用脚本、安全系统插件等，像常见的 nmap、sysbench 等程序。&lt;/p>
&lt;p>这里简单介绍 Lua 的安装使用。&lt;/p></description></item><item><title>React Router Dom V6 使用详解</title><link>https://gohalo.github.io/cn/blog/react-router-dom-introduce/</link><pubDate>Sun, 15 Mar 2020 22:10:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/react-router-dom-introduce/</guid><description>&lt;p>现在的网页，不同于之前的全页面刷新，一般会采用局部刷新，用户不会感知，看起来实际上只有一个页面，所以也被称为 &amp;ldquo;单页应用&amp;rdquo; (Single Page Appliaction) 。&lt;/p></description></item><item><title>React 项目实战</title><link>https://gohalo.github.io/cn/blog/react-practice-examples/</link><pubDate>Fri, 06 Mar 2020 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/react-practice-examples/</guid><description/></item><item><title>PyCharm 常用设置</title><link>https://gohalo.github.io/cn/blog/pycharm-settings/</link><pubDate>Fri, 06 Mar 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/pycharm-settings/</guid><description>&lt;p>PyCharm 是 JetBrains 打造的一款 Python IDE 跨平台的 IDE ，当然，还有其它语言的 IDE ，快捷键十分相似。&lt;/p>
&lt;p>这里简单介绍下 PyCharm 相关的一些常用配置。&lt;/p></description></item><item><title>GoLang Echo 简介</title><link>https://gohalo.github.io/cn/blog/golang-echo-http-framework/</link><pubDate>Thu, 05 Mar 2020 22:28:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-echo-http-framework/</guid><description>&lt;p>echo web 框架是通过 GoLang 开发的一种高性能、可扩展、轻量级的 web 框架，只包含了 MVC 框架的 C 部分，也就是负责 URL 路由和控制器部分，对于 V 视图和 M 数据操作可以使用自己喜欢的工具库来实现。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Breakpad 崩溃状态信息收集</title><link>https://gohalo.github.io/cn/blog/cpp-google-breakpad-introduce/</link><pubDate>Tue, 25 Feb 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-google-breakpad-introduce/</guid><description>&lt;p>一个跨平台的 Crash 状态采集工具，相对 Linux 中的 CoreDump 文件来说，采集的内容更小。&lt;/p></description></item><item><title>Python 命名空间和作用域介绍</title><link>https://gohalo.github.io/cn/blog/python-namespace-scope/</link><pubDate>Mon, 24 Feb 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-namespace-scope/</guid><description>&lt;p>在 Python 中，一切皆对象，命名空间实际是一个名称到对象的映射，另外，虽然 Python 是一种动态类型的语言，但是静态作用域语言，变量使用与作用域相关。&lt;/p>
&lt;p>这里详细介绍命名空间和作用域的关系。&lt;/p></description></item><item><title>详细介绍 Python 闭包以及装饰器</title><link>https://gohalo.github.io/cn/blog/python-decorator-closure/</link><pubDate>Thu, 20 Feb 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-decorator-closure/</guid><description>&lt;p>装饰器可以为 Python 提供一些修饰工作，所谓修饰工作就是想给现有的模块加上一些小功能，但又不让这个小功能侵入到原有的模块中的代码里去，最常见的三种函数修饰器 &lt;code>@staticmethod&lt;/code>、&lt;code>@classmethod&lt;/code> 和 &lt;code>@property&lt;/code> ，都是 Python 的内置函数。&lt;/p>
&lt;p>这里详细介绍其使用方式。&lt;/p></description></item><item><title>Python 变量基本概念详解</title><link>https://gohalo.github.io/cn/blog/python-variables-bind/</link><pubDate>Wed, 05 Feb 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-variables-bind/</guid><description>&lt;p>在 Python 中，所有的都是对象，变量与大部分常用语言有所区别，赋值的时候，严格来说不是赋值，而是变量的绑定，变量名称中并没有保存对象，而更像是在对象上添加了一个标签而已。&lt;/p>
&lt;p>这里简单介绍下 Python 中与变量相关的基本概念。&lt;/p></description></item><item><title>Python 日志使用详解</title><link>https://gohalo.github.io/cn/blog/python-third-package-logging/</link><pubDate>Thu, 30 Jan 2020 23:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-third-package-logging/</guid><description>&lt;p>用 Python 写代码时，经常需要打印日志，其实内部提供了一个灵活的 logging 模块，基本可以满足绝大部分的需求，如下简单介绍其使用方式。&lt;/p></description></item><item><title>Linux Capabilites 机制详细介绍</title><link>https://gohalo.github.io/cn/blog/linux-security-capabilities/</link><pubDate>Sat, 18 Jan 2020 21:39:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-security-capabilities/</guid><description>&lt;p>在 Linux 系统中，有些操作是需要 root 用户权限才能操作的，常见的包括 chown、使用 Raw Sokcet (ping) 等，如果使用 sudo 就会导致配置管理和权限控制比较麻烦。&lt;/p>
&lt;p>为了只给这个程序开所需要的权限，Linux 提供了一套 capabilities 机制，这里详细介绍。&lt;/p></description></item><item><title>C++ 智能指针</title><link>https://gohalo.github.io/cn/blog/cpp-smart-pointer-introduce/</link><pubDate>Wed, 15 Jan 2020 22:26:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-smart-pointer-introduce/</guid><description>类似于 C 语言，C++ 中申请的对象也需要手动释放，不像 Java GoLang 这类的语言，有自己的垃圾回收机制 (C++中有相关的实现，但非标准) ，这样 C++ 程序员需要重点关注内存的申请和释放，否则可能会导致内存泄漏。
为了解决 C++ 内存泄漏问题，在 C++11 中引入了智能指针 (Smart Pointer)，在一定程度上减轻了对内存的管理。
简介 # 例如对于如下的函数，如果没有显示的调用 delete(p) 函数，那么就会造成内存泄漏。
#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;iostream&amp;gt; class Rectangle { private: double width, height; }; void foobar(void) { Rectangle *p = new Rectangle(); //delete(p); } int main(void) { while (1) { foobar(); sleep(1); } } 而智能指针实际上就是为了解决上述的问题。
基本使用 # 一个栈上创建的对象，在退出栈的作用域之后，该对象会自动销毁，而智能指针就是使用的这一原理。创建一个智能指针保存申请好的内存地址，当程序退出作用域的时候，对应的智能指针被自动销毁，同时会释放其指向的内存。
在 C++11 中提供了三种智能指针 std::shared_ptr std::unique_ptr std::weak_ptr ，定义在头文件 &amp;lt;memory&amp;gt; 中，分别用于不同的场景中。
unique_ptr # 指向一个唯一的对象，该对象可以 move 但是不能进行赋值。</description></item><item><title>Python 常用模块</title><link>https://gohalo.github.io/cn/blog/python-third-package-others/</link><pubDate>Fri, 03 Jan 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-third-package-others/</guid><description/></item><item><title>一致性模型详解</title><link>https://gohalo.github.io/cn/blog/concurrency-consistent-models-introduce/</link><pubDate>Mon, 30 Dec 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-consistent-models-introduce/</guid><description>&lt;p>现实生活中，对于一个系统的组成会经常发生网络分区、消息丢失、发送延迟、消息重复、消息乱序等等，造成这一问题的原因有很多，包括光纤、交换机、网卡、主机硬件、操作系统、磁盘、虚拟化层、程序等等，都可能会出现各种各样的问题。&lt;/p>
&lt;p>此时就需要有一个比较直观的正确性模型，包括如何定义、描述。&lt;/p></description></item><item><title>C++ 右值引用</title><link>https://gohalo.github.io/cn/blog/cpp-right-value-reference/</link><pubDate>Fri, 20 Dec 2019 21:18:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-right-value-reference/</guid><description>&lt;p>在 C++11 的新特性中增加了所谓的右值引用的支持，其主要目的是为了解决两个问题：A) 临时对象非必要的拷贝操作；B) 在模板函数中如何按照参数的实际类型进行转发。&lt;/p>
&lt;p>同时，和右值引用相关的概念比较多，包括了纯右值、将亡值、Universal References、引用折叠、移动语义、Move语义和完美转发等等，这里简单介绍。&lt;/p></description></item><item><title>React 基本介绍</title><link>https://gohalo.github.io/cn/blog/react-basic-introduce/</link><pubDate>Wed, 20 Nov 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/react-basic-introduce/</guid><description>&lt;p>React 是一个用于构建用户界面的 JavaScript 库，起源于 Facebook 内部项目，最初用来架设 Instagram 的网站，并于 2013 年 5 月开源，以声明式、组件化的特性让编写代码变得简单，而且性能很高。&lt;/p>
&lt;p>另外，React 不仅可以用来开发 Web 应用，还能开发移动应用。&lt;/p></description></item><item><title>二分查找详解 (闭区间)</title><link>https://gohalo.github.io/cn/blog/algorithm-binary-search-other/</link><pubDate>Wed, 20 Nov 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-binary-search-other/</guid><description>&lt;p>之前的文章已经详细介绍了二分查找，不过使用的是闭区间，这里再介绍一下开区间的实现细节，两种方法基本没有区别，可以选择其中一个。&lt;/p></description></item><item><title>二分查找详解</title><link>https://gohalo.github.io/cn/blog/algorithm-binary-search/</link><pubDate>Wed, 20 Nov 2019 19:58:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-binary-search/</guid><description>&lt;p>二分查找 (Binary Search) 是一种效率较高的查找方法，不过其对保存的数据有所要求，数据需要线性顺序存储，同时需要保证数据是有序排列的。&lt;/p>
&lt;p>虽然二分查找的思路很简单，却有很多的细节问题，如整型溢出、边界的递进等等，这里详细介绍其使用方法。&lt;/p></description></item><item><title>C++ 可调用对象</title><link>https://gohalo.github.io/cn/blog/cpp-basic-callable-introduce/</link><pubDate>Tue, 12 Nov 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-basic-callable-introduce/</guid><description>&lt;p>在 C++11 之前，可调用对象包括了函数、函数指针以及重载 &lt;code>operator()&lt;/code> 运算符的对象；而在 C++11 之后，新增了 &lt;code>lambda&lt;/code> 表达式以及 &lt;code>bind()&lt;/code> 返回值，同时，引入了新的 &lt;code>function&lt;/code> 类型，用来统一可调用对象。&lt;/p></description></item><item><title>gRPC 源码解析</title><link>https://gohalo.github.io/cn/blog/golang-grpc-source-code-details/</link><pubDate>Tue, 29 Oct 2019 23:19:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-grpc-source-code-details/</guid><description>gRPC 是一个通用的 RPC 框架，这里简单看下 GoLang 中 gRPC 的实现。
简介 # 整个 RPC 服务的调用流程如下：
client 调用 client stub，这是一次本地过程调用； client stub 将参数打包成消息，然后发送这个消息，打包过程(序列化)也叫做 marshalling； client 所在的系统将消息发送给 server； server 的将收到的包传给 server stub； server stub 解包得到参数，解包(反序列化) 也被称作 unmarshalling； 最后 server stub 调用服务过程，返回结果按照相反的步骤传给 client 。
目录结构 # 在 gRPC 目录下有许多常用的包，例如：
metadata # 定义了 gRPC 所支持的元数据结构，包中方法可以对 MD 进行获取和处理。
Client # 对于代码中，实际调用流程为。
c := pb.NewGreeterClient(conn) r, err := c.SayHello(ctx, &amp;amp;pb.HelloRequest{Name: name}) Dial() clientconn.go |-DialContext() 除了个函数的入参，同时会新建一个CTX |-context.WithCancel() 创建所使用的上下文 Server # 一般来说分为了如下几步操作：</description></item><item><title>C 程序加载过程</title><link>https://gohalo.github.io/cn/blog/c-linux-load-process-plt-got/</link><pubDate>Sun, 20 Oct 2019 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-load-process-plt-got/</guid><description>&lt;p>利用动态库，可以节省磁盘、内存空间，而且可以提高程序运行效率；不过同时也导致调试比较困难，而且可能存在潜在的安全威胁。&lt;/p>
&lt;p>这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。&lt;/p></description></item><item><title>gRPC 基本介绍</title><link>https://gohalo.github.io/cn/blog/golang-grpc-introduce/</link><pubDate>Sat, 19 Oct 2019 23:19:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-grpc-introduce/</guid><description>&lt;p>gRPC 一开始由 google 开发，是一款开源的远程过程调用 (RPC) 系统。&lt;/p>
&lt;p>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，能够更容易地创建分布式应用和服务。&lt;/p></description></item><item><title>Linux 内存检查工具 Valgrind 介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-memory-valgrind/</link><pubDate>Sat, 12 Oct 2019 21:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-memory-valgrind/</guid><description>&lt;p>Valgrind 可以用于构建动态分析工具，包括一个工具集，每个工具可以进行一类的调试、分析、测试，以帮助完善程序。&lt;/p>
&lt;p>该工具采用的是模块化方式，可以很容易创建新的工具而又不会扰乱现有工具。&lt;/p></description></item><item><title>【拍案惊奇】之网络端口</title><link>https://gohalo.github.io/cn/blog/network-same-source-destination-port/</link><pubDate>Wed, 02 Oct 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-same-source-destination-port/</guid><description>&lt;p>如果在本地访问时，使用了一个源和目的端口都相同的 TCP 链接，会出现什么情况？&lt;/p></description></item><item><title>常用 Bash 脚本</title><link>https://gohalo.github.io/cn/blog/bash-some-useful-scripts/</link><pubDate>Tue, 01 Oct 2019 19:14:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-some-useful-scripts/</guid><description>&lt;p>这里总结一些常见的脚本，例如备份、日志清理等等。&lt;/p></description></item><item><title>Lua 和 C 语言相互调用</title><link>https://gohalo.github.io/cn/blog/lua-c-api/</link><pubDate>Sun, 22 Sep 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-c-api/</guid><description>&lt;p>Lua 是扩展性非常良好的语言，虽然核心非常精简，但是用户可以依靠 Lua 库来实现大部分工作，还可以通过与 C 函数相互调用来扩展程序功能。&lt;/p>
&lt;p>在 C 中嵌入 Lua 脚本既可以让用户在不重新编译代码的情况下修改 Lua 代码更新程序，也可以给用户提供一个自由定制的接口，这种方法遵循了机制与策略分离的原则；在 Lua 中调用 C 函数可以提高程序的运行效率。&lt;/p>
&lt;p>Lua 与 C 的相互调用在工程中相当实用，这里就简单讲解 Lua 与 C 相互调用的方法。&lt;/p></description></item><item><title>通过 CMake 进行测试</title><link>https://gohalo.github.io/cn/blog/cmake-unit-test-introduce/</link><pubDate>Sat, 10 Aug 2019 19:29:21 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-unit-test-introduce/</guid><description>&lt;p>CMake 除了提供自动编译的工具之外，还可以用来进行测试，提供了一整套基于 ctest 的工具。&lt;/p></description></item><item><title>GoLang pprof 模块介绍</title><link>https://gohalo.github.io/cn/blog/golang-common-module-pprof-performace-introduce/</link><pubDate>Mon, 05 Aug 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-pprof-performace-introduce/</guid><description>&lt;p>GoLang 提供了非常强大的代码性能分析工具 pprof，可以非常方便的分析代码运行性能，同时非常直观。&lt;/p></description></item><item><title>Linux 可执行文件解析工具</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</link><pubDate>Sat, 08 Jun 2019 21:19:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</guid><description>&lt;p>主要是在如何解析 ELF 格式的文件。&lt;/p></description></item><item><title>GoLang 逃逸分析</title><link>https://gohalo.github.io/cn/blog/golang-escape-analysis-introduce/</link><pubDate>Mon, 03 Jun 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-escape-analysis-introduce/</guid><description/></item><item><title>TLS/SSL CipherSuite 简介</title><link>https://gohalo.github.io/cn/blog/security-ssl-tls-ciphersuites/</link><pubDate>Mon, 06 May 2019 21:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-ssl-tls-ciphersuites/</guid><description>&lt;p>直接翻译为加密套件，在 TLS/SSL 中实际上包含了四类，用来完成握手阶段的信息交互，决定了后续信息交互的过程，包括了认证、加解密、密钥交换等所使用的算法。&lt;/p>
&lt;p>这里会简单介绍所支持的算法，以及如何在 OpenSSL 中使用。&lt;/p></description></item><item><title>GoLang 陷阱</title><link>https://gohalo.github.io/cn/blog/golang-some-pitfalls-introduce/</link><pubDate>Fri, 03 May 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-some-pitfalls-introduce/</guid><description>&lt;p>简单列举一些 GoLang 中容易犯的错误。&lt;/p></description></item><item><title>Bash 常用技巧整理</title><link>https://gohalo.github.io/cn/blog/bash-some-tips/</link><pubDate>Wed, 01 May 2019 23:19:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-some-tips/</guid><description>&lt;p>整理一些常见 Bash 的使用技巧，例如 Here Document、特殊字符文件处理、字符集设置等。&lt;/p></description></item><item><title>GoLang 内存模型</title><link>https://gohalo.github.io/cn/blog/golang-concept-memory-module-introduce/</link><pubDate>Wed, 01 May 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-memory-module-introduce/</guid><description>&lt;p>在 Golang 中所谓的内存模型，定义的是，对多个协程中共享的变量，一个协程中怎样可以看到其它协程的写入。&lt;/p>
&lt;p>当多个协程同时操作一个数据时，可以通过管道、同步原语 (sync 包中的 Mutex 以及 RWMutex)、原子操作 (sync/atomic 包中)。&lt;/p>
&lt;p>除此之外，为了保证语义的正确性，Golang 还对一些常见的场景做了语义上的约束。&lt;/p></description></item><item><title>GoLang Gopher</title><link>https://gohalo.github.io/cn/blog/golang-concept-much-more-gopher-introduce/</link><pubDate>Tue, 16 Apr 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-much-more-gopher-introduce/</guid><description>&lt;p>在人类自然语言学界有一个很著名的 &amp;ldquo;萨丕尔-沃夫&amp;rdquo; 假说，语言影响或决定人类的思维方式。&lt;/p>
&lt;p>Language inuences/determines thought. - Sapir-Whorf hypothesis&lt;/p>
&lt;p>那么 Gopher 的价值观是什么。&lt;/p></description></item><item><title>GoLang 调度机制</title><link>https://gohalo.github.io/cn/blog/golang-concept-scheduler-introduce/</link><pubDate>Mon, 15 Apr 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-scheduler-introduce/</guid><description>&lt;p>在 Go 语言中的核心是协程，其实现在用户态，那么就需要在用户态实现其调度器，在 1.1 版本对调度器进行了重构，也就是现在的 GMP 模型。&lt;/p>
&lt;p>另外，为了防止协程不让出 CPU 导致其它协程饿死，在 1.2 版本加入了强占式调度器。&lt;/p></description></item><item><title>GoLang 反射简介</title><link>https://gohalo.github.io/cn/blog/golang-reflect-introduce/</link><pubDate>Sat, 06 Apr 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-reflect-introduce/</guid><description>&lt;p>与 C/C++ 不同，GoLang 的指针是不支持指针运算和转换，GoLang 是静态语言，所有变量必须标明其类型，不同类型变量不能执行赋值、比较、计算等操作；指针也有其对应的类型，在编译阶段同样会进行检查。&lt;/p>
&lt;p>同时，GoLang 在运行阶段提供了一定的灵活性。&lt;/p></description></item><item><title>GoLang 接口源码解析</title><link>https://gohalo.github.io/cn/blog/golang-interface-source-code-introduce/</link><pubDate>Thu, 28 Mar 2019 20:23:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-interface-source-code-introduce/</guid><description/></item><item><title>Linux 子进程创建</title><link>https://gohalo.github.io/cn/blog/c-linux-fork-process-execute/</link><pubDate>Fri, 22 Mar 2019 22:11:22 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-fork-process-execute/</guid><description/></item><item><title>R 语言绘图</title><link>https://gohalo.github.io/cn/blog/r-language-graph-function-introduce/</link><pubDate>Tue, 19 Mar 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/r-language-graph-function-introduce/</guid><description>&lt;p>原生的 R 语言提供了非常强大的绘图功能，基本不需要其它辅助，就可以绘制非常炫目的图片，再加上各种各样的神级 R 包 (例如 &lt;code>ggplot2&lt;/code>、&lt;code>plotly&lt;/code> 等)，更是如虎添翼。&lt;/p>
&lt;p>另外，Python 语言中的 Matplotlib 库，同样提供了非常强大的绘图功能。&lt;/p></description></item><item><title>R 语言简介</title><link>https://gohalo.github.io/cn/blog/r-language-basic-introduce/</link><pubDate>Tue, 12 Mar 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/r-language-basic-introduce/</guid><description>&lt;p>R 语言作为统计学一门语言，一直属于一个小众的工具集，直到大数据爆发后，越来越多的人开始使用 R 语言进行数据分析。&lt;/p>
&lt;p>是一套开源的数据分析解决方案，为统计计算和绘图而生的语言和环境，几行简答的代码就可以实现很复杂的功能。&lt;/p></description></item><item><title>Linux C 陷阱</title><link>https://gohalo.github.io/cn/blog/linux-c-some-pitfalls-introduce/</link><pubDate>Sun, 10 Mar 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-some-pitfalls-introduce/</guid><description>&lt;p>一些 C 语言中比较容易犯错的知识点。&lt;/p></description></item><item><title>Golang 竞态检查</title><link>https://gohalo.github.io/cn/blog/golang-race-condition-introduce/</link><pubDate>Fri, 08 Mar 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-race-condition-introduce/</guid><description>&lt;p>Race Conditions 是最隐晦而且难以捉摸的编程错误之一，一般会在代码部署到生产之后很长时间才会发作，但是如果要通过 Golang 进行并发编程，那么就会很容易遇到。&lt;/p>
&lt;p>Go 的并发机制使得编写干净并发代码变得容易，但它们并不能防止竞态条件。&lt;/p></description></item><item><title>GoLang 管道详解</title><link>https://gohalo.github.io/cn/blog/golang-basic-syntax-channel-introduce/</link><pubDate>Fri, 01 Mar 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-syntax-channel-introduce/</guid><description>&lt;p>在 Go 语言中，通过协程和管道实现了 Communicating Sequential Processes, CSP 模型，两者承担了通信和同步中的重要角色。&lt;/p></description></item><item><title>UDP 通讯优化</title><link>https://gohalo.github.io/cn/blog/linux-c-udp-optimize-introduce/</link><pubDate>Wed, 27 Feb 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-udp-optimize-introduce/</guid><description>&lt;p>有部分应用场景采用的仍然是无连接协议，例如 DNS、StatsD 等，都是采用的 UDP 。&lt;/p>
&lt;p>UDP 不是面向连接的，所以不能像 TCP 通过建立多个连接来提高对服务器的并发访问，如果通过多线程共享一个 UDP Socket 可能会无法充分利用所有的 CPU 资源。&lt;/p>
&lt;p>这里简单介绍其优化方法，当然，这里的策略也适用与像 ICMP 这样的协议。&lt;/p></description></item><item><title>内存检查工具</title><link>https://gohalo.github.io/cn/blog/linux-c-some-memory-debugger-tools-introduce/</link><pubDate>Mon, 25 Feb 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-some-memory-debugger-tools-introduce/</guid><description/></item><item><title>GoLang 汇编语言</title><link>https://gohalo.github.io/cn/blog/golang-assembly-language-introduce/</link><pubDate>Sat, 23 Feb 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-assembly-language-introduce/</guid><description>&lt;p>现在的汇编通常作为从高阶语言到机器码的中间产品，表示方式常见的有 Intel 以及 AT&amp;amp;T 两种，不知道为啥 GoLang 选择的是参考 Plan 9 这种汇编语言，其使用的方式与前两者有很大的区别。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>GoLang 内存管理</title><link>https://gohalo.github.io/cn/blog/golang-concept-memory-management-module-introduce/</link><pubDate>Wed, 20 Feb 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-memory-management-module-introduce/</guid><description>&lt;p>在 C 语言中，通过 &lt;code>malloc()&lt;/code> 函数可以动态分配内存，常用的有 ptmalloc2(glib)、tcmalloc(Google)、jemaloc(FaceBook)，后两者在避免内存碎片以及性能上都有较大的优势。&lt;/p>
&lt;p>而 Go 中的内存分配器，其原理与 tcmalloc 类似，简单的说就是维护一块大的全局内存，每个线程 (P) 维护一块小的私有内存，私有内存不足再从全局申请。&lt;/p></description></item><item><title>基本算法介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-basic-concept/</link><pubDate>Wed, 20 Feb 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-basic-concept/</guid><description>&lt;p>这里简单介绍一下递归、分治算法、动态规划、贪心算法、回溯算法的区别和联系。&lt;/p></description></item><item><title>CMake 使用简介</title><link>https://gohalo.github.io/cn/blog/cmake-basic-introduce/</link><pubDate>Mon, 11 Feb 2019 17:49:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-basic-introduce/</guid><description>&lt;p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，对于简单的程序来说是可以的，当项目变得复杂之后会很难进行维护。&lt;/p>
&lt;p>而目前在维护 C/C++ 项目时，使用比较多的是 CMake ，这里就详细介绍下 CMake 的使用。&lt;/p></description></item><item><title>Memory Reordering 简析</title><link>https://gohalo.github.io/cn/blog/linux-c-memory-reordering-introduce/</link><pubDate>Fri, 01 Feb 2019 19:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-memory-reordering-introduce/</guid><description>&lt;p>以 C 语言为例，在编写完源代码之后，需要经过编译，然后在 CPU 上运行，为了提高代码的执行效率，在编译阶段和运行阶段会执行乱序优化，但同时也带来了一些副作用。&lt;/p>
&lt;p>这里简单介绍内存乱序的基本概念。&lt;/p></description></item><item><title>Python 语法简介</title><link>https://gohalo.github.io/cn/blog/python-basic-syntax-introduce/</link><pubDate>Sun, 30 Dec 2018 20:58:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-basic-syntax-introduce/</guid><description>&lt;p>这里介绍 Python 的基本的语法。&lt;/p></description></item><item><title>Golang 语法之结构体</title><link>https://gohalo.github.io/cn/blog/golang-syntax-structure-introduce/</link><pubDate>Sun, 30 Dec 2018 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-syntax-structure-introduce/</guid><description>&lt;p>类似于 C 中的结构体，也就是用户自定义的类型，它代表若干字段的集合。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>替换 glibc malloc</title><link>https://gohalo.github.io/cn/blog/linux-c-program-replace-glibc-memory-function/</link><pubDate>Wed, 19 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-program-replace-glibc-memory-function/</guid><description>&lt;p>在进行系统优化、内存泄漏测试时，经常需要对 glibc 的一些 API 进行替换，例如比较常见的是内存管理接口。&lt;/p>
&lt;p>如果代码量很大，或者使用了三方的静态库时，此时就无法直接替换相关的函数，例如 &lt;code>malloc()&lt;/code> &lt;code>realloc()&lt;/code> &lt;code>calloc()&lt;/code> 等，需要直接替换掉系统的相关函数。&lt;/p>
&lt;p>这里简单介绍几种方法。&lt;/p></description></item><item><title>PyMC 使用简介</title><link>https://gohalo.github.io/cn/blog/python-pymc-package-introduce/</link><pubDate>Thu, 13 Dec 2018 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-pymc-package-introduce/</guid><description>&lt;p>PyMC3 是一个用 Python 编写的开源的概率编程框架，完全通过 Python 代码来定义模型，并使用 Theano 通过变分推理进行梯度计算，并使用 C 实现加速运算。&lt;/p>
&lt;p>目前的 Theano 库已经不再维护，而 PyMC3 团队会单独维护与 PyMC3 相关的一些特性。&lt;/p></description></item><item><title>lock-free 编程</title><link>https://gohalo.github.io/cn/blog/linux-c-program-lock-free-queue-introduce/</link><pubDate>Sun, 09 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-program-lock-free-queue-introduce/</guid><description>&lt;p>简单介绍下无锁编程 (Lock Free) 的概念，并实现一个基本的 Queue 。&lt;/p></description></item><item><title>C 动态参数使用详解</title><link>https://gohalo.github.io/cn/blog/c-dynamic-arguments/</link><pubDate>Sun, 09 Dec 2018 21:40:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-dynamic-arguments/</guid><description>&lt;p>在使用过程中，通常会有参数个数不确定，最常见的是 &lt;code>printf&lt;/code> 这类的函数，只有在使用时才能确定参数的个数以及其类型。&lt;/p>
&lt;p>这里详细介绍其使用以及基本原理。&lt;/p></description></item><item><title>Bash 自动补全机制详解</title><link>https://gohalo.github.io/cn/blog/bash-auto-completion-introduce/</link><pubDate>Sat, 08 Dec 2018 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-auto-completion-introduce/</guid><description>&lt;p>在 Linux 命令行中，当输入字符后，按两次 &lt;code>Tab&lt;/code> 键，Shell 就会列出以这些字符打头的所有可用命令，如果只有一个命令匹配到，按一次 &lt;code>Tab&lt;/code> 键就自动将这个命令补全。&lt;/p>
&lt;p>比如，如果想更改密码，但只记得这个命令前几个字母是 pa，此时按 &lt;code>Tab&lt;/code> 键 Shell 就会自动补全 passwd 命令，非常方便。除了命令补全，还有路径、文件名补全，这个在通过 cd 命令切换到指定目录时特别好用。&lt;/p>
&lt;p>这里详细介绍其使用方法。&lt;/p></description></item><item><title>LLVM 使用简介</title><link>https://gohalo.github.io/cn/blog/llvm-compiler-infrastructure-introduce/</link><pubDate>Sat, 08 Dec 2018 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llvm-compiler-infrastructure-introduce/</guid><description>&lt;p>LLVM 计划启动于 2000 年，由 UIUC 大学的 Chris Lattner 博士主持，后入职 Apple 继续推广，所以 Apple 就成了主要的赞助商。&lt;/p>
&lt;p>最初是 Low Level Virtual Machine 的缩写，不过随着发展，逐渐整合成了一整套的编译工具，所以官方也就放弃了原有的缩写，而修改成 The LLVM Compiler Infrastructure 。&lt;/p>
&lt;p>其强大之处在于模块化，可以很方便适配不同的语言以及硬件平台。&lt;/p></description></item><item><title>Bash 生成随机内容</title><link>https://gohalo.github.io/cn/blog/bash-tips-random-content/</link><pubDate>Fri, 30 Nov 2018 23:30:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-tips-random-content/</guid><description>&lt;p>在编写代码时，一般会使用伪随机函数，不过对于安全通讯往往存在风险，Linux 提供了随机生成设备，可以提供基本满足真随机内容。&lt;/p>
&lt;p>这里介绍常见的使用技巧。&lt;/p></description></item><item><title>Huffman 编码简介</title><link>https://gohalo.github.io/cn/blog/huffman-introduce/</link><pubDate>Tue, 20 Nov 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/huffman-introduce/</guid><description>&lt;p>哈夫曼编码 Huffman Coding 是一种变长的前缀码，使用的算法是 David A. Huffman 还在 MIT 的学生时提出的，并且在 1952 年发表了名为 &lt;code>A Method for the Construction of Minimum-Redundancy Codes&lt;/code> 的文章。&lt;/p>
&lt;p>编码过程叫做哈夫曼编码，是一种普遍的熵编码技术，包括用于无损数据压缩领域。&lt;/p></description></item><item><title>APM 分布式跟踪系统</title><link>https://gohalo.github.io/cn/blog/monitor-apm-introduce/</link><pubDate>Tue, 23 Oct 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/monitor-apm-introduce/</guid><description>&lt;p>目前的产品架构，分布式系统得到了大范围的应用，使得系统更加灵活，不过同时也给开发、运维人员也带来了很大的难题，如何监控和优化分布式系统的行为。&lt;/p>
&lt;p>这里简单介绍下一个小众、简单的 APM 监控工具。&lt;/p></description></item><item><title>Google Benchmark 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-google-benchmark/</link><pubDate>Mon, 22 Oct 2018 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-google-benchmark/</guid><description>&lt;p>Google 提供的 Benchmark 工具是一款强大的性能压测工具，易于安装和使用，并提供了全面的性能测试接口。&lt;/p></description></item><item><title>Bash 模拟终端介绍</title><link>https://gohalo.github.io/cn/blog/bash-terminal-emulator/</link><pubDate>Tue, 16 Oct 2018 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-terminal-emulator/</guid><description>&lt;p>Bash 是一个交互程序，不过现在都是基于虚拟终端来实现，不同虚拟终端支持能力各有区别，这里简单介绍。&lt;/p></description></item><item><title>GCC 强弱符号、引用基本介绍</title><link>https://gohalo.github.io/cn/blog/c-strong-weak-symbol-reference/</link><pubDate>Sat, 13 Oct 2018 18:19:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-strong-weak-symbol-reference/</guid><description>&lt;p>在编程时经常会碰到一种情况叫符号重复定义，一般意味着多个目标文件中含有相同名字全局符号的定义，而有时又不会报错，为什么？&lt;/p>
&lt;p>在 glibc 中定义了很多类似 &lt;code>read()&lt;/code> &lt;code>open()&lt;/code> 的函数，但是又可以自己定义相同的函数？&lt;/p>
&lt;p>这就涉及到了强弱符号以及强弱引用的概念了，这里详细介绍。&lt;/p></description></item><item><title>SQLite 优化实践</title><link>https://gohalo.github.io/cn/blog/sqlite-optimize-introduce/</link><pubDate>Tue, 09 Oct 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/sqlite-optimize-introduce/</guid><description>&lt;p>SQLite 的写入性能与磁盘的性能有很大的关系，例如在 SATA 上可能只有 100 左右，在 SSD 上大概有 1K 左右，如果直接使用 RAMDisk 测试能达到 1W 以上。除此之外，还可以通过一些方法进行相关的优化。&lt;/p></description></item><item><title>C 语言 inline 简介</title><link>https://gohalo.github.io/cn/blog/language-c-inline-concept-introduce/</link><pubDate>Fri, 05 Oct 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-inline-concept-introduce/</guid><description>&lt;p>在 C 语言中，调用函数时会在栈空间生成一个函数调用栈，如果函数嵌套过深则会导致大量的栈空间消耗，甚至是溢出。内联函数的引入就是解决一些频繁调用小函数时的大量栈空间消耗问题，这是 C99 的新增特性。&lt;/p></description></item><item><title>C 宏使用技巧</title><link>https://gohalo.github.io/cn/blog/c-macros-basic-concepts-introduce/</link><pubDate>Sun, 30 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-macros-basic-concepts-introduce/</guid><description>拼接宏 # 其中 # 把宏的参数直接替换为字符串，不进行替换；而 ## 会把两个宏参数贴在一起。注意，当宏参数是另一个宏时，只要宏定义用到了 # 或 ## 的地方，其宏参数都不会再展开。
#include &amp;lt;stdio.h&amp;gt; #define INT_MAX 0x7FFFFFFF #define STRING(s) #s #define A 2 #define CONCAT(a, b) (int)(a##e##b) int main(void) { int AeA = 55; puts(STRING(INT_MAX)); // INT_MAX printf(&amp;#34;%d\n&amp;#34;, CONCAT(A, A)); // 55 return 0; } 如果将 CONCAT 宏定义修改为 (int)((a##e##b) + a) ，那么结果为 57 。
其中 A 和 INT_MAX 都是宏，而且做为了 STRING 和 CONCAT 的参数，但是因为存在 # 或者 ## 符号，所以其中的 A 和 INT_MAX 都没有展开。</description></item><item><title>SQLite 源码解析</title><link>https://gohalo.github.io/cn/blog/sqlite-sourcecode-analyze/</link><pubDate>Sat, 29 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/sqlite-sourcecode-analyze/</guid><description>&lt;p>SQLite 嵌入到使用它的应用程序中，它们共用相同的进程空间，而不是单独的一个进程，从外部看，它并不像一个 RDBMS，但在进程内部，它却是完整的，自包含的数据库引擎。&lt;/p>
&lt;p>核心大约有 3W 行标准 C 代码，这些代码都是模块化的，很容易阅读，如下简单介绍。&lt;/p></description></item><item><title>Linux GCC 常用技巧</title><link>https://gohalo.github.io/cn/blog/language-c-gcc-some-basic-tips/</link><pubDate>Thu, 27 Sep 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-gcc-some-basic-tips/</guid><description/></item><item><title>GoLang 闭包简介</title><link>https://gohalo.github.io/cn/blog/golang-basic-closure-introduce/</link><pubDate>Tue, 25 Sep 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-closure-introduce/</guid><description>&lt;p>在很多语言里实际上都支持闭包，例如 Python、Lua 等，GoLang 实际上也支持，功能基本类似，如果对闭包的概念比较熟悉，实际上也很好理解。&lt;/p>
&lt;p>这里简单介绍其概念以及常见的错误使用场景。&lt;/p></description></item><item><title>Linux C 数据对齐</title><link>https://gohalo.github.io/cn/blog/c-structure-align-basic-introduce/</link><pubDate>Thu, 20 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-structure-align-basic-introduce/</guid><description>&lt;p>C 语言中的结构体包含了各种成员，编译器会将结构体中的每个成员按其自然边界分配空间，合理的设置对齐规则，可以提高 CPU 的访问速度 (有些 CPU 会禁止非对齐，会抛出硬件异常)，降低结构体的占用空间。&lt;/p></description></item><item><title>Linux C 位域和大小端</title><link>https://gohalo.github.io/cn/blog/c-bit-field-and-endian-introduce/</link><pubDate>Tue, 18 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-bit-field-and-endian-introduce/</guid><description>在处理通讯协议时，经常需要按照字节甚至是位进行处理，例如 MySQL 协议，那么对于 C 而言如何方便的进行处理呢？ 另外，网络通讯时采用的是大端，到底是啥意思？
简介 # 在编写代码的时候，很大一部分工作是在不同的格式之间进行转换，从外部的数据结构转换成内部使用的结构，例如网络包 (TCP/IP、MySQL协议等)、磁盘文件 (GIF、JPEG等图片格式) 等等。
其中很重要的一部分就是整数的字节顺序问题，也就是当整数的大小超过了一个字节之后，如何进行表示，这就是所谓的字节序的问题。
CPU # 不同的 CPU 对应的字节序略有区别：
大端，PowerPC、IBM、Sun、51 小端，x86、DEC 其中 ARM 两种模式都可以支持，另外，网络协议中大部分使用的是大端字节序，所以就有一系列的 API 对整数进行转换。
# if __BYTE_ORDER == __BIG_ENDIAN # define ntohl(x) (x) # define ntohs(x) (x) # define htonl(x) (x) # define htons(x) (x) # else # define ntohl(x) __bswap_32(x) # define ntohs(x) __bswap_16(x) # define htonl(x) __bswap_32(x) # define htons(x) __bswap_16(x) # endif 其中 ntohs 为 network to host short 的简写，这些函数一般在头文件 &amp;lt;arpa/inet.</description></item><item><title>GoLang 异常处理</title><link>https://gohalo.github.io/cn/blog/golang-basic-error-panic/</link><pubDate>Sat, 15 Sep 2018 21:39:58 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-error-panic/</guid><description>&lt;p>Golang 中的错误处理是一个被大家经常拿出来讨论的话题(另外一个是泛型)，这里简单介绍其使用方法。&lt;/p></description></item><item><title>GoLang 并发控制</title><link>https://gohalo.github.io/cn/blog/golang-concurrent-control/</link><pubDate>Mon, 10 Sep 2018 18:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concurrent-control/</guid><description>&lt;p>协程不像进程或者线程可以被抢占，也就是可以强制退出，但是协程需要通过协作方式完成调度，也就是只能主动退出，如下是几种常见的退出方式。&lt;/p></description></item><item><title>C 整数介绍</title><link>https://gohalo.github.io/cn/blog/c-integer-basic-concepts-introduce/</link><pubDate>Fri, 07 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-integer-basic-concepts-introduce/</guid><description>&lt;p>在 C 中与整数类型相关的内容。&lt;/p></description></item><item><title>Linux C Flock 使用</title><link>https://gohalo.github.io/cn/blog/c-linux-flock-introduce/</link><pubDate>Fri, 03 Aug 2018 20:11:22 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-flock-introduce/</guid><description>&lt;p>在某些场景下，例如需要保证单个进程运行，通常的做法是生成一个 PID 文件，并将当前的进程 PID 写入，每次进程启动时检查文件以及进程是否存在。&lt;/p>
&lt;p>如果进程异常崩溃没有删除文件，而 Linux 中 PID 可以复用，那么就可能会导致误认为进程存在，虽然概率很低。&lt;/p>
&lt;p>其实在 Linux 中可以通过 flock 实现。&lt;/p></description></item><item><title>Python 新类和旧类区别</title><link>https://gohalo.github.io/cn/blog/python-old-new-style-class/</link><pubDate>Fri, 27 Jul 2018 19:49:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-old-new-style-class/</guid><description>&lt;p>在 Python 2.2 版本中引入了新式类 (New Style Class)，所以，通常将在此之前的类称为经典类或者旧类，而在此之后的称为新式类，两者在使用时略有区别。&lt;/p>
&lt;p>这里会简单介绍两者的区别。&lt;/p></description></item><item><title>Python 常用代码</title><link>https://gohalo.github.io/cn/blog/python-some-codes/</link><pubDate>Sun, 22 Jul 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-some-codes/</guid><description/></item><item><title>Socket 关闭方式</title><link>https://gohalo.github.io/cn/blog/language-c-socket-close-method/</link><pubDate>Wed, 20 Jun 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-socket-close-method/</guid><description>&lt;p>在 Linux 中，对于 Socket 来说，可以通过系统调用 &lt;code>close()&lt;/code> 关闭，通过还提供了一个 &lt;code>shutdown()&lt;/code> 接口，可以直接将 socket 关闭。&lt;/p>
&lt;p>那么两种方式有什么区别？&lt;/p></description></item><item><title>C 语言发布流程</title><link>https://gohalo.github.io/cn/blog/program-c-debug-release-etc/</link><pubDate>Sat, 16 Jun 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-debug-release-etc/</guid><description>&lt;p>整理下 C 语言中调试、发布的流程。&lt;/p></description></item><item><title>GCC 常用技巧</title><link>https://gohalo.github.io/cn/blog/program-c-language-gcc-some-stuff/</link><pubDate>Wed, 13 Jun 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-language-gcc-some-stuff/</guid><description>&lt;p>Clang 是一个 C++ 编写，基于 LLVM 的 C/C++、Objective-C 语言的轻量级编译器，在 2013.04 开始，已经全面支持 C++11 标准。&lt;/p></description></item><item><title>Linux GNU 内联汇编</title><link>https://gohalo.github.io/cn/blog/c-gnu-inline-assembly/</link><pubDate>Wed, 30 May 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-gnu-inline-assembly/</guid><description>&lt;p>在通过 C 做上层的开发时，实际上很少会用到汇编语言，不过对于 Linux 内核开发来说，经常会遇到与体系架构相关的功能或优化代码，此时可能需要通过将汇编语言指令插入到 C 语句的中间来执行这些任务。&lt;/p>
&lt;p>这里简单介绍下 GNU 中与 Linux 内联汇编相关的用法。&lt;/p></description></item><item><title>C 语言 Volatile 使用简介</title><link>https://gohalo.github.io/cn/blog/linux-c-volatile-statement-introduce/</link><pubDate>Sun, 20 May 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-volatile-statement-introduce/</guid><description>&lt;p>C 语言中的 volatile 关键字大部分都见过，但是很少有人能明确其具体使用的场景。实际上，上层编程很少会用到，一般只有涉及到 IO、中断等与硬件交互的底层编程才会经常使用。&lt;/p>
&lt;p>这里简单介绍其使用场景，使用方法。&lt;/p></description></item><item><title>Linux Random</title><link>https://gohalo.github.io/cn/blog/linux-random-introduce/</link><pubDate>Sat, 12 May 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-random-introduce/</guid><description>&lt;p>在 Linux 中，有两类用于生成随机数的设备，分别是 &lt;code>/dev/random&lt;/code> 以及 &lt;code>/dev/urandom&lt;/code> ，其中前者可能会导致阻塞，后者的安全性则较低。&lt;/p>
&lt;p>后者是 unblocked random 的简称，会重用内部池中的数据以产生伪随机数据，可用于安全性较低的应用。&lt;/p></description></item><item><title>GoLang HTTP 使用简介</title><link>https://gohalo.github.io/cn/blog/golang-http-webserver-introduce/</link><pubDate>Fri, 27 Apr 2018 18:13:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-http-webserver-introduce/</guid><description>&lt;p>除去细节，理解 HTTP 构建的网络应用只要关注客户端和服务端的处理，服务器主要用来接收客户端的请求，然后返回响应，在接收请求并处理的过程中，最重要的莫过于路由 (Router)。&lt;/p>
&lt;p>这里简单介绍如何使用 &lt;code>net/http&lt;/code> 构建 HTTP 请求。&lt;/p></description></item><item><title>C 常用函数</title><link>https://gohalo.github.io/cn/blog/language-c-some-basic-functions-usage-introduce/</link><pubDate>Fri, 20 Apr 2018 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-some-basic-functions-usage-introduce/</guid><description>&lt;p>C 语言中一些常用的基础函数，包括了 &lt;code>qsort()&lt;/code> &lt;code>bsearch()&lt;/code> &lt;code>atexit()&lt;/code> &lt;code>backtrace()&lt;/code> 等。&lt;/p></description></item><item><title>GCC 安全编译选项</title><link>https://gohalo.github.io/cn/blog/program-gcc-security-options/</link><pubDate>Mon, 09 Apr 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-gcc-security-options/</guid><description>&lt;p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，例如 ASLR、NX 等等，这里简单介绍一些常见的使用项。&lt;/p></description></item><item><title>C 指针简介</title><link>https://gohalo.github.io/cn/blog/language-c-pointer-basic-usage-introduce/</link><pubDate>Sun, 01 Apr 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-pointer-basic-usage-introduce/</guid><description>&lt;p>在 C 语言中，指针是一个特殊的变量，存储值指向内存中的一个地址，一个指针包含了四方面的内容：指针类型、指向类型，指针所指向的内存区以及指针本身所占据的内存区。&lt;/p>
&lt;p>指针或许是 C 语言中最复杂的东西了。&lt;/p></description></item><item><title>Golang 语法之接口</title><link>https://gohalo.github.io/cn/blog/golang-syntax-interface-introduce/</link><pubDate>Fri, 30 Mar 2018 20:23:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-syntax-interface-introduce/</guid><description>&lt;p>在 Go 语言的实际编程中，几乎所有的数据结构都围绕 Interface 展开，这是 GoLang 中所有数据结构的核心。&lt;/p>
&lt;p>首先，Go 不是一种典型的 OO 语言，它在语法上不支持类和继承的概念，而通过 Interface 可以看到多态的影子。&lt;/p></description></item><item><title>GoLang time 模块</title><link>https://gohalo.github.io/cn/blog/golang-common-module-time-introduce/</link><pubDate>Mon, 26 Mar 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-time-introduce/</guid><description>&lt;p>GoLang 中的 time 模块包含了一些与时间相关的函数，例如格式转换、定时器等。&lt;/p></description></item><item><title>Bash 基本语法</title><link>https://gohalo.github.io/cn/blog/bash-basic-syntax/</link><pubDate>Thu, 01 Mar 2018 22:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-basic-syntax/</guid><description>&lt;p>在 Linux 中通过 Bash 与系统进行简单的交互，但是，通常可能会有一些负责的逻辑进行处理，这就涉及到了 Bash 的编程，实际上就是通过命令行以及一些常见的处理逻辑。&lt;/p>
&lt;p>这里简单介绍常见的语法。&lt;/p></description></item><item><title>Python C</title><link>https://gohalo.github.io/cn/blog/python-c-bind-introduce/</link><pubDate>Tue, 30 Jan 2018 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-c-bind-introduce/</guid><description/></item><item><title>GoLang 模板使用简介</title><link>https://gohalo.github.io/cn/blog/golang-template-introduce/</link><pubDate>Tue, 09 Jan 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-template-introduce/</guid><description>&lt;p>在前后端分离的时代，模板语言使用的已经很少了，不过很多特定的场景还是很有用的，这里介绍其基本使用方法。&lt;/p></description></item><item><title>ELF 符号表</title><link>https://gohalo.github.io/cn/blog/program-c-elf-symbol-section/</link><pubDate>Sat, 06 Jan 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-elf-symbol-section/</guid><description/></item><item><title>CMocka 使用简介</title><link>https://gohalo.github.io/cn/blog/c-cmocka-introduce/</link><pubDate>Wed, 06 Dec 2017 18:19:58 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-cmocka-introduce/</guid><description>&lt;p>CMocka 是一针对 C 语言的单元测试框架，而且支持 mock 测试，其前身是由 Google 开发的 Cmockery，而后者由于不再维护，后来就通过 CMocka 继续开发维护。&lt;/p>
&lt;p>也就因此，可以看到有些细节与同样由 Google 开发的 gmock 和 gtest 有些相似，这里详细介绍其使用方式。&lt;/p></description></item><item><title>Python 三方库 requests</title><link>https://gohalo.github.io/cn/blog/python-third-package-requests/</link><pubDate>Thu, 30 Nov 2017 18:39:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-third-package-requests/</guid><description>&lt;p>这是一个简单但是非常优雅的 HTTP 库，对于一些常见的 API 调用非常简单实用。&lt;/p></description></item><item><title>GDB 死锁分析</title><link>https://gohalo.github.io/cn/blog/gdb-deadlock-analyze-introduce/</link><pubDate>Mon, 20 Nov 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-deadlock-analyze-introduce/</guid><description>&lt;p>pthread 是 POSIX 标准的多线程库，其源码位于 glibc 中的 Native POSIX Thread Library, NPTL 目录下，大部分的应用都是基于 pthread 来实现多线程的并行与同步管理。&lt;/p></description></item><item><title>Linux umask 使用</title><link>https://gohalo.github.io/cn/blog/linux-umask-and-open-introduce/</link><pubDate>Sun, 12 Nov 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-umask-and-open-introduce/</guid><description>&lt;p>在使用 umask 设置问价的掩码时遇到了一个坑，本来以为设置会很简单，但是开始设置时一直不是预期的结果。&lt;/p>
&lt;p>简单整理下踩坑的过程。&lt;/p></description></item><item><title>Fuzzing 测试</title><link>https://gohalo.github.io/cn/blog/program-c-fuzzing-test-introduce/</link><pubDate>Tue, 31 Oct 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-fuzzing-test-introduce/</guid><description>Fuzzing 一般指模糊测试，是一种基于黑盒的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。
同时，也作为了当前最为强大而有效的漏洞挖掘技术。
AFL # American Fuzzy Lop, AFL 是一种开源的模糊测试器，由谷歌的 Michal Zalewski 开发。
可以在源码编译时添加，或者使用 QEMU 模式，也就是 QEMU-(User Mode) ，在执行时注入部分代码进行测试。
目前使用 AFL 有两种方式：
开源软件，在编译的时候同时进行插桩； 闭源软件，配合QEMU直接对闭源的二进制代码进行fuzz测试。 安装 # 直接从 ALF Release 下载相关的版本，然后执行 make 即可。
默认安装在 /usr/local 相对目录下，可以通过 PREFIX=/usr &amp;amp;&amp;amp; make 修改。
使用 # 如果程序使用 autoconf 工具链构建，在执行 configure 脚本时，添加如下参数即可。
$ ./configure --disable-shared CC=&amp;#34;afl-gcc&amp;#34; CXX=&amp;#34;afl-g++&amp;#34; 其中 --disable-shared 选项可以允许通过 LD_LIBRARY_PATH 变量，让程序加载经过 AFL 插桩的 .so 文件，进行静态构建而不是动态链接。
如果是其它的 Makefile 文件，可以直接修改引用的编译器。
另外，为了后期更好的分析 crash 可以开启 Address Sanitizer, ASAN 检测工具，此工具可以更好的检测出缓存区溢出、UAF 等内存漏洞。</description></item><item><title>Linux Direct IO</title><link>https://gohalo.github.io/cn/blog/linux-direct-io-introduce/</link><pubDate>Fri, 27 Oct 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-direct-io-introduce/</guid><description>&lt;p>可以直接在应用层和磁盘之间建立通道，减少上下文切换次数。&lt;/p></description></item><item><title>Linux C 错误信息</title><link>https://gohalo.github.io/cn/blog/language-c-error-message-usage-introduce/</link><pubDate>Fri, 20 Oct 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-error-message-usage-introduce/</guid><description>&lt;p>在 C 代码中，当发生错误时，一般会在库函数中设置 errno ，然后应用可以通过 strerror 打印详细的错误信息，以方便定位问题。&lt;/p>
&lt;p>但是有些错误打印函数标示为安全的？这是什么意思？使用时应该注意什么？&lt;/p></description></item><item><title>GoLang Array VS. Slice</title><link>https://gohalo.github.io/cn/blog/golang-array-slice-concept-introduce/</link><pubDate>Wed, 18 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-array-slice-concept-introduce/</guid><description>&lt;p>两者十分类似，很容易造成混淆。&lt;/p></description></item><item><title>GoLang 日志模块使用介绍</title><link>https://gohalo.github.io/cn/blog/golang-log-module-introduce/</link><pubDate>Mon, 16 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-log-module-introduce/</guid><description>&lt;p>打印日志是最常规的需求，GoLang 的基础库只提供了简单的格式化功能，但是很多基础功能不存在，例如日志级别、文件切割等等。&lt;/p>
&lt;p>这里介绍 Uber 开发的一个日志库 ZAP 。&lt;/p></description></item><item><title>GoLang 网络编程</title><link>https://gohalo.github.io/cn/blog/golang-example-socket-introduce/</link><pubDate>Sat, 14 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-example-socket-introduce/</guid><description>&lt;p>Golang 对 TCP 做了很好的抽象，而且提供了很高的性能，其底层的 netpoller 通过非阻塞的 IO 多路复用实现，然后再结合协程的调度，使得用户在编程时实际是阻塞接口。&lt;/p></description></item><item><title>GDB 常用命令</title><link>https://gohalo.github.io/cn/blog/gdb-commands-usage-cheatsheet/</link><pubDate>Thu, 05 Oct 2017 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-commands-usage-cheatsheet/</guid><description>&lt;p>这里一些常用的 gdb 命令。&lt;/p></description></item><item><title>GDB 栈帧简介</title><link>https://gohalo.github.io/cn/blog/gdb-stack-frame-introduce/</link><pubDate>Thu, 05 Oct 2017 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-stack-frame-introduce/</guid><description>&lt;p>栈是一块内存空间，会从高地址向低地址增长，同时在函数调用过程中，会通过栈寄存器来维护栈帧相关的内容。函数运行时，栈帧 (Stack Frame) 非常重要，包含了函数的局部变量以及函数调用之间的传参。&lt;/p></description></item><item><title>Flex 简介</title><link>https://gohalo.github.io/cn/blog/program-concept-lexical-flex-introduce/</link><pubDate>Fri, 29 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-concept-lexical-flex-introduce/</guid><description>一种词法分析器，可以通过正则表达式识别文本中的词汇，然后自动生成对应的 C 代码，最后编译链接 C 代码就可以了。
Flex 采用的是状态机，通过分析输入流 (字符流)，只要发现一段字符能够匹配一个关键字 (正则表达式)，就会采取对应的动作。
简介 # Flex 文件被 %% 分成了上中下三个部分：
第一部分中要写入 C/C++ 代码必须用 %{ 和 %} 括起来，将原封不动放到生成源码中。 第二部分是规则段，包括了模式 (正则表达式) 和动作，由空白分开，当匹配到模式时，就会执行后面的动作。 第三部分可以直接写入 C/C++ 代码。 yylex() 是扫描程序的入口，调用该函数启动或重新开始，该函数会初始化一些全局变量，然后开始扫描。如果定义的 flex 动作是将数值传递给调用程序，那么对 yylex() 的下次调用就从它停止的地方继续扫描。
%{ #include &amp;lt;stdio.h&amp;gt; %} %% is | are { printf(&amp;#34;%s: VERB &amp;#34;, yytext); } island printf(&amp;#34;LAND &amp;#34;); [0-9]+ printf(&amp;#34;NUMBER &amp;#34;); [ \t]+ /* ignore whitespace */; [a-zA-Z][a-zA-Z0-9]* printf(&amp;#34;COMMON WORD &amp;#34;); .|\n { ECHO; } %% int main(void) { yylex(); } 特殊字符 '.</description></item><item><title>词法语法解析</title><link>https://gohalo.github.io/cn/blog/program-lexical-basic-introduce/</link><pubDate>Fri, 29 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-lexical-basic-introduce/</guid><description>&lt;p>介绍与词法语法分析相关的概念。&lt;/p></description></item><item><title>Bison 简介</title><link>https://gohalo.github.io/cn/blog/program-concept-syntax-bison-introduce/</link><pubDate>Wed, 20 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-concept-syntax-bison-introduce/</guid><description>&lt;p>bison 读入一个 CFG 文法的文件，在程序内经过计算，输出一个 parser generator 的 c 文件；也就是说 Bison 适合上下文无关文法，采用 LALR Parser (LALR语法分析器)。&lt;/p></description></item><item><title>UUID 详细介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-uuid-introduce/</link><pubDate>Fri, 15 Sep 2017 21:18:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-uuid-introduce/</guid><description>&lt;p>UUID 的目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中心节点指定，无需考虑数据库创建时的名称重复问题，目前最广泛应用的 UUID 是 RFC4122 协议规范的。&lt;/p>
&lt;p>有时 GUID 也特指是微软对标准 UUID 的实现，其实 RFC4122 的作者之一也是微软员工，这里介绍其使用方法。&lt;/p></description></item><item><title>正则表达式</title><link>https://gohalo.github.io/cn/blog/program-c-string-regular-expression/</link><pubDate>Tue, 05 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-regular-expression/</guid><description/></item><item><title>P2P 协议简介</title><link>https://gohalo.github.io/cn/blog/network-p2p-introduce/</link><pubDate>Mon, 28 Aug 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-p2p-introduce/</guid><description>不同于传统的 C/S 服务模型，取消了中心服务器，每个节点都可以作为客户端和服务端。
简介 # BitTorrent 实际上是一个协议族，其基本协议是 BEP-3 ，其它的大部分协议都是围绕这个来进行扩展或补充。
如果要通过 P2P 协议进行下载，必须要包含如下的几个文件：
种子文件，一般后缀为 .torrent ，本质上是一个由 bencode 编码的文本文件，把资源分成很多虚拟块，并记录每个块的 hash 值，还包括了文件大小、名字、Tracker服务器等信息。 BT 客户端，也就是专门解析 BT 协议的程序，例如迅雷、电驴等。 Tracker 服务器，记录着 Peer 和种子相关信息，起着中心调控的作用。 在下载资源的时候，大致的流程如下：
客户端解码种子文件，得到 Tracker 服务器的地址和资源信息； 通过和 Tracker 服务器沟通得到其它已经下载该资源的 Peers 信息； 再和这些 Peers 沟通得到自己想要的部分。 可以看到，在上述的流程中，Tracker 是整个流程的关键部分，如果不能通过 Tracker 读取到 Peers 的相关信息，那么也就无法下载资源。
DHT 协议 # 为了弥补 Tracker 的单点问题，于是出现了 Distributed Hash Table, DHT 协议，该协议基于 Kademlia 建立。
参考 # 一个资源嗅探器的网站 bthub.io 。 官方网站 bittorrent.org 包括了很多相关协议的开发文档。 一个传输可视化的示例网站 mq8.org 。</description></item><item><title>Linux C 网络编程</title><link>https://gohalo.github.io/cn/blog/program-c-network/</link><pubDate>Mon, 21 Aug 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-network/</guid><description/></item><item><title>MySQL 线上部署</title><link>https://gohalo.github.io/cn/blog/mysql-deploy-online/</link><pubDate>Mon, 21 Aug 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-deploy-online/</guid><description>&lt;p>主要介绍下 MySQL 如何在线上进行部署。&lt;/p></description></item><item><title>Linux C 网络编程</title><link>https://gohalo.github.io/cn/blog/c-linux-network-socket-program/</link><pubDate>Mon, 21 Aug 2017 17:49:01 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-network-socket-program/</guid><description>&lt;p>在 linux 中的网络编程会涉及到很多的细节，这里简单整理常见的问题，例如套接子信息、域名解析等等，有些也可能不怎么常见，以备不时之需。&lt;/p></description></item><item><title>50 行 Python 实现 Bitcoin</title><link>https://gohalo.github.io/cn/blog/bitcoin-50-python-lines/</link><pubDate>Mon, 07 Aug 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bitcoin-50-python-lines/</guid><description>&lt;p>区块链近年来被越炒越热，是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一次比特币网络交易的信息，用于验证其信息的有效性和生成下一个区块。&lt;/p>
&lt;p>而比特币的交易过程中，就使用了区块链技术。&lt;/p></description></item><item><title>C/C++ Sanitizer 简介</title><link>https://gohalo.github.io/cn/blog/language-c-some-sanitizers-introduce/</link><pubDate>Tue, 25 Jul 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-some-sanitizers-introduce/</guid><description>&lt;p>Sanitizer 英文翻译过来是杀菌剂的意思，Google 提供了很多相关的一些 Sanitizers ，用来检测程序的异常。&lt;/p>
&lt;p>可以做内存、地址访问、竞态条件的检测，这里简单介绍。&lt;/p></description></item><item><title>R 概率函数</title><link>https://gohalo.github.io/cn/blog/r-language-some-statistic-function-introduce/</link><pubDate>Sat, 15 Jul 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/r-language-some-statistic-function-introduce/</guid><description/></item><item><title>GoLang sync 模块介绍</title><link>https://gohalo.github.io/cn/blog/golang-common-module-sync-introduce/</link><pubDate>Sun, 11 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-sync-introduce/</guid><description/></item><item><title>Golang nil 解析</title><link>https://gohalo.github.io/cn/blog/golang-basic-concept-nil-introduce/</link><pubDate>Sat, 10 Jun 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-concept-nil-introduce/</guid><description/></item><item><title>Golang bytes 模块</title><link>https://gohalo.github.io/cn/blog/golang-common-module-bytes-introduce/</link><pubDate>Thu, 08 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-bytes-introduce/</guid><description>&lt;p>Golang 中的 bytes 包使用频率较高，主要提供了字节相关的操作，通常作为缓冲区使用。&lt;/p></description></item><item><title>Golang 调试方法</title><link>https://gohalo.github.io/cn/blog/golang-call-frame-debug-method-introduce/</link><pubDate>Thu, 08 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-call-frame-debug-method-introduce/</guid><description/></item><item><title>Python DocString 简介</title><link>https://gohalo.github.io/cn/blog/python-basic-syntax-docstring-introduce/</link><pubDate>Mon, 05 Jun 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-basic-syntax-docstring-introduce/</guid><description>&lt;p>也就是 Python 的文档字符串，提供了一种很方便的方式将文档与 modules、functions、classes 以及 methods ；该字符串是在对象的第一个语句中定义，然后通过 &lt;code>__doc__&lt;/code> 引用。&lt;/p></description></item><item><title>Python 杂项</title><link>https://gohalo.github.io/cn/blog/python-tips/</link><pubDate>Mon, 05 Jun 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-tips/</guid><description>&lt;p>在此记录与 Python 相关的乱七八糟的东西。&lt;/p></description></item><item><title>C++ 构造析构函数详细分析</title><link>https://gohalo.github.io/cn/blog/cpp-constructor-destructor/</link><pubDate>Wed, 31 May 2017 20:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-constructor-destructor/</guid><description>&lt;p>在 C++ 中，当类的内存申请完之后，会通过构造函数进行初始化，而构造函数在不同的使用场景下又分成了不同的类型，例如默认构造函数、简单构造函数、复制构造函数、转换构造函数等等。&lt;/p>
&lt;p>同时，在涉及到赋值操作时，最好将赋值操作运算符也重载掉，尤其是会动态申请内存的类；另外，随着 C++11 标准的发布，有引入了移动构造函数以及移动赋值运算符。&lt;/p>
&lt;p>这就导致构造函数与赋值重载不断重叠，很容易引起混淆，所以，这里就详细介绍其使用方式。&lt;/p></description></item><item><title>Python ORM 简介</title><link>https://gohalo.github.io/cn/blog/python-orm-introduce/</link><pubDate>Tue, 23 May 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-orm-introduce/</guid><description>&lt;p>很多数据库都可以通过相应的库，直接编写原生的 SQL 语句进行操作，实现增删改查，但是如果功能比较复杂，就会导致重用性不强。&lt;/p>
&lt;p>Object Relational Mapping, ORM 建立在数据库 API 之上，使用关系对象映射进行数据库操作；简言之，将对象转换成 SQL，然后使用数据 API 执行 SQL 并获取执行结果。&lt;/p></description></item><item><title>压缩库使用</title><link>https://gohalo.github.io/cn/blog/program-c-compress-library-introduce/</link><pubDate>Mon, 01 May 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-compress-library-introduce/</guid><description/></item><item><title>Linux Fail Points</title><link>https://gohalo.github.io/cn/blog/linux-c-fail-point-introduce/</link><pubDate>Mon, 10 Apr 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-fail-point-introduce/</guid><description>&lt;p>对于一些异常一般很难构建，尤其是像系统 API 调用、硬件故障等等，通过 FailPoints 可以在指定的代码段注入一些异常处理。&lt;/p>
&lt;p>实际上，BSD 已经提供了一套相关的 FailPoints 机制。&lt;/p></description></item><item><title>C++ STL 使用</title><link>https://gohalo.github.io/cn/blog/language-cpp-stl-basic-usage-introduce/</link><pubDate>Thu, 23 Mar 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-cpp-stl-basic-usage-introduce/</guid><description/></item><item><title>关于 C++ 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/cpp-basic-syntax-introduce/</link><pubDate>Mon, 20 Mar 2017 21:15:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-basic-syntax-introduce/</guid><description>&lt;p>一般会将 C++ 划分为所谓的中级语言，从底层的 C 语言发展而来，提供了比 C 更丰富的特性，而又没有提供类似 Java、Python 等语言的高级特性，所以，介于中间，称之为中级语言。&lt;/p>
&lt;p>随着 C++11 标准的发布，以及更新的 C++0x 标准，C++ 提供的功能越来越完善。&lt;/p>
&lt;p>这里仅简单介绍下基本的概念。&lt;/p></description></item><item><title>Python2 VS. Python3</title><link>https://gohalo.github.io/cn/blog/python-version2-vs-version3-introduce/</link><pubDate>Thu, 23 Feb 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-version2-vs-version3-introduce/</guid><description/></item><item><title>Python 字典对象实现</title><link>https://gohalo.github.io/cn/blog/python-dictioniary-string-hash-table/</link><pubDate>Sun, 08 Jan 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-dictioniary-string-hash-table/</guid><description>&lt;p>在 Python 中有一个字典，可以看作是一个 Key Value 对，其代码是通过哈希表实现，也就是说，字典是一个数组，而数组的索引是键经过哈希函数处理后得到的。&lt;/p>
&lt;p>Python 字典是用哈希表 (hash table) 实现，哈希表是一个数组，它的索引是对键运用哈希函数计算求得的。&lt;/p>
&lt;p>这里简单结合 Python 中 Hash 函数的实现。&lt;/p></description></item><item><title>C 代码覆盖率</title><link>https://gohalo.github.io/cn/blog/c-coverage-introduce/</link><pubDate>Sun, 13 Nov 2016 17:12:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-coverage-introduce/</guid><description>&lt;p>我们已经提供了一些测试用例，但是这些测试用例的好坏如何评估？是否已经覆盖了所有的函数？函数中的分支以及边界条件是否都已经覆盖？&lt;/p>
&lt;p>这就需要通过代码覆盖率进行查看，这里简单介绍其使用方法。&lt;/p></description></item><item><title>C 编译链接</title><link>https://gohalo.github.io/cn/blog/c-compile-linkage-introduce/</link><pubDate>Sun, 23 Oct 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-compile-linkage-introduce/</guid><description>&lt;p>详细介绍下与 C 语言相关的概念。&lt;/p></description></item><item><title>C Mock 使用以及机制介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-mock-wrap-unit-test/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-mock-wrap-unit-test/</guid><description>&lt;p>编写高效松耦合的模块，体现的是功力，而完善的测试用例则是习惯。包括了一些异常场景的积累，代码重构时的验证等等，编写有效的测试用例就尤为重要。&lt;/p>
&lt;p>而 C 语言，由于其偏向于底层，导致不能像 Java、Python、GO 那样提供了成熟的测试框架。&lt;/p>
&lt;p>这里简单介绍一下基于 cmocka 修改的测试框架，会通过一些宏定义处理部分问题，当然，真正使用时还需要一些其它的技巧。&lt;/p></description></item><item><title>CMake 常用示例</title><link>https://gohalo.github.io/cn/blog/cmake-some-tips/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-some-tips/</guid><description>&lt;p>整理常用的示例。&lt;/p></description></item><item><title>Ping 协议详细介绍</title><link>https://gohalo.github.io/cn/blog/network-icmp-ping-introduce/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-icmp-ping-introduce/</guid><description>&lt;p>Internet Control Message Protocol, ICMP(RFC-792) 基于 IP 协议，工作在七层协议的第三层，主要用来解析网络路由情况，通过返回错误信息进行分析定位。&lt;/p>
&lt;p>这里详细介绍其使用方式。&lt;/p></description></item><item><title>详细介绍 GoLang 的包管理机制</title><link>https://gohalo.github.io/cn/blog/golang-package-management/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-package-management/</guid><description>&lt;p>当拿到代码后，用户首先看到和接触的就是源码文件的布局、命名还有包的结构，代码漂亮、布局清晰、通俗易懂，就像是设计严谨的 API 一样。GoLang 的包管理经历了好几个阶段，从简单的通过环境变量管理，到现在完善的机制。&lt;/p>
&lt;p>相比其它语言，GoLang 的包管理机制对包、变量、代码格式，甚至代码组织结构等，都有详细的约束，这里详细介绍其包管理的规则。&lt;/p></description></item><item><title>GoLang JSON 编码解码</title><link>https://gohalo.github.io/cn/blog/golang-json-encode-decode-introduce/</link><pubDate>Fri, 07 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-json-encode-decode-introduce/</guid><description>&lt;p>随着 REST API 的兴起，基本上已经前后端分离，更多的返回格式是 json 字符串，这里简单讨论下在 GoLang 中如何编码和解码 JSON 结构。&lt;/p>
&lt;p>GoLang 提供了 &lt;code>encoding/json&lt;/code> 的标准库用于 JSON 的处理，简单记录 GoLang 中使用 JSON 的常用技巧。&lt;/p></description></item><item><title>Bash 重定向</title><link>https://gohalo.github.io/cn/blog/linux-bash-redirect-details/</link><pubDate>Fri, 23 Sep 2016 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-bash-redirect-details/</guid><description>&lt;p>所谓 IO 重定向简单来说就是一个过程，这个过程捕捉一个文件、命令、程序、脚本、甚至脚本中的代码块的输出，然后把捕捉到的输出，作为输入发送给另外一个文件、命令、程序、或者脚本。&lt;/p>
&lt;p>这里简单介绍常用命令及其实现。&lt;/p></description></item><item><title>GoLang 常用工具</title><link>https://gohalo.github.io/cn/blog/golang-some-third-tools/</link><pubDate>Mon, 08 Aug 2016 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-some-third-tools/</guid><description>&lt;p>这里简单介绍下 GoLang 中常用的工具，包括了 GVM、GDM、Goreman 等。&lt;/p></description></item><item><title>GoLang 实现 SSH 相关示例</title><link>https://gohalo.github.io/cn/blog/ssh-golang-examples/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-golang-examples/</guid><description>&lt;p>GoLang 提供了基础的 SSH 库，可以用来作为服务端或者客户端使用，这里整理了常见的用法。&lt;/p></description></item><item><title>Rust 迭代器详解</title><link>https://gohalo.github.io/cn/blog/rust-advanced-iterator/</link><pubDate>Mon, 18 Jul 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-iterator/</guid><description>&lt;p>Rust 中的迭代器 (Iterator) 是一个强大灵活的工具，将数据和处理过程分离，可以简化对数组、Map、链表等的访问操作。实现时，采用惰性求值，有效降低非必要的性能开销。&lt;/p></description></item><item><title>ELF 详解</title><link>https://gohalo.github.io/cn/blog/program-elf-details/</link><pubDate>Tue, 21 Jun 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-elf-details/</guid><description>&lt;p>ELF 的全称为 Executable and Linkable Format 用于存储 Linux 程序，可以从运行以及链接的两个视角查看，分别通过 Program Header Table 以及 Section Header Table 查看。&lt;/p></description></item><item><title>ZeroMQ 架构</title><link>https://gohalo.github.io/cn/blog/zeromq-architecture/</link><pubDate>Mon, 20 Jun 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zeromq-architecture/</guid><description>&lt;p>之前介绍了 ZeroMQ 的基本使用方法，接下来介绍一下其架构。&lt;/p></description></item><item><title>ZeroMQ 简介</title><link>https://gohalo.github.io/cn/blog/zeromq-introduce/</link><pubDate>Fri, 10 Jun 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zeromq-introduce/</guid><description>&lt;p>ZMQ (Zero Message Queue) 是一个 C++ 编写的高性能分布式消息队列，是一个非常简单好用的传输层，使得 Socket 编程更加简单、简洁和性能更高效。&lt;/p>
&lt;p>目前比较常用的消息中间件产品包括了 RabbitMQ、ZeroMQ、ActiveMQ，三者分别通过　Erlang、C++、Java 实现，相比而言，ZMQ 是一个简单的库，而非单独的中间件产品。&lt;/p>
&lt;p>接下来简单介绍一下 ZMQ 的相关内容。&lt;/p></description></item><item><title>CSS 选择器介绍</title><link>https://gohalo.github.io/cn/blog/web-css-selector/</link><pubDate>Fri, 20 May 2016 20:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-css-selector/</guid><description>&lt;p>简单介绍在 CSS 中如何选择对应的元素。&lt;/p></description></item><item><title>GoLang 参数校验</title><link>https://gohalo.github.io/cn/blog/golang-validator-introduce/</link><pubDate>Sat, 12 Mar 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-validator-introduce/</guid><description>&lt;p>接口开发经常会遇到一个问题是后端需要大量代码进行参数校验，防止用户的恶意请求。最常见的如日期格式、用户年龄、性别等必须是正常的值，不能随意设置。&lt;/p>
&lt;p>这里介绍 GoLang 中的一个参数校验库。&lt;/p></description></item><item><title>C Preload 简介</title><link>https://gohalo.github.io/cn/blog/c-preload-introduce/</link><pubDate>Thu, 25 Feb 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-preload-introduce/</guid><description>&lt;p>Linux C 中有一个很不错的特性，可以在不改变程序的前提下，修改动态库所调用的函数，也就是 Preload 功能。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Ansible 简介</title><link>https://gohalo.github.io/cn/blog/python-ansible/</link><pubDate>Sat, 13 Feb 2016 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-ansible/</guid><description>&lt;p>Ansible 是一个配置管理工具，当然同类的产品还有 Puppet、Chef、SaltStack 等，不过上述的三者都是基于服务端+客户端的模式，而 Ansible 相对来说要简单的多，无需安装服务端和客户端，只需要有 ssh 即可，而且使用简单。&lt;/p></description></item><item><title>Python 异步任务队列</title><link>https://gohalo.github.io/cn/blog/python-async-queue/</link><pubDate>Wed, 10 Feb 2016 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-async-queue/</guid><description>&lt;p>Python 中有很多的调度系统，这里简单介绍一下常用的，例如 APScheduler、Redis Queue、Celery 等。&lt;/p></description></item><item><title>SQLite 使用简介</title><link>https://gohalo.github.io/cn/blog/sqlite-introduce/</link><pubDate>Tue, 19 Jan 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/sqlite-introduce/</guid><description>&lt;p>SQLite 是一个开源的嵌入式关系数据库，一个简单无需配置的小型数据库，支持事物，在嵌入式设备或者小型应用中使用较多，例如 Android、Chrome、WeChat 等系统。&lt;/p>
&lt;p>它在 2000 年由 D. Richard Hipp 发布，用来减少应用程序管理数据的开销，可移植性好、很容易使用、高效而且可靠。&lt;/p></description></item><item><title>Java C 程序调用</title><link>https://gohalo.github.io/cn/blog/program-c-java/</link><pubDate>Wed, 23 Dec 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-java/</guid><description>&lt;p>简单介绍下 Java 和 C 程序的相互调用。&lt;/p></description></item><item><title>C/C++ 常见错误整理</title><link>https://gohalo.github.io/cn/blog/cpp-some-pitfalls/</link><pubDate>Tue, 22 Dec 2015 21:00:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-some-pitfalls/</guid><description/></item><item><title>CSS 示例代码</title><link>https://gohalo.github.io/cn/blog/web-css-basic-examples/</link><pubDate>Tue, 15 Dec 2015 22:10:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-css-basic-examples/</guid><description>&lt;p>介绍一些常见的 CSS 简单相关示例。&lt;/p></description></item><item><title>Linux 自动编译 AutoTools</title><link>https://gohalo.github.io/cn/blog/linux-autotools-auto-compile-introduce/</link><pubDate>Mon, 30 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-autotools-auto-compile-introduce/</guid><description>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。
这里简单介绍下 AutoTools 一系列工具的使用。
Autotools # 在 Linux 平台上，经常使用 configure-&amp;gt;make-&amp;gt;make install 从源码开始编译安装，也就是 GNU 构建系统，利用脚本和 make 程序在特定平台上编译软件，也就是利用 autotools 创建构建系统的项目。
注意，有些程序虽然也是采用上述的三步，但并未采用 autotools 实现，如 nginx 是作者编写的构建程序。
在 CentOS 中可以直接通过 yum install automake autoconf 安装相关的文件；利用 autotools 生成 Makefile 的过程如下图所示。
其中用到的核心工具包括了 Autoconf 和 Automake ，首先从用户和开发者角度看看两者的区别。关于 autotools 的简单处理流程可以参考 automake 中的 Setup Explained 内容。
用户视角 # configure 脚本是由软件开发者维护并发布给用户使用的 shell 脚本，该脚本作用是检测系统环境，最终目的是生成 Makefile 和 config.h 两个文件。
开发者在分发源码包时，除了源代码 (.c .h)，还有许多支撑软件构建的文件和工具，其中最重要的文件就是 Makefile.in 和 config.h.in 两个，在 configure 脚本执行成功后，将为每个 *.</description></item><item><title>Python 虚拟环境详解</title><link>https://gohalo.github.io/cn/blog/python-virtual-environments/</link><pubDate>Mon, 30 Nov 2015 20:19:36 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-virtual-environments/</guid><description>&lt;p>Python 的虚拟环境用来创建一个相对独立的执行环境，尤其是一些依赖的三方包，最常见的如不同项目依赖同一个但是不同版本的三方包，而且，在虚拟环境中的安装包不会影响到系统的安装包。&lt;/p>
&lt;p>不过，其具体的工作原理是怎样的，这里详细介绍。&lt;/p></description></item><item><title>数据结构 -- SkipList</title><link>https://gohalo.github.io/cn/blog/structure-skiplist-introduce/</link><pubDate>Fri, 20 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-skiplist-introduce/</guid><description>&lt;p>William Pugh 于 1990 年发表了 &lt;code>Skip lists: a probabilistic alternative to balanced trees&lt;/code> 论文，也就是设计初衷是作为替换平衡树的一种选择，这是一种随机化数据结构，基于并联的链表，其效率可比拟二叉查找树。&lt;/p>
&lt;p>同时，可以支持排序。&lt;/p></description></item><item><title>C 参数解析</title><link>https://gohalo.github.io/cn/blog/program-c-linux-getopt-usage-introduce/</link><pubDate>Tue, 10 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-linux-getopt-usage-introduce/</guid><description>&lt;p>在 glibc 中提供了一个通用的参数解析库，包括了短参以及长参的使用。&lt;/p></description></item><item><title>Linux 自动编译 Makefile</title><link>https://gohalo.github.io/cn/blog/linux-makefile-auto-compile-introduce/</link><pubDate>Tue, 03 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-makefile-auto-compile-introduce/</guid><description>&lt;p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。&lt;/p>
&lt;p>这里简单介绍下最基本的 Makefile 。&lt;/p></description></item><item><title>Lua 源码解析</title><link>https://gohalo.github.io/cn/blog/lua-sourcecode/</link><pubDate>Wed, 28 Oct 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-sourcecode/</guid><description>&lt;p>Lua 类似于 Java、Python，实际执行的都不是机器码，而是运行在虚拟机上的，而虚拟机则屏蔽了底层不同的硬件，从而使得这些程序可以跨平台执行，包括不同的操作系统以及不同的硬件平台。&lt;/p>
&lt;p>相比而言，Lua 的代码十分简单，源码总共才 2W 行左右，但是却实现了很多不错的特性。&lt;/p>
&lt;p>接下来，我们看看 Lua 具体是如何工作的。&lt;/p></description></item><item><title>Java JDBC 驱动介绍</title><link>https://gohalo.github.io/cn/blog/java-jdbc-introduce/</link><pubDate>Mon, 19 Oct 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/java-jdbc-introduce/</guid><description>&lt;p>JDBC (Java Datebase Connectivity) 实际是一个独立于特定数据库管理系统、通用的 SQL 数据库存取和操作的公共接口，它是 JAVA 访问数据库的一种标准。也就是说它只是接口规范，具体实现是各数据库厂商提供的驱动程序。&lt;/p>
&lt;p>接下来，先看看 JDBC 的使用方法，然后看看其具体的实现原理。&lt;/p></description></item><item><title>GoLang Echo 中间件</title><link>https://gohalo.github.io/cn/blog/golang-echo-middleware/</link><pubDate>Tue, 06 Oct 2015 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-echo-middleware/</guid><description>&lt;p>Echo 中间件指的是可以拦截 http 请求的特殊函数，在请求和响应中间可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。&lt;/p></description></item><item><title>Lua 协程</title><link>https://gohalo.github.io/cn/blog/lua-coroutine/</link><pubDate>Tue, 06 Oct 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-coroutine/</guid><description>协程是另外一种并发方式，相比多进程或者多线程来说，其上下文的切换成本开销更小，这也意味这协程的执行更加高效。
Lua 作为一种简单的语言，仍然可以支持闭包、协程等较新的特性，在此介绍一下协程相关的内容。
简介 # 对于并发任务，通常有两种解决方法：A) 抢占式 (preemptive) 多任务，常见的是通过操作系统决定何时执行哪个任务；B) 协作式 (cooperative) 多任务，有任务自身决定何时放弃任务的执行。
协程 (coroutine) 是一种程序控制机制，实际上在上世纪 60 年代就已经被提出，用来方便地实现协作式的多任务。在很多主流的程序语言中，如 C/C++、Java 等，很少能看到协程，但现在不少脚本语言，如 Python、Lua 等，都提供了协程或与之相似的机制。
Lua 实现的是一种非对称式 (asymmetric) 或者称为半对称式 (semi-symmetric) 协程，之所以被称为非对称的，是因为它提供了两种传递程序控制权的操作：A) 利用 resume() (重)调用协程；B) 通过 yield 挂起协程并将程序控制权返回给协程的调用者。这看起来有点像函数的调用过程。
而 libtask 的实现就更像对称式的协程。
协程类似于线程，包含了自己的栈、本地变量、指针，但是包括了其它的全局变量是共享的。与线程不同的是，线程可以真正的在多个核上并发执行，而协程在具体的时间只能运行其中的一个。
常用接口 # 与协程相关的函数包含在 coroutine table 中，其中的 create() 函数用来创建一个协程，该函数会返回一个 thread 类型的变量，用来表示协程。
co = coroutine.create(function () print(&amp;#34;Hello World&amp;#34;) end) print(co) --&amp;gt; thread: 0x24a0b20 Lua 中的协程包含了四种状态：suspended、running、dead 以及 normal，可以通过 satatus() 查看。
print(coroutine.status(co)) --&amp;gt; suspended 刚创建的协程处于 suspended 状态，也就是说创建时不会自动运行；可以通过 resume() 函数运行或者重新运行该协程，将状态从 suspended 转换为 running 。如上的函数中，仅仅打印字符串，那么执行完成之后，状态会变为 dead 。</description></item><item><title>Bash 基本介绍</title><link>https://gohalo.github.io/cn/blog/bash-basic-introduce/</link><pubDate>Wed, 23 Sep 2015 22:55:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-basic-introduce/</guid><description>&lt;p>一些与 Bash 相关的内容，如命令执行顺序、配置文件、通配符、元字符及转义字符等。&lt;/p></description></item><item><title>Bash 命令注释</title><link>https://gohalo.github.io/cn/blog/bash-tips-command-comment/</link><pubDate>Sat, 19 Sep 2015 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-tips-command-comment/</guid><description>&lt;p>在通过 &lt;code>man&lt;/code> 查看命令时，可以看到对参数解释时是有大概的固定格式的，这里基本介绍如下。&lt;/p></description></item><item><title>C 语言的字符串</title><link>https://gohalo.github.io/cn/blog/program-c-string-stuff/</link><pubDate>Wed, 16 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-stuff/</guid><description>&lt;p>简单介绍下 C 语言中与字符串操作相关的函数。&lt;/p></description></item><item><title>C 加载过程</title><link>https://gohalo.github.io/cn/blog/c-load-process/</link><pubDate>Tue, 15 Sep 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-load-process/</guid><description>&lt;p>这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。&lt;/p></description></item><item><title>C 语言通配符</title><link>https://gohalo.github.io/cn/blog/program-c-string-linux-wildcard/</link><pubDate>Tue, 08 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-linux-wildcard/</guid><description>&lt;p>简单介绍下 C 语言中与字符串操作相关的函数。&lt;/p></description></item><item><title>最小的ELF文件</title><link>https://gohalo.github.io/cn/blog/linux-the-really-teensy-elf-file/</link><pubDate>Wed, 26 Aug 2015 21:16:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-the-really-teensy-elf-file/</guid><description>&lt;p>从最经典 &amp;ldquo;Hello World&amp;rdquo; C 程序实例，逐步演示如何通过各种常用工具来分析 ELF 文件，并逐步精简代码，尽量减少可执行文件的大小。&lt;/p>
&lt;p>接下来，看看一个可打印 &amp;ldquo;Hello World&amp;rdquo; 的可执行文件能够小到什么样的地步。&lt;/p></description></item><item><title>C 语言的奇技淫巧</title><link>https://gohalo.github.io/cn/blog/program-c-tips/</link><pubDate>Sun, 16 Aug 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-tips/</guid><description>&lt;p>整理下 C 语言中常用的技巧。&lt;/p></description></item><item><title>Python 时间操作</title><link>https://gohalo.github.io/cn/blog/python-time-handle/</link><pubDate>Fri, 26 Jun 2015 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-time-handle/</guid><description>&lt;p>Python 与时间处理相关的提供了 datetime、time、calendar 三个模块，而且还有三方模块 pytz 可以使用；另外，datetime 模块中又存在 datetime、time 类，不要与相应的模块混淆。&lt;/p></description></item><item><title>Java 环境搭建</title><link>https://gohalo.github.io/cn/blog/java-environment/</link><pubDate>Fri, 19 Jun 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/java-environment/</guid><description>&lt;p>简单记录一下 Linux 下的 Java 环境搭建，以及使用方法。&lt;/p></description></item><item><title>Python 动态执行</title><link>https://gohalo.github.io/cn/blog/python-eval/</link><pubDate>Tue, 16 Jun 2015 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-eval/</guid><description>&lt;p>在 Python 中，允许通过 exec 和 eval 执行以字符串形式表示的代码片段，这体现了动态语言的特性，可以让代码变得更灵活。实际上，在使用 exec 和 eval 时，也是需要进行编译的，没错是 &amp;ldquo;编译&amp;rdquo;。&lt;/p>
&lt;p>只是与 C 需要编译成机器码不同，CPython 需要编译成字节码 (ByteCode) 。&lt;/p>
&lt;p>接下来，我们看看 Python 的动态执行相关内容。&lt;/p></description></item><item><title>Python 模块简介</title><link>https://gohalo.github.io/cn/blog/python-modules-introduce/</link><pubDate>Sun, 07 Jun 2015 21:39:22 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-modules-introduce/</guid><description>在 Python 解析器中，每次重新进入，之前定义的函数、变量等都会丢失，所以，通常是将代码保存在文件中运行，而随着功能增加，文件会变得越来越大，为了方便维护，会将其拆分成多个文件。
其它语言也有类似的问题，Python 将其称为模块 (Module) ，通过模块可以定义函数、类、变量等，从而更有逻辑地组织 Python 代码。
这里介绍模块的引入、搜索、制作等一些常见的问题。
简介 # 每个文件都是一个模块 (module)，其模块名就是对应的文件名，在模块内运行时，可以通过全局变量 __name__ 获取，最常见的就是 __main__ 的判断，也就是是否为主 Pyhton 脚本。
if __name__ == &amp;#34;__main__&amp;#34;: print(&amp;#34;Hello World&amp;#34;) 也就是该文件可以作为模块引入其它代码中，也可以作为一个独立的执行文件运行，而判断的逻辑就是这里的 if __name__ == &amp;quot;__main__&amp;quot; 语句，直接调用脚本时，对应 __name__ 变量保存的是 __main__ ，如果是引入的模块，则是模块名称。
模块导入 # 可以通过 import 关键字导入模块，也就是添加到当前的命名空间中，根据不同的使用场景，有如下的几种方式。
# 直接导入模块，可以通过math.cos()调用 import math # 导入模块中的函数，这样可以直接调用cos sin，不过很容易被覆盖 from math import cos, sin # 导入模块的所有符号 from math import * # 导入模块的符号，为了防止名字覆盖，将其重命名 from math import pi as PI 导入的模块会保存在 sys.modules 中，这是一个字典，如果多次导入第二次实际不会有加载的动作。</description></item><item><title>Python 的垃圾回收</title><link>https://gohalo.github.io/cn/blog/python-garbage-collection/</link><pubDate>Sun, 07 Jun 2015 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-garbage-collection/</guid><description>&lt;p>Python 带有自动垃圾回收机制，但是它真的能处理所有的垃圾回收问题吗？ 是不是有了自动垃圾回收，就不用再担心内存泄露了呢？ 为什么经常会看到文章说，在实现自己的类时，不要使用 &lt;code>__del__()&lt;/code> ？&lt;/p>
&lt;p>很多当代的语言都实现了垃圾回收机制，包括 Java、Ruby、Lua、Go等，从而将众码农从内存管理中释放出来，那么 Python 的垃圾回收是怎么实现的呢？&lt;/p>
&lt;p>这篇文章将详细介绍 Python 垃圾回收的使用方法，包括示例以及相关的源码分析。&lt;/p></description></item><item><title>Linux AIO</title><link>https://gohalo.github.io/cn/blog/linux-program-aio/</link><pubDate>Sat, 09 May 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-aio/</guid><description>&lt;p>AIO 是 Linux 下的异步读写模型，它是 2.6 内核提供的一个标准增强特性。对于文件的读写，即使以 O_NONBLOCK 方式来打开一个文件，也会处于 &amp;ldquo;阻塞&amp;rdquo; 状态，因为文件时时刻刻处于可读状态，而从磁盘到内存所等待的时间是惊人的。&lt;/p>
&lt;p>为了充份发挥把数据从磁盘复制到内存的时间，引入了 AIO 模型，其基本原理是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成。稍后或在接收到 I/O 操作完成的通知时，进程就可以检索 I/O 操作的结果。&lt;/p></description></item><item><title>C 多语言支持</title><link>https://gohalo.github.io/cn/blog/c-linux-i18n-multi-language-gettext-usage/</link><pubDate>Wed, 06 May 2015 18:20:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-i18n-multi-language-gettext-usage/</guid><description>&lt;p>可以通过 gettext 进行处理，一个在 Linux 上的 i18n 国际化常用的解决方案。&lt;/p></description></item><item><title>FTP 服务简介</title><link>https://gohalo.github.io/cn/blog/network-service-ftp/</link><pubDate>Wed, 29 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-service-ftp/</guid><description>&lt;p>File Transfer Protocol, FTP(RFC 959) 是 TCP/IP 协议组中的协议之一，其传输效率非常高，在网络上传输大的文件时，一般也采用该协议。&lt;/p></description></item><item><title>Linux C++ 线程同步</title><link>https://gohalo.github.io/cn/blog/program-cpp-linux-synchronize/</link><pubDate>Thu, 23 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-cpp-linux-synchronize/</guid><description/></item><item><title>Linux 线程同步</title><link>https://gohalo.github.io/cn/blog/program-c-linux-pthreads-synchronize/</link><pubDate>Thu, 23 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-linux-pthreads-synchronize/</guid><description>&lt;p>线程的三个主要同步原语：互斥锁 (mutex)、信号量 (semaphore) 和条件变量 (cond)。其中 mutex 和 sem 都是对应 futex 进行了简单的封装，在不存在冲突的情况下就不用陷入到内核中进行仲裁；而且 pthread_join 也是借助 futex 来实现的。&lt;/p>
&lt;p>简单介绍下 Linux 中与线程相关的编程。&lt;/p></description></item><item><title>glob 命令格式使用详解</title><link>https://gohalo.github.io/cn/blog/bash-tips-glob-introduce/</link><pubDate>Tue, 10 Feb 2015 20:30:45 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-tips-glob-introduce/</guid><description>&lt;p>除了常见的正则表达式之外，还有一种 glob 模式经常用于匹配文件路径，相比正则来说更加简单，匹配效率也要更高一些，所以，在某些方面可以替换掉正则。&lt;/p></description></item><item><title>Greenlet Gevent</title><link>https://gohalo.github.io/cn/blog/python-gevent-greenlet/</link><pubDate>Thu, 04 Sep 2014 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-gevent-greenlet/</guid><description>&lt;p>对于服务器端的编程，从多进程，到多线程，再到异步回调，再到现在比较流行的协程的方式。对于 Python 来说，支持多进程；由于存在 GIL，实际对于线程会有性能影响。&lt;/p>
&lt;p>对于 Python 协程在此介绍一下 greenlet 的实现。&lt;/p></description></item><item><title>闰秒简介</title><link>https://gohalo.github.io/cn/blog/linux-leap-seconds-basic-introduce/</link><pubDate>Sat, 30 Aug 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-leap-seconds-basic-introduce/</guid><description>&lt;p>闰秒，是为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中对协调世界时增加或减少 1 秒的调整。&lt;/p>
&lt;p>由于地球自转的不均匀性和长期变慢性，当世界时和原子时之间相差超过到 ±0.9 秒时，就把协调世界时向前拨 1 秒或向后拨 1 秒。&lt;/p>
&lt;p>闰秒的调整也就是意味着 UTC 与 TAI(国际原子时) 之间的差异，截止到 2016 年，两者已经相差 37 秒。&lt;/p></description></item><item><title>libgcrypt 使用</title><link>https://gohalo.github.io/cn/blog/security-libgcrypt-practice/</link><pubDate>Wed, 16 Jul 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-libgcrypt-practice/</guid><description>&lt;p>libgcrypt 是一个非常成熟的加密算法库，也是著名的开源加密软件 GnuPG 的底层库，支持多种对称、非对称加密算法，以及多种 Hash 算法。&lt;/p>
&lt;p>接下来，看看该库的使用方式。&lt;/p></description></item><item><title>Linux 时间函数</title><link>https://gohalo.github.io/cn/blog/linux-timer-functions/</link><pubDate>Mon, 02 Jun 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-timer-functions/</guid><description>&lt;p>简单介绍下 Linux 中与时间相关的函数。&lt;/p></description></item><item><title>Awesome Projects</title><link>https://gohalo.github.io/cn/blog/awesome-projects/</link><pubDate>Sun, 25 May 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/awesome-projects/</guid><description/></item><item><title>SEO 优化技巧</title><link>https://gohalo.github.io/cn/blog/seo-tips-for-webs/</link><pubDate>Mon, 28 Oct 2013 19:20:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/seo-tips-for-webs/</guid><description>&lt;p>所谓的 SEO 也就是搜索引擎优化，指遵循搜索引擎的搜索原理，对网站结构、网页文字语言和站点间互动外交略等进行合理规划部署，以改善网站在搜索引擎的搜索表现，进而增加客户发现并访问网站的可能性。&lt;/p>
&lt;p>这里主要介绍一些常见的优化技巧。&lt;/p></description></item><item><title>Python 基本环境准备</title><link>https://gohalo.github.io/cn/blog/python-environment-prepare/</link><pubDate>Thu, 17 Oct 2013 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-environment-prepare/</guid><description>&lt;p>与 Java 类似，Python 底层通过一个虚拟机运行，而且已经移植到了多个平台上，也就是，需要根据不同的平台安装虚拟机，实际上最主要的就是 python 可执行文件。&lt;/p>
&lt;p>现在大多数安装的都是 CPython ，也就是 C 语言实现的 Python ，通常，直接使用安装包安装即可。&lt;/p>
&lt;p>这里详细介绍如何安装环境，使用虚拟环境等等。&lt;/p></description></item><item><title>【专题】C/C++ 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-c-cpp/</link><pubDate>Fri, 12 Nov 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-c-cpp/</guid><description>C 语言 # 在 1989 年，美国国家标准协会 (ANSI) 对 C 语言进行了标准化，此时 C 语言又被称为 ANSI C。在一年后被国际标准化组织 ISO 采纳，所以 C 语言在 ISO 中有了一个官方名称 ISO/IEC 9899:1990 ，其中 9899 是 C 语言在 ISO 标准中代号 (C++ 是 14882)，冒号后面的 1990 表示当前修订好的版本是在 1990 年发布。
所以，最开始的 C 语言标准也被称为 C89、C90 或者 C89/C90，后续又在 1999、2007、2011 进行了改进。另外，C++ 在从 C++11 之后，基本固定每三年发布一个新版本。
整数介绍 包括了类型提升、整型溢出等。 宏使用 一些基本使用规则，以及常见注意事项。 数据对齐 结构体以及内存的对齐方式。 指针简介 包括了基本概念、函数指针等概念的介绍。 位域和字节序 位域或位段相关概念，以及大小端字节序相关的内容。 inline 简介 有点类似于 C 中的宏，但是又有所区别。 Volatile 简介 C 语言中与 volatile 相关的介绍。 基本概念 # 不只是 C 相关代码，实际上更多的是 Linux 中的基本介绍。</description></item><item><title>【专题】Python 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-python/</link><pubDate>Sun, 17 Oct 2010 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-python/</guid><description>&lt;p>Python 是一种解释型语言，提供了跨平台的支持，可以快速开发一些脚本，随着 AI 的兴起，提供了一些常见的开发框架，这里详解介绍 Python 的使用。&lt;/p></description></item><item><title>【专题】Rust 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-rust/</link><pubDate>Sat, 16 Oct 2010 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-rust/</guid><description>&lt;p>可以将 Rust 理解为 C 的直接替代品，提供了系统级的性能，而且在很多方面更好，最常提到的就是内存安全，并且可以与遗留 C 代码原生互操作以进行增量替换。&lt;/p></description></item><item><title>【专题】GoLang 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-golang/</link><pubDate>Wed, 06 Oct 2010 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-golang/</guid><description>&lt;p>GoLang 是谷歌 2009 年发布的开源编程语言，其开发人员都是计算机界大神一般的存在，提供了便捷的协程使用，具有很高的并发性。目前很多 Cloud Native 软件都是通过 GoLang 编写，例如 Docker、K8S、LXD 等等。&lt;/p></description></item><item><title>【专题】Bash 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-bash/</link><pubDate>Sun, 19 Sep 2010 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-bash/</guid><description>&lt;p>Shell 是一个程序，用于用户和操作系统进行交互，相当于是一个命令解析器，Shell 有很多种，其实现有很多细节差异，不过大部分的语法基本相同。&lt;/p>
&lt;p>在 Linux 中默认的就是 Bash 实现，这里介绍其常用语法以及使用技巧。&lt;/p></description></item><item><title>【专题】Java 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-java/</link><pubDate>Thu, 06 May 2010 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-java/</guid><description>&lt;p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的高级程序设计语言，可运行于多个平台，如 Windows、Mac OS 及其它多种类 UNIX 版本的系统，包括 Linux 系统。&lt;/p></description></item></channel></rss>