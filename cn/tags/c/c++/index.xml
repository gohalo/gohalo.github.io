<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c/c++ on</title><link>https://gohalo.github.io/cn/tags/c/c++/</link><description>Recent content in c/c++ on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://gohalo.github.io/cn/tags/c/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>详细介绍 C++ 的强制转换方法</title><link>https://gohalo.github.io/cn/blog/cpp-cast-methods-introduce/</link><pubDate>Fri, 20 Nov 2020 23:18:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-cast-methods-introduce/</guid><description>&lt;p>在 C 中提供了强制类型转换，不过其实现很简单，而且没有区分具体的使用场景，所以，在编译或者运行阶段可能会出现一些异常，尤其是一旦不注意极易发生异常。&lt;/p>
&lt;p>为此，C++ 对于不同的场景进行了划分，由于 C++ 支持面向对象编程，也因此对这一场景进行了优化。&lt;/p>
&lt;p>本文详细介绍其使用场景。&lt;/p></description></item><item><title>CMake 使用简介</title><link>https://gohalo.github.io/cn/blog/cmake-basic-introduce/</link><pubDate>Thu, 26 Dec 2019 17:49:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-basic-introduce/</guid><description>&lt;p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，对于简单的程序来说是可以的，当项目变得复杂之后会很难进行维护。&lt;/p>
&lt;p>而目前在维护 C/C++ 项目时，使用比较多的是 CMake ，这里就详细介绍下 CMake 的使用。&lt;/p></description></item><item><title>C++ 右值引用</title><link>https://gohalo.github.io/cn/blog/cpp-right-value-reference/</link><pubDate>Fri, 20 Dec 2019 21:18:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-right-value-reference/</guid><description>&lt;p>在 C++11 的新特性中增加了所谓的右值引用的支持，其主要目的是为了解决两个问题：A) 临时对象非必要的拷贝操作；B) 在模板函数中如何按照参数的实际类型进行转发。&lt;/p>
&lt;p>同时，和右值引用相关的概念比较多，包括了纯右值、将亡值、Universal References、引用折叠、移动语义、Move语义和完美转发等等，这里简单介绍。&lt;/p></description></item><item><title>Linux 可执行文件解析工具</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</link><pubDate>Sat, 08 Jun 2019 21:19:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</guid><description>&lt;p>主要是在如何解析 ELF 格式的文件。&lt;/p></description></item><item><title>C 动态参数使用详解</title><link>https://gohalo.github.io/cn/blog/c-dynamic-arguments/</link><pubDate>Wed, 19 Dec 2018 21:40:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-dynamic-arguments/</guid><description>&lt;p>在使用过程中，通常会有参数个数不确定，最常见的是 &lt;code>printf&lt;/code> 这类的函数，只有在使用时才能确定参数的个数以及其类型。&lt;/p>
&lt;p>这里详细介绍其使用以及基本原理。&lt;/p></description></item><item><title>Linux C 网络编程</title><link>https://gohalo.github.io/cn/blog/c-linux-network-socket-program/</link><pubDate>Mon, 21 Aug 2017 17:49:01 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-network-socket-program/</guid><description>&lt;p>在 linux 中的网络编程会涉及到很多的细节，这里简单整理常见的问题，例如套接子信息、域名解析等等，有些也可能不怎么常见，以备不时之需。&lt;/p></description></item><item><title>C++ 构造析构函数详细分析</title><link>https://gohalo.github.io/cn/blog/cpp-constructor-destructor/</link><pubDate>Wed, 31 May 2017 20:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-constructor-destructor/</guid><description>&lt;p>在 C++ 中，当类的内存申请完之后，会通过构造函数进行初始化，而构造函数在不同的使用场景下又分成了不同的类型，例如默认构造函数、简单构造函数、复制构造函数、转换构造函数等等。&lt;/p>
&lt;p>同时，在涉及到赋值操作时，最好将赋值操作运算符也重载掉，尤其是会动态申请内存的类；另外，随着 C++11 标准的发布，有引入了移动构造函数以及移动赋值运算符。&lt;/p>
&lt;p>这就导致构造函数与赋值重载不断重叠，很容易引起混淆，所以，这里就详细介绍其使用方式。&lt;/p></description></item><item><title>关于 C++ 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/cpp-basic-syntax-introduce/</link><pubDate>Mon, 20 Mar 2017 21:15:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-basic-syntax-introduce/</guid><description>&lt;p>一般会将 C++ 划分为所谓的中级语言，从底层的 C 语言发展而来，提供了比 C 更丰富的特性，而又没有提供类似 Java、Python 等语言的高级特性，所以，介于中间，称之为中级语言。&lt;/p>
&lt;p>随着 C++11 标准的发布，以及更新的 C++0x 标准，C++ 提供的功能越来越完善。&lt;/p>
&lt;p>这里仅简单介绍下基本的概念。&lt;/p></description></item><item><title>C 代码覆盖率</title><link>https://gohalo.github.io/cn/blog/c-coverage-introduce/</link><pubDate>Sun, 13 Nov 2016 17:12:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-coverage-introduce/</guid><description>&lt;p>我们已经提供了一些测试用例，但是这些测试用例的好坏如何评估？是否已经覆盖了所有的函数？函数中的分支以及边界条件是否都已经覆盖？&lt;/p>
&lt;p>这就需要通过代码覆盖率进行查看，这里简单介绍其使用方法。&lt;/p></description></item><item><title>C Mock 使用以及机制介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-mock-wrap-unit-test/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-mock-wrap-unit-test/</guid><description>&lt;p>编写高效松耦合的模块，体现的是功力，而完善的测试用例则是习惯。包括了一些异常场景的积累，代码重构时的验证等等，编写有效的测试用例就尤为重要。&lt;/p>
&lt;p>而 C 语言，由于其偏向于底层，导致不能像 Java、Python、GO 那样提供了成熟的测试框架。&lt;/p>
&lt;p>这里简单介绍一下基于 cmocka 修改的测试框架，会通过一些宏定义处理部分问题，当然，真正使用时还需要一些其它的技巧。&lt;/p></description></item><item><title>CMake 常用示例</title><link>https://gohalo.github.io/cn/blog/cmake-some-tips/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-some-tips/</guid><description>&lt;p>整理常用的示例。&lt;/p></description></item><item><title>【专题】C/C++ 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-c-cpp/</link><pubDate>Fri, 12 Nov 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-c-cpp/</guid><description>C # 链接顺序 静态库的不同顺序会影响最终二进制的生成，这里简单介绍。 动态参数 在函数传参过程中允许使用多个动态参数，这里介绍如何使用以及其原理。 强弱符号 编译过程中提供了强弱符号的概念，可以用于简单的覆盖。 CPP # 基本概念 介绍基本的语法，例如封装、继承、多态、多线程等等。 构造析构 在对象内存申请完之后会通过构造函数初始化，不同场景包含了多种构造函数。 强制转换 按照不同的场景提供了不同的类型转换方法，这样在异常是可以及时发现。 右值引用 按照不同的场景提供了不同的类型转换方法，这样在异常是可以及时发现。 Linux 编程 # 在 Linux 环境下会有不同的实现。
网络编程 网络编程中的基本概念，例如结构体、域名解析、IP 地址等。 工具解析 介绍一些在 Linux 常用的二进制解析工具。 进程创建 Linux 中有多种子进程的创建方式，这里详细介绍其用法。 单元测试 编译过程中提供了强弱符号的概念，可以用于类似单元测试的场景。 内存检查 # Valgrind 介绍一些在 Linux 常用的二进制解析工具。 GDB # GDB 是一个很强大的调试工具，支持远程调试、嵌入式调试、输出的重定向。
基本介绍 简单介绍其常用的功能，包括 watchpoint、catchpoint 等内容。 调试格式 这里对标准的 DWARF 格式进行详细介绍。 栈帧分析 栈是一块内存空间，会从高地址向低地址增长，用于保存临时变量、传参等。 初始脚本 启动时会默认加载初始化脚本，通常是部分命令配置以及一些复杂函数。 Python脚本 在 7.X 之后的版本中增加了 Python 脚本支持，比之前的 DSL 实现要强大很多。 Test # 测试主要是为了可以提前发现异常，尤其是当重构时，可以进行完整的验证，所以，就慢慢衍生出了所谓 Test Drived Develop, TDD，而且产生了很多测试方法。</description></item></channel></rss>