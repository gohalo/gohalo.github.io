<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c/cpp on</title><link>https://gohalo.github.io/cn/tags/c/cpp/</link><description>Recent content in c/cpp on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://gohalo.github.io/cn/tags/c/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 调用 C 使用示例</title><link>https://gohalo.github.io/cn/blog/rust-ffi-rust-invoke-c/</link><pubDate>Mon, 24 Jun 2024 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-ffi-rust-invoke-c/</guid><description>&lt;p>简单介绍 Rust 调用 C 常用的示例代码。&lt;/p></description></item><item><title>C 调用 Rust 使用示例</title><link>https://gohalo.github.io/cn/blog/rust-ffi-c-invoke-rust/</link><pubDate>Thu, 20 Jun 2024 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-ffi-c-invoke-rust/</guid><description>&lt;p>整理 C 调用 Rust 时需要注意的事项。&lt;/p></description></item><item><title>LLVM 即时编译</title><link>https://gohalo.github.io/cn/blog/llvm-jit-introduce/</link><pubDate>Sun, 29 Oct 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llvm-jit-introduce/</guid><description>&lt;p>当前大部分的一些三方编译器都会依赖于 LLVM 框架，除了经常使用的 clang 编译器之外，还可以作为一个框架使用。&lt;/p></description></item><item><title>CRC 循环校验详解</title><link>https://gohalo.github.io/cn/blog/crc-basic-introduce/</link><pubDate>Sun, 20 Nov 2022 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/crc-basic-introduce/</guid><description>&lt;p>Cyclic Redundancy Check, CRC 循环冗余校验，通常用于网络、文件等校验，校验码的长度固定，而且从检错的正确率与速度成本之间比较好的平衡，使其称为当前最常见的数据校验方式。&lt;/p></description></item><item><title>C++ 命令行解析包 gflags 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-gflags-usage/</link><pubDate>Sun, 22 Nov 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-gflags-usage/</guid><description>&lt;p>gflags 是 Google 提供的一个命令行参数处理的开源库，目前已经独立开源，比传统的 &lt;code>getopt()&lt;/code> 功能更加强大，可以将不同的参数定义分布到各个源码文件中，不需要集中管理。&lt;/p>
&lt;p>提供了 C++ 和 Python 两个版本，这里仅详细介绍 C++ 版本的使用方式。&lt;/p></description></item><item><title>详细介绍 C++ 的强制转换方法</title><link>https://gohalo.github.io/cn/blog/cpp-cast-methods-introduce/</link><pubDate>Fri, 20 Nov 2020 23:18:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-cast-methods-introduce/</guid><description>&lt;p>在 C 中提供了强制类型转换，不过其实现很简单，而且没有区分具体的使用场景，所以，在编译或者运行阶段可能会出现一些异常，尤其是一旦不注意极易发生异常。&lt;/p>
&lt;p>为此，C++ 对于不同的场景进行了划分，由于 C++ 支持面向对象编程，也因此对这一场景进行了优化。&lt;/p>
&lt;p>本文详细介绍其使用场景。&lt;/p></description></item><item><title>详细介绍 glibc 特性宏的使用</title><link>https://gohalo.github.io/cn/blog/glibc-feature-macros-usage/</link><pubDate>Fri, 23 Oct 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/glibc-feature-macros-usage/</guid><description>&lt;p>GNU C Library 也就是 glibc 库，是目前 Linux 上最为基本的 C 语言库，不过其实现的不只是标准的 C 定义，还包括了其它的一些标准协议，不同场景下用户可以使用不同的接口。&lt;/p>
&lt;p>这些特性的开启都是通过宏来实现的，这里详细介绍其使用方式。&lt;/p></description></item><item><title>C++ Mock 工具 gmock 使用</title><link>https://gohalo.github.io/cn/blog/cpp-gmock-usage/</link><pubDate>Fri, 25 Sep 2020 19:30:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-gmock-usage/</guid><description>&lt;p>所谓的 mock 方法，是单元测试中常见的一种测试方式，用来模拟对象、隔离边界等，例如单元测试时模拟三方接口，这样服务可以独立测试；开发阶段不需要依赖其它类的开发进度等等。&lt;/p>
&lt;p>在 C++ 中，比较常用的是 Google 的 GMock 工具，可以用来模拟构造接口，并返回 mock 数据。&lt;/p>
&lt;p>这里我们从一个简单的示例开始，一步步详细介绍其使用方法，以及一些常用的技巧。&lt;/p></description></item><item><title>C++ 单测工具 gtest 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-google-test-introduce/</link><pubDate>Wed, 16 Sep 2020 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-google-test-introduce/</guid><description>&lt;p>这是 Google 提供的一个跨平台的测试、Mock 框架，很简单几乎没有依赖，但是提供了丰富的断言机制，尤其是提供了大部分其它语言测试框架没有的死亡测试。&lt;/p>
&lt;p>这里就详细介绍如何使用这一单元测试工具。&lt;/p></description></item><item><title>浮点数的前世今生</title><link>https://gohalo.github.io/cn/blog/computer-floating-point-introduce/</link><pubDate>Mon, 08 Jun 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/computer-floating-point-introduce/</guid><description>&lt;p>在计算机中，所有的信息都是通过二进制进行保存的，对于浮点数也不例外，但是，因为字节长度有限，这样就很难保证能表示所有的实数。&lt;/p>
&lt;p>这也就是造成了 &lt;code>0.1 + 0.2&lt;/code> 的结果不太符合预期，这里一步步介绍这一问题产生的原因。&lt;/p></description></item><item><title>Linux Capabilites 机制详细介绍</title><link>https://gohalo.github.io/cn/blog/linux-security-capabilities/</link><pubDate>Sat, 18 Jan 2020 21:39:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-security-capabilities/</guid><description>&lt;p>在 Linux 系统中，有些操作是需要 root 用户权限才能操作的，常见的包括 chown、使用 Raw Sokcet (ping) 等，如果使用 sudo 就会导致配置管理和权限控制比较麻烦。&lt;/p>
&lt;p>为了只给这个程序开所需要的权限，Linux 提供了一套 capabilities 机制，这里详细介绍。&lt;/p></description></item><item><title>C++ 智能指针</title><link>https://gohalo.github.io/cn/blog/cpp-smart-pointer-introduce/</link><pubDate>Wed, 15 Jan 2020 22:26:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-smart-pointer-introduce/</guid><description>类似于 C 语言，C++ 中申请的对象也需要手动释放，不像 Java GoLang 这类的语言，有自己的垃圾回收机制 (C++中有相关的实现，但非标准) ，这样 C++ 程序员需要重点关注内存的申请和释放，否则可能会导致内存泄漏。
为了解决 C++ 内存泄漏问题，在 C++11 中引入了智能指针 (Smart Pointer)，在一定程度上减轻了对内存的管理。
简介 # 例如对于如下的函数，如果没有显示的调用 delete(p) 函数，那么就会造成内存泄漏。
#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;iostream&amp;gt; class Rectangle { private: double width, height; }; void foobar(void) { Rectangle *p = new Rectangle(); //delete(p); } int main(void) { while (1) { foobar(); sleep(1); } } 而智能指针实际上就是为了解决上述的问题。
基本使用 # 一个栈上创建的对象，在退出栈的作用域之后，该对象会自动销毁，而智能指针就是使用的这一原理。创建一个智能指针保存申请好的内存地址，当程序退出作用域的时候，对应的智能指针被自动销毁，同时会释放其指向的内存。
在 C++11 中提供了三种智能指针 std::shared_ptr std::unique_ptr std::weak_ptr ，定义在头文件 &amp;lt;memory&amp;gt; 中，分别用于不同的场景中。
unique_ptr # 指向一个唯一的对象，该对象可以 move 但是不能进行赋值。</description></item><item><title>C++ 右值引用</title><link>https://gohalo.github.io/cn/blog/cpp-right-value-reference/</link><pubDate>Fri, 20 Dec 2019 21:18:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-right-value-reference/</guid><description>&lt;p>在 C++11 的新特性中增加了所谓的右值引用的支持，其主要目的是为了解决两个问题：A) 临时对象非必要的拷贝操作；B) 在模板函数中如何按照参数的实际类型进行转发。&lt;/p>
&lt;p>同时，和右值引用相关的概念比较多，包括了纯右值、将亡值、Universal References、引用折叠、移动语义、Move语义和完美转发等等，这里简单介绍。&lt;/p></description></item><item><title>C++ 可调用对象</title><link>https://gohalo.github.io/cn/blog/cpp-basic-callable-introduce/</link><pubDate>Tue, 12 Nov 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-basic-callable-introduce/</guid><description>&lt;p>在 C++11 之前，可调用对象包括了函数、函数指针以及重载 &lt;code>operator()&lt;/code> 运算符的对象；而在 C++11 之后，新增了 &lt;code>lambda&lt;/code> 表达式以及 &lt;code>bind()&lt;/code> 返回值，同时，引入了新的 &lt;code>function&lt;/code> 类型，用来统一可调用对象。&lt;/p></description></item><item><title>C 程序加载过程</title><link>https://gohalo.github.io/cn/blog/c-linux-load-process-plt-got/</link><pubDate>Sun, 20 Oct 2019 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-load-process-plt-got/</guid><description>&lt;p>利用动态库，可以节省磁盘、内存空间，而且可以提高程序运行效率；不过同时也导致调试比较困难，而且可能存在潜在的安全威胁。&lt;/p>
&lt;p>这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。&lt;/p></description></item><item><title>Linux 内存检查工具 Valgrind 介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-memory-valgrind/</link><pubDate>Sat, 12 Oct 2019 21:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-memory-valgrind/</guid><description>&lt;p>Valgrind 可以用于构建动态分析工具，包括一个工具集，每个工具可以进行一类的调试、分析、测试，以帮助完善程序。&lt;/p>
&lt;p>该工具采用的是模块化方式，可以很容易创建新的工具而又不会扰乱现有工具。&lt;/p></description></item><item><title>通过 CMake 进行测试</title><link>https://gohalo.github.io/cn/blog/cmake-unit-test-introduce/</link><pubDate>Sat, 10 Aug 2019 19:29:21 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-unit-test-introduce/</guid><description>&lt;p>CMake 除了提供自动编译的工具之外，还可以用来进行测试，提供了一整套基于 ctest 的工具。&lt;/p></description></item><item><title>Linux 可执行文件解析工具</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</link><pubDate>Sat, 08 Jun 2019 21:19:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</guid><description>&lt;p>主要是在如何解析 ELF 格式的文件。&lt;/p></description></item><item><title>ABI 二进制接口介绍</title><link>https://gohalo.github.io/cn/blog/c-application-binary-interface/</link><pubDate>Wed, 10 Apr 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-application-binary-interface/</guid><description>&lt;p>如果将编译后的代码反汇编，会发现传参过程中有很多寄存器相关的操作，包括了传参、数据的清理等等。&lt;/p>
&lt;p>那么具体是怎么工作的？为什么要按照这一规则？&lt;/p></description></item><item><title>Linux 子进程创建</title><link>https://gohalo.github.io/cn/blog/c-linux-fork-process-execute/</link><pubDate>Fri, 22 Mar 2019 22:11:22 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-fork-process-execute/</guid><description/></item><item><title>Linux C 陷阱</title><link>https://gohalo.github.io/cn/blog/linux-c-some-pitfalls-introduce/</link><pubDate>Sun, 10 Mar 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-some-pitfalls-introduce/</guid><description>&lt;p>一些 C 语言中比较容易犯错的知识点。&lt;/p></description></item><item><title>UDP 通讯优化</title><link>https://gohalo.github.io/cn/blog/linux-c-udp-optimize-introduce/</link><pubDate>Wed, 27 Feb 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-udp-optimize-introduce/</guid><description>&lt;p>有部分应用场景采用的仍然是无连接协议，例如 DNS、StatsD 等，都是采用的 UDP 。&lt;/p>
&lt;p>UDP 不是面向连接的，所以不能像 TCP 通过建立多个连接来提高对服务器的并发访问，如果通过多线程共享一个 UDP Socket 可能会无法充分利用所有的 CPU 资源。&lt;/p>
&lt;p>这里简单介绍其优化方法，当然，这里的策略也适用与像 ICMP 这样的协议。&lt;/p></description></item><item><title>内存检查工具</title><link>https://gohalo.github.io/cn/blog/linux-c-some-memory-debugger-tools-introduce/</link><pubDate>Mon, 25 Feb 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-some-memory-debugger-tools-introduce/</guid><description/></item><item><title>CMake 使用简介</title><link>https://gohalo.github.io/cn/blog/cmake-basic-introduce/</link><pubDate>Mon, 11 Feb 2019 17:49:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-basic-introduce/</guid><description>&lt;p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，对于简单的程序来说是可以的，当项目变得复杂之后会很难进行维护。&lt;/p>
&lt;p>而目前在维护 C/C++ 项目时，使用比较多的是 CMake ，这里就详细介绍下 CMake 的使用。&lt;/p></description></item><item><title>Memory Reordering 简析</title><link>https://gohalo.github.io/cn/blog/linux-c-memory-reordering-introduce/</link><pubDate>Fri, 01 Feb 2019 19:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-memory-reordering-introduce/</guid><description>&lt;p>以 C 语言为例，在编写完源代码之后，需要经过编译，然后在 CPU 上运行，为了提高代码的执行效率，在编译阶段和运行阶段会执行乱序优化，但同时也带来了一些副作用。&lt;/p>
&lt;p>这里简单介绍内存乱序的基本概念。&lt;/p></description></item><item><title>C/CPP 静态链接顺序</title><link>https://gohalo.github.io/cn/blog/c-cpp-static-linkage/</link><pubDate>Mon, 28 Jan 2019 22:10:33 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-cpp-static-linkage/</guid><description>&lt;p>静态链接和动态链接最大的区别就在于链接的时机不一样，静态链接是在生车可执行程序前，而动态链接的进行则是在程序执行时，而且静态链接库的位置不同将会影响二进制文件生成。&lt;/p></description></item><item><title>替换 glibc malloc</title><link>https://gohalo.github.io/cn/blog/linux-c-program-replace-glibc-memory-function/</link><pubDate>Wed, 19 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-program-replace-glibc-memory-function/</guid><description>&lt;p>在进行系统优化、内存泄漏测试时，经常需要对 glibc 的一些 API 进行替换，例如比较常见的是内存管理接口。&lt;/p>
&lt;p>如果代码量很大，或者使用了三方的静态库时，此时就无法直接替换相关的函数，例如 &lt;code>malloc()&lt;/code> &lt;code>realloc()&lt;/code> &lt;code>calloc()&lt;/code> 等，需要直接替换掉系统的相关函数。&lt;/p>
&lt;p>这里简单介绍几种方法。&lt;/p></description></item><item><title>lock-free 编程</title><link>https://gohalo.github.io/cn/blog/linux-c-program-lock-free-queue-introduce/</link><pubDate>Sun, 09 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-program-lock-free-queue-introduce/</guid><description>&lt;p>简单介绍下无锁编程 (Lock Free) 的概念，并实现一个基本的 Queue 。&lt;/p></description></item><item><title>C 动态参数使用详解</title><link>https://gohalo.github.io/cn/blog/c-dynamic-arguments/</link><pubDate>Sun, 09 Dec 2018 21:40:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-dynamic-arguments/</guid><description>&lt;p>在使用过程中，通常会有参数个数不确定，最常见的是 &lt;code>printf&lt;/code> 这类的函数，只有在使用时才能确定参数的个数以及其类型。&lt;/p>
&lt;p>这里详细介绍其使用以及基本原理。&lt;/p></description></item><item><title>LLVM 使用简介</title><link>https://gohalo.github.io/cn/blog/llvm-compiler-infrastructure-introduce/</link><pubDate>Sat, 08 Dec 2018 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llvm-compiler-infrastructure-introduce/</guid><description>&lt;p>LLVM 计划启动于 2000 年，由 UIUC 大学的 Chris Lattner 博士主持，后入职 Apple 继续推广，所以 Apple 就成了主要的赞助商。&lt;/p>
&lt;p>最初是 Low Level Virtual Machine 的缩写，不过随着发展，逐渐整合成了一整套的编译工具，所以官方也就放弃了原有的缩写，而修改成 The LLVM Compiler Infrastructure 。&lt;/p>
&lt;p>其强大之处在于模块化，可以很方便适配不同的语言以及硬件平台。&lt;/p></description></item><item><title>Google Benchmark 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-google-benchmark/</link><pubDate>Mon, 22 Oct 2018 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-google-benchmark/</guid><description>&lt;p>Google 提供的 Benchmark 工具是一款强大的性能压测工具，易于安装和使用，并提供了全面的性能测试接口。&lt;/p></description></item><item><title>GCC 强弱符号、引用基本介绍</title><link>https://gohalo.github.io/cn/blog/c-strong-weak-symbol-reference/</link><pubDate>Sat, 13 Oct 2018 18:19:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-strong-weak-symbol-reference/</guid><description>&lt;p>在编程时经常会碰到一种情况叫符号重复定义，一般意味着多个目标文件中含有相同名字全局符号的定义，而有时又不会报错，为什么？&lt;/p>
&lt;p>在 glibc 中定义了很多类似 &lt;code>read()&lt;/code> &lt;code>open()&lt;/code> 的函数，但是又可以自己定义相同的函数？&lt;/p>
&lt;p>这就涉及到了强弱符号以及强弱引用的概念了，这里详细介绍。&lt;/p></description></item><item><title>C 语言 inline 简介</title><link>https://gohalo.github.io/cn/blog/language-c-inline-concept-introduce/</link><pubDate>Fri, 05 Oct 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-inline-concept-introduce/</guid><description>&lt;p>在 C 语言中，调用函数时会在栈空间生成一个函数调用栈，如果函数嵌套过深则会导致大量的栈空间消耗，甚至是溢出。内联函数的引入就是解决一些频繁调用小函数时的大量栈空间消耗问题，这是 C99 的新增特性。&lt;/p></description></item><item><title>C 宏使用技巧</title><link>https://gohalo.github.io/cn/blog/c-macros-basic-concepts-introduce/</link><pubDate>Sun, 30 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-macros-basic-concepts-introduce/</guid><description>拼接宏 # 其中 # 把宏的参数直接替换为字符串，不进行替换；而 ## 会把两个宏参数贴在一起。注意，当宏参数是另一个宏时，只要宏定义用到了 # 或 ## 的地方，其宏参数都不会再展开。
#include &amp;lt;stdio.h&amp;gt; #define INT_MAX 0x7FFFFFFF #define STRING(s) #s #define A 2 #define CONCAT(a, b) (int)(a##e##b) int main(void) { int AeA = 55; puts(STRING(INT_MAX)); // INT_MAX printf(&amp;#34;%d\n&amp;#34;, CONCAT(A, A)); // 55 return 0; } 如果将 CONCAT 宏定义修改为 (int)((a##e##b) + a) ，那么结果为 57 。
其中 A 和 INT_MAX 都是宏，而且做为了 STRING 和 CONCAT 的参数，但是因为存在 # 或者 ## 符号，所以其中的 A 和 INT_MAX 都没有展开。</description></item><item><title>Linux GCC 常用技巧</title><link>https://gohalo.github.io/cn/blog/language-c-gcc-some-basic-tips/</link><pubDate>Thu, 27 Sep 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-gcc-some-basic-tips/</guid><description/></item><item><title>Linux C 数据对齐</title><link>https://gohalo.github.io/cn/blog/c-structure-align-basic-introduce/</link><pubDate>Thu, 20 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-structure-align-basic-introduce/</guid><description>&lt;p>C 语言中的结构体包含了各种成员，编译器会将结构体中的每个成员按其自然边界分配空间，合理的设置对齐规则，可以提高 CPU 的访问速度 (有些 CPU 会禁止非对齐，会抛出硬件异常)，降低结构体的占用空间。&lt;/p></description></item><item><title>Linux C 位域和大小端</title><link>https://gohalo.github.io/cn/blog/c-bit-field-and-endian-introduce/</link><pubDate>Tue, 18 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-bit-field-and-endian-introduce/</guid><description>在处理通讯协议时，经常需要按照字节甚至是位进行处理，例如 MySQL 协议，那么对于 C 而言如何方便的进行处理呢？ 另外，网络通讯时采用的是大端，到底是啥意思？
简介 # 在编写代码的时候，很大一部分工作是在不同的格式之间进行转换，从外部的数据结构转换成内部使用的结构，例如网络包 (TCP/IP、MySQL协议等)、磁盘文件 (GIF、JPEG等图片格式) 等等。
其中很重要的一部分就是整数的字节顺序问题，也就是当整数的大小超过了一个字节之后，如何进行表示，这就是所谓的字节序的问题。
CPU # 不同的 CPU 对应的字节序略有区别：
大端，PowerPC、IBM、Sun、51 小端，x86、DEC 其中 ARM 两种模式都可以支持，另外，网络协议中大部分使用的是大端字节序，所以就有一系列的 API 对整数进行转换。
# if __BYTE_ORDER == __BIG_ENDIAN # define ntohl(x) (x) # define ntohs(x) (x) # define htonl(x) (x) # define htons(x) (x) # else # define ntohl(x) __bswap_32(x) # define ntohs(x) __bswap_16(x) # define htonl(x) __bswap_32(x) # define htons(x) __bswap_16(x) # endif 其中 ntohs 为 network to host short 的简写，这些函数一般在头文件 &amp;lt;arpa/inet.</description></item><item><title>C 整数介绍</title><link>https://gohalo.github.io/cn/blog/c-integer-basic-concepts-introduce/</link><pubDate>Fri, 07 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-integer-basic-concepts-introduce/</guid><description>&lt;p>在 C 中与整数类型相关的内容。&lt;/p></description></item><item><title>C11 标准解读</title><link>https://gohalo.github.io/cn/blog/program-c-c11-standard-introduce/</link><pubDate>Sat, 01 Sep 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-c11-standard-introduce/</guid><description/></item><item><title>gdbinit 功能介绍</title><link>https://gohalo.github.io/cn/blog/gdb-gdbinit-script/</link><pubDate>Mon, 13 Aug 2018 20:10:51 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-gdbinit-script/</guid><description>&lt;p>在启动时，会在当前用户目录下寻找文件名为 &lt;code>.gdbinit&lt;/code> 的文件，如果存在，会执行该文件中的所有命令，通常用于简单的配置命令，如设置所需的默认汇编程序格式、输出数据默认基数，还可以读取宏编码语言，从而实现更强大的自定义函数。&lt;/p></description></item><item><title>Linux C Flock 使用</title><link>https://gohalo.github.io/cn/blog/c-linux-flock-introduce/</link><pubDate>Fri, 03 Aug 2018 20:11:22 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-flock-introduce/</guid><description>&lt;p>在某些场景下，例如需要保证单个进程运行，通常的做法是生成一个 PID 文件，并将当前的进程 PID 写入，每次进程启动时检查文件以及进程是否存在。&lt;/p>
&lt;p>如果进程异常崩溃没有删除文件，而 Linux 中 PID 可以复用，那么就可能会导致误认为进程存在，虽然概率很低。&lt;/p>
&lt;p>其实在 Linux 中可以通过 flock 实现。&lt;/p></description></item><item><title>C 语言使用 SSL</title><link>https://gohalo.github.io/cn/blog/program-c-ssl-tls-basic-introduce/</link><pubDate>Sun, 08 Jul 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-ssl-tls-basic-introduce/</guid><description/></item><item><title>Socket 关闭方式</title><link>https://gohalo.github.io/cn/blog/language-c-socket-close-method/</link><pubDate>Wed, 20 Jun 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-socket-close-method/</guid><description>&lt;p>在 Linux 中，对于 Socket 来说，可以通过系统调用 &lt;code>close()&lt;/code> 关闭，通过还提供了一个 &lt;code>shutdown()&lt;/code> 接口，可以直接将 socket 关闭。&lt;/p>
&lt;p>那么两种方式有什么区别？&lt;/p></description></item><item><title>GCC 常用技巧</title><link>https://gohalo.github.io/cn/blog/program-c-language-gcc-some-stuff/</link><pubDate>Wed, 13 Jun 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-language-gcc-some-stuff/</guid><description>&lt;p>Clang 是一个 C++ 编写，基于 LLVM 的 C/C++、Objective-C 语言的轻量级编译器，在 2013.04 开始，已经全面支持 C++11 标准。&lt;/p></description></item><item><title>Linux GNU 内联汇编</title><link>https://gohalo.github.io/cn/blog/c-gnu-inline-assembly/</link><pubDate>Wed, 30 May 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-gnu-inline-assembly/</guid><description>&lt;p>在通过 C 做上层的开发时，实际上很少会用到汇编语言，不过对于 Linux 内核开发来说，经常会遇到与体系架构相关的功能或优化代码，此时可能需要通过将汇编语言指令插入到 C 语句的中间来执行这些任务。&lt;/p>
&lt;p>这里简单介绍下 GNU 中与 Linux 内联汇编相关的用法。&lt;/p></description></item><item><title>C 语言 Volatile 使用简介</title><link>https://gohalo.github.io/cn/blog/linux-c-volatile-statement-introduce/</link><pubDate>Sun, 20 May 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-volatile-statement-introduce/</guid><description>&lt;p>C 语言中的 volatile 关键字大部分都见过，但是很少有人能明确其具体使用的场景。实际上，上层编程很少会用到，一般只有涉及到 IO、中断等与硬件交互的底层编程才会经常使用。&lt;/p>
&lt;p>这里简单介绍其使用场景，使用方法。&lt;/p></description></item><item><title>C 常用函数</title><link>https://gohalo.github.io/cn/blog/language-c-some-basic-functions-usage-introduce/</link><pubDate>Fri, 20 Apr 2018 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-some-basic-functions-usage-introduce/</guid><description>&lt;p>C 语言中一些常用的基础函数，包括了 &lt;code>qsort()&lt;/code> &lt;code>bsearch()&lt;/code> &lt;code>atexit()&lt;/code> &lt;code>backtrace()&lt;/code> 等。&lt;/p></description></item><item><title>GCC 安全编译选项</title><link>https://gohalo.github.io/cn/blog/program-gcc-security-options/</link><pubDate>Mon, 09 Apr 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-gcc-security-options/</guid><description>&lt;p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，例如 ASLR、NX 等等，这里简单介绍一些常见的使用项。&lt;/p></description></item><item><title>C 指针简介</title><link>https://gohalo.github.io/cn/blog/language-c-pointer-basic-usage-introduce/</link><pubDate>Sun, 01 Apr 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-pointer-basic-usage-introduce/</guid><description>&lt;p>在 C 语言中，指针是一个特殊的变量，存储值指向内存中的一个地址，一个指针包含了四方面的内容：指针类型、指向类型，指针所指向的内存区以及指针本身所占据的内存区。&lt;/p>
&lt;p>指针或许是 C 语言中最复杂的东西了。&lt;/p></description></item><item><title>Python C</title><link>https://gohalo.github.io/cn/blog/python-c-bind-introduce/</link><pubDate>Tue, 30 Jan 2018 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-c-bind-introduce/</guid><description/></item><item><title>Linux C 动态库加载</title><link>https://gohalo.github.io/cn/blog/c-reload-dynamic-library/</link><pubDate>Wed, 03 Jan 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-reload-dynamic-library/</guid><description>&lt;p>简单来说，对于正在运行的程序，当尝试重新加载动态库时，可能会导致程序 CoreDump 。&lt;/p>
&lt;p>这里简单解释下其原因，以及规避方案。&lt;/p></description></item><item><title>DWARF 格式简介</title><link>https://gohalo.github.io/cn/blog/gdb-dwarf-format-introduce/</link><pubDate>Sun, 10 Dec 2017 23:49:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-dwarf-format-introduce/</guid><description>&lt;p>也就是 Debugging With Attributed RecordFormats, DWARF ，到目前为止，应该包括了 &lt;code>V1~5&lt;/code> 共五个版本，其中 dwarf2 对 dwarf1 的改变很大，而后续的版本基本上是对前者的扩展。&lt;/p>
&lt;p>这一格式独立于语言，不过使用比较多的是 C/C++ ，这里简单介绍在 GDB 中，如何对这些调试信息进行组织、实现，并且如何利用调试信息进行 C 语言级别的调试。&lt;/p></description></item><item><title>CMocka 使用简介</title><link>https://gohalo.github.io/cn/blog/c-cmocka-introduce/</link><pubDate>Wed, 06 Dec 2017 18:19:58 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-cmocka-introduce/</guid><description>&lt;p>CMocka 是一针对 C 语言的单元测试框架，而且支持 mock 测试，其前身是由 Google 开发的 Cmockery，而后者由于不再维护，后来就通过 CMocka 继续开发维护。&lt;/p>
&lt;p>也就因此，可以看到有些细节与同样由 Google 开发的 gmock 和 gtest 有些相似，这里详细介绍其使用方式。&lt;/p></description></item><item><title>Linux 信号机制</title><link>https://gohalo.github.io/cn/blog/kernel-signal-introduce/</link><pubDate>Sat, 25 Nov 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-signal-introduce/</guid><description>&lt;p>软中断信号 (简称为信号) 是用来通知进程发生了异步事件，是在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。&lt;/p>
&lt;p>信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。&lt;/p>
&lt;p>进程之间可以互相通过系统调用 kill 发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。&lt;/p>
&lt;p>信号机制除了基本通知功能外，还可以传递附加信息。&lt;/p></description></item><item><title>GDB 死锁分析</title><link>https://gohalo.github.io/cn/blog/gdb-deadlock-analyze-introduce/</link><pubDate>Mon, 20 Nov 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-deadlock-analyze-introduce/</guid><description>&lt;p>pthread 是 POSIX 标准的多线程库，其源码位于 glibc 中的 Native POSIX Thread Library, NPTL 目录下，大部分的应用都是基于 pthread 来实现多线程的并行与同步管理。&lt;/p></description></item><item><title>Linux umask 使用</title><link>https://gohalo.github.io/cn/blog/linux-umask-and-open-introduce/</link><pubDate>Sun, 12 Nov 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-umask-and-open-introduce/</guid><description>&lt;p>在使用 umask 设置问价的掩码时遇到了一个坑，本来以为设置会很简单，但是开始设置时一直不是预期的结果。&lt;/p>
&lt;p>简单整理下踩坑的过程。&lt;/p></description></item><item><title>Fuzzing 测试</title><link>https://gohalo.github.io/cn/blog/program-c-fuzzing-test-introduce/</link><pubDate>Tue, 31 Oct 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-fuzzing-test-introduce/</guid><description>Fuzzing 一般指模糊测试，是一种基于黑盒的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。
同时，也作为了当前最为强大而有效的漏洞挖掘技术。
AFL # American Fuzzy Lop, AFL 是一种开源的模糊测试器，由谷歌的 Michal Zalewski 开发。
可以在源码编译时添加，或者使用 QEMU 模式，也就是 QEMU-(User Mode) ，在执行时注入部分代码进行测试。
目前使用 AFL 有两种方式：
开源软件，在编译的时候同时进行插桩； 闭源软件，配合QEMU直接对闭源的二进制代码进行fuzz测试。 安装 # 直接从 ALF Release 下载相关的版本，然后执行 make 即可。
默认安装在 /usr/local 相对目录下，可以通过 PREFIX=/usr &amp;amp;&amp;amp; make 修改。
使用 # 如果程序使用 autoconf 工具链构建，在执行 configure 脚本时，添加如下参数即可。
$ ./configure --disable-shared CC=&amp;#34;afl-gcc&amp;#34; CXX=&amp;#34;afl-g++&amp;#34; 其中 --disable-shared 选项可以允许通过 LD_LIBRARY_PATH 变量，让程序加载经过 AFL 插桩的 .so 文件，进行静态构建而不是动态链接。
如果是其它的 Makefile 文件，可以直接修改引用的编译器。
另外，为了后期更好的分析 crash 可以开启 Address Sanitizer, ASAN 检测工具，此工具可以更好的检测出缓存区溢出、UAF 等内存漏洞。</description></item><item><title>Linux C 错误信息</title><link>https://gohalo.github.io/cn/blog/language-c-error-message-usage-introduce/</link><pubDate>Fri, 20 Oct 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-error-message-usage-introduce/</guid><description>&lt;p>在 C 代码中，当发生错误时，一般会在库函数中设置 errno ，然后应用可以通过 strerror 打印详细的错误信息，以方便定位问题。&lt;/p>
&lt;p>但是有些错误打印函数标示为安全的？这是什么意思？使用时应该注意什么？&lt;/p></description></item><item><title>GDB 常用命令</title><link>https://gohalo.github.io/cn/blog/gdb-commands-usage-cheatsheet/</link><pubDate>Thu, 05 Oct 2017 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-commands-usage-cheatsheet/</guid><description>&lt;p>这里一些常用的 gdb 命令。&lt;/p></description></item><item><title>GDB 栈帧简介</title><link>https://gohalo.github.io/cn/blog/gdb-stack-frame-introduce/</link><pubDate>Thu, 05 Oct 2017 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-stack-frame-introduce/</guid><description>&lt;p>栈是一块内存空间，会从高地址向低地址增长，同时在函数调用过程中，会通过栈寄存器来维护栈帧相关的内容。函数运行时，栈帧 (Stack Frame) 非常重要，包含了函数的局部变量以及函数调用之间的传参。&lt;/p></description></item><item><title>正则表达式</title><link>https://gohalo.github.io/cn/blog/program-c-string-regular-expression/</link><pubDate>Tue, 05 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-regular-expression/</guid><description/></item><item><title>Linux C 网络编程</title><link>https://gohalo.github.io/cn/blog/program-c-network/</link><pubDate>Mon, 21 Aug 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-network/</guid><description/></item><item><title>MySQL 线上部署</title><link>https://gohalo.github.io/cn/blog/mysql-deploy-online/</link><pubDate>Mon, 21 Aug 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-deploy-online/</guid><description>&lt;p>主要介绍下 MySQL 如何在线上进行部署。&lt;/p></description></item><item><title>Linux C 网络编程</title><link>https://gohalo.github.io/cn/blog/c-linux-network-socket-program/</link><pubDate>Mon, 21 Aug 2017 17:49:01 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-network-socket-program/</guid><description>&lt;p>在 linux 中的网络编程会涉及到很多的细节，这里简单整理常见的问题，例如套接子信息、域名解析等等，有些也可能不怎么常见，以备不时之需。&lt;/p></description></item><item><title>C/C++ Sanitizer 简介</title><link>https://gohalo.github.io/cn/blog/language-c-some-sanitizers-introduce/</link><pubDate>Tue, 25 Jul 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-some-sanitizers-introduce/</guid><description>&lt;p>Sanitizer 英文翻译过来是杀菌剂的意思，Google 提供了很多相关的一些 Sanitizers ，用来检测程序的异常。&lt;/p>
&lt;p>可以做内存、地址访问、竞态条件的检测，这里简单介绍。&lt;/p></description></item><item><title>MySQL CAPI 接口</title><link>https://gohalo.github.io/cn/blog/mysql-capi/</link><pubDate>Fri, 21 Jul 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-capi/</guid><description>&lt;p>在编写 MySQL 客户端程序时，最常见的就是如何连接以及关闭 MySQL，这里需要注意，如果使用不当将会造成内存泄漏。&lt;/p>
&lt;p>这里，简单介绍 MySQL 中如何通过 C 进行编程。&lt;/p></description></item><item><title>C++ 构造析构函数详细分析</title><link>https://gohalo.github.io/cn/blog/cpp-constructor-destructor/</link><pubDate>Wed, 31 May 2017 20:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-constructor-destructor/</guid><description>&lt;p>在 C++ 中，当类的内存申请完之后，会通过构造函数进行初始化，而构造函数在不同的使用场景下又分成了不同的类型，例如默认构造函数、简单构造函数、复制构造函数、转换构造函数等等。&lt;/p>
&lt;p>同时，在涉及到赋值操作时，最好将赋值操作运算符也重载掉，尤其是会动态申请内存的类；另外，随着 C++11 标准的发布，有引入了移动构造函数以及移动赋值运算符。&lt;/p>
&lt;p>这就导致构造函数与赋值重载不断重叠，很容易引起混淆，所以，这里就详细介绍其使用方式。&lt;/p></description></item><item><title>GDB Python 脚本</title><link>https://gohalo.github.io/cn/blog/gdb-python-script/</link><pubDate>Sat, 15 Apr 2017 20:39:11 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-python-script/</guid><description>&lt;p>GDB 很早就支持自定义脚本辅助调试，不过语法比较老，不如 Python 使用方便广泛，从 GDB 7.X(2009) 版本开始支持 Python Scripting ，不过建议使用 9.X 以上的版本，关于 Python 的详细特性可以参考 &lt;a href="https://www.sourceware.org/gdb/news/">GDB News&lt;/a> 的内容。&lt;/p></description></item><item><title>Linux Fail Points</title><link>https://gohalo.github.io/cn/blog/linux-c-fail-point-introduce/</link><pubDate>Mon, 10 Apr 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-fail-point-introduce/</guid><description>&lt;p>对于一些异常一般很难构建，尤其是像系统 API 调用、硬件故障等等，通过 FailPoints 可以在指定的代码段注入一些异常处理。&lt;/p>
&lt;p>实际上，BSD 已经提供了一套相关的 FailPoints 机制。&lt;/p></description></item><item><title>C++ STL 使用</title><link>https://gohalo.github.io/cn/blog/language-cpp-stl-basic-usage-introduce/</link><pubDate>Thu, 23 Mar 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-cpp-stl-basic-usage-introduce/</guid><description/></item><item><title>关于 C++ 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/cpp-basic-syntax-introduce/</link><pubDate>Mon, 20 Mar 2017 21:15:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-basic-syntax-introduce/</guid><description>&lt;p>一般会将 C++ 划分为所谓的中级语言，从底层的 C 语言发展而来，提供了比 C 更丰富的特性，而又没有提供类似 Java、Python 等语言的高级特性，所以，介于中间，称之为中级语言。&lt;/p>
&lt;p>随着 C++11 标准的发布，以及更新的 C++0x 标准，C++ 提供的功能越来越完善。&lt;/p>
&lt;p>这里仅简单介绍下基本的概念。&lt;/p></description></item><item><title>GDB 基本功能介绍</title><link>https://gohalo.github.io/cn/blog/gdb-basic-usage-introduce/</link><pubDate>Fri, 10 Mar 2017 22:30:31 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-basic-usage-introduce/</guid><description>&lt;p>GNU Project Debugger, GDB 一个代码调试工具，通过系统提供的 ptrace 接口实现的控制进程，然后可以在进程内部查看信息，甚至调用函数。&lt;/p></description></item><item><title>C 代码覆盖率</title><link>https://gohalo.github.io/cn/blog/c-coverage-introduce/</link><pubDate>Sun, 13 Nov 2016 17:12:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-coverage-introduce/</guid><description>&lt;p>我们已经提供了一些测试用例，但是这些测试用例的好坏如何评估？是否已经覆盖了所有的函数？函数中的分支以及边界条件是否都已经覆盖？&lt;/p>
&lt;p>这就需要通过代码覆盖率进行查看，这里简单介绍其使用方法。&lt;/p></description></item><item><title>C 编译链接</title><link>https://gohalo.github.io/cn/blog/c-compile-linkage-introduce/</link><pubDate>Sun, 23 Oct 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-compile-linkage-introduce/</guid><description>&lt;p>详细介绍下与 C 语言相关的概念。&lt;/p></description></item><item><title>C Mock 使用以及机制介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-mock-wrap-unit-test/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-mock-wrap-unit-test/</guid><description>&lt;p>编写高效松耦合的模块，体现的是功力，而完善的测试用例则是习惯。包括了一些异常场景的积累，代码重构时的验证等等，编写有效的测试用例就尤为重要。&lt;/p>
&lt;p>而 C 语言，由于其偏向于底层，导致不能像 Java、Python、GO 那样提供了成熟的测试框架。&lt;/p>
&lt;p>这里简单介绍一下基于 cmocka 修改的测试框架，会通过一些宏定义处理部分问题，当然，真正使用时还需要一些其它的技巧。&lt;/p></description></item><item><title>CMake 常用示例</title><link>https://gohalo.github.io/cn/blog/cmake-some-tips/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-some-tips/</guid><description>&lt;p>整理常用的示例。&lt;/p></description></item><item><title>C Preload 简介</title><link>https://gohalo.github.io/cn/blog/c-preload-introduce/</link><pubDate>Thu, 25 Feb 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-preload-introduce/</guid><description>&lt;p>Linux C 中有一个很不错的特性，可以在不改变程序的前提下，修改动态库所调用的函数，也就是 Preload 功能。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Java C 程序调用</title><link>https://gohalo.github.io/cn/blog/program-c-java/</link><pubDate>Wed, 23 Dec 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-java/</guid><description>&lt;p>简单介绍下 Java 和 C 程序的相互调用。&lt;/p></description></item><item><title>C/C++ 常见错误整理</title><link>https://gohalo.github.io/cn/blog/cpp-some-pitfalls/</link><pubDate>Tue, 22 Dec 2015 21:00:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-some-pitfalls/</guid><description/></item><item><title>Linux 自动编译 AutoTools</title><link>https://gohalo.github.io/cn/blog/linux-autotools-auto-compile-introduce/</link><pubDate>Mon, 30 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-autotools-auto-compile-introduce/</guid><description>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。
这里简单介绍下 AutoTools 一系列工具的使用。
Autotools # 在 Linux 平台上，经常使用 configure-&amp;gt;make-&amp;gt;make install 从源码开始编译安装，也就是 GNU 构建系统，利用脚本和 make 程序在特定平台上编译软件，也就是利用 autotools 创建构建系统的项目。
注意，有些程序虽然也是采用上述的三步，但并未采用 autotools 实现，如 nginx 是作者编写的构建程序。
在 CentOS 中可以直接通过 yum install automake autoconf 安装相关的文件；利用 autotools 生成 Makefile 的过程如下图所示。
其中用到的核心工具包括了 Autoconf 和 Automake ，首先从用户和开发者角度看看两者的区别。关于 autotools 的简单处理流程可以参考 automake 中的 Setup Explained 内容。
用户视角 # configure 脚本是由软件开发者维护并发布给用户使用的 shell 脚本，该脚本作用是检测系统环境，最终目的是生成 Makefile 和 config.h 两个文件。
开发者在分发源码包时，除了源代码 (.c .h)，还有许多支撑软件构建的文件和工具，其中最重要的文件就是 Makefile.in 和 config.h.in 两个，在 configure 脚本执行成功后，将为每个 *.</description></item><item><title>Linux Package 管理</title><link>https://gohalo.github.io/cn/blog/linux-package-config-introduce/</link><pubDate>Fri, 27 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-package-config-introduce/</guid><description>&lt;p>可以通过 &lt;code>pkg-config&lt;/code> 命令来检索系统中安装库文件的信息，通常用于库的编译和连接。&lt;/p></description></item><item><title>Linux 自动编译 Makefile</title><link>https://gohalo.github.io/cn/blog/linux-makefile-auto-compile-introduce/</link><pubDate>Tue, 03 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-makefile-auto-compile-introduce/</guid><description>&lt;p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。&lt;/p>
&lt;p>这里简单介绍下最基本的 Makefile 。&lt;/p></description></item><item><title>C 语言的字符串</title><link>https://gohalo.github.io/cn/blog/program-c-string-stuff/</link><pubDate>Wed, 16 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-stuff/</guid><description>&lt;p>简单介绍下 C 语言中与字符串操作相关的函数。&lt;/p></description></item><item><title>C 加载过程</title><link>https://gohalo.github.io/cn/blog/c-load-process/</link><pubDate>Tue, 15 Sep 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-load-process/</guid><description>&lt;p>这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。&lt;/p></description></item><item><title>C 语言通配符</title><link>https://gohalo.github.io/cn/blog/program-c-string-linux-wildcard/</link><pubDate>Tue, 08 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-linux-wildcard/</guid><description>&lt;p>简单介绍下 C 语言中与字符串操作相关的函数。&lt;/p></description></item><item><title>C 语言的奇技淫巧</title><link>https://gohalo.github.io/cn/blog/program-c-tips/</link><pubDate>Sun, 16 Aug 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-tips/</guid><description>&lt;p>整理下 C 语言中常用的技巧。&lt;/p></description></item><item><title>C 多语言支持</title><link>https://gohalo.github.io/cn/blog/c-linux-i18n-multi-language-gettext-usage/</link><pubDate>Wed, 06 May 2015 18:20:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-i18n-multi-language-gettext-usage/</guid><description>&lt;p>可以通过 gettext 进行处理，一个在 Linux 上的 i18n 国际化常用的解决方案。&lt;/p></description></item><item><title>Linux C++ 线程同步</title><link>https://gohalo.github.io/cn/blog/program-cpp-linux-synchronize/</link><pubDate>Thu, 23 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-cpp-linux-synchronize/</guid><description/></item><item><title>闰秒简介</title><link>https://gohalo.github.io/cn/blog/linux-leap-seconds-basic-introduce/</link><pubDate>Sat, 30 Aug 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-leap-seconds-basic-introduce/</guid><description>&lt;p>闰秒，是为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中对协调世界时增加或减少 1 秒的调整。&lt;/p>
&lt;p>由于地球自转的不均匀性和长期变慢性，当世界时和原子时之间相差超过到 ±0.9 秒时，就把协调世界时向前拨 1 秒或向后拨 1 秒。&lt;/p>
&lt;p>闰秒的调整也就是意味着 UTC 与 TAI(国际原子时) 之间的差异，截止到 2016 年，两者已经相差 37 秒。&lt;/p></description></item><item><title>Linux 时间函数</title><link>https://gohalo.github.io/cn/blog/linux-timer-functions/</link><pubDate>Mon, 02 Jun 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-timer-functions/</guid><description>&lt;p>简单介绍下 Linux 中与时间相关的函数。&lt;/p></description></item><item><title>【专题】C/C++ 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-c-cpp/</link><pubDate>Fri, 12 Nov 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-c-cpp/</guid><description>C 语言 # 在 1989 年，美国国家标准协会 (ANSI) 对 C 语言进行了标准化，此时 C 语言又被称为 ANSI C。在一年后被国际标准化组织 ISO 采纳，所以 C 语言在 ISO 中有了一个官方名称 ISO/IEC 9899:1990 ，其中 9899 是 C 语言在 ISO 标准中代号 (C++ 是 14882)，冒号后面的 1990 表示当前修订好的版本是在 1990 年发布。
所以，最开始的 C 语言标准也被称为 C89、C90 或者 C89/C90，后续又在 1999、2007、2011 进行了改进。另外，C++ 在从 C++11 之后，基本固定每三年发布一个新版本。
整数介绍 包括了类型提升、整型溢出等。 宏使用 一些基本使用规则，以及常见注意事项。 数据对齐 结构体以及内存的对齐方式。 指针简介 包括了基本概念、函数指针等概念的介绍。 位域和字节序 位域或位段相关概念，以及大小端字节序相关的内容。 inline 简介 有点类似于 C 中的宏，但是又有所区别。 Volatile 简介 C 语言中与 volatile 相关的介绍。 基本概念 # 不只是 C 相关代码，实际上更多的是 Linux 中的基本介绍。</description></item></channel></rss>