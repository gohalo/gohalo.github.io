<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>c/cpp on</title><link>https://gohalo.github.io/cn/tags/c/cpp/</link><description>Recent content in c/cpp on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://gohalo.github.io/cn/tags/c/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux 内存检查工具 Valgrind 介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-memory-valgrind/</link><pubDate>Sat, 12 Oct 2019 21:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-memory-valgrind/</guid><description>&lt;p>Valgrind 可以用于构建动态分析工具，包括一个工具集，每个工具可以进行一类的调试、分析、测试，以帮助完善程序。&lt;/p>
&lt;p>该工具采用的是模块化方式，可以很容易创建新的工具而又不会扰乱现有工具。&lt;/p></description></item><item><title>C/CPP 静态链接顺序</title><link>https://gohalo.github.io/cn/blog/c-cpp-static-linkage/</link><pubDate>Sun, 28 Apr 2019 22:10:33 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-cpp-static-linkage/</guid><description>&lt;p>静态链接和动态链接最大的区别就在于链接的时机不一样，静态链接是在生车可执行程序前，而动态链接的进行则是在程序执行时，而且静态链接库的位置不同将会影响二进制文件生成。&lt;/p></description></item><item><title>GCC 强弱符号、引用基本介绍</title><link>https://gohalo.github.io/cn/blog/c-strong-weak-symbol-reference/</link><pubDate>Sat, 13 Oct 2018 18:19:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-strong-weak-symbol-reference/</guid><description>&lt;p>在编程时经常会碰到一种情况叫符号重复定义，一般意味着多个目标文件中含有相同名字全局符号的定义，而有时又不会报错，为什么？&lt;/p>
&lt;p>在 glibc 中定义了很多类似 &lt;code>read()&lt;/code> &lt;code>open()&lt;/code> 的函数，但是又可以自己定义相同的函数？&lt;/p>
&lt;p>这就涉及到了强弱符号以及强弱引用的概念了，这里详细介绍。&lt;/p></description></item><item><title>gdbinit 功能介绍</title><link>https://gohalo.github.io/cn/blog/gdb-gdbinit-script/</link><pubDate>Mon, 13 Aug 2018 20:10:51 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-gdbinit-script/</guid><description>&lt;p>在启动时，会在当前用户目录下寻找文件名为 &lt;code>.gdbinit&lt;/code> 的文件，如果存在，会执行该文件中的所有命令，通常用于简单的配置命令，如设置所需的默认汇编程序格式、输出数据默认基数，还可以读取宏编码语言，从而实现更强大的自定义函数。&lt;/p></description></item><item><title>DWARF 格式简介</title><link>https://gohalo.github.io/cn/blog/gdb-dwarf-format-introduce/</link><pubDate>Sun, 10 Dec 2017 23:49:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-dwarf-format-introduce/</guid><description>&lt;p>也就是 Debugging With Attributed RecordFormats, DWARF ，到目前为止，应该包括了 &lt;code>V1~5&lt;/code> 共五个版本，其中 dwarf2 对 dwarf1 的改变很大，而后续的版本基本上是对前者的扩展。&lt;/p>
&lt;p>这一格式独立于语言，不过使用比较多的是 C/C++ ，这里简单介绍在 GDB 中，如何对这些调试信息进行组织、实现，并且如何利用调试信息进行 C 语言级别的调试。&lt;/p></description></item><item><title>GDB 栈帧简介</title><link>https://gohalo.github.io/cn/blog/gdb-stack-frame-introduce/</link><pubDate>Thu, 05 Oct 2017 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-stack-frame-introduce/</guid><description>&lt;p>栈是一块内存空间，会从高地址向低地址增长，同时在函数调用过程中，会通过栈寄存器来维护栈帧相关的内容。函数运行时，栈帧 (Stack Frame) 非常重要，包含了函数的局部变量以及函数调用之间的传参。&lt;/p></description></item><item><title>GDB Python 脚本</title><link>https://gohalo.github.io/cn/blog/gdb-python-script/</link><pubDate>Sat, 15 Apr 2017 20:39:11 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-python-script/</guid><description>&lt;p>GDB 很早就支持自定义脚本辅助调试，不过语法比较老，不如 Python 使用方便广泛，从 GDB 7.X(2009) 版本开始支持 Python Scripting ，不过建议使用 9.X 以上的版本，关于 Python 的详细特性可以参考 &lt;a href="https://www.sourceware.org/gdb/news/">GDB News&lt;/a> 的内容。&lt;/p></description></item><item><title>GDB 基本功能介绍</title><link>https://gohalo.github.io/cn/blog/gdb-basic-usage-introduce/</link><pubDate>Fri, 10 Mar 2017 22:30:31 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-basic-usage-introduce/</guid><description>&lt;p>GNU Project Debugger, GDB 一个代码调试工具，通过系统提供的 ptrace 接口实现的控制进程，然后可以在进程内部查看信息，甚至调用函数。&lt;/p></description></item><item><title>Linux 子进程创建</title><link>https://gohalo.github.io/cn/blog/c-linux-fork-process-execute/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-fork-process-execute/</guid><description/></item></channel></rss>