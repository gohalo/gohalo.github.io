<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on</title><link>https://gohalo.github.io/cn/tags/linux/</link><description>Recent content in linux on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 21 Nov 2024 22:10:42 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Protobuf Rust 语言使用介绍</title><link>https://gohalo.github.io/cn/blog/protobuf-rust-usage/</link><pubDate>Thu, 21 Nov 2024 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-rust-usage/</guid><description>&lt;p>Prost 是一个用于序列化和反序列化 Google Protocol Buffers 协议的 Rust 库，支持消息嵌套、默认值、枚举类型等。&lt;/p></description></item><item><title>ToyDB 简介</title><link>https://gohalo.github.io/cn/blog/database-toydb-introduce/</link><pubDate>Thu, 12 Sep 2024 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-toydb-introduce/</guid><description>&lt;p>一个 Rust 编写的分布式数据库实现，麻雀虽小五脏俱全。&lt;/p></description></item><item><title>Ray 源码解析</title><link>https://gohalo.github.io/cn/blog/ray-source-code/</link><pubDate>Fri, 16 Aug 2024 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ray-source-code/</guid><description/></item><item><title>Torch MNIST 使用示例</title><link>https://gohalo.github.io/cn/blog/pytorch-mnist/</link><pubDate>Fri, 16 Aug 2024 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/pytorch-mnist/</guid><description/></item><item><title>Neovim 插件管理工具</title><link>https://gohalo.github.io/cn/blog/neovim-plugins-management/</link><pubDate>Wed, 12 Jun 2024 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-plugins-management/</guid><description>&lt;p>历史曾经推荐使用 &lt;a href="https://gohalo.github.io/cn/blog/neovim-plugins-management-legacy-packer/">Packer.nvim&lt;/a> 作为插件管理工具，不过该插件从 2023.08 开始不再维护，所以就有了 &lt;a href="https://github.com/folke/lazy.nvim">lazy.nvim&lt;/a> 插件。&lt;/p>
&lt;p>这里详细介绍其使用。&lt;/p></description></item><item><title>LLM 使用简介</title><link>https://gohalo.github.io/cn/blog/llm-from-scratch/</link><pubDate>Fri, 08 Dec 2023 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llm-from-scratch/</guid><description>&lt;p>主要是 Karpathy 的相关实现，通过简单的示例、资源介绍 LLM 相关的概念。&lt;/p></description></item><item><title>LLM 本地运行</title><link>https://gohalo.github.io/cn/blog/llm-local-running/</link><pubDate>Fri, 08 Dec 2023 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llm-local-running/</guid><description/></item><item><title>SSH 登陆失败常见问题排查</title><link>https://gohalo.github.io/cn/blog/ssh-login-failed/</link><pubDate>Wed, 08 Nov 2023 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-login-failed/</guid><description/></item><item><title>LLVM 即时编译</title><link>https://gohalo.github.io/cn/blog/llvm-jit-introduce/</link><pubDate>Sun, 29 Oct 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llvm-jit-introduce/</guid><description>&lt;p>当前大部分的一些三方编译器都会依赖于 LLVM 框架，除了经常使用的 clang 编译器之外，还可以作为一个框架使用。&lt;/p></description></item><item><title>Google Trace Viewer</title><link>https://gohalo.github.io/cn/blog/google-chrome-trace/</link><pubDate>Fri, 21 Jul 2023 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/google-chrome-trace/</guid><description>&lt;p>在 Chrome 中的 &lt;a href="chrome://tracing/">chrome://tracing&lt;/a> 提供了简单有效的 Trace 可视化方案，作为 Performance Profile、Timeline Tracing 都很方便。&lt;/p></description></item><item><title>RDP 通讯协议详解</title><link>https://gohalo.github.io/cn/blog/rdp-windows-protocol/</link><pubDate>Sun, 16 Jul 2023 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rdp-windows-protocol/</guid><description>&lt;p>有过 Windows 使用经验的人对于远程桌面（Remote Desktop Protocol ，RDP）一定不会陌生。RDP 是由微软公司开发的一种专有协议，它为用户提供了通过网络连接到另一台计算机的图形界面。在使用上，用户需要使用 RDP 客户端软件，而在远程另一台计算机则需要运行 RDP 服务器软件。&lt;/p></description></item><item><title>Wireshark 工具使用</title><link>https://gohalo.github.io/cn/blog/linux-network-tools-wireshark/</link><pubDate>Sun, 16 Jul 2023 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-tools-wireshark/</guid><description>&lt;p>Wireshark (之前被称为 Ethereal) 是一个网络封包分析软件，接收网络封包，并尽可能显示出最为详细的网络报文资料，这里详细介绍其使用方式。&lt;/p></description></item><item><title>通过 Wireshark 解析 TLS 报文</title><link>https://gohalo.github.io/cn/blog/wireshark-decrypt-tls-ssl/</link><pubDate>Sun, 16 Jul 2023 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/wireshark-decrypt-tls-ssl/</guid><description>&lt;p>SSL/TLS 是目前使用最广泛的安全通讯协议，最常见的 HTTPS 也是建立在该协议之上的，尤其是 TLSv1.3 版本更新之后，其性能、安全性得以有效提升，在带来安全性的同时，在开发阶段很难对通讯协议进行调试。&lt;/p>
&lt;p>通过 Wireshark 可以分析绝大部分的 TCP/IP 协议流量，包括了 TLS 协议，可以用来分析协议的工作方式或者排查问题。&lt;/p></description></item><item><title>NeoVim 基本环境配置</title><link>https://gohalo.github.io/cn/blog/neovim-basic-usage/</link><pubDate>Fri, 02 Sep 2022 21:14:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-basic-usage/</guid><description>&lt;p>最开始 NeoVim 是 Vim 的功能增强，但是随着不断开发，功能越来越完善，而且已经分道扬镳，现在已经成为了更加接近现代的开发工具，尤其是随着 &lt;a href="https://neovim.io/charter/">Vision&lt;/a> 计划的开发，也包括了其子项目 &lt;a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter&lt;/a>。&lt;/p></description></item><item><title>Linux 用户管理</title><link>https://gohalo.github.io/cn/blog/linux-user-account-management/</link><pubDate>Fri, 26 Aug 2022 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-user-account-management/</guid><description>&lt;p>Linux 是一个多用户多任务的分时操作系统，可以允许多个用户同时登陆，通过账户管理，可以方便系统管理员对用户进行跟踪，控制系统资源的访问，也可以帮助用户组织文件，并为用户提供安全性保护。&lt;/p>
&lt;p>对于普通用户来说，每个账号都拥有一个惟一的用户名以及口令，只有在输入正确之后才可以进入系统以及主目录。&lt;/p>
&lt;p>这里详细介绍与用户管理相关的内容。&lt;/p></description></item><item><title>使用 C API 执行 Linux 用户相关操作</title><link>https://gohalo.github.io/cn/blog/linux-user-manage-c-api/</link><pubDate>Fri, 26 Aug 2022 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-user-manage-c-api/</guid><description>&lt;p>通过 glibc 提供的 API 可以获取用户信息、切换用户等操作，在使用的时候有很多注意事项，例如可能会遇到即使用户存在仍读取失败，密码的密文是如何生成的等等。&lt;/p>
&lt;p>这里会进行简单介绍一些常见的问题以及如何规避。&lt;/p></description></item><item><title>Ray 计算框架详解</title><link>https://gohalo.github.io/cn/blog/ray-compute-engine/</link><pubDate>Tue, 16 Aug 2022 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ray-compute-engine/</guid><description/></item><item><title>draw.io 一款开源免费流程图绘制软件</title><link>https://gohalo.github.io/cn/blog/draw-tools-online/</link><pubDate>Sun, 12 Jun 2022 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/draw-tools-online/</guid><description>&lt;p>这是一款免费开源的图形绘制软件，支持丰富的模板，可以直接嵌入现有图片，包括 SVG 格式，还可以自定义图形，甚至编辑数学表达式。&lt;/p>
&lt;p>这里简单整理常见用法。&lt;/p></description></item><item><title>Socks 代理协议详解</title><link>https://gohalo.github.io/cn/blog/network-proxy-socks/</link><pubDate>Thu, 28 Apr 2022 21:39:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-proxy-socks/</guid><description>&lt;p>Socks 是一个代理协议，这里会对协议进行详细介绍，同时会介绍其使用场景。&lt;/p></description></item><item><title>Telnet 协议详解</title><link>https://gohalo.github.io/cn/blog/network-telnet-introduce/</link><pubDate>Thu, 28 Apr 2022 21:39:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-telnet-introduce/</guid><description>&lt;p>Telnet 是一个简单的远程终端协议，通过 TCP 连接登录到远端服务器，相比之前需要通过硬件终端连接服务器的方式要简单很多，但是因为没有加密容易导致信息泄漏，建议使用 SSH 而非 Telnet 协议。&lt;/p>
&lt;p>协议内部使用 Network Virtual Terminal, NVT，也就是所谓的虚拟网络终端，然后两端根据各自字符集等进行转换。&lt;/p></description></item><item><title>BCC eBPF 使用</title><link>https://gohalo.github.io/cn/blog/linux-ebpf-bcc-tools/</link><pubDate>Wed, 01 Dec 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ebpf-bcc-tools/</guid><description>&lt;p>正常来说，如果要使用 eBPF 提供的能力，需要完成 &amp;ldquo;编写BPF代码-编译成字节码-注入内核-获取结果-展示&amp;rdquo; 这一整套流程，而且会非常复杂。&lt;/p>
&lt;p>而 bcc 是通过 Python 编写的一个 eBPF 工具集，使得上述的 整个过程更加便捷。&lt;/p></description></item><item><title>eBPF 基本功能介绍</title><link>https://gohalo.github.io/cn/blog/linux-ebpf-basic-introduce/</link><pubDate>Wed, 01 Dec 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ebpf-basic-introduce/</guid><description>&lt;p>Berkeley Packet Filter, BPF 提供了强大的网络包过滤规则，可以确定应该检查哪些流量、忽略哪些流量等，而内核近几年发展的 Extended BPF, eBPF 实际上将应用范围，处理效率进行了更新。&lt;/p>
&lt;p>eBPF 是 Linux 内核近几年最为引人注目的特性之一，通过一个内核内置的字节码虚拟机，完成数据包过滤、调用栈跟踪、耗时统计、热点分析等等高级功能。&lt;/p></description></item><item><title>Debian 系统配置</title><link>https://gohalo.github.io/cn/blog/linux-debian-distribution/</link><pubDate>Sun, 12 Sep 2021 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-debian-distribution/</guid><description>&lt;p>Debian 是最早最老牌的 Linux 发行版之一，最大优点是极其稳定快速，是 Ubuntu、Linux Mint 和 elementary OS 等 Linux 操作系统的母板，同时拥有强大的 APT 包管理机制和丰富的软件源，可以方便地安装和平滑升级软件和系统，省去很多编译安装和版本升级的麻烦.&lt;/p>
&lt;p>其具有完善的包管理系统，它的每个组件和应用程序都内置在系统中安装的软件包中。&lt;/p></description></item><item><title>Python 通过 Paramiko 访问 SSH 服务</title><link>https://gohalo.github.io/cn/blog/ssh-python-paramiko-examples/</link><pubDate>Thu, 12 Aug 2021 20:28:54 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-python-paramiko-examples/</guid><description>&lt;p>Paramiko 实现了 SSH2 协议，用于与远程机器建立经过认证和加密后的安全连接，与 SSL 不同的是，SSH 不需要权威机构签署的分层证书，采用分布式的方式管理。&lt;/p></description></item><item><title>自动控制 PID 算法详细使用</title><link>https://gohalo.github.io/cn/blog/automatic-control-pid-details/</link><pubDate>Sun, 01 Aug 2021 10:29:33 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/automatic-control-pid-details/</guid><description>&lt;p>Proportional Integral Derivative, PID 控制是最早发展起来的控制策略之一，由于其算法简单、鲁棒性好和可靠性高，被广泛应用于工业过程控制。&lt;/p>
&lt;p>这里详细介绍实际使用时使用问题。&lt;/p></description></item><item><title>SASS 基本用法介绍</title><link>https://gohalo.github.io/cn/blog/web-sass-introduce/</link><pubDate>Mon, 26 Jul 2021 21:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-sass-introduce/</guid><description>&lt;p>通过 CSS 可以用来开发网页样式，不过它没有变量、条件语句，只是单纯的描述，写起来很费事，所以，就有人开始为 CSS 加入编程的元素，也就是预处理器。&lt;/p>
&lt;p>使用时通过专门的编程语言进行网页设计，然后再编译成正常的 CSS 文件，最常见的包括了 SASS、LESS 等。&lt;/p></description></item><item><title>RFB 通讯协议详解</title><link>https://gohalo.github.io/cn/blog/vnc-rbf-protocol/</link><pubDate>Fri, 16 Jul 2021 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vnc-rbf-protocol/</guid><description>&lt;p>VNC 是一套实现远程网络操控的软件，通常用于界面操作。&lt;/p></description></item><item><title>Curl 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-curl/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-curl/</guid><description>&lt;p>常用的 curl 相关命令整理。&lt;/p></description></item><item><title>Netcat 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-netcat/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-netcat/</guid><description>&lt;p>常用的 netcat 相关命令整理。&lt;/p></description></item><item><title>Wget 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-wget/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-wget/</guid><description>&lt;p>常用的 wget 相关命令整理。&lt;/p></description></item><item><title>排序算法简介</title><link>https://gohalo.github.io/cn/blog/algorithm-sort-introduce/</link><pubDate>Sun, 08 Nov 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-sort-introduce/</guid><description/></item><item><title>Linux PAM 认证机制使用详解</title><link>https://gohalo.github.io/cn/blog/linux-security-pam-introduce/</link><pubDate>Tue, 13 Oct 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-security-pam-introduce/</guid><description>Linux 通常会通过 login 进程完成登陆，最开始时只是简单的提示用户输入用户名和密码，然后校验用户是否存在、密码是否正确，如果都正常，那么就会直接完成登陆，进入到 Shell 程序运行。
PAM 提供了独立于具体程序配置机制，可以更加灵活的鉴权方案，这里详细介绍其使用方式。
简介 # 通常在用户登陆时，需要有一套的验证授权机制，最开始的时候，这一整套的验证机制是硬编码到程序中的，这样当程序有 bug 或者需要修改验证策略时，只能修改源程序。
为了改善这些问题，人们开始思考其他的方法，也就是所谓的 Pluggable Authentication Modules, PAM 应运而生了。
PAM 提供了一整套的鉴权、授权、密码管理、会话管理机制等，只需要程序支持 PAM 框架，用户就可以在完全不修改程序的条件下，动态修改鉴权机制，例如除了常规的用户名密码登陆，还可以使用指纹、One-Time-Password 等机制。
运行机制 # 如下是一个最常见的 login 示例程序，其中包括了二进制 login 可执行程序，该程序会动态链接 libpam.so 库，该库会读取 /etc/pam.d/login 配置文件，并根据配置文件中的内容，按照顺序生成不同栈。
然后，会根据不同的栈以及配置执行相关的动作。
相关文件 # 在 64 位系统中，与 PAM 相关的文件包含了如下几类：
/usr/lib64/libpam.so* 核心库，使用 PAM 机制的应用会链接到该库上。 /etc/pam.conf /etc/pam.d/* 配置文件，配置内容基本类似，前者为全局配置，通过第一列标识应用程序，而后者则以文件名标识应用程序，结构层次更加明确，也更常见。 /usr/lib64/security/pam_*.so 可以动态加载的模块，在配置文件中可以直接通过文件名引用。 如果一个应用程序 (例如 login) 想使用 PAM 提供的机制，那么需要链接到 libpam.so 库，否则就不支持 PAM 机制，可以通过如下命令查看。
$ ldd /usr/bin/login | grep pam libpam.so.0 =&amp;gt; /lib64/libpam.</description></item><item><title>通过 OpenSSL 制作自签名证书</title><link>https://gohalo.github.io/cn/blog/openssl-self-signed-certificate/</link><pubDate>Sat, 12 Sep 2020 22:20:03 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/openssl-self-signed-certificate/</guid><description>&lt;p>一般来说，在互联网上使用 HTTPS 时，需要向一些官方的 CA 中心申请证书，不过一般来说比较贵。如果只是公司内部使用，那么就可以自己制作证书，当然也可以模拟 CA 的方式管理证书。&lt;/p>
&lt;p>这里详细介绍如何使用 OpenSSL 制作自签名证书，包括了自建 CA 的方式。&lt;/p></description></item><item><title>详细介绍 PKI 以及 CA 基本概念</title><link>https://gohalo.github.io/cn/blog/ssl-public-key-infrastructure/</link><pubDate>Thu, 13 Aug 2020 19:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssl-public-key-infrastructure/</guid><description>&lt;p>公钥基础设施 (Public Key Infrastructure, PKI) 是目前网络安全建设的基础与核心，而证书认证机构 (Certificate Authority, CA) 更是核心中的核心，其中 CA 最重要的用途就是提供根证书，用来加强服务器和客户端之间信息交互的安全性。&lt;/p>
&lt;p>这里简单介绍一些基本概念。&lt;/p></description></item><item><title>Websocket 协议详解</title><link>https://gohalo.github.io/cn/blog/network-websocket-introduce/</link><pubDate>Sat, 25 Jul 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-websocket-introduce/</guid><description>&lt;p>对于 HTTP 协议，通信只能由客户端发起，服务端无法主动向客户端推送信息，通过轮询方式就很消耗资源。&lt;/p>
&lt;p>为了达到实时响应以及良好的用户体验，通常通过 AJAX 实现异步无刷新请求功能，不过只能在浏览器异步请求服务器，也就是拉取；而推送一般通过类似 Comet 的技术，略显复杂。&lt;/p>
&lt;p>而 WebSocket 是一种全新的协议，将 TCP 的 Socket 应用在了 web page 上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工工作模式。&lt;/p>
&lt;p>这里详细介绍其实现。&lt;/p></description></item><item><title>CentOS 安装与配置</title><link>https://gohalo.github.io/cn/blog/centos-config-from-scratch/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/centos-config-from-scratch/</guid><description>&lt;p>CentOS (Community Enterprise Operating System) 也即社区版的企业操作系统，是 Linux 发行版本之一，来自于 Red Hat Enterprise Linux 所开放的源码编译而成。因此，对稳定性较高的服务器通常以 CentOS 替代商业版的 Red Hat 。&lt;/p>
&lt;p>两者的不同在于 CentOS 并不包含封闭源代码软件。下面会介绍桌面版的 CentOS 在安装时需要作的一些常用配置。&lt;/p></description></item><item><title>KVM 虚拟平台</title><link>https://gohalo.github.io/cn/blog/linux-kernel-based-virtual-machine-kvm/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-based-virtual-machine-kvm/</guid><description>&lt;p>全虚拟化最简单通俗的理解是，在一台机器上可以运行不同的平台 (例如Linux、Windows等)，不过其对应的仍然是 x86_64 架构。另外，如果允许在机器上可以运行不同的架构(例如x86_64、PowerPC、ARM等)，那么这种的虚拟化方式称为硬件仿真。&lt;/p>
&lt;p>这里简单介绍下 Linux 中 KVM 的使用方式。&lt;/p></description></item><item><title>MinIO 使用详解</title><link>https://gohalo.github.io/cn/blog/minio-object-storage/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/minio-object-storage/</guid><description>安装 # 可以从 Download 查看不同平台的安装方法，如下以 RPM 为例，同时会包含 systemd 的配置文件。
在 /lib/systemd/system/minio.service 可以看到具体的启动命令行为 minio server $MINIO_OPTS $MINIO_VOLUMES，同时需要修改启动的用户名和用户组，修改如下配置文件后启动。
# cat /etc/default/minio MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password MINIO_DOMAIN=&amp;#34;minio.com&amp;#34; MINIO_VOLUMES=&amp;#34;/opt/minio/data&amp;#34; MINIO_OPTS=&amp;#34;--address :9000 --console-address :9001&amp;#34; # systemctl start minio 然后访问 http://localhost:9001 即可，注意，从 2021 版本开始，需要通过 MINIO_ROOT_USER/MINIO_ROOT_PASSWORD 替换之前的 MINIO_ACCESS_KEY/MINIO_SECRET_KEY 配置参数，其它常用配置参数可以参考：
MINIO_REGION 部署所在区域，一般通过 国家-区域-编号 表示，例如 us-west-1 。 MINIO_DOMAIN 配置后支持 Virtual Host 方式访问。 默认会使用 Path Style 也就是类似 http://xxx.com:9000/bucket/1.txt 方式访问对象，设置 MINIO_DOMAIN 参数后将会同时支持 Virtual Host Style 方式，此时桶名会作为域名，例如 http://bucket.xxx.com:9000/1.txt 这种路径。
注意，此时要同时设置域名解析，如果是本地，可以参考 DNSmasq 中的介绍，同时增加。
配置 # 同样按照上述的介绍下载客户端，最新一般是 mc 命令。</description></item><item><title>XWindow 简介</title><link>https://gohalo.github.io/cn/blog/linux-xwindow-introduce/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-xwindow-introduce/</guid><description>&lt;p>XWindow 是一种以位图方式显示的软件窗口系统，最初是 1984 年麻省理工学院的研究成果，之后变成类 UNIX 操作系统的标准化软件工具包及显示架构协议。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>yum 配置以及常用 rpm 命令</title><link>https://gohalo.github.io/cn/blog/yum-rpm-config-and-command-usage/</link><pubDate>Wed, 01 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/yum-rpm-config-and-command-usage/</guid><description>&lt;p>在 CentOS 中，会通过 YUM 或者 RPM 进行软件包的管理，不过 RPM 不能很好的解决软件之间的依赖关系，所以目前使用较多的是 YUM 源。&lt;/p>
&lt;p>介绍常用的管理命令，基本的 RPM 规范，常见的错误处理，例如镜像地址配置、本地源设置、强制安装包等等。&lt;/p></description></item><item><title>Neovim 插件管理工具之 Packer(历史)</title><link>https://gohalo.github.io/cn/blog/neovim-plugins-management-legacy-packer/</link><pubDate>Fri, 12 Jun 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-plugins-management-legacy-packer/</guid><description>&lt;p>从 Neovim 0.5 版本开始，一般推荐使用 Lua 原生的 &lt;code>packer.nvim&lt;/code> 做插件管理，现在大多数插件都支持该管理工具。&lt;/p>
&lt;p>这里详细介绍其使用。&lt;/p></description></item><item><title>如何在 Linux 中查看 CPU 信息</title><link>https://gohalo.github.io/cn/blog/check-cpu-info-on-linux/</link><pubDate>Fri, 29 May 2020 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/check-cpu-info-on-linux/</guid><description>&lt;p>现在 CPU 一般是多核，甚至包括了现在的手机，而每个核又包含了缓存，那么，在 Linux 上如何通过命令查看当前 CPU 的信息呢？例如，常见的型号、时钟频率、核数等等，在这篇文章里会详细介绍。&lt;/p></description></item><item><title>Linux 网络配置</title><link>https://gohalo.github.io/cn/blog/linux-network-settings/</link><pubDate>Wed, 20 May 2020 21:29:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-settings/</guid><description>&lt;p>现在很多系统管理员仍在使用 ifconfig、route、arp 和 netstat 等命令行工具，来管理和排查各种网络配置。这套工具也就是 net-tools 包，源于 BSD TCP/IP 工具箱，但是自 2001 年以后基本就停滞不前。&lt;/p>
&lt;p>iproute 作为一套新的网络配置工具，旨在替换原有的 net-tools 工具包，这里大概介绍下两者的区别。&lt;/p></description></item><item><title>Linux 密码管理</title><link>https://gohalo.github.io/cn/blog/how-to-save-password-security/</link><pubDate>Thu, 23 Apr 2020 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/how-to-save-password-security/</guid><description>&lt;p>简单介绍下 Linux 中的密码管理。&lt;/p></description></item><item><title>VIM 颜色配置</title><link>https://gohalo.github.io/cn/blog/vim-tips-true-colors/</link><pubDate>Sun, 12 Apr 2020 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-tips-true-colors/</guid><description>&lt;p>不同的终端对于颜色的支持能力略有区别。&lt;/p></description></item><item><title>Linux 用户管理的最佳实践</title><link>https://gohalo.github.io/cn/blog/linux-user-best-practise/</link><pubDate>Tue, 25 Feb 2020 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-user-best-practise/</guid><description>&lt;p>在 Linux 中，权限管理包括了用户、主用户组、从用户组，通过这三者的组织可以方便对权限的管理，尤其是对于文件的权限管理。这里假设一个运维中的使用场景，通过创建一系列的用户以及用户组，然后查看其权限管理的方案。&lt;/p></description></item><item><title>Linux Capabilites 机制详细介绍</title><link>https://gohalo.github.io/cn/blog/linux-security-capabilities/</link><pubDate>Sat, 18 Jan 2020 21:39:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-security-capabilities/</guid><description>&lt;p>在 Linux 系统中，有些操作是需要 root 用户权限才能操作的，常见的包括 chown、使用 Raw Sokcet (ping) 等，如果使用 sudo 就会导致配置管理和权限控制比较麻烦。&lt;/p>
&lt;p>为了只给这个程序开所需要的权限，Linux 提供了一套 capabilities 机制，这里详细介绍。&lt;/p></description></item><item><title>Podman 使用简介</title><link>https://gohalo.github.io/cn/blog/podman-container-basic-introduce/</link><pubDate>Sun, 01 Dec 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/podman-container-basic-introduce/</guid><description>&lt;p>Docker 是一个以 root 身份在系统上运行的守护程序，然后利用 Linux 内核的功能来管理正在运行的容器，包括了容器镜像。&lt;/p>
&lt;p>而 Podman 提供与 Docker 类似的功能，但是不再以 root 用户运行，而且非常驻进程。&lt;/p></description></item><item><title>【拍案惊奇】之网络端口</title><link>https://gohalo.github.io/cn/blog/network-same-source-destination-port/</link><pubDate>Wed, 02 Oct 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-same-source-destination-port/</guid><description>&lt;p>如果在本地访问时，使用了一个源和目的端口都相同的 TCP 链接，会出现什么情况？&lt;/p></description></item><item><title>Linux 系统配置</title><link>https://gohalo.github.io/cn/blog/linux-system-config/</link><pubDate>Fri, 27 Sep 2019 19:49:36 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-system-config/</guid><description>&lt;p>一些与 Linux 系统配置相关的介绍。&lt;/p></description></item><item><title>开源协议简介</title><link>https://gohalo.github.io/cn/blog/opensource-license/</link><pubDate>Tue, 10 Sep 2019 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/opensource-license/</guid><description/></item><item><title>关于 OSCP 的基本概念以及使用介绍</title><link>https://gohalo.github.io/cn/blog/ssl-oscp-introduce/</link><pubDate>Thu, 15 Aug 2019 20:19:43 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssl-oscp-introduce/</guid><description>&lt;p>对于颁发的证书，如果因为一些特殊原因，例如私钥泄漏、证书信息有误、颁发了其它域名证书等等，这样，就需要吊销某些证书，这里关键就是浏览器或客户端如何知道当前使用的证书已经被吊销了。&lt;/p>
&lt;p>为了解决这一问题，引入了 Certificate Revocation List, CRL 和 Online Certificate Status Protocol, OCSP 技术，前者需要用户定期下载用于脱机使用，后者则可实时在线查询。&lt;/p></description></item><item><title>Linux Alternatives 命令使用</title><link>https://gohalo.github.io/cn/blog/linux-command-alternatives-introduce/</link><pubDate>Thu, 13 Jun 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-alternatives-introduce/</guid><description>&lt;p>在 Linux 中，对于相同的功能可能会存在多种的实现，例如查看文件可以使用 head、tail、cat 等；而且，即使相同软件可能会有多个版本，例如 Python 有 2.X、3.X 版本，等等。&lt;/p>
&lt;p>为了统一命令、方便管理，就可以使用 Linux 中的 alternatives 命令，这里简单介绍。&lt;/p></description></item><item><title>VIM技巧 -- 自动换行</title><link>https://gohalo.github.io/cn/blog/vim-auto-return/</link><pubDate>Wed, 12 Jun 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-auto-return/</guid><description> 自动换行 # 输入时，默认 Vim 是不会自动换行的，可以通过设定 :set textwidth=29 选项，让 Vim 自动在第 30 列换行，注意，对于已经存在的文本是不会换行的，也超过制定长度后也不会换行。
这里的换行不会添加 EOL 符号，而只是影响显示。希望允许设置显示的最大宽度，超过之后可以不显示或者换行，如果换行，那么上下切换行的时候就不要再以原有的行进行切换。
通过设置 linebreak=true 可以只在分词的时候进行换行，而设置为 false 时会在对应的字符位置直接换行。
换行切换 # 一行因为过长自动换行之后，可以通过 gj 切换，为了保持与之前的快捷键统一，那么就可以使用如下的映射。
noremap j gj noremap k gk</description></item><item><title>Linux 可执行文件解析工具</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</link><pubDate>Sat, 08 Jun 2019 21:19:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</guid><description>&lt;p>主要是在如何解析 ELF 格式的文件。&lt;/p></description></item><item><title>Prometheus 监控系统</title><link>https://gohalo.github.io/cn/blog/monitor-system-prometheus-introduce/</link><pubDate>Sat, 01 Jun 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/monitor-system-prometheus-introduce/</guid><description>&lt;p>一套开源的时序数据存储方案，同时包含了前端的页面展示。&lt;/p></description></item><item><title>Linux 常用配置</title><link>https://gohalo.github.io/cn/blog/linux-basic-common-setup/</link><pubDate>Tue, 21 May 2019 20:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-basic-common-setup/</guid><description>&lt;p>这里简单整理在 Linux 安装过程中常见的配置。&lt;/p></description></item><item><title>OpenSSL 常用命令</title><link>https://gohalo.github.io/cn/blog/linux-network-command-openssl/</link><pubDate>Fri, 10 May 2019 22:08:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-openssl/</guid><description>&lt;p>OpenSSL 除了提供一个开发库之外，还包括了一些常用的命令，这里简单介绍其使用方式。&lt;/p></description></item><item><title>X509 证书内容详细介绍</title><link>https://gohalo.github.io/cn/blog/ssl-x509-certification-details/</link><pubDate>Tue, 07 May 2019 20:08:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssl-x509-certification-details/</guid><description>&lt;p>在 X509 标准中，规定了证书包含的信息，同时说明了记录信息的方法，也就是详细的证书格式。&lt;/p>
&lt;p>这里详细介绍其基本概念。&lt;/p></description></item><item><title>Prophet 使用简介</title><link>https://gohalo.github.io/cn/blog/prophet-usage-introduce/</link><pubDate>Sat, 20 Apr 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/prophet-usage-introduce/</guid><description>&lt;p>Facebook 提供的 Prophet 算法主要是用来处理单变量的时间序列，对于一些异常数据以及确实的情况可以很好的处理，对于周期性的数据几乎可以全自动地预测未来的走势。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>ABI 二进制接口介绍</title><link>https://gohalo.github.io/cn/blog/c-application-binary-interface/</link><pubDate>Wed, 10 Apr 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-application-binary-interface/</guid><description>&lt;p>如果将编译后的代码反汇编，会发现传参过程中有很多寄存器相关的操作，包括了传参、数据的清理等等。&lt;/p>
&lt;p>那么具体是怎么工作的？为什么要按照这一规则？&lt;/p></description></item><item><title>网络 Namespace</title><link>https://gohalo.github.io/cn/blog/linux-namespace-network-introduce/</link><pubDate>Wed, 10 Apr 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-namespace-network-introduce/</guid><description>Namespace # ---- 查看帮助信息 # ip netns help ----- 当前NS的列表 # ip netns list ----- 添加NS，会在/var/run/netns目录下创建 # ip netns add foobar ----- 删除全部或者指定的NS # ip -all netns delete # ip netns delete foobar 对于每个 Network Namespace 来说，它会有自己独立的网卡、路由表、ARP 表、iptables 等和网络相关的资源，通过 ip netns exec 命令可以在 NS 中执行命令。
----- 查看网卡信息 # ip netns exec foobar ip addr ----- lo网卡默认关闭，可以通过如下命令打开 # ip netns exec foobar ip link set lo up ----- ping回环地址 # ip netns exec foobar ping -c 3 127.</description></item><item><title>Docker RunC 简介</title><link>https://gohalo.github.io/cn/blog/docker-component-runc-introduce/</link><pubDate>Mon, 08 Apr 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-component-runc-introduce/</guid><description>&lt;p>OCI 定义了容器运行时标准，runC 是 Docker 按照开放容器格式标准 Open Container Format, OCF 制定的一种具体实现。&lt;/p>
&lt;p>该项目从 Docker 的 libcontainer 中迁移来，实现了容器启停、资源隔离等功能，所以，可以直接通过该工具运行容器。&lt;/p></description></item><item><title>Beringei 内存时序数据库</title><link>https://gohalo.github.io/cn/blog/beringei-memory-database-introduce/</link><pubDate>Tue, 02 Apr 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/beringei-memory-database-introduce/</guid><description>&lt;p>Facebook 在 2017.02.03 开源了一个高性能内存时序数据存储引擎 Beringei ，用来解决监控数据的存储和查询需求，具有快速读写、高压缩比等特性。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>常用 DNS 工具介绍</title><link>https://gohalo.github.io/cn/blog/dns-tools-usage/</link><pubDate>Fri, 22 Mar 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/dns-tools-usage/</guid><description>&lt;p>之前已经介绍了关于 DNS 常见的基本概念，这里会通过一些常见的命令行工具进行验证，例如 getent、nslookup、dig 等等。&lt;/p></description></item><item><title>KVM 网路配置介绍</title><link>https://gohalo.github.io/cn/blog/linux-kvm-network-setting/</link><pubDate>Tue, 12 Mar 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kvm-network-setting/</guid><description/></item><item><title>Linux C 陷阱</title><link>https://gohalo.github.io/cn/blog/linux-c-some-pitfalls-introduce/</link><pubDate>Sun, 10 Mar 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-some-pitfalls-introduce/</guid><description>&lt;p>一些 C 语言中比较容易犯错的知识点。&lt;/p></description></item><item><title>UDP 通讯优化</title><link>https://gohalo.github.io/cn/blog/linux-c-udp-optimize-introduce/</link><pubDate>Wed, 27 Feb 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-udp-optimize-introduce/</guid><description>&lt;p>有部分应用场景采用的仍然是无连接协议，例如 DNS、StatsD 等，都是采用的 UDP 。&lt;/p>
&lt;p>UDP 不是面向连接的，所以不能像 TCP 通过建立多个连接来提高对服务器的并发访问，如果通过多线程共享一个 UDP Socket 可能会无法充分利用所有的 CPU 资源。&lt;/p>
&lt;p>这里简单介绍其优化方法，当然，这里的策略也适用与像 ICMP 这样的协议。&lt;/p></description></item><item><title>内存检查工具</title><link>https://gohalo.github.io/cn/blog/linux-c-some-memory-debugger-tools-introduce/</link><pubDate>Mon, 25 Feb 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-some-memory-debugger-tools-introduce/</guid><description/></item><item><title>Windows WSL 环境使用</title><link>https://gohalo.github.io/cn/blog/windows-wsl-introduce/</link><pubDate>Thu, 21 Feb 2019 20:40:59 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/windows-wsl-introduce/</guid><description>&lt;p>所谓的 WSL 就是 Windows Subsystem for Linux 的缩写，意思是 Linux 版的 Window 子系统，可以在 Windows 上运行 Linux 系统。&lt;/p></description></item><item><title>C/CPP 静态链接顺序</title><link>https://gohalo.github.io/cn/blog/c-cpp-static-linkage/</link><pubDate>Mon, 28 Jan 2019 22:10:33 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-cpp-static-linkage/</guid><description>&lt;p>静态链接和动态链接最大的区别就在于链接的时机不一样，静态链接是在生车可执行程序前，而动态链接的进行则是在程序执行时，而且静态链接库的位置不同将会影响二进制文件生成。&lt;/p></description></item><item><title>Linux PID 分配方法</title><link>https://gohalo.github.io/cn/blog/linux-pid-allocate-method-introduce/</link><pubDate>Sat, 19 Jan 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-pid-allocate-method-introduce/</guid><description>&lt;p>在 Linux 系统中，每个进程都有一个非负整型表示的唯一进程 ID，虽然在主机级别是唯一的，但是进程的 ID 可以重用，一个进程停止后，其它的进程可以复用该 ID 。&lt;/p>
&lt;p>Linux 采用延迟重用的算法，在大部分场景下会使得新进程 ID 不同于最近终止进程所使用的 ID，以防止将新进程误认为是使用同一 ID 的某个已终止的先前进程。&lt;/p>
&lt;p>这里主要讨论了 Linux 中分配进程 ID 的方法以及源码实现。&lt;/p></description></item><item><title>LVM 简介</title><link>https://gohalo.github.io/cn/blog/linux-logical-volume-manager-lvm-introduce/</link><pubDate>Thu, 10 Jan 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-logical-volume-manager-lvm-introduce/</guid><description>&lt;p>在最初对磁盘分区的大小进行规划时，很难确定其真正使用的磁盘空间，那在后续的管理时就非常麻烦，实际上类似的问题可以通过 LVM 进行管理。&lt;/p>
&lt;p>Logical Volume Manager, LVM 一般翻译为 &amp;ldquo;逻辑卷管理&amp;rdquo;，它是 Linux 下对磁盘分区进行管理的一种机制，在磁盘分区和文件系统之间的一个逻辑层，可以灵活的调整分区大小。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>Linux Write API 简介</title><link>https://gohalo.github.io/cn/blog/linux-kernel-vfs-multi-write-methods-introduce/</link><pubDate>Tue, 08 Jan 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-vfs-multi-write-methods-introduce/</guid><description>&lt;p>之前其实已经介绍过，Linux 中有条设计原则，&amp;ldquo;一切都是文件&amp;rdquo; 。&lt;/p>
&lt;p>对于文件的操作除了 &lt;code>open()&lt;/code> &lt;code>close()&lt;/code> 之外，使用比较多的就是 &lt;code>read()&lt;/code> 和 &lt;code>write()&lt;/code> 函数了，为了适配不同的应用场景，实际上，Linux 还提供了 &lt;code>writev()&lt;/code> &lt;code>pwrite()&lt;/code> 之类的函数。&lt;/p>
&lt;p>那么，这些函数的区别、使用场景是什么。&lt;/p></description></item><item><title>DNS 协议详解</title><link>https://gohalo.github.io/cn/blog/network-dns-protocol-details-introduce/</link><pubDate>Fri, 21 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-protocol-details-introduce/</guid><description>&lt;p>也就是做 DNS 解析时，客户端和服务端的通讯协议，详见 &lt;a href="https://www.ietf.org/rfc/rfc1035.txt">RFC1035 4.MESSAGES&lt;/a> 部分。&lt;/p>
&lt;p>这里简单介绍其基本概念。&lt;/p></description></item><item><title>替换 glibc malloc</title><link>https://gohalo.github.io/cn/blog/linux-c-program-replace-glibc-memory-function/</link><pubDate>Wed, 19 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-program-replace-glibc-memory-function/</guid><description>&lt;p>在进行系统优化、内存泄漏测试时，经常需要对 glibc 的一些 API 进行替换，例如比较常见的是内存管理接口。&lt;/p>
&lt;p>如果代码量很大，或者使用了三方的静态库时，此时就无法直接替换相关的函数，例如 &lt;code>malloc()&lt;/code> &lt;code>realloc()&lt;/code> &lt;code>calloc()&lt;/code> 等，需要直接替换掉系统的相关函数。&lt;/p>
&lt;p>这里简单介绍几种方法。&lt;/p></description></item><item><title>lock-free 编程</title><link>https://gohalo.github.io/cn/blog/linux-c-program-lock-free-queue-introduce/</link><pubDate>Sun, 09 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-program-lock-free-queue-introduce/</guid><description>&lt;p>简单介绍下无锁编程 (Lock Free) 的概念，并实现一个基本的 Queue 。&lt;/p></description></item><item><title>Protobuf 序列化详解</title><link>https://gohalo.github.io/cn/blog/protobuf-protocol-serialize-details/</link><pubDate>Sat, 24 Nov 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-protocol-serialize-details/</guid><description>&lt;p>类似于 JSON、XML 格式，Protocol Buffer 是 Google 出品的一种轻量而且高效的结构化数据存储格式，性能比 JSON、XML 要强很多，包括其序列化、反序列化速度，数据压缩效果。&lt;/p>
&lt;p>当然，带来的问题是可读性不高。&lt;/p></description></item><item><title>Linux 常用命令 inotify 介绍</title><link>https://gohalo.github.io/cn/blog/linux-command-inotify-introduce/</link><pubDate>Wed, 21 Nov 2018 23:10:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-inotify-introduce/</guid><description>&lt;p>在 Linux 系统下 inotify 是一种强大的、细粒度的、异步的文件系统事件监控机制，通过该机制可以快速感知文件的变化，这样可以用于一些文件的实时同步。&lt;/p></description></item><item><title>Huffman 编码简介</title><link>https://gohalo.github.io/cn/blog/huffman-introduce/</link><pubDate>Tue, 20 Nov 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/huffman-introduce/</guid><description>&lt;p>哈夫曼编码 Huffman Coding 是一种变长的前缀码，使用的算法是 David A. Huffman 还在 MIT 的学生时提出的，并且在 1952 年发表了名为 &lt;code>A Method for the Construction of Minimum-Redundancy Codes&lt;/code> 的文章。&lt;/p>
&lt;p>编码过程叫做哈夫曼编码，是一种普遍的熵编码技术，包括用于无损数据压缩领域。&lt;/p></description></item><item><title>HTTP2 HPACK 介绍</title><link>https://gohalo.github.io/cn/blog/network-http2-hpack-introduce/</link><pubDate>Fri, 16 Nov 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http2-hpack-introduce/</guid><description>&lt;p>Google 直接在 HTTP1.X 的基础上设计了 SPDY 协议，对头部使用 deflate 算法进行压缩，一并解决了多路复用和优先级等问题。而 HTTP2 的实现就是参考了 SPDY 协议，但是专门为头部压缩设计了一套压缩算法，就是这里的 HPACK 。&lt;/p></description></item><item><title>Linux Socket 端口使用</title><link>https://gohalo.github.io/cn/blog/linux-socket-port-range-introduce/</link><pubDate>Tue, 13 Nov 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-socket-port-range-introduce/</guid><description>&lt;p>Linux 使用的 TCP/IP 协议栈会使用四元组，在客户端与服务端建立链接的时候一般无需指定端口，可以直接使用系统默认指定的端口。&lt;/p>
&lt;p>当然，也可以指定固定的端口，不过此时可能会导致端口冲突。&lt;/p></description></item><item><title>Linux 进程退出码</title><link>https://gohalo.github.io/cn/blog/linux-process-exit-code-introduce/</link><pubDate>Sun, 04 Nov 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-exit-code-introduce/</guid><description>&lt;p>Linux 下进程的退出包括了正常退出和异常退出，正常退出包括了 A) &lt;code>main()&lt;/code> 函数中通过 &lt;code>return&lt;/code> 返回；B) 调用 &lt;code>exit()&lt;/code> 或者 &lt;code>_exit()&lt;/code> 退出。异常退出包括了 A) &lt;code>abort()&lt;/code> 函数；B) 收到了信号退出。&lt;/p>
&lt;p>不管是哪种退出方式，系统最终都会执行内核中的同一代码，并将进程的退出方式以返回码的方式保存下来。&lt;/p></description></item><item><title>HTTP2 协议简介</title><link>https://gohalo.github.io/cn/blog/network-http2-protocol-introduce/</link><pubDate>Tue, 16 Oct 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http2-protocol-introduce/</guid><description>&lt;p>HTTP2 也就是超文本传输协议第 2 版，基于 TCP 连接的一个上层协议，允许在一个 TCP 连接上多路复用，支持优先级、流量控制、服务器推送、首部HPACK压缩、&lt;/p>
&lt;p>保持了与 HTTP1 相同的基本语义，例如 方法语义 (GET PUST PUT DELETE 等)、状态码 (200 404 500 等)、URL 等等，相比来说做了如下的优化。&lt;/p>
&lt;p>通过单个 TCP 连接支持多个通道；头部压缩，解析会更快、更小等等。&lt;/p></description></item><item><title>C 语言 inline 简介</title><link>https://gohalo.github.io/cn/blog/language-c-inline-concept-introduce/</link><pubDate>Fri, 05 Oct 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-inline-concept-introduce/</guid><description>&lt;p>在 C 语言中，调用函数时会在栈空间生成一个函数调用栈，如果函数嵌套过深则会导致大量的栈空间消耗，甚至是溢出。内联函数的引入就是解决一些频繁调用小函数时的大量栈空间消耗问题，这是 C99 的新增特性。&lt;/p></description></item><item><title>Linux 常用命令 rsync 介绍</title><link>https://gohalo.github.io/cn/blog/linux-command-rsync-introduce/</link><pubDate>Mon, 01 Oct 2018 21:10:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-rsync-introduce/</guid><description>&lt;p>rsync 是一个远程数据同步工具，使用 &amp;ldquo;rsync算法&amp;rdquo; 来使本地和远程两个主机之间的文件达到同步，该算法只传送两个文件的不同部分，从而可以有效提高传输效率，而且本地复制文件也可以提高效率。&lt;/p></description></item><item><title>Linux GCC 常用技巧</title><link>https://gohalo.github.io/cn/blog/language-c-gcc-some-basic-tips/</link><pubDate>Thu, 27 Sep 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-gcc-some-basic-tips/</guid><description/></item><item><title>C11 标准解读</title><link>https://gohalo.github.io/cn/blog/program-c-c11-standard-introduce/</link><pubDate>Sat, 01 Sep 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-c11-standard-introduce/</guid><description/></item><item><title>Linux 内存磁盘</title><link>https://gohalo.github.io/cn/blog/linux-ramdisk-introduce/</link><pubDate>Thu, 23 Aug 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ramdisk-introduce/</guid><description>&lt;p>简单来说，我们在做一些压测时，可能会由于磁盘性能的限制无法得到极限的压测结果，此时可以使用 RAM DISK 进行测试。&lt;/p>
&lt;p>内存磁盘是把一部分内存模拟成磁盘，可以把它当成一块高速的硬盘使用。&lt;/p></description></item><item><title>gdbinit 功能介绍</title><link>https://gohalo.github.io/cn/blog/gdb-gdbinit-script/</link><pubDate>Mon, 13 Aug 2018 20:10:51 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-gdbinit-script/</guid><description>&lt;p>在启动时，会在当前用户目录下寻找文件名为 &lt;code>.gdbinit&lt;/code> 的文件，如果存在，会执行该文件中的所有命令，通常用于简单的配置命令，如设置所需的默认汇编程序格式、输出数据默认基数，还可以读取宏编码语言，从而实现更强大的自定义函数。&lt;/p></description></item><item><title>Linux OOM 简介</title><link>https://gohalo.github.io/cn/blog/kernel-memory-oom-killer-introduce/</link><pubDate>Wed, 01 Aug 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-oom-killer-introduce/</guid><description/></item><item><title>Linux Cache VS. Buffer</title><link>https://gohalo.github.io/cn/blog/linux-memory-buffer-vs-cache-details/</link><pubDate>Sat, 28 Jul 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-memory-buffer-vs-cache-details/</guid><description>&lt;p>实际上 Buffer 和 Cache 是两个用烂的词，在不同的场景下其语义会有所区别。在 Linux 的内存管理中，Buffer 是指 Buffer Cache(缓冲区缓存)，Cache 是指 Page Cache(页面缓存)。&lt;/p>
&lt;p>这里简单介绍其概念。&lt;/p></description></item><item><title>Linux PIPE 相关介绍</title><link>https://gohalo.github.io/cn/blog/linux-pipe-stuff-introduce/</link><pubDate>Fri, 20 Jul 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-pipe-stuff-introduce/</guid><description>&lt;p>在命令行以及代码中经常使用管道，不过其使用是有些限制的，这里简单介绍。&lt;/p></description></item><item><title>Linux Hang Task 简介</title><link>https://gohalo.github.io/cn/blog/linux-kernel-hang-task-panic-introduce/</link><pubDate>Sat, 30 Jun 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-hang-task-panic-introduce/</guid><description>&lt;p>长期以来，处于 D 状态的进程都是让人比较烦恼的问题，此时不能接收信号，不能 &lt;code>kill&lt;/code> 掉，用户对此基本是无能为力，而且也很难知道发生的原因，一般来说只能重启服务器恢复。&lt;/p>
&lt;p>正常来说 D 状态的任务只有在 IO 操作时会有，而且会很快完成，只有在极端的异常场景下才会出现问题，例如磁盘损坏、NFS 的 bug 等等，不过如果驱动写的完善的话，一般会增加超时机制，原则上不会出现永久的 D 状态进程。&lt;/p>
&lt;p>也就是说，只有在内核驱动不合理的时候可能会导致进程长期处于 D 状态，无法唤醒，类似于死锁状态。&lt;/p></description></item><item><title>Socket 关闭方式</title><link>https://gohalo.github.io/cn/blog/language-c-socket-close-method/</link><pubDate>Wed, 20 Jun 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-socket-close-method/</guid><description>&lt;p>在 Linux 中，对于 Socket 来说，可以通过系统调用 &lt;code>close()&lt;/code> 关闭，通过还提供了一个 &lt;code>shutdown()&lt;/code> 接口，可以直接将 socket 关闭。&lt;/p>
&lt;p>那么两种方式有什么区别？&lt;/p></description></item><item><title>C 语言发布流程</title><link>https://gohalo.github.io/cn/blog/program-c-debug-release-etc/</link><pubDate>Sat, 16 Jun 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-debug-release-etc/</guid><description>&lt;p>整理下 C 语言中调试、发布的流程。&lt;/p></description></item><item><title>GCC 常用技巧</title><link>https://gohalo.github.io/cn/blog/program-c-language-gcc-some-stuff/</link><pubDate>Wed, 13 Jun 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-language-gcc-some-stuff/</guid><description>&lt;p>Clang 是一个 C++ 编写，基于 LLVM 的 C/C++、Objective-C 语言的轻量级编译器，在 2013.04 开始，已经全面支持 C++11 标准。&lt;/p></description></item><item><title>Linux GNU 内联汇编</title><link>https://gohalo.github.io/cn/blog/c-gnu-inline-assembly/</link><pubDate>Wed, 30 May 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-gnu-inline-assembly/</guid><description>&lt;p>在通过 C 做上层的开发时，实际上很少会用到汇编语言，不过对于 Linux 内核开发来说，经常会遇到与体系架构相关的功能或优化代码，此时可能需要通过将汇编语言指令插入到 C 语句的中间来执行这些任务。&lt;/p>
&lt;p>这里简单介绍下 GNU 中与 Linux 内联汇编相关的用法。&lt;/p></description></item><item><title>Protobuf 协议简介</title><link>https://gohalo.github.io/cn/blog/protobuf-protocol-introduce/</link><pubDate>Thu, 24 May 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-protocol-introduce/</guid><description>&lt;p>Protobuf (Google Protocol Buffers) 是 google 开发的的一套用于数据存储，网络通信时用于协议编解码的工具库，与 XML 和 JSON 数据格式类似，但采用的是二进制的数据格式，具有更高的传输，打包和解包效率。&lt;/p>
&lt;p>相比 JSON 来说，Protobuf 的效率、编解码速度更快、数据体积更小，带来的问题是数据可读性变差，协议升级比较麻烦。&lt;/p></description></item><item><title>C 语言 Volatile 使用简介</title><link>https://gohalo.github.io/cn/blog/linux-c-volatile-statement-introduce/</link><pubDate>Sun, 20 May 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-volatile-statement-introduce/</guid><description>&lt;p>C 语言中的 volatile 关键字大部分都见过，但是很少有人能明确其具体使用的场景。实际上，上层编程很少会用到，一般只有涉及到 IO、中断等与硬件交互的底层编程才会经常使用。&lt;/p>
&lt;p>这里简单介绍其使用场景，使用方法。&lt;/p></description></item><item><title>Linux Random</title><link>https://gohalo.github.io/cn/blog/linux-random-introduce/</link><pubDate>Sat, 12 May 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-random-introduce/</guid><description>&lt;p>在 Linux 中，有两类用于生成随机数的设备，分别是 &lt;code>/dev/random&lt;/code> 以及 &lt;code>/dev/urandom&lt;/code> ，其中前者可能会导致阻塞，后者的安全性则较低。&lt;/p>
&lt;p>后者是 unblocked random 的简称，会重用内部池中的数据以产生伪随机数据，可用于安全性较低的应用。&lt;/p></description></item><item><title>Linux 进程监控</title><link>https://gohalo.github.io/cn/blog/linux-monitor-process-introduce/</link><pubDate>Wed, 09 May 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-process-introduce/</guid><description/></item><item><title>Linux 网络状态查看</title><link>https://gohalo.github.io/cn/blog/linux-network-status/</link><pubDate>Thu, 26 Apr 2018 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-status/</guid><description>&lt;p>直接通过 &lt;code>man 8 netstat&lt;/code> 查看帮助时就可以发现这样的一句话 &lt;code>This program is obsolete. Replacement for netstat is ss.&lt;/code>，而且后面还有几个相关的等价示例介绍。&lt;/p>
&lt;p>所以这里简单介绍与 ss 相关的指令。&lt;/p></description></item><item><title>NMAP 使用</title><link>https://gohalo.github.io/cn/blog/linux-network-command-nmap/</link><pubDate>Tue, 17 Apr 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-nmap/</guid><description>&lt;p>Nmap 是一款网络扫描和主机检测的非常有用的工具，不仅可以收集信息，同时可用来作为一个漏洞探测器或安全扫描器。&lt;/p></description></item><item><title>C 指针简介</title><link>https://gohalo.github.io/cn/blog/language-c-pointer-basic-usage-introduce/</link><pubDate>Sun, 01 Apr 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-pointer-basic-usage-introduce/</guid><description>&lt;p>在 C 语言中，指针是一个特殊的变量，存储值指向内存中的一个地址，一个指针包含了四方面的内容：指针类型、指向类型，指针所指向的内存区以及指针本身所占据的内存区。&lt;/p>
&lt;p>指针或许是 C 语言中最复杂的东西了。&lt;/p></description></item><item><title>Docker Network 简介</title><link>https://gohalo.github.io/cn/blog/docker-basic-concept-network-introduce/</link><pubDate>Mon, 12 Mar 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-basic-concept-network-introduce/</guid><description/></item><item><title>Beanstalk 使用简介</title><link>https://gohalo.github.io/cn/blog/message-queue-beanstalk-introduce/</link><pubDate>Sun, 21 Jan 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/message-queue-beanstalk-introduce/</guid><description>&lt;p>这是 FaceBook 实现的一个消息队列，其协议是基于 ASCII 的，上报的数据可以通过 binlog 进行持久化，其高可用类似于 Memcached 的方式，也就是各个进程之间不知道相互的存在。&lt;/p>
&lt;p>支持优先级、延时、超时重发、预留等机制，支持分布式的后台任务和定时任务处理。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>ELF 符号表</title><link>https://gohalo.github.io/cn/blog/program-c-elf-symbol-section/</link><pubDate>Sat, 06 Jan 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-elf-symbol-section/</guid><description/></item><item><title>Linux C 动态库加载</title><link>https://gohalo.github.io/cn/blog/c-reload-dynamic-library/</link><pubDate>Wed, 03 Jan 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-reload-dynamic-library/</guid><description>&lt;p>简单来说，对于正在运行的程序，当尝试重新加载动态库时，可能会导致程序 CoreDump 。&lt;/p>
&lt;p>这里简单解释下其原因，以及规避方案。&lt;/p></description></item><item><title>ETCD 源码解析</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-details/</link><pubDate>Fri, 15 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-details/</guid><description>&lt;p>在上篇 &lt;a href="https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/">ETCD 示例源码&lt;/a> 中介绍了 ETCD 代码中 RAFT 相关的示例代码，接着介绍与 ETCD 相关的代码。&lt;/p></description></item><item><title>FastDFS 使用简介</title><link>https://gohalo.github.io/cn/blog/fastdfs-introduce/</link><pubDate>Tue, 12 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/fastdfs-introduce/</guid><description>这是一个开源的轻量级分布式文件系统，主要功能有文件存储、文件同步、文件访问等，解决了大容量存储和负载均衡的问题，适合以文件为载体的在线服务，如相册网站、视频网站等等，一般文件大小为 4KB &amp;lt; file_size &amp;lt; 500MB 。
简介 # 服务端包括了 Tracker Server 和 Storage Server 两个部分，前者用于负载均衡和调度，后者用于文件存储。两种类型服务可以多节点部署，单个节点宕机不会影响整体提供服务。
Tracker Server # 负责管理所有的 Storage Server 和 Group ，每个 Storage Server 启动后会主动连接到 Tracker ，告知自己所属的 Group 同时保持心跳信息，Tracker 会根据上报的元数据在内存中维护映射信息。
Storage Server # 真正存储数据的地方，以分组 Group 为单位，每个分组包含了多个 Storage Server ，数据互为备份，存储空间以最小的为准。
实际上 Group 是一个逻辑概念，主要是为了能够方便的进行应用隔离、负责均衡和副本数定制，如果 Group 内机器出现故障需要该 Group 内的其它机器重新同步数据。
使用简介 # 首先是通过源码编译打包，V5.0 之前的版本依赖 libevent 而 V5.0 以后不再依赖 libevent ，V5.04 开始依赖 libfastcommon 。
----- 安装libfastcommon，这个是提取出来的单独公共代码库 ./make.sh ./make.sh install rpmbuild --bb libfastcommon.spec ----- 编译安装fastdfs .</description></item><item><title>DWARF 格式简介</title><link>https://gohalo.github.io/cn/blog/gdb-dwarf-format-introduce/</link><pubDate>Sun, 10 Dec 2017 23:49:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-dwarf-format-introduce/</guid><description>&lt;p>也就是 Debugging With Attributed RecordFormats, DWARF ，到目前为止，应该包括了 &lt;code>V1~5&lt;/code> 共五个版本，其中 dwarf2 对 dwarf1 的改变很大，而后续的版本基本上是对前者的扩展。&lt;/p>
&lt;p>这一格式独立于语言，不过使用比较多的是 C/C++ ，这里简单介绍在 GDB 中，如何对这些调试信息进行组织、实现，并且如何利用调试信息进行 C 语言级别的调试。&lt;/p></description></item><item><title>TC 使用简介</title><link>https://gohalo.github.io/cn/blog/network-traffic-control-introduce/</link><pubDate>Fri, 01 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-traffic-control-introduce/</guid><description>&lt;p>网络的 IP 服务模型是尽力而为的，这样的模型不能体现某些流量的重要性，所以诞生了 QoS 技术，Linux 很早就提供了流量控制接口，命令行工具是 tc (Traffic Control)。&lt;/p></description></item><item><title>数字挂钟</title><link>https://gohalo.github.io/cn/blog/linux-command-cron-clock/</link><pubDate>Sun, 26 Nov 2017 22:45:35 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-cron-clock/</guid><description>&lt;p>一个很有意思的数学挂钟，这个时钟通过各种符号计算公式表示 1~12 个数字。&lt;/p></description></item><item><title>你所不知道的 Linux 定时任务</title><link>https://gohalo.github.io/cn/blog/linux-command-cron-introduce/</link><pubDate>Sat, 25 Nov 2017 20:45:35 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-cron-introduce/</guid><description>&lt;p>在 Linux 中，我们经常使用 cron 执行一些定时任务，只需要配置一下时间，它就可以周期的执行一些任务。&lt;/p>
&lt;p>不知道你是否清楚它的详细用法？是否发现，脚本单独运行时是好好的，放到 cron 任务里却挂了！！！一个部署了 crond 的服务器，系统资源却被莫名其妙的被占满了，Why？？？&lt;/p></description></item><item><title>Linux 信号机制</title><link>https://gohalo.github.io/cn/blog/kernel-signal-introduce/</link><pubDate>Sat, 25 Nov 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-signal-introduce/</guid><description>&lt;p>软中断信号 (简称为信号) 是用来通知进程发生了异步事件，是在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。&lt;/p>
&lt;p>信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。&lt;/p>
&lt;p>进程之间可以互相通过系统调用 kill 发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。&lt;/p>
&lt;p>信号机制除了基本通知功能外，还可以传递附加信息。&lt;/p></description></item><item><title>GDB 死锁分析</title><link>https://gohalo.github.io/cn/blog/gdb-deadlock-analyze-introduce/</link><pubDate>Mon, 20 Nov 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-deadlock-analyze-introduce/</guid><description>&lt;p>pthread 是 POSIX 标准的多线程库，其源码位于 glibc 中的 Native POSIX Thread Library, NPTL 目录下，大部分的应用都是基于 pthread 来实现多线程的并行与同步管理。&lt;/p></description></item><item><title>ETCD 示例源码</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/</link><pubDate>Wed, 15 Nov 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/</guid><description>&lt;p>现在已知的 Golang 版本的 RAFT 的开源实现主要有两个：一个是 CoreOS 的 etcd 中的实现，使用的项目有比如 tidb、cockroachdb 等；另外一个是 hashcorp 的 RAFT 实现，使用的项目有比如 consul、InfluxDB 等。&lt;/p>
&lt;p>相比而言，前者只实现了一个整体框架，很多的功能需要用户实现，难度增加但是更加灵活；而后者则是完整的实现，WAL、SnapShot、存储、序列化等。&lt;/p></description></item><item><title>Linux umask 使用</title><link>https://gohalo.github.io/cn/blog/linux-umask-and-open-introduce/</link><pubDate>Sun, 12 Nov 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-umask-and-open-introduce/</guid><description>&lt;p>在使用 umask 设置问价的掩码时遇到了一个坑，本来以为设置会很简单，但是开始设置时一直不是预期的结果。&lt;/p>
&lt;p>简单整理下踩坑的过程。&lt;/p></description></item><item><title>Fuzzing 测试</title><link>https://gohalo.github.io/cn/blog/program-c-fuzzing-test-introduce/</link><pubDate>Tue, 31 Oct 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-fuzzing-test-introduce/</guid><description>Fuzzing 一般指模糊测试，是一种基于黑盒的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。
同时，也作为了当前最为强大而有效的漏洞挖掘技术。
AFL # American Fuzzy Lop, AFL 是一种开源的模糊测试器，由谷歌的 Michal Zalewski 开发。
可以在源码编译时添加，或者使用 QEMU 模式，也就是 QEMU-(User Mode) ，在执行时注入部分代码进行测试。
目前使用 AFL 有两种方式：
开源软件，在编译的时候同时进行插桩； 闭源软件，配合QEMU直接对闭源的二进制代码进行fuzz测试。 安装 # 直接从 ALF Release 下载相关的版本，然后执行 make 即可。
默认安装在 /usr/local 相对目录下，可以通过 PREFIX=/usr &amp;amp;&amp;amp; make 修改。
使用 # 如果程序使用 autoconf 工具链构建，在执行 configure 脚本时，添加如下参数即可。
$ ./configure --disable-shared CC=&amp;#34;afl-gcc&amp;#34; CXX=&amp;#34;afl-g++&amp;#34; 其中 --disable-shared 选项可以允许通过 LD_LIBRARY_PATH 变量，让程序加载经过 AFL 插桩的 .so 文件，进行静态构建而不是动态链接。
如果是其它的 Makefile 文件，可以直接修改引用的编译器。
另外，为了后期更好的分析 crash 可以开启 Address Sanitizer, ASAN 检测工具，此工具可以更好的检测出缓存区溢出、UAF 等内存漏洞。</description></item><item><title>Linux Direct IO</title><link>https://gohalo.github.io/cn/blog/linux-direct-io-introduce/</link><pubDate>Fri, 27 Oct 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-direct-io-introduce/</guid><description>&lt;p>可以直接在应用层和磁盘之间建立通道，减少上下文切换次数。&lt;/p></description></item><item><title>Linux C 错误信息</title><link>https://gohalo.github.io/cn/blog/language-c-error-message-usage-introduce/</link><pubDate>Fri, 20 Oct 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-error-message-usage-introduce/</guid><description>&lt;p>在 C 代码中，当发生错误时，一般会在库函数中设置 errno ，然后应用可以通过 strerror 打印详细的错误信息，以方便定位问题。&lt;/p>
&lt;p>但是有些错误打印函数标示为安全的？这是什么意思？使用时应该注意什么？&lt;/p></description></item><item><title>Inotify 机制详解</title><link>https://gohalo.github.io/cn/blog/kernel-inotify-introduce/</link><pubDate>Wed, 11 Oct 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-inotify-introduce/</guid><description>日常工作中，经常会需要知道某些文件上的变化，一般是通过轮询机制检查文件的变化，不过这样非常低效。
Inotify 是一种文件变化通知机制，Linux 内核从 2.6.13 开始引入，而 BSD 和 Mac OS 系统中比较有名的是 kqueue，可以高效地实时跟踪文件系统的变化。
这里简单介绍其使用方法。
简介 # 可以通过如下方式查看是否支持 Inotify 机制。
$ grep INOTIFY_USER /boot/config-$(uname -r) CONFIG_INOTIFY_USER=y 如果输出 CONFIG_INOTIFY_USER=y 那么就表示系统支持 inotify 机制。
源码实现 # 在用户态主要通过三个系统调用，首先是要创建 inotify 实例。
#include &amp;lt;sys/inotify.h&amp;gt; int inotify_init(void); int inotify_init1(int flags); 每个 inotify 实例对应一个独立的排序的队列，文件系统的变化事件被称做 watches 的一个对象管理，每一个 watch 是一个二元组：
目标，可以是文件或目录； 事件掩码，应用希望关注的 inotify 事件，每位对应一个 inotify 事件。 Watch 对象通过 watch 描述符引用，其中，目录 watches 将返回在该目录下的所有文件上面发生的事件。
下面函数用于添加一个 watch 。
#include &amp;lt;sys/inotify.h&amp;gt; int inotify_add_watch(int fd, const char *pathname, uint32_t mask); 参数： fd 如上的 inotify_init() 返回的文件描述符； path 被监视的目标的路径名，可以是文件名或目录名； mask 事件掩码，在头文件 `linux/inotify.</description></item><item><title>Flex 简介</title><link>https://gohalo.github.io/cn/blog/program-concept-lexical-flex-introduce/</link><pubDate>Fri, 29 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-concept-lexical-flex-introduce/</guid><description>一种词法分析器，可以通过正则表达式识别文本中的词汇，然后自动生成对应的 C 代码，最后编译链接 C 代码就可以了。
Flex 采用的是状态机，通过分析输入流 (字符流)，只要发现一段字符能够匹配一个关键字 (正则表达式)，就会采取对应的动作。
简介 # Flex 文件被 %% 分成了上中下三个部分：
第一部分中要写入 C/C++ 代码必须用 %{ 和 %} 括起来，将原封不动放到生成源码中。 第二部分是规则段，包括了模式 (正则表达式) 和动作，由空白分开，当匹配到模式时，就会执行后面的动作。 第三部分可以直接写入 C/C++ 代码。 yylex() 是扫描程序的入口，调用该函数启动或重新开始，该函数会初始化一些全局变量，然后开始扫描。如果定义的 flex 动作是将数值传递给调用程序，那么对 yylex() 的下次调用就从它停止的地方继续扫描。
%{ #include &amp;lt;stdio.h&amp;gt; %} %% is | are { printf(&amp;#34;%s: VERB &amp;#34;, yytext); } island printf(&amp;#34;LAND &amp;#34;); [0-9]+ printf(&amp;#34;NUMBER &amp;#34;); [ \t]+ /* ignore whitespace */; [a-zA-Z][a-zA-Z0-9]* printf(&amp;#34;COMMON WORD &amp;#34;); .|\n { ECHO; } %% int main(void) { yylex(); } 特殊字符 '.</description></item><item><title>词法语法解析</title><link>https://gohalo.github.io/cn/blog/program-lexical-basic-introduce/</link><pubDate>Fri, 29 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-lexical-basic-introduce/</guid><description>&lt;p>介绍与词法语法分析相关的概念。&lt;/p></description></item><item><title>Bison 简介</title><link>https://gohalo.github.io/cn/blog/program-concept-syntax-bison-introduce/</link><pubDate>Wed, 20 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-concept-syntax-bison-introduce/</guid><description>&lt;p>bison 读入一个 CFG 文法的文件，在程序内经过计算，输出一个 parser generator 的 c 文件；也就是说 Bison 适合上下文无关文法，采用 LALR Parser (LALR语法分析器)。&lt;/p></description></item><item><title>UUID 详细介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-uuid-introduce/</link><pubDate>Fri, 15 Sep 2017 21:18:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-uuid-introduce/</guid><description>&lt;p>UUID 的目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中心节点指定，无需考虑数据库创建时的名称重复问题，目前最广泛应用的 UUID 是 RFC4122 协议规范的。&lt;/p>
&lt;p>有时 GUID 也特指是微软对标准 UUID 的实现，其实 RFC4122 的作者之一也是微软员工，这里介绍其使用方法。&lt;/p></description></item><item><title>Zabbix 监控系统</title><link>https://gohalo.github.io/cn/blog/zabbix-monitor-introduce/</link><pubDate>Sun, 10 Sep 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zabbix-monitor-introduce/</guid><description>&lt;p>Zabbix 能监视各种网络、系统参数，保证服务器系统的安全运行，同时提供了灵活的 API 接口，例如通知机制，可以让系统管理员及时通过或者当前的异常状态，支持 Agentd、SNMP、JMX 等多种监控方式。&lt;/p>
&lt;p>同时，提供了一个 WEB 界面，可以作为分布式系统监控以及网络监控的企业级开源解决方案。&lt;/p></description></item><item><title>正则表达式</title><link>https://gohalo.github.io/cn/blog/program-c-string-regular-expression/</link><pubDate>Tue, 05 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-regular-expression/</guid><description/></item><item><title>CentOS 内核、软件升级</title><link>https://gohalo.github.io/cn/blog/centos-update-version/</link><pubDate>Fri, 01 Sep 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/centos-update-version/</guid><description>&lt;p>CentOS 使用 yum 管理包以及升级内核，不过为了保持稳定，一般官方仓库提供的内核版本往往小于 Linux 的正式版本。&lt;/p>
&lt;p>这里简单介绍如何使用三方仓库进行升级。&lt;/p></description></item><item><title>P2P 协议简介</title><link>https://gohalo.github.io/cn/blog/network-p2p-introduce/</link><pubDate>Mon, 28 Aug 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-p2p-introduce/</guid><description>不同于传统的 C/S 服务模型，取消了中心服务器，每个节点都可以作为客户端和服务端。
简介 # BitTorrent 实际上是一个协议族，其基本协议是 BEP-3 ，其它的大部分协议都是围绕这个来进行扩展或补充。
如果要通过 P2P 协议进行下载，必须要包含如下的几个文件：
种子文件，一般后缀为 .torrent ，本质上是一个由 bencode 编码的文本文件，把资源分成很多虚拟块，并记录每个块的 hash 值，还包括了文件大小、名字、Tracker服务器等信息。 BT 客户端，也就是专门解析 BT 协议的程序，例如迅雷、电驴等。 Tracker 服务器，记录着 Peer 和种子相关信息，起着中心调控的作用。 在下载资源的时候，大致的流程如下：
客户端解码种子文件，得到 Tracker 服务器的地址和资源信息； 通过和 Tracker 服务器沟通得到其它已经下载该资源的 Peers 信息； 再和这些 Peers 沟通得到自己想要的部分。 可以看到，在上述的流程中，Tracker 是整个流程的关键部分，如果不能通过 Tracker 读取到 Peers 的相关信息，那么也就无法下载资源。
DHT 协议 # 为了弥补 Tracker 的单点问题，于是出现了 Distributed Hash Table, DHT 协议，该协议基于 Kademlia 建立。
参考 # 一个资源嗅探器的网站 bthub.io 。 官方网站 bittorrent.org 包括了很多相关协议的开发文档。 一个传输可视化的示例网站 mq8.org 。</description></item><item><title>Linux C 网络编程</title><link>https://gohalo.github.io/cn/blog/program-c-network/</link><pubDate>Mon, 21 Aug 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-network/</guid><description/></item><item><title>MySQL 线上部署</title><link>https://gohalo.github.io/cn/blog/mysql-deploy-online/</link><pubDate>Mon, 21 Aug 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-deploy-online/</guid><description>&lt;p>主要介绍下 MySQL 如何在线上进行部署。&lt;/p></description></item><item><title>C/C++ Sanitizer 简介</title><link>https://gohalo.github.io/cn/blog/language-c-some-sanitizers-introduce/</link><pubDate>Tue, 25 Jul 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-some-sanitizers-introduce/</guid><description>&lt;p>Sanitizer 英文翻译过来是杀菌剂的意思，Google 提供了很多相关的一些 Sanitizers ，用来检测程序的异常。&lt;/p>
&lt;p>可以做内存、地址访问、竞态条件的检测，这里简单介绍。&lt;/p></description></item><item><title>Linux CGroup 监控</title><link>https://gohalo.github.io/cn/blog/linux-monitor-cgroup-introduce/</link><pubDate>Sun, 23 Jul 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-cgroup-introduce/</guid><description/></item><item><title>tcpdump 常用网络命令</title><link>https://gohalo.github.io/cn/blog/linux-network-command-tcpdump/</link><pubDate>Sun, 16 Jul 2017 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-tcpdump/</guid><description>&lt;p>tcpdump 会根据表达式 (expression) 来决定是否过滤报文，如果满足条件则会捕获报文，如果没有给出任何条件则会将所有的报文捕获。&lt;/p></description></item><item><title>Linux ptrace 简介</title><link>https://gohalo.github.io/cn/blog/linux-ptrace-api-introduce/</link><pubDate>Thu, 15 Jun 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ptrace-api-introduce/</guid><description>&lt;p>&lt;code>ptrace()&lt;/code> 是一个由 Linux 内核提供的系统调用，允许一个用户态进程检查、修改另一个进程的内存和寄存器，通常用在类似 gdb、strace 的调试器中，用来实现断点调试、系统调用的跟踪。&lt;/p>
&lt;p>你想过怎么实现对系统调用的拦截吗？你尝试过通过改变系统调用的参数来愚弄你的系统 kernel 吗？你想过调试器是如何使运行中的进程暂停并且控制它吗？&lt;/p>
&lt;p>这里简单介绍如何使用该接口。&lt;/p></description></item><item><title>Linux 资源限制</title><link>https://gohalo.github.io/cn/blog/linux-resource-limit-introduce/</link><pubDate>Tue, 09 May 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-resource-limit-introduce/</guid><description>&lt;p>如何通过最简单的设置来实现最有效的性能调优，在有限资源的条件下保证程序的运作，ulimit 是在处理这些问题时，经常使用的一种简单手段。&lt;/p>
&lt;p>ulimit 是一种 Linux 系统的内键功能，它具有一套参数集，用于为由它生成的 shell 进程及其子进程的资源使用设置限制。&lt;/p></description></item><item><title>压缩库使用</title><link>https://gohalo.github.io/cn/blog/program-c-compress-library-introduce/</link><pubDate>Mon, 01 May 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-compress-library-introduce/</guid><description/></item><item><title>GDB Python 脚本</title><link>https://gohalo.github.io/cn/blog/gdb-python-script/</link><pubDate>Sat, 15 Apr 2017 20:39:11 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-python-script/</guid><description>&lt;p>GDB 很早就支持自定义脚本辅助调试，不过语法比较老，不如 Python 使用方便广泛，从 GDB 7.X(2009) 版本开始支持 Python Scripting ，不过建议使用 9.X 以上的版本，关于 Python 的详细特性可以参考 &lt;a href="https://www.sourceware.org/gdb/news/">GDB News&lt;/a> 的内容。&lt;/p></description></item><item><title>libev 信号处理</title><link>https://gohalo.github.io/cn/blog/libev-source-code-signal-process-details/</link><pubDate>Sat, 15 Apr 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-source-code-signal-process-details/</guid><description>&lt;p>信号的处理非常敏感，如果处理不当很容易出现问题，如果在信号处理函数中使用了非信号安全函数，那么很容易发生死锁。&lt;/p>
&lt;p>这里简单介绍 libev 中是如何处理信号的。&lt;/p></description></item><item><title>Linux Fail Points</title><link>https://gohalo.github.io/cn/blog/linux-c-fail-point-introduce/</link><pubDate>Mon, 10 Apr 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-fail-point-introduce/</guid><description>&lt;p>对于一些异常一般很难构建，尤其是像系统 API 调用、硬件故障等等，通过 FailPoints 可以在指定的代码段注入一些异常处理。&lt;/p>
&lt;p>实际上，BSD 已经提供了一套相关的 FailPoints 机制。&lt;/p></description></item><item><title>Linux 信号安全</title><link>https://gohalo.github.io/cn/blog/linux-signal-safe-introduce/</link><pubDate>Wed, 05 Apr 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-signal-safe-introduce/</guid><description>&lt;p>最近遇到比较奇葩的问题，在信号处理函数中，为了方便查看收到的是何信号，会打印相关的日志，不过也因此在连续收到信号时导致死锁。&lt;/p>
&lt;p>这里简单排查下原因，以及如何进行规避。&lt;/p></description></item><item><title>SSH 常用技巧</title><link>https://gohalo.github.io/cn/blog/ssh-some-tips/</link><pubDate>Mon, 27 Mar 2017 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-some-tips/</guid><description>&lt;p>简单记录一些常见的 SSH 使用技巧。&lt;/p></description></item><item><title>libev 时间处理</title><link>https://gohalo.github.io/cn/blog/libev-timers/</link><pubDate>Mon, 20 Mar 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-timers/</guid><description>&lt;p>在之前的文章中介绍了 libev 库的基本概念以及常见的使用方法，其中与时间相关的内容只是简单介绍，不过这一部分涉及到的内容会比较多，而且杂，所以单独摘出来介绍下。&lt;/p></description></item><item><title>GDB 基本功能介绍</title><link>https://gohalo.github.io/cn/blog/gdb-basic-usage-introduce/</link><pubDate>Fri, 10 Mar 2017 22:30:31 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-basic-usage-introduce/</guid><description>&lt;p>GNU Project Debugger, GDB 一个代码调试工具，通过系统提供的 ptrace 接口实现的控制进程，然后可以在进程内部查看信息，甚至调用函数。&lt;/p></description></item><item><title>CPU 物理架构</title><link>https://gohalo.github.io/cn/blog/linux-cpu-physical-arch-introduce/</link><pubDate>Wed, 01 Mar 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-cpu-physical-arch-introduce/</guid><description/></item><item><title>Linux NTP 介绍</title><link>https://gohalo.github.io/cn/blog/linux-ntp-related-stuff-introduce/</link><pubDate>Tue, 28 Feb 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ntp-related-stuff-introduce/</guid><description>&lt;p>网络时间协议 (Network Time Protocol, NTP) 是通过 &lt;a href="https://tools.ietf.org/html/rfc1305">RFC-1305&lt;/a> 定义的时间同步协议，该协议基于 UDP 协议，使用端口号为 123；该协议用于在时间服务器和客户端之间同步时间，从而使网络内所有设备的时钟保持一致。&lt;/p>
&lt;p>这里简单介绍 NTP 的使用方法。&lt;/p></description></item><item><title>报文超过 MTU</title><link>https://gohalo.github.io/cn/blog/linux-network-mtu-oversize/</link><pubDate>Mon, 20 Feb 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-mtu-oversize/</guid><description>&lt;p>正常来说，通过 TCP 传输的报文应该不会超过 MTU 大小，一般是 1500 大小。&lt;/p>
&lt;p>但是，如果通过 tcpdump 获取报文，那么可能会出现报文大小超过 MTU 的报文，甚至超过 20K 。&lt;/p></description></item><item><title>Linux 进程状态</title><link>https://gohalo.github.io/cn/blog/linux-process-state-introduce/</link><pubDate>Thu, 16 Feb 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-state-introduce/</guid><description>&lt;p>Linux 中的进程在不同的阶段会通过其状态显示，一般来说会有 7 种，相当于一个状态机运行。&lt;/p>
&lt;p>这里简单介绍，以及一些常见的特殊状态。&lt;/p></description></item><item><title>Linux 惊群详解</title><link>https://gohalo.github.io/cn/blog/linux-details-of-thundering-herd/</link><pubDate>Mon, 06 Feb 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-details-of-thundering-herd/</guid><description>简言之，惊群现象就是当多个进程或线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。
这里对 Linux 中的惊群现象进行简单介绍。
惊群 # 关于惊群的解释可以查看 Wiki 的解释 Thundering herd problem 。
accept() # 常见的场景如下。
主进程执行 socket()+bind()+listen() 后，fork() 多个子进程，每个子进程都通过 accept() 循环处理这个 socket；此时，每个进程都阻塞在 accpet() 调用上，当一个新连接到来时，所有的进程都会被唤醒，但其中只有一个进程会 accept() 成功，其余皆失败，重新休眠。这就是 accept 惊群。
如果只用一个进程去 accept 新连接，并通过消息队列等同步方式使其他子进程处理这些新建的连接，那么将会造成效率低下；因为这个进程只能用来 accept 连接，该进程可能会造成瓶颈。
而实际上，对于 Linux 来说，这只是历史上的问题，现在的内核都解决该问题，也即只会唤醒一个进程。可以通过如下程序进行测试，只会激活一个进程。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/wait.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #define PROCESS_NUM 10 int main() { int fd = socket(PF_INET, SOCK_STREAM, 0); int connfd; int pid, i, status; char sendbuff[1024]; struct sockaddr_in serveraddr; printf(&amp;#34;Listening 0.</description></item><item><title>StatsD 监控简介</title><link>https://gohalo.github.io/cn/blog/statsd-monitor-introduce/</link><pubDate>Fri, 03 Feb 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/statsd-monitor-introduce/</guid><description>&lt;p>StatsD 的使用非常简单，其中 Etsy 改写后使用的是 Node.js 编写的，所以需要先安装好 node 环境，然后修改配置文件，直接启动即可。&lt;/p>
&lt;p>当然，也可以将其理解为一个协议，也就对应了多种语言的实现。&lt;/p>
&lt;p>这里简单介绍与之相关的概念。&lt;/p></description></item><item><title>Sysbench 压测工具</title><link>https://gohalo.github.io/cn/blog/linux-benchmark-tools-sysbench/</link><pubDate>Fri, 20 Jan 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-benchmark-tools-sysbench/</guid><description>&lt;p>Linux 中有很多压测工具，不同的场景会各有优劣，例如磁盘压测工具 fio 。&lt;/p>
&lt;p>Sysbench 算是一个比较通用的压测或者基准测试工具，这是一个开源、模块化、跨平台的多线程性能测试工具，可以用来进行 CPU、内存、IO、线程、数据库的性能测试，其中数据库支持 MySQL、Oracle 和 PostgreSQL 。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Linux 时间相关概念介绍</title><link>https://gohalo.github.io/cn/blog/linux-time-basic/</link><pubDate>Sun, 15 Jan 2017 21:16:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-time-basic/</guid><description>&lt;p>简单介绍在 Linux 中部分与时间相关的概念，例如时区、闰秒、夏令时、ntp 等。&lt;/p>
&lt;p>&amp;ldquo;现在几点了？&amp;rdquo; 或者 &amp;ldquo;离过年还有多久？&amp;rdquo; 这恐怕连小学生也觉得是再简单不过的问题了；但是如果问及 &amp;ldquo;时间是什么？&amp;rdquo; 恐怕绝大多数人都会顿觉茫然。&lt;/p></description></item><item><title>Linux 进程优先级</title><link>https://gohalo.github.io/cn/blog/linux-process-exec-priority-nice-introduce/</link><pubDate>Thu, 12 Jan 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-exec-priority-nice-introduce/</guid><description/></item><item><title>事件驱动库 libev 使用详解</title><link>https://gohalo.github.io/cn/blog/libev-basic-introduce/</link><pubDate>Fri, 30 Dec 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-basic-introduce/</guid><description>&lt;p>libev 是一个通过 C 语言编写的，高性能的事件循环库，支持多种事件类型，与此类似的事件循环库还有 libevent、libubox 等，相比来说这个库要简单很多，在此详细介绍下 libev 相关的内容。&lt;/p></description></item><item><title>Linux 后台服务管理</title><link>https://gohalo.github.io/cn/blog/linux-daemon-tools/</link><pubDate>Fri, 23 Dec 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-daemon-tools/</guid><description>&lt;p>在 Linux 中，对于一个后台服务，如果要可靠地在后台运行，最好能监控进程状态，在意外结束时能自动重启。&lt;/p>
&lt;p>常见的功能全面的主流工具主要有 monit(C)、supervisor(Python)、goreman(Go)，其中 goreman 是对 Ruby 下广泛使用的 foreman 工具，使用 golang 的重写。&lt;/p>
&lt;p>在此，仅介绍下在 Linux 中如何使用。&lt;/p></description></item><item><title>libev 源码详解</title><link>https://gohalo.github.io/cn/blog/libev-source-code-introduce/</link><pubDate>Thu, 15 Dec 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-source-code-introduce/</guid><description>&lt;p>libev 内部结构比较简单，只提供了基本的处理逻辑，其中核心主要分成了几部分：文件描述符处理。&lt;/p></description></item><item><title>RPM DB 修复</title><link>https://gohalo.github.io/cn/blog/linux-rpm-fixdb-introduce/</link><pubDate>Thu, 01 Dec 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-rpm-fixdb-introduce/</guid><description>&lt;p>在一些 Linux 的发行版本中，例如 CentOS、SUSE 中，会采用 RPM 来管理软件包，不过在使用过程中，经常会出现由于各种各样的原因导致 RPM DB 被损坏。&lt;/p>
&lt;p>这里简单介绍一下其修复方法。&lt;/p></description></item><item><title>Conky 配置简介</title><link>https://gohalo.github.io/cn/blog/linux-conky-introduce/</link><pubDate>Thu, 17 Nov 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-conky-introduce/</guid><description>&lt;p>Conky 是一个轻量级的桌面系统监控工具，支持多种监控项，而且支持 Python、Lua 脚本。&lt;/p></description></item><item><title>Linux Gunplot 使用简介</title><link>https://gohalo.github.io/cn/blog/linux-gnuplot/</link><pubDate>Thu, 03 Nov 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-gnuplot/</guid><description>&lt;p>主要介绍一下 Linux 中的 Gnuplot Graphviz 套件，主要用于画图。&lt;/p>
&lt;p>Ggnuplot 是一个命令行驱动的绘图工具，可将数学函数或数值资料以平面图或立体图的形式画在不同种类终端机或绘图输出装置上，是由 Colin Kelley 和 Thomas Williams 于 1986 年开发的绘图程序发展而来的，可以在多个平台下使用。&lt;/p>
&lt;p>graphviz 是贝尔实验室开发的一个开源的工具包，它使用一个特定的 DSL(领域特定语言) dot 作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。该软件包提供丰富的导出格式，如常用的图片格式，SVG、PDF 格式等。&lt;/p>
&lt;p>在此介绍一下常见的使用方法。&lt;/p></description></item><item><title>PGP 简介</title><link>https://gohalo.github.io/cn/blog/security-pgp-introduce/</link><pubDate>Fri, 21 Oct 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-pgp-introduce/</guid><description>&lt;p>GnuPGP 是一个基于公钥加密体系的加密软件，功能强大，有很快的速度，而且源码是免费的。&lt;/p>
&lt;p>这里简单介绍下 PGP 相关内容。&lt;/p></description></item><item><title>InfluxDB</title><link>https://gohalo.github.io/cn/blog/influxdata-influxdb-introduce/</link><pubDate>Sun, 25 Sep 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/influxdata-influxdb-introduce/</guid><description>&lt;p>InfluxDB 是一个开源分布式时序、事件和指标数据库，使用 Go 语言编写，无需外部依赖，其设计目标是实现分布式和水平伸缩扩展。&lt;/p>
&lt;p>InfluxData 提供了 TICK 一套解决方案，不过使用比较多的是 InfluxDB，在此就介绍下 InfluxDB 以及 Telegraf 。&lt;/p></description></item><item><title>Systemtap</title><link>https://gohalo.github.io/cn/blog/linux-systemtap/</link><pubDate>Thu, 15 Sep 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-systemtap/</guid><description>&lt;p>Systemtap 几乎是目前所知的最强大的内核调试工具，甚至有人说它无所不能，接下来，我们就看看 SystemTAP 。&lt;/p></description></item><item><title>HTTP 协议简介</title><link>https://gohalo.github.io/cn/blog/network-http-introduce/</link><pubDate>Fri, 09 Sep 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http-introduce/</guid><description>&lt;p>HTTP 协议在 TCP/IP 协议之上，目前已经成为了互联网的基础协议，也是网页开发的必备知识，这里简单介绍下 HTTP 协议的历史演变、设计思路，以及相关的解析实现。&lt;/p></description></item><item><title>Collectd 源码解析</title><link>https://gohalo.github.io/cn/blog/collectd-sourcecode/</link><pubDate>Fri, 26 Aug 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/collectd-sourcecode/</guid><description>&lt;p>接下来介绍下 Collectd 中源码的实现。&lt;/p></description></item><item><title>Collectd 简介</title><link>https://gohalo.github.io/cn/blog/collectd-introduce/</link><pubDate>Tue, 16 Aug 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/collectd-introduce/</guid><description>&lt;p>collectd 是一个后台监控程序，用来采集其所运行系统上的系统信息，并提供各种存储方式来存储为不同值的格式，例如 RRD 文件形式、文本格式、MongoDB 等等。&lt;/p>
&lt;p>在此，简单介绍下 collectd 。&lt;/p></description></item><item><title>cgroup 之 cpuset 简介</title><link>https://gohalo.github.io/cn/blog/linux-cgroup-cpuset-subsys-introduce/</link><pubDate>Fri, 05 Aug 2016 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-cgroup-cpuset-subsys-introduce/</guid><description>&lt;p>在内核中可以通过 CPUSET 限制进程只使用某几个 CPU，更准确的说是某个几个逻辑核。&lt;/p></description></item><item><title>SSH 代理设置</title><link>https://gohalo.github.io/cn/blog/ssh-port-forwarding/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-port-forwarding/</guid><description>&lt;p>通过 ssh 的端口转发或者隧道 (tunneling) 功能，可以实现: A) 加密 SSH Client 端至 SSH Server 端之间的通讯数据；B) 突破防火墙的限制完成一些之前无法建立的 TCP 连接。&lt;/p></description></item><item><title>SSH 基本介绍</title><link>https://gohalo.github.io/cn/blog/ssh-basic-introduce/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-basic-introduce/</guid><description>&lt;p>传统的 telnet、rcp ftp、rlogin、rsh 都是极不安全的，并且会使用明文传送密码，OpenSSH 提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。&lt;/p>
&lt;p>OpenSSH 是 SSH (Secure SHell) 协议的免费开源实现，SSH 协议族可以用来进行远程控制，或在计算机之间传送文件。这里简单介绍下 SSH 和 OpenSSH 的使用。&lt;/p></description></item><item><title>SSH 密钥管理</title><link>https://gohalo.github.io/cn/blog/ssh-keys-manage/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-keys-manage/</guid><description>&lt;p>服务端会保存自己的公私钥，客户端每次链接时会确认是否为上次记录主机。&lt;/p></description></item><item><title>SSH 证书登录介绍</title><link>https://gohalo.github.io/cn/blog/ssh-cert-manage/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-cert-manage/</guid><description>&lt;p>从 OpenSSH 5.4 版本 (2010年) 开始支持 SSH 证书，相比 SSL 中使用的证书来说，SSH 的更为简单，没有证书链只有一个 CA 证书，这样就免去了商业签名授权。&lt;/p></description></item><item><title>通过 tcprstat 工具统计应答时间</title><link>https://gohalo.github.io/cn/blog/linux-tcprstat/</link><pubDate>Wed, 20 Jul 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-tcprstat/</guid><description>&lt;p>一个不错的工具，可以用来统计服务端的数据处理时间，包括了最大最小值等统计信息。&lt;/p>
&lt;p>本文简单介绍该工具的使用方法及其实现原理。&lt;/p></description></item><item><title>Redis 简介</title><link>https://gohalo.github.io/cn/blog/redis-introduce/</link><pubDate>Mon, 18 Jul 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/redis-introduce/</guid><description>&lt;p>REmote DIctionary Server (Redis) 是一个由 Salvatore Sanfilippo 写的 KV 存储系统，采用 C 语言实现，同时提供了多种语言的 API 。&lt;/p>
&lt;p>Redis 是完全开源免费的高性能 KV 数据库，相比其它的 KV 数据库来说，Redis 还支持持久化，可以将内存中的数据保存到磁盘中，重启时再次加载；除了 KV 接口，还支持 list、set、hash 等多种数据库结构；同时支持备份以及集群模式。&lt;/p></description></item><item><title>Nginx 源码解析</title><link>https://gohalo.github.io/cn/blog/nginx-sourcecode-analyze/</link><pubDate>Tue, 28 Jun 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-sourcecode-analyze/</guid><description>&lt;p>Nginx 是业界之名的高性能服务器，采用模块化实现，这里简单看下其实现方式。&lt;/p></description></item><item><title>uWSGI 简介</title><link>https://gohalo.github.io/cn/blog/uwsgi-introduce/</link><pubDate>Thu, 23 Jun 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/uwsgi-introduce/</guid><description>&lt;p>这是一个 C 语言编写的 web 容器，实现了 wsgi 和 uwsig 协议，速度很快。&lt;/p></description></item><item><title>ELF 详解</title><link>https://gohalo.github.io/cn/blog/program-elf-details/</link><pubDate>Tue, 21 Jun 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-elf-details/</guid><description>&lt;p>ELF 的全称为 Executable and Linkable Format 用于存储 Linux 程序，可以从运行以及链接的两个视角查看，分别通过 Program Header Table 以及 Section Header Table 查看。&lt;/p></description></item><item><title>ZeroMQ 架构</title><link>https://gohalo.github.io/cn/blog/zeromq-architecture/</link><pubDate>Mon, 20 Jun 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zeromq-architecture/</guid><description>&lt;p>之前介绍了 ZeroMQ 的基本使用方法，接下来介绍一下其架构。&lt;/p></description></item><item><title>ZeroMQ 简介</title><link>https://gohalo.github.io/cn/blog/zeromq-introduce/</link><pubDate>Fri, 10 Jun 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zeromq-introduce/</guid><description>&lt;p>ZMQ (Zero Message Queue) 是一个 C++ 编写的高性能分布式消息队列，是一个非常简单好用的传输层，使得 Socket 编程更加简单、简洁和性能更高效。&lt;/p>
&lt;p>目前比较常用的消息中间件产品包括了 RabbitMQ、ZeroMQ、ActiveMQ，三者分别通过　Erlang、C++、Java 实现，相比而言，ZMQ 是一个简单的库，而非单独的中间件产品。&lt;/p>
&lt;p>接下来简单介绍一下 ZMQ 的相关内容。&lt;/p></description></item><item><title>Linux IO 调度器</title><link>https://gohalo.github.io/cn/blog/linux-kernel-io-scheduler/</link><pubDate>Sun, 05 Jun 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-io-scheduler/</guid><description>&lt;p>用来决定块设备上 IO 操作提交顺序的方法，主要是用于提高吞吐量、降低响应时间。然而两者是相互矛盾的，为了尽量平衡这两者，Linux 内核提供了多种调度算法来适应不同的 IO 请求场景。&lt;/p>
&lt;p>这里简单介绍下 Linux 中的 IO 调度器。&lt;/p></description></item><item><title>Nginx + uWSGI + Flask</title><link>https://gohalo.github.io/cn/blog/nginx-uwsgi-flask/</link><pubDate>Mon, 23 May 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-uwsgi-flask/</guid><description>&lt;p>如前所述，Flask 是一个轻量级的 Web 应用框架，这里简单介绍如何通过 nginx、uwsgi 搭建 flask 环境。&lt;/p></description></item><item><title>Nginx 监控</title><link>https://gohalo.github.io/cn/blog/nginx-monitor/</link><pubDate>Sat, 30 Apr 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-monitor/</guid><description>&lt;p>Nginx 服务器在生产环境中运行时，可以通过类似 Nagios、Zabbix、Munin 之类的网络监控软件。然而，很多时候处理问题时，只需要快速简单的查看当前 Nginx 服务器的状态请求。&lt;/p>
&lt;p>可以使用一个 Python 编写的工具 ngxtop，可以直接从 &lt;a href="https://github.com/lebinh/ngxtop">www.github.com&lt;/a> 上下载相应的源码。&lt;/p>
&lt;p>接下来介绍一下该工具的使用方法。&lt;/p></description></item><item><title>Nginx 日志解析</title><link>https://gohalo.github.io/cn/blog/nginx-logs/</link><pubDate>Wed, 27 Apr 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-logs/</guid><description>&lt;p>在 Nginx 的统计排错过程中，通常要依赖日志，Nginx 有非常灵活的日志记录模式，每个级别的配置可以有各自独立的访问日志。&lt;/p></description></item><item><title>Nginx 通用网关</title><link>https://gohalo.github.io/cn/blog/nginx-cgi-introduce/</link><pubDate>Mon, 18 Apr 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-cgi-introduce/</guid><description>&lt;p>CGI (Common Gateway Interface，通用网关接口) 描述了客户端和服务器程序之间传输数据的一种标准，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。&lt;/p>
&lt;p>在此我们看下具体的实现以及应用。&lt;/p></description></item><item><title>Nginx 入门</title><link>https://gohalo.github.io/cn/blog/nginx-introduce/</link><pubDate>Sat, 02 Apr 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-introduce/</guid><description>&lt;p>Nginx (发音 &amp;ldquo;Engine X&amp;rdquo;) 是一款轻量级且高性能的 Web 服务器、反向代理服务器，同时也是一个 IMAP POP3 SMTP 服务器，完全通过 C 语言编写，支持多平台，并且在 BSD-like 协议下发行。&lt;/p>
&lt;p>是由俄罗斯的 Igor Sysoev 开发，其特点是占有内存少、并发能力强、丰富的功能集和示例配置文件。在此仅简单介绍其安装使用方法。&lt;/p></description></item><item><title>Webserver 简介</title><link>https://gohalo.github.io/cn/blog/webserver-introduce/</link><pubDate>Wed, 23 Mar 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/webserver-introduce/</guid><description>&lt;p>简单介绍一下 webserver，其中很大一部分是关于一些小型软件的介绍。&lt;/p></description></item><item><title>C Preload 简介</title><link>https://gohalo.github.io/cn/blog/c-preload-introduce/</link><pubDate>Thu, 25 Feb 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-preload-introduce/</guid><description>&lt;p>Linux C 中有一个很不错的特性，可以在不改变程序的前提下，修改动态库所调用的函数，也就是 Preload 功能。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Linux 内核模块</title><link>https://gohalo.github.io/cn/blog/kernel-modules/</link><pubDate>Tue, 23 Feb 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-modules/</guid><description>&lt;p>简单介绍下 Linux 中的内核模块编写，包括了内核签名机制的配置。&lt;/p></description></item><item><title>libevent</title><link>https://gohalo.github.io/cn/blog/linux-libevent/</link><pubDate>Fri, 12 Feb 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-libevent/</guid><description>&lt;p>libevent 是一个轻量级的开源的高性能的事件库，适用于 windows、linux、bsd 等多种平台，根据不同的平台，会选择使用 select、epoll、kqueue 等系统调用管理事件机制。&lt;/p>
&lt;p>下面简单介绍下。&lt;/p></description></item><item><title>DVWA 简介</title><link>https://gohalo.github.io/cn/blog/security-dvwa-introduce/</link><pubDate>Wed, 03 Feb 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-dvwa-introduce/</guid><description>&lt;p>DVWA (Damn Vulnerable Web Application) 是用 PHP+MySQL 编写的一套用于漏洞检测和教学的程序，支持多种数据库，包括了 SQL 注入、XSS 等一些常见的安全漏洞。&lt;/p>
&lt;p>详细的内容可以参考官方网站 &lt;a href="http://www.dvwa.co.uk/">www.dvwa.co.uk&lt;/a>，在此暂时仅介绍其环境的安装方法。&lt;/p></description></item><item><title>日志切割 logrotate 使用方法</title><link>https://gohalo.github.io/cn/blog/logrotate-usage/</link><pubDate>Sun, 31 Jan 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/logrotate-usage/</guid><description>&lt;p>通常我们会通过日志记录程序运行时各种信息，如有异常，则通过日志分析用户行为、记录运行轨迹、查找程序问题。但是，磁盘空间有限，为了节省空间和方便整理，可以将日志文件按时间或大小分成多份，删除时间久远的日志文件。&lt;/p>
&lt;p>这就是通常说的日志滚动 (log rotation)，在本文中，就简单介绍下 Linux 中的 logrotate 程序。&lt;/p></description></item><item><title>SSH 便捷登录配置</title><link>https://gohalo.github.io/cn/blog/ssh-simplify-your-life/</link><pubDate>Fri, 22 Jan 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-simplify-your-life/</guid><description>&lt;p>通常在一个 ssh 链接中，需要指定用户名、主机名、主机端口号、配置参数等信息，如果每次登陆一台主机都要输入，那么就会变的非常麻烦，而且一些 IP 地址通常又非常难记。&lt;/p>
&lt;p>为此，我们可以通过 OpenSSH 的客户端配置文件简化我们的登陆方式，下面简单介绍下。&lt;/p></description></item><item><title>SaltStack 使用简介</title><link>https://gohalo.github.io/cn/blog/saltstack-introduce/</link><pubDate>Sat, 02 Jan 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/saltstack-introduce/</guid><description>&lt;hr>
&lt;p>SaltStack 是一个轻量级的运维工具，具备配置管理、远程执行、监控等功能，类似于 Puppet 和 Chef，不过这两者是用 Ruby 写的，而 Salt Stack 用的是 Python。&lt;/p>
&lt;p>结下来看看具体的使用。&lt;/p></description></item><item><title>软件 DNSmasq 使用介绍</title><link>https://gohalo.github.io/cn/blog/linux-dnsmasq-introduce/</link><pubDate>Sun, 20 Dec 2015 21:50:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-dnsmasq-introduce/</guid><description>&lt;p>通常上网使用的 DNS 服务器都是由电信、联通等运营商提供的，或者是公用的 DNS 解析服务器，例如 Google 提供的解析器，这通常会带来些问题，如有时解析不正常、经常弹出广告等。&lt;/p>
&lt;p>有时我们需要管理 DNS 解析，如加速 DNS 的解析过程、纠正错误的 DNS 解析记录、配置局域网的 DNS 解析等等。&lt;/p>
&lt;p>DNSmasq 就是其中的一个主机上最常用的解决方案，相比 BIND 来说，其更加小巧，配置更加方便，其源码仅有 2 万多行，但足以满足常见的需求。&lt;/p></description></item><item><title>ARP 协议详解</title><link>https://gohalo.github.io/cn/blog/network-arp-introduce/</link><pubDate>Tue, 15 Dec 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-arp-introduce/</guid><description>&lt;p>地址解析协议 Address Resolution Protocol, ARP 是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，在 IPv4 中极其重要。&lt;/p></description></item><item><title>VirtualBox 的一些高级特性</title><link>https://gohalo.github.io/cn/blog/wonderful-things-about-virtualbox/</link><pubDate>Sat, 05 Dec 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/wonderful-things-about-virtualbox/</guid><description>&lt;p>本文不会介绍如何安装 VirtualBox，也不会讲解如何安装操作系统，只是介绍一些比较好玩的特性，一些很有意思，但是经常会被忽略的特性。&lt;/p>
&lt;p>怎么样，一块看看吧。&lt;/p></description></item><item><title>Linux 自动编译 AutoTools</title><link>https://gohalo.github.io/cn/blog/linux-autotools-auto-compile-introduce/</link><pubDate>Mon, 30 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-autotools-auto-compile-introduce/</guid><description>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。
这里简单介绍下 AutoTools 一系列工具的使用。
Autotools # 在 Linux 平台上，经常使用 configure-&amp;gt;make-&amp;gt;make install 从源码开始编译安装，也就是 GNU 构建系统，利用脚本和 make 程序在特定平台上编译软件，也就是利用 autotools 创建构建系统的项目。
注意，有些程序虽然也是采用上述的三步，但并未采用 autotools 实现，如 nginx 是作者编写的构建程序。
在 CentOS 中可以直接通过 yum install automake autoconf 安装相关的文件；利用 autotools 生成 Makefile 的过程如下图所示。
其中用到的核心工具包括了 Autoconf 和 Automake ，首先从用户和开发者角度看看两者的区别。关于 autotools 的简单处理流程可以参考 automake 中的 Setup Explained 内容。
用户视角 # configure 脚本是由软件开发者维护并发布给用户使用的 shell 脚本，该脚本作用是检测系统环境，最终目的是生成 Makefile 和 config.h 两个文件。
开发者在分发源码包时，除了源代码 (.c .h)，还有许多支撑软件构建的文件和工具，其中最重要的文件就是 Makefile.in 和 config.h.in 两个，在 configure 脚本执行成功后，将为每个 *.</description></item><item><title>Linux Package 管理</title><link>https://gohalo.github.io/cn/blog/linux-package-config-introduce/</link><pubDate>Fri, 27 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-package-config-introduce/</guid><description>&lt;p>可以通过 &lt;code>pkg-config&lt;/code> 命令来检索系统中安装库文件的信息，通常用于库的编译和连接。&lt;/p></description></item><item><title>C 参数解析</title><link>https://gohalo.github.io/cn/blog/program-c-linux-getopt-usage-introduce/</link><pubDate>Tue, 10 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-linux-getopt-usage-introduce/</guid><description>&lt;p>在 glibc 中提供了一个通用的参数解析库，包括了短参以及长参的使用。&lt;/p></description></item><item><title>Linux 进程执行简介</title><link>https://gohalo.github.io/cn/blog/kernel-process-introduce/</link><pubDate>Thu, 05 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-process-introduce/</guid><description>&lt;p>简单介绍一下 Linux 中的常见的一些与进程相关的操作，主要是执行命令、守护进程等。&lt;/p></description></item><item><title>Linux 自动编译 Makefile</title><link>https://gohalo.github.io/cn/blog/linux-makefile-auto-compile-introduce/</link><pubDate>Tue, 03 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-makefile-auto-compile-introduce/</guid><description>&lt;p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。&lt;/p>
&lt;p>这里简单介绍下最基本的 Makefile 。&lt;/p></description></item><item><title>如何制作一个标准的 RPM 包</title><link>https://gohalo.github.io/cn/blog/linux-create-rpm-package/</link><pubDate>Wed, 21 Oct 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-create-rpm-package/</guid><description>&lt;p>Red-Hat Package Manager 简称 RPM，这一文件格式在历史名称上虽然打着 RedHat 标志，但其原始设计理念是开放式的，现在包括 OpenLinux、SuSE、Turbo Linux 等多个 Linux 分发版本都有采用，可以算是公认的行业标准了。&lt;/p>
&lt;p>在此介绍下如何制作 RPM 包，尤其是如何写 .spec 配置文件，以及常见的技巧。&lt;/p></description></item><item><title>Kernel 映射文件</title><link>https://gohalo.github.io/cn/blog/kernel-memory-mmap-introduce/</link><pubDate>Fri, 16 Oct 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-mmap-introduce/</guid><description>&lt;p>mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。&lt;/p>
&lt;p>这里简单介绍下如何使用。&lt;/p></description></item><item><title>Linux 内存监控</title><link>https://gohalo.github.io/cn/blog/linux-monitor-memory-introduce/</link><pubDate>Mon, 12 Oct 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-memory-introduce/</guid><description/></item><item><title>SELinux 简介</title><link>https://gohalo.github.io/cn/blog/linux-selinux-introduce/</link><pubDate>Sat, 03 Oct 2015 19:38:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-selinux-introduce/</guid><description>&lt;p>Security-Enhanced Linux, SELinux 给 Linux 带来的最重要价值是：提供了一个灵活的，可配置的 MAC 机制。包括了内核中的模块，以及用户态的工具，对于用户来说是透明的，只有同时满足了 &amp;ldquo;标准 Linux 访问控制&amp;rdquo; 和 &amp;ldquo;SELinux 访问控制&amp;rdquo; 时，主体才能访问客体。&lt;/p></description></item><item><title>SSH 通讯协议介绍</title><link>https://gohalo.github.io/cn/blog/ssh-protocol-details/</link><pubDate>Thu, 17 Sep 2015 22:58:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-protocol-details/</guid><description>&lt;p>SSH 通讯是基于几个基本协议完成，这里简单介绍。&lt;/p></description></item><item><title>Systemd 使用简介</title><link>https://gohalo.github.io/cn/blog/linux-systemd/</link><pubDate>Thu, 17 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-systemd/</guid><description>&lt;p>现在一般新发行的版本会采用新的 init 进程，也就是 systemd ，其中启动过程可以通过 man bootup 查看。&lt;/p>
&lt;p>在此，简单介绍一下 systemd 。&lt;/p></description></item><item><title>C 语言的字符串</title><link>https://gohalo.github.io/cn/blog/program-c-string-stuff/</link><pubDate>Wed, 16 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-stuff/</guid><description>&lt;p>简单介绍下 C 语言中与字符串操作相关的函数。&lt;/p></description></item><item><title>C 加载过程</title><link>https://gohalo.github.io/cn/blog/c-load-process/</link><pubDate>Tue, 15 Sep 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-load-process/</guid><description>&lt;p>这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。&lt;/p></description></item><item><title>Linux IP 隧道技术</title><link>https://gohalo.github.io/cn/blog/network-ip-tunneling/</link><pubDate>Sun, 13 Sep 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-ip-tunneling/</guid><description>&lt;p>隧道是一种封装技术，它利用一种网络协议来传输另一种网络协议，即利用一种网络传输协议，将其它协议产生的数据报文封装在它自己的报文中，然后在网络中传输。&lt;/p>
&lt;p>隧道可以看做是一条虚拟的点对点连接，隧道的两端需要对数据报文进行封装及解封装，常用的是基于 IP 的隧道。&lt;/p>
&lt;p>在此简单介绍下隧道技术。&lt;/p></description></item><item><title>Linux IO 多路复用</title><link>https://gohalo.github.io/cn/blog/linux-program-io-multiplexing/</link><pubDate>Sat, 12 Sep 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-io-multiplexing/</guid><description>&lt;p>通过 IO 多路复用技术，系统内核缓冲 IO 数据，当某个 IO 准备好后，系统通知应用程序该 IO 可读或可写，这样应用程序可以马上完成相应的 IO 操作，而不需要等待系统完成相应 IO 操作，从而应用程序不必因等待 IO 操作而阻塞。&lt;/p>
&lt;p>这里简单介绍下 Linux 中 IO 多路复用的使用。&lt;/p></description></item><item><title>C 语言通配符</title><link>https://gohalo.github.io/cn/blog/program-c-string-linux-wildcard/</link><pubDate>Tue, 08 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-linux-wildcard/</guid><description>&lt;p>简单介绍下 C 语言中与字符串操作相关的函数。&lt;/p></description></item><item><title>最小的ELF文件</title><link>https://gohalo.github.io/cn/blog/linux-the-really-teensy-elf-file/</link><pubDate>Wed, 26 Aug 2015 21:16:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-the-really-teensy-elf-file/</guid><description>&lt;p>从最经典 &amp;ldquo;Hello World&amp;rdquo; C 程序实例，逐步演示如何通过各种常用工具来分析 ELF 文件，并逐步精简代码，尽量减少可执行文件的大小。&lt;/p>
&lt;p>接下来，看看一个可打印 &amp;ldquo;Hello World&amp;rdquo; 的可执行文件能够小到什么样的地步。&lt;/p></description></item><item><title>Linux 网络超时与重传</title><link>https://gohalo.github.io/cn/blog/network-timeout-retries/</link><pubDate>Mon, 17 Aug 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-timeout-retries/</guid><description>&lt;p>在此介绍重传，为了保证可靠性，在 TCP 的三次握手、数据传输、链接关闭阶段都有响应的重传机制。那么，重传的次数都是有那些参数指定？tcp_retries1 和 tcp_retries2 到底有什么区别？什么是 orphan socket ？&lt;/p></description></item><item><title>C 语言的奇技淫巧</title><link>https://gohalo.github.io/cn/blog/program-c-tips/</link><pubDate>Sun, 16 Aug 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-tips/</guid><description>&lt;p>整理下 C 语言中常用的技巧。&lt;/p></description></item><item><title>Linux 网络半链接、链接队列</title><link>https://gohalo.github.io/cn/blog/network-synack-queue/</link><pubDate>Wed, 05 Aug 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-synack-queue/</guid><description>&lt;p>我们知道在建立链接阶段，需要完成三次握手，而这一阶段是在内核中完成，为此保存了两个队列：半链接队列 (SYN队列)、链接队列 (Accepted队列)。&lt;/p>
&lt;p>那么，这两个队列分别对应到内核中的那些成员？队列的大小由那些参数决定？当队列满了之后，对应用的影响是什么？其报错的内容是什么？&lt;/p>
&lt;p>在这篇文章里大致介绍下。&lt;/p></description></item><item><title>Linux 的防火墙</title><link>https://gohalo.github.io/cn/blog/network-netfilter-iptables/</link><pubDate>Tue, 23 Jun 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-netfilter-iptables/</guid><description>&lt;p>Linux 防火墙是由 Netfilter 和 iptables 两个组件组成，其中前者在内核空间中；后者是一个用户程序，用于插入、修改和删除相应的防火墙规则。&lt;/p>
&lt;p>通过 Netfilter+iptables 可以实现数据包过滤、网络地址转换和数据报文处理等功能。&lt;/p></description></item><item><title>Linux AIO</title><link>https://gohalo.github.io/cn/blog/linux-program-aio/</link><pubDate>Sat, 09 May 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-aio/</guid><description>&lt;p>AIO 是 Linux 下的异步读写模型，它是 2.6 内核提供的一个标准增强特性。对于文件的读写，即使以 O_NONBLOCK 方式来打开一个文件，也会处于 &amp;ldquo;阻塞&amp;rdquo; 状态，因为文件时时刻刻处于可读状态，而从磁盘到内存所等待的时间是惊人的。&lt;/p>
&lt;p>为了充份发挥把数据从磁盘复制到内存的时间，引入了 AIO 模型，其基本原理是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成。稍后或在接收到 I/O 操作完成的通知时，进程就可以检索 I/O 操作的结果。&lt;/p></description></item><item><title>FTP 服务简介</title><link>https://gohalo.github.io/cn/blog/network-service-ftp/</link><pubDate>Wed, 29 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-service-ftp/</guid><description>&lt;p>File Transfer Protocol, FTP(RFC 959) 是 TCP/IP 协议组中的协议之一，其传输效率非常高，在网络上传输大的文件时，一般也采用该协议。&lt;/p></description></item><item><title>Linux C++ 线程同步</title><link>https://gohalo.github.io/cn/blog/program-cpp-linux-synchronize/</link><pubDate>Thu, 23 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-cpp-linux-synchronize/</guid><description/></item><item><title>Linux 线程同步</title><link>https://gohalo.github.io/cn/blog/program-c-linux-pthreads-synchronize/</link><pubDate>Thu, 23 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-linux-pthreads-synchronize/</guid><description>&lt;p>线程的三个主要同步原语：互斥锁 (mutex)、信号量 (semaphore) 和条件变量 (cond)。其中 mutex 和 sem 都是对应 futex 进行了简单的封装，在不存在冲突的情况下就不用陷入到内核中进行仲裁；而且 pthread_join 也是借助 futex 来实现的。&lt;/p>
&lt;p>简单介绍下 Linux 中与线程相关的编程。&lt;/p></description></item><item><title>cares 异步 DNS 简介</title><link>https://gohalo.github.io/cn/blog/network-dns-async-resolve-introduce/</link><pubDate>Sat, 18 Apr 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-async-resolve-introduce/</guid><description>&lt;p>c-ares 是一个 C89 实现的异步请求 DNS 的实现，一些常见的软件 (如 curl、NodeJS、WireShark 等等) 都使用了这一软件库。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>HTTP/HTTPS 代理协议</title><link>https://gohalo.github.io/cn/blog/network-proxy-http-https/</link><pubDate>Fri, 10 Apr 2015 22:09:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-proxy-http-https/</guid><description>&lt;p>代理服务器的功能是代理网络用户去取得网络信息，是网络信息的中转站，通常用于隐藏身份、充当防火墙、防止攻击、权限控制等用途。&lt;/p></description></item><item><title>SSH 安全审计</title><link>https://gohalo.github.io/cn/blog/ssh-security-audit/</link><pubDate>Fri, 10 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-security-audit/</guid><description/></item><item><title>DNS 配置文件 resolv.conf 简介</title><link>https://gohalo.github.io/cn/blog/network-dns-resolv-conf-usage-introduce/</link><pubDate>Mon, 30 Mar 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-resolv-conf-usage-introduce/</guid><description>&lt;p>Linux 中可以通过 &lt;code>/etc/resolv.conf&lt;/code> 文件配置 DNS 服务器的地址，不过目前该文件大部分是通过一些工具自动配置的，例如 NetworkManager ，那么这就可能会导致在重启网络服务后该配置文件被刷新。&lt;/p>
&lt;p>这里简单介绍其使用方式。&lt;/p></description></item><item><title>DNS 的基本概念详解</title><link>https://gohalo.github.io/cn/blog/network-dns-basic-introduce/</link><pubDate>Thu, 19 Mar 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-basic-introduce/</guid><description>&lt;p>在通过浏览器访问某个网站时，或者说访问网络上的服务器时，可以直接使用 IP 地址，但是对于人类来说很难记忆，为此引入了域名，而为了可以做到自动解析，于时就有了 DNS 。&lt;/p>
&lt;p>这里详细介绍 DNS 的基本概念。&lt;/p></description></item><item><title>LXC sshd 单进程启动</title><link>https://gohalo.github.io/cn/blog/linux-container-lxc-sshd/</link><pubDate>Wed, 11 Mar 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-container-lxc-sshd/</guid><description>&lt;p>在之前的 &lt;a href="https://gohalo.github.io/cn/blog/linux-container-lxc-introduce/">LXC 简介&lt;/a> 中介绍了如何搭建 CentOS 7 容器，在此介绍如何单独启动 sshd 这一个进程。这样，实际上我们可以通过这种方式启动类似 MySQL 之类的服务，从而减小成本。&lt;/p>
&lt;p>接下来，我们看看是如何启动的。&lt;/p></description></item><item><title>LXC 网络设置相关</title><link>https://gohalo.github.io/cn/blog/linux-container-lxc-network/</link><pubDate>Sun, 08 Mar 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-container-lxc-network/</guid><description>&lt;p>LXC 本身就是基于内核的 Namespace、Cgroup 的隔离技术，对于网络同样使用了网络上常用的虚拟技术，包括 veth、vlan、macvlan 等等。&lt;/p>
&lt;p>在此仅介绍一下 LXC 中与网络相关的使用方法。&lt;/p></description></item><item><title>LXC 简介</title><link>https://gohalo.github.io/cn/blog/linux-container-lxc-introduce/</link><pubDate>Mon, 02 Mar 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-container-lxc-introduce/</guid><description>&lt;p>LXC (Linux Containters) 是一种基于内核容器的用户空间接口，提供了一系列创建、配置、管理的接口。&lt;/p>
&lt;p>其提供了比 chroot 更强的资源隔离，但是与硬件提供的完全虚拟化又不同，其目标为创建一个不需要独立内核，但近可能接近标准 Linux 安装的环境。&lt;/p>
&lt;p>在此简单介绍其使用方法，以及常用的命令。&lt;/p></description></item><item><title>Kernel 内存杂项</title><link>https://gohalo.github.io/cn/blog/kernel-memory-tips/</link><pubDate>Sat, 21 Feb 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-tips/</guid><description>&lt;p>简单介绍下内核中与内存相关的内容。&lt;/p></description></item><item><title>Nginx HTTPS 配置</title><link>https://gohalo.github.io/cn/blog/security-ssl-tls-nginx-https-setting/</link><pubDate>Sat, 27 Dec 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-ssl-tls-nginx-https-setting/</guid><description>&lt;p>简单介绍如何使用 Nginx 搭建 https 服务。&lt;/p></description></item><item><title>HAProxy 简介</title><link>https://gohalo.github.io/cn/blog/haproxy-introduce/</link><pubDate>Fri, 28 Nov 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/haproxy-introduce/</guid><description>&lt;p>HAProxy 是一个免费的负载均衡软件，可以运行于大部分主流的 Linux 操作系统上，提供了 L4 和 L7 两种负载均衡能力，可媲美商用负载均衡器的性能和稳定性，使其不仅仅是免费负载均衡软件的首选，更几乎成为了唯一选择。&lt;/p>
&lt;p>这里简单介绍下 HAProxy 的使用方式。&lt;/p></description></item><item><title>Linux 网络负载均衡</title><link>https://gohalo.github.io/cn/blog/network-load-balancing/</link><pubDate>Mon, 24 Nov 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-load-balancing/</guid><description>&lt;p>对于一个每秒处理百万请求的网站来说，通常是有整个集群提供服务的，而如何做到负载均衡呢？&lt;/p></description></item><item><title>Linux 进程切换</title><link>https://gohalo.github.io/cn/blog/linux-context-schedule/</link><pubDate>Mon, 17 Nov 2014 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-context-schedule/</guid><description>&lt;p>在本文中介绍了 Linux 的进程切换以及协程的相关文档，包括了上下文相关信息、Linux 进程切换的过程以及协程相关的信息。&lt;/p></description></item><item><title>Linux 网络加速</title><link>https://gohalo.github.io/cn/blog/network-speedup-introduce/</link><pubDate>Mon, 27 Oct 2014 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-speedup-introduce/</guid><description>&lt;p>硬件与 CPU 进行信息沟通有两种方式，一种是中断，另一种是轮询。中断是硬件主动产生中断信号，中断控制器将信号传递给 CPU，此时 CPU 会停下手中的工作，执行中断任务；轮询则是 CPU 主动，定时查询硬件设备的状态，是否处理硬件请求。&lt;/p>
&lt;p>随着网络带宽越来越大，实际由中断带来的 CPU 负载越来越大，这也就导致了 NAPI 的出现。&lt;/p>
&lt;p>不过这不是本文要讲的重点，本文着重看下网络针对 SMP 所做的优化。&lt;/p></description></item><item><title>Linux 内存-内核空间</title><link>https://gohalo.github.io/cn/blog/kernel-memory-management-from-kernel-view/</link><pubDate>Tue, 21 Oct 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-management-from-kernel-view/</guid><description>&lt;p>线性地址到物理地址的映射是通过 page table 完成的，内核会在启动分页机制前完成初始化；而且内核会将 A) 不可用物理地址空间，B) 内核代码以及内核初始数据结构对应的地址空间保留。&lt;/p>
&lt;p>接下来，看看内核中是如何管理内存的。&lt;/p></description></item><item><title>Linux 中的 loopback 设备</title><link>https://gohalo.github.io/cn/blog/linux-network-loopback/</link><pubDate>Thu, 02 Oct 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-loopback/</guid><description>&lt;p>我们知道，在 Linux 设备中有一个 lo 设备，在此稍微介绍下。&lt;/p></description></item><item><title>Linux 内存-用户空间</title><link>https://gohalo.github.io/cn/blog/kernel-memory-management-from-userspace-view/</link><pubDate>Sat, 27 Sep 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-management-from-userspace-view/</guid><description>&lt;p>简单介绍下 Linux 中用户空间的内存管理，包括了内存的布局、内存申请等操作。&lt;/p></description></item><item><title>Linux 共享内存</title><link>https://gohalo.github.io/cn/blog/linux-program-shared-memory/</link><pubDate>Wed, 10 Sep 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-shared-memory/</guid><description>&lt;p>共享内存应该是进程间通信最有效的方式，同一块物理内存被映射到两个不同进程 A、B 各自的地址空间；进程 A 可以立即看到进程 B 对共享内存中数据的更新，反之亦然。&lt;/p>
&lt;p>接下来简单介绍下与共享内存相关的内容。&lt;/p></description></item><item><title>程序简介</title><link>https://gohalo.github.io/cn/blog/program-exec-basic-concept-introduce/</link><pubDate>Fri, 01 Aug 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-exec-basic-concept-introduce/</guid><description>&lt;p>可执行二进制文件在编译以及加载过程中都有统一的格式，不同的平台其格式略有不同，这还只是在磁盘上的保存方式，而加载到内存中又不相同。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>文件完整性检查</title><link>https://gohalo.github.io/cn/blog/file-integrity-check/</link><pubDate>Tue, 03 Jun 2014 19:38:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/file-integrity-check/</guid><description>&lt;p>通常为了防止文件的内容被修改，如一个文件号称是包含了补丁的文件，却被人加入了木马；同时也可以用来保证文件的完整性，防止文件被损坏。&lt;/p>
&lt;p>当然，一些 hash 算法可能会被破解，所以一些网站则提供了多种完整性校验方法。&lt;/p></description></item><item><title>Linux 时间函数</title><link>https://gohalo.github.io/cn/blog/linux-timer-functions/</link><pubDate>Mon, 02 Jun 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-timer-functions/</guid><description>&lt;p>简单介绍下 Linux 中与时间相关的函数。&lt;/p></description></item><item><title>dstat 使用及其原理</title><link>https://gohalo.github.io/cn/blog/dstat-introduce/</link><pubDate>Tue, 27 May 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/dstat-introduce/</guid><description>&lt;p>dstat 是一个不错的系统监控程序，类似于 vmstat、iostat、mpstat，所不同的是，可以监控多个系统指标，如 CPU、网络、内存、中断等，可以将结果显示到终端，也可保存到文件。&lt;/p>
&lt;p>另外，该程序是通过 Python 实现的，可以动态指定插件，甚至编写自己的插件。&lt;/p>
&lt;p>在本文中，大致介绍其使用方法，以及实现的原理。&lt;/p></description></item><item><title>Awesome Projects</title><link>https://gohalo.github.io/cn/blog/awesome-projects/</link><pubDate>Sun, 25 May 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/awesome-projects/</guid><description/></item><item><title>TMUX 简介</title><link>https://gohalo.github.io/cn/blog/tmux-terminal-introduce/</link><pubDate>Wed, 21 May 2014 19:49:37 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/tmux-terminal-introduce/</guid><description>&lt;p>TMUX 类似于 screen，是一个窗口管理器，而且功能更加强大，提供了强劲的、易于使用的命令行界面，可横向和纵向分割窗口，支持 UTF-8 编码及 256 色终端等特性。&lt;/p>
&lt;p>接下来简单介绍下 TMUX 的使用。&lt;/p></description></item><item><title>Linux 监控之 IO</title><link>https://gohalo.github.io/cn/blog/linux-monitor-io-introduce/</link><pubDate>Sat, 03 May 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-io-introduce/</guid><description>&lt;p>简单介绍下 Linux 中与 IO 相关的内容。&lt;/p></description></item><item><title>TCP/IP 协议之 TIME_WAIT</title><link>https://gohalo.github.io/cn/blog/network-tcpip-timewait/</link><pubDate>Tue, 29 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-tcpip-timewait/</guid><description>&lt;p>&lt;code>TIME_WAIT&lt;/code> 是 TCP 协议栈中比较特殊的状态，其主要目的是保证不同的链接不会相互干扰，但是对于一些高性能的场景，就可能由于较多的 &lt;code>TIME_WAIT&lt;/code> 状态最终导致链接不可用。&lt;/p>
&lt;p>如下简单介绍如何充分利用该状态。&lt;/p></description></item><item><title>TCP/IP 协议简介</title><link>https://gohalo.github.io/cn/blog/network-tcpip-introduce/</link><pubDate>Mon, 07 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-tcpip-introduce/</guid><description>&lt;p>TCP 协议是 &amp;ldquo;面向连接&amp;rdquo; 的，整个过程被分为几个阶段：准备、协商、建立连接、管理以及最后的连接终止，同时可以管理多个链接。&lt;/p>
&lt;p>接下来，我们看看 TCP 协议是如何实现的。&lt;/p></description></item><item><title>Linux 网卡驱动的工作原理</title><link>https://gohalo.github.io/cn/blog/network-driver-works/</link><pubDate>Thu, 03 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-driver-works/</guid><description>&lt;p>如题所示，介绍网卡是如何接收数据，然后又是如何交给上层处理。因为鄙人的网卡驱动用的是 e1000e，所以就以此为例了。&lt;/p>
&lt;p>Just enjoy it.&lt;/p></description></item><item><title>Linux 常用命令 SED</title><link>https://gohalo.github.io/cn/blog/linux-commands-text-sed-introduce/</link><pubDate>Fri, 21 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-commands-text-sed-introduce/</guid><description>&lt;p>sed 是一个精简的、非交互式的编辑器，可以提供与编辑器 VIM 或者 EMACS 相同的编辑任务，但 sed 不提供交互使用方式，只能在命令行下输入编辑命令。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Linux 常用命令 AWK</title><link>https://gohalo.github.io/cn/blog/linux-commands-text-awk-introduce/</link><pubDate>Wed, 19 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-commands-text-awk-introduce/</guid><description>&lt;p>AWK 是一种程序语言，对文档资料的处理具有很强的功能，擅长从格式化报文或一个大的文本文件中抽取数据，会将一行文字按分隔符分为多个域，然后进行处理。&lt;/p>
&lt;p>这里简单介绍其常用的方法。&lt;/p></description></item><item><title>Linux VFS 文件系统</title><link>https://gohalo.github.io/cn/blog/linux-kernel-virtual-file-system-introduce/</link><pubDate>Sat, 15 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-virtual-file-system-introduce/</guid><description>&lt;p>在次重申下，Linux 的设计理念是：一切都是文件！&lt;/p>
&lt;p>也就是在 Linux 中，一切设备皆是以文件的形式进行操作，如网络套接字、硬件设备等。这一切都是通过一个中间层实现的，被称为 VFS (Virtual File System) 。&lt;/p></description></item><item><title>Linux 文件操作</title><link>https://gohalo.github.io/cn/blog/linux-file-operations/</link><pubDate>Mon, 10 Mar 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-file-operations/</guid><description>&lt;p>Linux 的设计理念是：一切都是文件！在此简单介绍下 Linux 中常见的文件操作。&lt;/p></description></item><item><title>Linux 硬件启动</title><link>https://gohalo.github.io/cn/blog/kernel-hardware-startup/</link><pubDate>Tue, 25 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-hardware-startup/</guid><description>&lt;p>从内核加电之后，简单介绍如何从硬件加载启动。&lt;/p></description></item><item><title>Linux 内核编译</title><link>https://gohalo.github.io/cn/blog/kernel-compile/</link><pubDate>Sun, 23 Feb 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-compile/</guid><description>现在安装时，一般是发行版本已经编译创建好的通用内核，对于一些特定的需求，如嵌入式设置，那么可能就需要手动编译内核镜像。
这里简单介绍如何手动编译内核。
内核镜像介绍 # 通常 Unix 平台下的内核镜像称为 unix，Linux 也与之相似，不过随着虚拟内存 (Virtual Memory) 的发展，于是支持虚拟内存的内核在前面添加了 vm，其中 vmlinux 源自 vmunix 。现在 Linux 支持虚拟内存，不再像老的操作系统比如 DOS 会有 640KB 内存的限制。
在 DOS 的时代，采用的是 16 位段寻址方式，因此只能访问 1M 的空间。在这 1M 的 RAM 空间里，段址从 A000 起，被分配给了显示缓存、外部设备 ROM、BIOS ROM 等等。因此，一般情况下， dos 可供自己分配的也就是段 A000 之前的那部分了，这部分的大小为 640K 。
一般来说，一个可启动的内核镜像 (bootable kernel image) 是经过 zlib 算法压缩的，2.6.30 之后采用 LZMA 或者 BZIP2，vmlinuz 最后的 z 表示内核是压缩的，这也意味着内核中会有一段解压程序。
内核中包含了各种内核镜像的格式，如 vmlinux、zImage、bzImage、uImage 等，首先介绍一下内核中的常见内核文件。
vmlinux 是静态编译出来的最原始的 ELF 文件，包括了内核镜像、调试信息、符号表等内容；其中 &amp;ldquo;vm&amp;rdquo; 代表 &amp;ldquo;Virtual Memory&amp;rdquo;，现在一般都是虚拟内存模式，这个是相对于 8086 的实地址而言。 bzImage 是 vmlinux 经过 gzip 压缩后的文件，适用于大内核，&amp;ldquo;bz&amp;rdquo; 表示 &amp;ldquo;big zImage&amp;rdquo;。 uImage 是 uboot 专用的镜像文件，它是在 zImage 之前加上一个长度为 0x40 的头信息，包括了该镜像文件的类型、加载位置、生成时间、大小等信息。 在发行版本中，通常使用 vmlinuz 标示，而实际上是 bzImage 格式，可以通过 file 命令查看。</description></item><item><title>Linux Netlink 简介</title><link>https://gohalo.github.io/cn/blog/linux-communication-netlink/</link><pubDate>Wed, 19 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-communication-netlink/</guid><description>&lt;p>Netlink 机制是在 Linux 中作为内核态与用户态的一种通讯机制，它是基于 socket 的！！！怎么样，没有想到，除了 TCP/IP 协议外，这样也可以 ^_^&lt;/p>
&lt;p>另外的一个特性是，面向数据报文的无连接消息子系统，有点类似于 UDP 协议。&lt;/p></description></item><item><title>Linux 中断</title><link>https://gohalo.github.io/cn/blog/kernel-interrupts/</link><pubDate>Wed, 19 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-interrupts/</guid><description>&lt;p>中断在很大程度上解放了 CPU，提高了 CPU 的执行效率，弥补了 CPU 与外设运行速度之间的差距。&lt;/p></description></item><item><title>Linux 中的 socketfs</title><link>https://gohalo.github.io/cn/blog/network-socketfs/</link><pubDate>Mon, 10 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-socketfs/</guid><description>&lt;p>BSD socket 是用户程序与网络协议栈之间的接口层，用户通过调用 socket API 将报文传给协议栈，以及从协议栈读取报文。实际上，Linux 对于网络提供了一个与虚拟文件系统相似的接口，也就是可以通过 socket 接口打开一个类似的文件，而内核中实际是通过 sockfs 文件系统实现的。&lt;/p>
&lt;p>接下来我们就在这篇文章中查看下与 socketfs 相关的内容。&lt;/p></description></item><item><title>Linux 网络常见监控项以及报错</title><link>https://gohalo.github.io/cn/blog/linux-monitor-network/</link><pubDate>Mon, 03 Feb 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-network/</guid><description>&lt;p>本来是想将报错和监控拆开的，但是发现两者几乎是耦合的，通过监控项才能发现错误，定为错误的原因时也要依赖监控项，索性就将两者合并到了一起。&lt;/p>
&lt;p>对于很多的报错，实际上你即使看到报错的信息也不清楚到底是那里报错了，或者模棱两可，甚至是误导。最好的方式是 &amp;ldquo;Show me the code&amp;rdquo; 。&lt;/p>
&lt;p>在此，简单介绍一下与网络相关的调试、查看方法，当然也包括了报错相关的内容。&lt;/p></description></item><item><title>Linux 网络协议栈简介</title><link>https://gohalo.github.io/cn/blog/network-introduce/</link><pubDate>Thu, 23 Jan 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-introduce/</guid><description>&lt;p>Linux 的 TCP/IP 协议栈估计是目前最灵活、应用最广的网络协议栈了，具有清晰的层次结构以及清晰定义的原语和接口，不仅使得上层应用开发者可以无需关心下层架构或者内部机制，从而提供相对透明的操作网络。&lt;/p>
&lt;p>在本文中简单介绍一下与协议栈相关的内容。&lt;/p></description></item><item><title>Linux Chroot</title><link>https://gohalo.github.io/cn/blog/linux-chroot/</link><pubDate>Mon, 13 Jan 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-chroot/</guid><description>&lt;p>chroot 也就是 change root directory，也就是改变程序执行时所参考的根目录位置。在 Linux 系统中，系统默认的目录结构都是以 &amp;ldquo;/&amp;quot;，即是以根 (root) 开始的，而在使用 chroot 之后，系统的目录结构将以指定的位置作为 &amp;ldquo;/&amp;rdquo; 位置。&lt;/p>
&lt;p>应用场景比较多，如安全中的蜜罐、系统启动时用的 initrd、嵌入式系统挂载的 NFS、Linux From Scratch 的编译过程等等。&lt;/p>
&lt;p>在此，简单介绍下 chroot 。&lt;/p></description></item><item><title>Markdown 使用介绍</title><link>https://gohalo.github.io/cn/blog/cheatsheet-markdown/</link><pubDate>Thu, 18 Jul 2013 22:14:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cheatsheet-markdown/</guid><description>&lt;p>Markdown 是一种很简单的标记语法，可以直接使用普通的文本编辑器编写，在渲染之后具有一定的格式，主要特点就是简单、方便书写。&lt;/p>
&lt;p>同时，还有一些衍生版本，用于扩展一些常见的功能，常见的有 Markdown Extra、MultiMarkdown、Maruku 等。&lt;/p>
&lt;p>这里简单整理基础语法的速查表，详细语法可以参考 &lt;a href="https://daringfireball.net/projects/markdown/syntax">Markdown Syntax&lt;/a> 中的介绍。&lt;/p></description></item><item><title>Kernel 系统时钟</title><link>https://gohalo.github.io/cn/blog/kernel-timer-introduce/</link><pubDate>Tue, 02 Jul 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-timer-introduce/</guid><description/></item><item><title>Kernel 调度系统</title><link>https://gohalo.github.io/cn/blog/kernel-scheduler/</link><pubDate>Fri, 21 Jun 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-scheduler/</guid><description>&lt;p>操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级和高优先级进程的需要尽可能调和等等。&lt;/p>
&lt;p>什么时候以怎样的方式选择一个进程运行，就是所谓的调度策略 (Scheduling Policy)。&lt;/p>
&lt;p>本文中，介绍下 Linux Kernel 中时如何实现的。&lt;/p></description></item><item><title>关于时间的杂七杂八</title><link>https://gohalo.github.io/cn/blog/time-mess/</link><pubDate>Sat, 01 Jun 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/time-mess/</guid><description>&lt;p>一篇引用的文章，忘了从哪里引用的了。&lt;/p></description></item><item><title>Linux 常用监控工具</title><link>https://gohalo.github.io/cn/blog/linux-monitor-misc/</link><pubDate>Sun, 12 May 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-misc/</guid><description>在此简单列举一些常见的监控工具，以及配置方式等。
SAR # sar (select activity information) 用于采集系统的信息，默认会保存一个月的信息，在 CentOS 中包含在 sysstat软件包中。与此相关的还有：
sac, system ativity data collector。也就是 sar 的后端，用于收集信息； sa1，用于将信息保存为二进制信息，默认位置为 /var/log/sa/saXX (其中XX表示当月的日期)； sar2，显示每天的统计信息，是 一个 shell 脚本； sadf，用于转换为其它的格式 (如csv，xml) 的程序。 sar1 和 sar2 会在 cron 任务中调用，配置在 /etc/cron.d/sysstat 文件中，默认每 10 分钟调用 sa1 采集一次数据；在 23:53 时通过 sa2 转换一次数据，默认保存 28 天，可以在 /usr/lib64/sa/sa2 中设置。
其中 /etc/cron.d/sysstat 文件内容如下。
# Run system activity accounting tool every 10 minutes */10 * * * * root /usr/lib64/sa/sa1 1 1 # Generate a daily summary of process accounting at 23:53 53 23 * * * root /usr/lib64/sa/sa2 -A 因为使用的是 crontab ，所以最小的粒度是 1min；当然，也可以使用 sa1 1 60 每秒执行依次，并执行 60 次，进一步减小监控的粒度。</description></item><item><title>Cache 能否回收</title><link>https://gohalo.github.io/cn/blog/linux-monitor-memory-cache-buffer-introduce/</link><pubDate>Sat, 20 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-memory-cache-buffer-introduce/</guid><description/></item><item><title>Linux 常用命令</title><link>https://gohalo.github.io/cn/blog/linux-commands-tips/</link><pubDate>Fri, 12 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-commands-tips/</guid><description>&lt;p>主要介绍下在 Linux 中，日常用到的一些常用指令，如 find、cmp 等。&lt;/p></description></item><item><title>Linux 监控之 Memory</title><link>https://gohalo.github.io/cn/blog/linux-monitor-memory/</link><pubDate>Sat, 06 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-memory/</guid><description>&lt;p>在 Linux 的内存分配机制中，优先使用物理内存，当物理内存还有空闲时，不会释放其占用内存，就算占用内存的程序已经被关闭了，该程序所占用的内存用来做缓存使用，这样对于开启过的程序、或是读取刚存取过得数据会比较快，可以提高整体 IO 效率。&lt;/p></description></item><item><title>Kernel 内存映射</title><link>https://gohalo.github.io/cn/blog/kernel-memory-virtual-physical-map/</link><pubDate>Fri, 05 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-virtual-physical-map/</guid><description>&lt;p>现在的操作系统在内存使用时，一般为逻辑地址，那么逻辑地址和物理地址之间是怎样映射的，或者说，通过逻辑地址如何找到物理内存中的内容。&lt;/p>
&lt;p>其实，包括动态共享库，mmap 映射等，都使用到了虚拟内存，也就是逻辑地址的映射。&lt;/p>
&lt;p>这里，简单介绍下逻辑地址到物理地址的映射关系。&lt;/p></description></item><item><title>Linux LVS</title><link>https://gohalo.github.io/cn/blog/linux-lvs-introduce/</link><pubDate>Fri, 15 Mar 2013 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-lvs-introduce/</guid><description>&lt;p>LVS 通常用于四层的网络服务器做负载均衡，其工作在内核层，而且效率非常高；部署时还会使用 heartbeat 以及 keepalived 做高可用。&lt;/p>
&lt;p>在本文中，我们对其做些介绍。&lt;/p></description></item><item><title>Linux 常用技巧</title><link>https://gohalo.github.io/cn/blog/linux-tips/</link><pubDate>Sat, 09 Mar 2013 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-tips/</guid><description/></item><item><title>【专题】Linux 网络相关</title><link>https://gohalo.github.io/cn/blog/topic-linux-network/</link><pubDate>Sat, 10 Apr 2010 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-network/</guid><description/></item><item><title>【专题】Linux 安全相关</title><link>https://gohalo.github.io/cn/blog/topic-linux-security/</link><pubDate>Sat, 27 Mar 2010 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-security/</guid><description>&lt;p>介绍 Linux 中与安全相关的内容，例如 SSH、SELinux 等，当然，也包括了一些安全相关基本的概念，例如加密算法、TLS 等等，这里作为一个专题介绍一些常见概念。&lt;/p></description></item><item><title>【专题】Linux 环境搭建</title><link>https://gohalo.github.io/cn/blog/topic-linux-environment-setup/</link><pubDate>Thu, 25 Feb 2010 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-environment-setup/</guid><description>&lt;p>Linux 有多个发行版本，其中 RedHat、Debian 及其衍生版本占了很大一部分，大部分的基本功能相似，但是环境又略有区别，这里简单介绍其基础的环境使用，以及一些常见概念。&lt;/p></description></item></channel></rss>