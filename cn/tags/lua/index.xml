<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lua on</title><link>https://gohalo.github.io/cn/tags/lua/</link><description>Recent content in lua on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 30 Apr 2020 18:19:15 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/lua/index.xml" rel="self" type="application/rss+xml"/><item><title>Lua 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/lua-basic-introduce/</link><pubDate>Thu, 30 Apr 2020 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-basic-introduce/</guid><description>&lt;p>Lua 历史可以从 1993 年开始，到现在为止，在很多场景都可以看到 Lua 的影子，如游戏开发、Web 应用脚本、安全系统插件等，像常见的 nmap、sysbench 等程序。&lt;/p>
&lt;p>这里简单介绍 Lua 的安装使用。&lt;/p></description></item><item><title>Lua 和 C 语言相互调用</title><link>https://gohalo.github.io/cn/blog/lua-c-api/</link><pubDate>Sun, 22 Sep 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-c-api/</guid><description>&lt;p>Lua 是扩展性非常良好的语言，虽然核心非常精简，但是用户可以依靠 Lua 库来实现大部分工作，还可以通过与 C 函数相互调用来扩展程序功能。&lt;/p>
&lt;p>在 C 中嵌入 Lua 脚本既可以让用户在不重新编译代码的情况下修改 Lua 代码更新程序，也可以给用户提供一个自由定制的接口，这种方法遵循了机制与策略分离的原则；在 Lua 中调用 C 函数可以提高程序的运行效率。&lt;/p>
&lt;p>Lua 与 C 的相互调用在工程中相当实用，这里就简单讲解 Lua 与 C 相互调用的方法。&lt;/p></description></item><item><title>Lua 源码解析</title><link>https://gohalo.github.io/cn/blog/lua-sourcecode/</link><pubDate>Wed, 28 Oct 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-sourcecode/</guid><description>&lt;p>Lua 类似于 Java、Python，实际执行的都不是机器码，而是运行在虚拟机上的，而虚拟机则屏蔽了底层不同的硬件，从而使得这些程序可以跨平台执行，包括不同的操作系统以及不同的硬件平台。&lt;/p>
&lt;p>相比而言，Lua 的代码十分简单，源码总共才 2W 行左右，但是却实现了很多不错的特性。&lt;/p>
&lt;p>接下来，我们看看 Lua 具体是如何工作的。&lt;/p></description></item><item><title>Lua 协程</title><link>https://gohalo.github.io/cn/blog/lua-coroutine/</link><pubDate>Tue, 06 Oct 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-coroutine/</guid><description>协程是另外一种并发方式，相比多进程或者多线程来说，其上下文的切换成本开销更小，这也意味这协程的执行更加高效。
Lua 作为一种简单的语言，仍然可以支持闭包、协程等较新的特性，在此介绍一下协程相关的内容。
简介 # 对于并发任务，通常有两种解决方法：A) 抢占式 (preemptive) 多任务，常见的是通过操作系统决定何时执行哪个任务；B) 协作式 (cooperative) 多任务，有任务自身决定何时放弃任务的执行。
协程 (coroutine) 是一种程序控制机制，实际上在上世纪 60 年代就已经被提出，用来方便地实现协作式的多任务。在很多主流的程序语言中，如 C/C++、Java 等，很少能看到协程，但现在不少脚本语言，如 Python、Lua 等，都提供了协程或与之相似的机制。
Lua 实现的是一种非对称式 (asymmetric) 或者称为半对称式 (semi-symmetric) 协程，之所以被称为非对称的，是因为它提供了两种传递程序控制权的操作：A) 利用 resume() (重)调用协程；B) 通过 yield 挂起协程并将程序控制权返回给协程的调用者。这看起来有点像函数的调用过程。
而 libtask 的实现就更像对称式的协程。
协程类似于线程，包含了自己的栈、本地变量、指针，但是包括了其它的全局变量是共享的。与线程不同的是，线程可以真正的在多个核上并发执行，而协程在具体的时间只能运行其中的一个。
常用接口 # 与协程相关的函数包含在 coroutine table 中，其中的 create() 函数用来创建一个协程，该函数会返回一个 thread 类型的变量，用来表示协程。
co = coroutine.create(function () print(&amp;#34;Hello World&amp;#34;) end) print(co) --&amp;gt; thread: 0x24a0b20 Lua 中的协程包含了四种状态：suspended、running、dead 以及 normal，可以通过 satatus() 查看。
print(coroutine.status(co)) --&amp;gt; suspended 刚创建的协程处于 suspended 状态，也就是说创建时不会自动运行；可以通过 resume() 函数运行或者重新运行该协程，将状态从 suspended 转换为 running 。如上的函数中，仅仅打印字符串，那么执行完成之后，状态会变为 dead 。</description></item><item><title>【专题】Lua 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-lua/</link><pubDate>Thu, 12 Aug 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-lua/</guid><description>&lt;p>Lua 在葡萄牙语中是 &amp;ldquo;月亮&amp;rdquo; 的意思，是一个小巧的脚本语言，官方版本只包括一个精简的核心和最基本的库，使得其体积小、启动速度快，从而特别适合嵌入到其它程序里。&lt;/p></description></item></channel></rss>