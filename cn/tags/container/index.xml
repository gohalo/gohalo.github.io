<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>container on</title><link>https://gohalo.github.io/cn/tags/container/</link><description>Recent content in container on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 28 Mar 2023 21:33:42 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/container/index.xml" rel="self" type="application/rss+xml"/><item><title>K8S Controller 常用命令</title><link>https://gohalo.github.io/cn/blog/kubernets-crd-controller-details/</link><pubDate>Tue, 28 Mar 2023 21:33:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-crd-controller-details/</guid><description>简介 # 在构建自定义的 Operator 时会涉及到如下几种组件：
client-go 底层用于与 K8S API 进行交互，支持资源的 CRUD 操作，包含了 ClientSet、DynamicClient、RESTClient 三种。 controller-runtime 封装了控制器的处理框架，底层会调用 client-go 库。 kubebuilder 可以很方便渲染出 Controller 整个框架，该框架使用的就是 controller-runtime 模块。 operator-sdk 同样基于 controller-runtime 实现，而且同时使用了 kubebuilder 来构建 Go 项目。 简单来说，当前 Controller 的编写包含了 OperatorSDK、Kubebuilder、ClientGo 三种方式，前两者提供了更加实用的封装，而 ClientGo 相对来说要简单很多，这里简单介绍 Kubebuilder 的使用方式。
Kubebuilder # Kubebuilder 由 K8S Special Interest Group, SIG API Machinery 拥有和维护，用于帮助开发者创建 CRD 并生成 Controller 脚手架，包含了如下的组件：
Client 封装了对资源的操作，修改会直接访问 APIServer ，而查询则会访问本地 Cache 信息。 Cache 负责生成 SharedInformer，会监听 GVK 下的 GVR 变化，然后触发 Controller 的 Reconcile 逻辑。 Manager 管理协调多个 Controller，提供共有依赖以及基础服务(例如保活)，负责初始化 Controller、Cache、Client 的工作。 Finzlizers 用于处理资源的预删除逻辑，保障资源被删除后能够从 Cache 中读取到，清理相关的其它资源。 Builder 构造器，提供了一系列配置接口，可以通过链式条用进行组装，最终为 Reconciler 生成相应的 Controller 对象。 示例 # 可以直接从 GitHub Release 上下载对应的二进制文件。</description></item><item><title>CRD 使用详解</title><link>https://gohalo.github.io/cn/blog/kubernets-crd-sample/</link><pubDate>Mon, 12 Dec 2022 19:17:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-crd-sample/</guid><description/></item><item><title>K8S 本地集群 Kind 使用介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-minimal-kind-cluster/</link><pubDate>Sat, 12 Nov 2022 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-minimal-kind-cluster/</guid><description>&lt;p>kind 是 Kubernetes in Docker 的简写，是一个使用 Docker 容器作为 Nodes，在本地创建和运行 Kubernetes 群集的工具，适用于在本机创建 Kubernetes 群集环境进行开发和测试，而且支持离线部署。&lt;/p></description></item><item><title>K8S 包管理工具 Helm 介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-helm-introduce/</link><pubDate>Fri, 21 Oct 2022 19:50:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-helm-introduce/</guid><description>&lt;p>Helm 是 K8S 中的包管理器，可以非常方便的完成应用的安装、卸载、升级等，Chart 是 Helm 的打包格式，其内部包含了一组相关的 K8S 资源。&lt;/p></description></item><item><title>K8S 配置上下文介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-config-context/</link><pubDate>Wed, 22 Dec 2021 19:40:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-config-context/</guid><description>&lt;p>通常在开发过程中需要维护多个集群，例如研发、测试、生产等，为了方便管理可以通过 kubeconfig 维护集群、用户、命名空间、身份认证相关的信息，用来快速切换访问的集群。&lt;/p></description></item><item><title>K8S Kustomize 命令介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-commands-kustomize-usage/</link><pubDate>Fri, 22 Oct 2021 23:19:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-commands-kustomize-usage/</guid><description>&lt;p>这是 K8S 的原生配置管理，以无模板方式来定制应用的配置，以 Base+Overlay 的方式生成应用最终部署时所需的描述文件。&lt;/p></description></item><item><title>K8S Patch 命令介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-commands-patch-usage/</link><pubDate>Fri, 22 Oct 2021 23:19:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-commands-patch-usage/</guid><description>&lt;p>通过 patch 命令可以对集群中的资源进行部分更新，也就是以补丁 (Patch) 方式修改、更新某资源的字段，相对于 apply 命令来说，无需提供完整的资源文件，只需要提供更新的内容即可。&lt;/p></description></item><item><title>K8S 常用命令</title><link>https://gohalo.github.io/cn/blog/kubernets-commands-usage/</link><pubDate>Fri, 22 Oct 2021 19:43:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-commands-usage/</guid><description>&lt;p>整理下 K8S 的常用命令，以供参考。&lt;/p></description></item><item><title>通过 go-client 访问 K8S 集群</title><link>https://gohalo.github.io/cn/blog/kubernets-source-code-go-client/</link><pubDate>Tue, 12 Oct 2021 23:11:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-source-code-go-client/</guid><description>&lt;p>&lt;code>client-go&lt;/code> 是用 GoLang 编写的官方编程式交互客户端库，提供对 Kubernetes API Server 服务的交互访问，也是 Kubernetes 的核心处理框架，其源码中已经集成了 &lt;code>client-go&lt;/code> 的源码，无需单独下载。&lt;/p></description></item><item><title>Docker 主机映射</title><link>https://gohalo.github.io/cn/blog/docker-hosts-mapping/</link><pubDate>Wed, 22 Sep 2021 21:30:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-hosts-mapping/</guid><description>&lt;p>配置服务器时，经常会修改域名映射，Linux 中就是 /etc/hosts 文件，不过容器每次启动都会覆盖。&lt;/p></description></item><item><title>Docker 使用简介</title><link>https://gohalo.github.io/cn/blog/docker-basic-introduce/</link><pubDate>Mon, 20 Sep 2021 23:10:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-basic-introduce/</guid><description>&lt;p>从 Docker 1.11 开始，Docker 容器运行已经不是简单的通过 Docker Daemon 启动，而是集成了 containerd、runC 等多个组件，在 Docker 服务启动之后，可以看到系统上启动了 dockerd、containerd 等进程。&lt;/p>
&lt;p>这里简单介绍一些与 Docker 相关的基本概念。&lt;/p></description></item><item><title>K8S ConfigMap 使用介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-components-configmap/</link><pubDate>Fri, 10 Sep 2021 20:18:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-components-configmap/</guid><description>&lt;p>在 K8S 中可以通过 configmap 保存应用的配置，这样就将配置和运行代码分开了。&lt;/p></description></item><item><title>Containerd 介绍</title><link>https://gohalo.github.io/cn/blog/docker-containerd-introduce/</link><pubDate>Sun, 22 Aug 2021 21:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-containerd-introduce/</guid><description>&lt;p>早在 K8S 1.7 时，Containerd 已经作为运行时替换 Docker 了，只是大部分时候因为熟悉 Docker 会默认使用 docker-shim ，而在 1.24 版本起就彻底替换为了 Containerd 运行时。&lt;/p>
&lt;p>这里简单介绍使用方式。&lt;/p></description></item><item><title>K8S 简单安装部署服务</title><link>https://gohalo.github.io/cn/blog/kubernets-simple-install/</link><pubDate>Sun, 01 Aug 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-simple-install/</guid><description>&lt;p>现在很多的 K8S 部署是通过容器安装的，这里介绍如何在物理机上独立部署，这也是最简单的方式。&lt;/p></description></item><item><title>Docker 镜像分析工具 Dive 简介</title><link>https://gohalo.github.io/cn/blog/docker-image-layers-analyze/</link><pubDate>Wed, 21 Jul 2021 22:18:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-image-layers-analyze/</guid><description>&lt;p>Docker 的容器镜像是一层层叠加的，可以通过 &lt;code>docker inspect&lt;/code> 命令查看镜像中的 meta 信息，或者通过 &lt;code>docker history&lt;/code> 了解镜像的构建历史，不过相对来说不够清晰。&lt;/p>
&lt;p>这里介绍一个很好用的工具 Dive 。&lt;/p></description></item><item><title>Kubernets 网络示例</title><link>https://gohalo.github.io/cn/blog/kubernets-examples-nginx/</link><pubDate>Fri, 19 Mar 2021 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-examples-nginx/</guid><description>&lt;p>这里以 Nginx 为例，介绍几种常见的网络模型。&lt;/p></description></item><item><title>K8S Ingress 详细介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-components-ingress/</link><pubDate>Wed, 10 Mar 2021 23:19:41 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-components-ingress/</guid><description/></item><item><title>YAML 配置格式</title><link>https://gohalo.github.io/cn/blog/yaml-format-standard/</link><pubDate>Wed, 10 Mar 2021 23:15:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/yaml-format-standard/</guid><description>&lt;p>YAML 是一种可读性高的数据标记语言，通常用于配置文件，可存放一些复杂的数据类型，例如列表、字典等。&lt;/p></description></item><item><title>K8S 权限管理介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-access-control-introduce/</link><pubDate>Tue, 02 Mar 2021 23:19:41 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-access-control-introduce/</guid><description/></item><item><title>K8S 网络简介</title><link>https://gohalo.github.io/cn/blog/kubernets-network-introduce/</link><pubDate>Mon, 21 Dec 2020 20:30:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-network-introduce/</guid><description>简介 # K8S 中的网络以及 IP 地址都分了三层，分别为：
Node Network 各个 Node 之间的通讯方式，可以是物理网络或者虚拟网络； Pod Network 各个 Pod 之间通讯，Pod 可以在 Node 内部，也可以是跨 Node ； Service Network 也就是 Pod 对外部暴露的接口，创建 Service 时会新建一个 IP 。 与之对应的 IP 地址包括了：
Node IP 每个 Node 之间通讯时，分配的 IP 地址； Pod IP 每个 Pod 会分配一个 IP 地址，一般由 Pause 容器创建，一个 Node 中可以包含多个 Pod ； Cluster IP 对应了 Service 内部 IP ，作为服务的入口。 K8S 支持 Flannel、Calico、Weave Network 等多种 CNI 网络驱动。
Docker 网络 # 在 Docker 的后台服务启动之后，会创建一个 docker0 的网关，容器默认会分配在一个以 docker0 为默认网关的虚拟子网中。</description></item><item><title>Kubernetes 基本介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-basic-introduce/</link><pubDate>Thu, 10 Dec 2020 21:50:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-basic-introduce/</guid><description/></item><item><title>K8S Secret 介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-components-secret/</link><pubDate>Tue, 21 Jul 2020 22:09:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-components-secret/</guid><description>&lt;p>在 K8S 中通过 configmap 保存了常用配置，但是因为是明文保存会导致安全问题，对于敏感信息可以通过 Secret 保存。&lt;/p></description></item><item><title>Docker 示例 Alpine + OpenSSH</title><link>https://gohalo.github.io/cn/blog/docker-example-sshd/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-example-sshd/</guid><description>&lt;p>SSH 是最常见的远程连接协议，这里通过 Alpine 和 OpenSSH 搭建一个示例。&lt;/p></description></item><item><title>K8S 制作离线镜像</title><link>https://gohalo.github.io/cn/blog/kubernets-create-offline-images/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-create-offline-images/</guid><description>&lt;p>大部分的镜像制作都是通过 Dockerfile 来实现的，基本都是基于基础镜像制作，这里介绍使用 &lt;code>buildah&lt;/code> 来构建基础镜像，可以以此理解其基本原理。&lt;/p></description></item><item><title>Docker Compose 简介</title><link>https://gohalo.github.io/cn/blog/docker-compose-introduce/</link><pubDate>Sun, 22 Dec 2019 21:34:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-compose-introduce/</guid><description>&lt;p>Docker Compose 是 Docker 官方编排项目，用于快速的部署应用。通过 DockerFile 可以快速生成一个容器，如果要多个容器配合使用，那么就可以通过该编排工具完成。&lt;/p></description></item><item><title>Dockerfile 简介</title><link>https://gohalo.github.io/cn/blog/docker-dockerfile/</link><pubDate>Thu, 11 Jul 2019 21:48:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-dockerfile/</guid><description>&lt;p>Dockerfile 可以用来创建一个镜像，允许在该文件中调用一些命令行中的命令，这样可以利用一个基础镜像，然后附加一些基础操作，最后直接自动生成新镜像。&lt;/p></description></item><item><title>K8S Pod 简介</title><link>https://gohalo.github.io/cn/blog/kubernets-components-pod-deployment/</link><pubDate>Tue, 12 Mar 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-components-pod-deployment/</guid><description>&lt;p>K8S 中有各种各样的组件，对于容器来说 K8S 的最小单元由 Pod 进行组成，它封装了一个或多个应用程序的容器、存储资源、网络 IP 以及管理容器的选项。&lt;/p></description></item><item><title>K8S Pause</title><link>https://gohalo.github.io/cn/blog/kubernets-basic-components-pause/</link><pubDate>Sat, 12 Jan 2019 21:50:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-basic-components-pause/</guid><description>&lt;p>在 K8S 的 Slave 节点上，除了本身启动的容器外，还会看到很多的 Pause 容器，一般是一个 Pod 会对应一个 Pause 。&lt;/p>
&lt;p>那么这个 Pause 的用途是什么？&lt;/p></description></item><item><title>Docker Volume 简介</title><link>https://gohalo.github.io/cn/blog/docker-concept-volume-introduce/</link><pubDate>Wed, 02 Aug 2017 21:16:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-concept-volume-introduce/</guid><description>&lt;p>所谓的 Docker 数据持久化，也就是数据不会随着容器的结束而删除，对于像数据库这类的应用，为了能够使数据持久化，提供了 Volume 的概念，简单来说，就是可以绕过默认的联合文件系统，将文件或者目录保存在宿主机上。&lt;/p>
&lt;p>通常有两种：A) Bind Mount 保存在主机上的某个目录；B) Volume 通过 Docker 自己管理的 Volume 。&lt;/p></description></item><item><title>【专题】Linux 容器介绍</title><link>https://gohalo.github.io/cn/blog/topic-linux-container/</link><pubDate>Fri, 12 Mar 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-container/</guid><description/></item></channel></rss>