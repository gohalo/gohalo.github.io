<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on</title><link>https://gohalo.github.io/cn/tags/golang/</link><description>Recent content in golang on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 08 Nov 2023 19:29:18 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>GoLang Promethus 监控系统</title><link>https://gohalo.github.io/cn/blog/golang-monitor-prometheus/</link><pubDate>Wed, 08 Nov 2023 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-monitor-prometheus/</guid><description>&lt;p>这里通过 Prometheus 提供的客户端库添加相关的指标，并通过 HTTP 暴露相关指标。&lt;/p></description></item><item><title>Temporal 微服务架构</title><link>https://gohalo.github.io/cn/blog/golang-framework-temporal/</link><pubDate>Wed, 08 Nov 2023 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-framework-temporal/</guid><description/></item><item><title>OpenTelemetry 标准详解</title><link>https://gohalo.github.io/cn/blog/monitor-opentelemetry-introduce/</link><pubDate>Sat, 21 Oct 2023 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/monitor-opentelemetry-introduce/</guid><description>&lt;p>OpenTelemetry, OTel 是一个中立开源的可观测性框架，用于仪表化、生成、收集和导出诸如跟踪、度量、日志等遥测数据。&lt;/p></description></item><item><title>GoLang 常用模块</title><link>https://gohalo.github.io/cn/blog/golang-basic-module/</link><pubDate>Wed, 26 Oct 2022 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-module/</guid><description>&lt;p>简单介绍常见的模块，例如 fmt、unsafe、signal、container 等。&lt;/p></description></item><item><title>BoltDB 数据库详细介绍</title><link>https://gohalo.github.io/cn/blog/golang-boltdb-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-boltdb-introduce/</guid><description>&lt;p>ETCD 后端存储采用的是 BBolt 存储引擎，其前身是 BoltDB ，这是一款 golang 实现的嵌入式 KV 存储引擎，参考的是 LMDB，支持事务、ACID、MVCC、ZeroCopy、BTree等特性。&lt;/p></description></item><item><title>GoLang 国际化</title><link>https://gohalo.github.io/cn/blog/golang-i18n-introduce/</link><pubDate>Fri, 17 Jun 2022 23:19:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-i18n-introduce/</guid><description>简介 # 有两个容易混淆的概念：A) 本地化 L10n，将软件翻译为本地语言的过程，通常是翻译人员的职责；B) 国际化 i18n，使得软件可以被本地化，通常是开发人员的职责。
代码中有很多需要与人交互的内容，一般需要做一些国际化的处理，通常步骤如下：
从源码中获取需要翻译的字符串。 翻译字符串，有很多的平台支持，甚至有些是免费的。 应用已经翻译的字符串，可以是通过数据库、配置文件方式读取，也可以编译成二进制甚至生成代码。 使用已经翻译字符，包括了 Web 使用 Accept-Language 以及主机上的 LANGUAGE 环境变量。 实际上已经有个 https://golang.org/x/text 代码包支持，官方声明如下。
a repository of text-related packages related to internationalization (i18n) and localization (l10n) 。
其中的 message 库主要用于上述的步骤三，以类似 fmt 的接口来输出已经翻译的字符串，如下是简单示例。
package main import ( &amp;#34;golang.org/x/text/message&amp;#34; &amp;#34;golang.org/x/text/language&amp;#34; ) func main() { p := message.NewPrinter(language.BritishEnglish) p.Printf(&amp;#34;There are %v flowers in our garden.\n&amp;#34;, 1500) p = message.NewPrinter(language.Greek) p.Printf(&amp;#34;There are %v flowers in our garden.</description></item><item><title>GoLang SSH 源码解析</title><link>https://gohalo.github.io/cn/blog/ssh-golang-details/</link><pubDate>Sat, 27 Nov 2021 20:18:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-golang-details/</guid><description>&lt;p>之前的文章已经介绍了简单的示例，这里对部分常用的源码进行解析。&lt;/p></description></item><item><title>Casbin 使用详细介绍</title><link>https://gohalo.github.io/cn/blog/casbin-access-control/</link><pubDate>Sun, 14 Feb 2021 22:39:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/casbin-access-control/</guid><description>&lt;p>Casbin 是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型，注意，其只负责权限控制，没有用户管理的实现。&lt;/p></description></item><item><title>GoLang INI 配置文件解析</title><link>https://gohalo.github.io/cn/blog/golang-ini-config-parse/</link><pubDate>Sun, 09 Aug 2020 21:59:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-ini-config-parse/</guid><description>&lt;p>INI 是 Initialization File 的缩写，也就是初始化文件，原来是 Windows 系统配置文件所采用的存储格式，不过因为其使用简单，所以后来被广泛应用。&lt;/p>
&lt;p>这里介绍如何通过 GoLang 解析。&lt;/p></description></item><item><title>GoLang WebSocket 编程</title><link>https://gohalo.github.io/cn/blog/golang-websocket-program/</link><pubDate>Tue, 28 Jul 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-websocket-program/</guid><description/></item><item><title>GoLang Trace 详解</title><link>https://gohalo.github.io/cn/blog/golang-trace-basic/</link><pubDate>Wed, 15 Apr 2020 21:18:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-trace-basic/</guid><description>&lt;p>GoLang 有很多的 Profile 工具，包括了 CPU、Memory、Blocking 各种 Profiler 实现，也包括了 GC/Scheduler Tracer、Heap Dumper，这些工具大部分提供的是聚合信息，即使 Dump 这种可以查看内存对象的，也很难确定其执行过程。&lt;/p>
&lt;p>于是乎，就有了 Trace 实现。&lt;/p></description></item><item><title>GoLang 单元测试</title><link>https://gohalo.github.io/cn/blog/golang-testing-method/</link><pubDate>Wed, 15 Apr 2020 21:18:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-testing-method/</guid><description>&lt;p>程序开发中比较重要的一点是如何可以高效的进行单元测试，可以保证快速发现定位问题，在 GoLang 中自带了一个轻量级的测试框架 &lt;code>testing&lt;/code> 以及 &lt;code>go test&lt;/code> 命令来实现单元测试和性能测试。&lt;/p></description></item><item><title>GoLang Echo 简介</title><link>https://gohalo.github.io/cn/blog/golang-echo-http-framework/</link><pubDate>Thu, 05 Mar 2020 22:28:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-echo-http-framework/</guid><description>&lt;p>echo web 框架是通过 GoLang 开发的一种高性能、可扩展、轻量级的 web 框架，只包含了 MVC 框架的 C 部分，也就是负责 URL 路由和控制器部分，对于 V 视图和 M 数据操作可以使用自己喜欢的工具库来实现。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>gRPC 源码解析</title><link>https://gohalo.github.io/cn/blog/golang-grpc-source-code-details/</link><pubDate>Tue, 29 Oct 2019 23:19:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-grpc-source-code-details/</guid><description>gRPC 是一个通用的 RPC 框架，这里简单看下 GoLang 中 gRPC 的实现。
简介 # 整个 RPC 服务的调用流程如下：
client 调用 client stub，这是一次本地过程调用； client stub 将参数打包成消息，然后发送这个消息，打包过程(序列化)也叫做 marshalling； client 所在的系统将消息发送给 server； server 的将收到的包传给 server stub； server stub 解包得到参数，解包(反序列化) 也被称作 unmarshalling； 最后 server stub 调用服务过程，返回结果按照相反的步骤传给 client 。
目录结构 # 在 gRPC 目录下有许多常用的包，例如：
metadata # 定义了 gRPC 所支持的元数据结构，包中方法可以对 MD 进行获取和处理。
Client # 对于代码中，实际调用流程为。
c := pb.NewGreeterClient(conn) r, err := c.SayHello(ctx, &amp;amp;pb.HelloRequest{Name: name}) Dial() clientconn.go |-DialContext() 除了个函数的入参，同时会新建一个CTX |-context.WithCancel() 创建所使用的上下文 Server # 一般来说分为了如下几步操作：</description></item><item><title>gRPC 基本介绍</title><link>https://gohalo.github.io/cn/blog/golang-grpc-introduce/</link><pubDate>Sat, 19 Oct 2019 23:19:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-grpc-introduce/</guid><description>&lt;p>gRPC 一开始由 google 开发，是一款开源的远程过程调用 (RPC) 系统。&lt;/p>
&lt;p>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，能够更容易地创建分布式应用和服务。&lt;/p></description></item><item><title>GoLang pprof 模块介绍</title><link>https://gohalo.github.io/cn/blog/golang-common-module-pprof-performace-introduce/</link><pubDate>Mon, 05 Aug 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-pprof-performace-introduce/</guid><description>&lt;p>GoLang 提供了非常强大的代码性能分析工具 pprof，可以非常方便的分析代码运行性能，同时非常直观。&lt;/p></description></item><item><title>GoLang Delve 调试工具</title><link>https://gohalo.github.io/cn/blog/golang-debug-delve/</link><pubDate>Tue, 23 Jul 2019 22:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-debug-delve/</guid><description>&lt;p>Delve 是 GoLang 的三方调试器，相比 GDB 来说能更好的理解 GoLang 的运行时，包括数据结构、表达式等，目前支持 Linux、Windows 以及 Mac 等平台。&lt;/p></description></item><item><title>GoLang 逃逸分析</title><link>https://gohalo.github.io/cn/blog/golang-escape-analysis-introduce/</link><pubDate>Mon, 03 Jun 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-escape-analysis-introduce/</guid><description/></item><item><title>GoLang 陷阱</title><link>https://gohalo.github.io/cn/blog/golang-some-pitfalls-introduce/</link><pubDate>Fri, 03 May 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-some-pitfalls-introduce/</guid><description>&lt;p>简单列举一些 GoLang 中容易犯的错误。&lt;/p></description></item><item><title>GoLang 内存模型</title><link>https://gohalo.github.io/cn/blog/golang-concept-memory-module-introduce/</link><pubDate>Wed, 01 May 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-memory-module-introduce/</guid><description>&lt;p>在 Golang 中所谓的内存模型，定义的是，对多个协程中共享的变量，一个协程中怎样可以看到其它协程的写入。&lt;/p>
&lt;p>当多个协程同时操作一个数据时，可以通过管道、同步原语 (sync 包中的 Mutex 以及 RWMutex)、原子操作 (sync/atomic 包中)。&lt;/p>
&lt;p>除此之外，为了保证语义的正确性，Golang 还对一些常见的场景做了语义上的约束。&lt;/p></description></item><item><title>GoLang 基本语法介绍</title><link>https://gohalo.github.io/cn/blog/golang-basic-syntax/</link><pubDate>Thu, 25 Apr 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-syntax/</guid><description>&lt;p>简单介绍常见的语法，例如 import、异常处理、反射等。&lt;/p></description></item><item><title>GoLang Gopher</title><link>https://gohalo.github.io/cn/blog/golang-concept-much-more-gopher-introduce/</link><pubDate>Tue, 16 Apr 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-much-more-gopher-introduce/</guid><description>&lt;p>在人类自然语言学界有一个很著名的 &amp;ldquo;萨丕尔-沃夫&amp;rdquo; 假说，语言影响或决定人类的思维方式。&lt;/p>
&lt;p>Language inuences/determines thought. - Sapir-Whorf hypothesis&lt;/p>
&lt;p>那么 Gopher 的价值观是什么。&lt;/p></description></item><item><title>GoLang 调度机制</title><link>https://gohalo.github.io/cn/blog/golang-concept-scheduler-introduce/</link><pubDate>Mon, 15 Apr 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-scheduler-introduce/</guid><description>&lt;p>在 Go 语言中的核心是协程，其实现在用户态，那么就需要在用户态实现其调度器，在 1.1 版本对调度器进行了重构，也就是现在的 GMP 模型。&lt;/p>
&lt;p>另外，为了防止协程不让出 CPU 导致其它协程饿死，在 1.2 版本加入了强占式调度器。&lt;/p></description></item><item><title>GoLang 反射简介</title><link>https://gohalo.github.io/cn/blog/golang-reflect-introduce/</link><pubDate>Sat, 06 Apr 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-reflect-introduce/</guid><description>&lt;p>与 C/C++ 不同，GoLang 的指针是不支持指针运算和转换，GoLang 是静态语言，所有变量必须标明其类型，不同类型变量不能执行赋值、比较、计算等操作；指针也有其对应的类型，在编译阶段同样会进行检查。&lt;/p>
&lt;p>同时，GoLang 在运行阶段提供了一定的灵活性。&lt;/p></description></item><item><title>GoLang 接口源码解析</title><link>https://gohalo.github.io/cn/blog/golang-interface-source-code-introduce/</link><pubDate>Thu, 28 Mar 2019 20:23:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-interface-source-code-introduce/</guid><description/></item><item><title>Golang 竞态检查</title><link>https://gohalo.github.io/cn/blog/golang-race-condition-introduce/</link><pubDate>Fri, 08 Mar 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-race-condition-introduce/</guid><description>&lt;p>Race Conditions 是最隐晦而且难以捉摸的编程错误之一，一般会在代码部署到生产之后很长时间才会发作，但是如果要通过 Golang 进行并发编程，那么就会很容易遇到。&lt;/p>
&lt;p>Go 的并发机制使得编写干净并发代码变得容易，但它们并不能防止竞态条件。&lt;/p></description></item><item><title>GoLang 管道详解</title><link>https://gohalo.github.io/cn/blog/golang-basic-syntax-channel-introduce/</link><pubDate>Fri, 01 Mar 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-syntax-channel-introduce/</guid><description>&lt;p>在 Go 语言中，通过协程和管道实现了 Communicating Sequential Processes, CSP 模型，两者承担了通信和同步中的重要角色。&lt;/p></description></item><item><title>GoLang 汇编语言</title><link>https://gohalo.github.io/cn/blog/golang-assembly-language-introduce/</link><pubDate>Sat, 23 Feb 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-assembly-language-introduce/</guid><description>&lt;p>现在的汇编通常作为从高阶语言到机器码的中间产品，表示方式常见的有 Intel 以及 AT&amp;amp;T 两种，不知道为啥 GoLang 选择的是参考 Plan 9 这种汇编语言，其使用的方式与前两者有很大的区别。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>GoLang 内存管理</title><link>https://gohalo.github.io/cn/blog/golang-concept-memory-management-module-introduce/</link><pubDate>Wed, 20 Feb 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-memory-management-module-introduce/</guid><description>&lt;p>在 C 语言中，通过 &lt;code>malloc()&lt;/code> 函数可以动态分配内存，常用的有 ptmalloc2(glib)、tcmalloc(Google)、jemaloc(FaceBook)，后两者在避免内存碎片以及性能上都有较大的优势。&lt;/p>
&lt;p>而 Go 中的内存分配器，其原理与 tcmalloc 类似，简单的说就是维护一块大的全局内存，每个线程 (P) 维护一块小的私有内存，私有内存不足再从全局申请。&lt;/p></description></item><item><title>Golang 语法之结构体</title><link>https://gohalo.github.io/cn/blog/golang-syntax-structure-introduce/</link><pubDate>Sun, 30 Dec 2018 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-syntax-structure-introduce/</guid><description>&lt;p>类似于 C 中的结构体，也就是用户自定义的类型，它代表若干字段的集合。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>APM 分布式跟踪系统</title><link>https://gohalo.github.io/cn/blog/monitor-apm-introduce/</link><pubDate>Tue, 23 Oct 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/monitor-apm-introduce/</guid><description>&lt;p>目前的产品架构，分布式系统得到了大范围的应用，使得系统更加灵活，不过同时也给开发、运维人员也带来了很大的难题，如何监控和优化分布式系统的行为。&lt;/p>
&lt;p>这里简单介绍下一个小众、简单的 APM 监控工具。&lt;/p></description></item><item><title>GoLang 闭包简介</title><link>https://gohalo.github.io/cn/blog/golang-basic-closure-introduce/</link><pubDate>Tue, 25 Sep 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-closure-introduce/</guid><description>&lt;p>在很多语言里实际上都支持闭包，例如 Python、Lua 等，GoLang 实际上也支持，功能基本类似，如果对闭包的概念比较熟悉，实际上也很好理解。&lt;/p>
&lt;p>这里简单介绍其概念以及常见的错误使用场景。&lt;/p></description></item><item><title>GoLang 异常处理</title><link>https://gohalo.github.io/cn/blog/golang-basic-error-panic/</link><pubDate>Sat, 15 Sep 2018 21:39:58 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-error-panic/</guid><description>&lt;p>Golang 中的错误处理是一个被大家经常拿出来讨论的话题(另外一个是泛型)，这里简单介绍其使用方法。&lt;/p></description></item><item><title>GoLang 并发控制</title><link>https://gohalo.github.io/cn/blog/golang-concurrent-control/</link><pubDate>Mon, 10 Sep 2018 18:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concurrent-control/</guid><description>&lt;p>协程不像进程或者线程可以被抢占，也就是可以强制退出，但是协程需要通过协作方式完成调度，也就是只能主动退出，如下是几种常见的退出方式。&lt;/p></description></item><item><title>GoLang 基本介绍</title><link>https://gohalo.github.io/cn/blog/golang-basic-introduce/</link><pubDate>Tue, 21 Aug 2018 21:09:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-introduce/</guid><description>&lt;p>GoLang 目前越来越火，包括了 Docker、InfluxDB、etcd 等等，越来越多的工程都在使用 GoLang 。虽然它的语法都比较 &amp;ldquo;奇葩&amp;rdquo;，一些高级语言支持的特性却都不支持，但其高并发、高效率等等，也使其热度不减。&lt;/p>
&lt;p>这篇文章主要简单介绍下 GoLang 环境的搭建。&lt;/p></description></item><item><title>GORM 关联操作基本概念</title><link>https://gohalo.github.io/cn/blog/golang-db-gorm-preload/</link><pubDate>Sun, 19 Aug 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-db-gorm-preload/</guid><description>&lt;p>关于 GORM 有些与常规 ORM 不同的基本概念，理解这些概念对于使用 GROM 函数会有很大帮助，而不是简单使用 RAW SQL 实现。&lt;/p></description></item><item><title>GORM 源码解析</title><link>https://gohalo.github.io/cn/blog/golang-db-gorm-source/</link><pubDate>Sun, 19 Aug 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-db-gorm-source/</guid><description/></item><item><title>GoLang DB 操作简介</title><link>https://gohalo.github.io/cn/blog/golang-db-introduce/</link><pubDate>Sat, 19 May 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-db-introduce/</guid><description>&lt;p>GoLang 提供了标准包用于对 SQL 数据库进行访问，作为操作数据库的入口对象 sql.DB, 主要为提供了两个重要的功能：A) 提供管理底层数据库连接的打开和关闭操作；B) 管理数据库连接池。&lt;/p>
&lt;p>需要注意的是，sql.DB 表示操作数据库的抽象访问接口，而非一个数据库连接对象，会根据实际的驱动打开关闭数据库连接，管理连接池。&lt;/p>
&lt;p>这里简单介绍 MySQL 的使用方式。&lt;/p></description></item><item><title>GoLang HTTP 使用简介</title><link>https://gohalo.github.io/cn/blog/golang-http-webserver-introduce/</link><pubDate>Fri, 27 Apr 2018 18:13:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-http-webserver-introduce/</guid><description>&lt;p>除去细节，理解 HTTP 构建的网络应用只要关注客户端和服务端的处理，服务器主要用来接收客户端的请求，然后返回响应，在接收请求并处理的过程中，最重要的莫过于路由 (Router)。&lt;/p>
&lt;p>这里简单介绍如何使用 &lt;code>net/http&lt;/code> 构建 HTTP 请求。&lt;/p></description></item><item><title>Golang 语法之接口</title><link>https://gohalo.github.io/cn/blog/golang-syntax-interface-introduce/</link><pubDate>Fri, 30 Mar 2018 20:23:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-syntax-interface-introduce/</guid><description>&lt;p>在 Go 语言的实际编程中，几乎所有的数据结构都围绕 Interface 展开，这是 GoLang 中所有数据结构的核心。&lt;/p>
&lt;p>首先，Go 不是一种典型的 OO 语言，它在语法上不支持类和继承的概念，而通过 Interface 可以看到多态的影子。&lt;/p></description></item><item><title>GoLang time 模块</title><link>https://gohalo.github.io/cn/blog/golang-common-module-time-introduce/</link><pubDate>Mon, 26 Mar 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-time-introduce/</guid><description>&lt;p>GoLang 中的 time 模块包含了一些与时间相关的函数，例如格式转换、定时器等。&lt;/p></description></item><item><title>JWT 简介</title><link>https://gohalo.github.io/cn/blog/golang-json-web-token-jwt/</link><pubDate>Tue, 13 Feb 2018 21:27:20 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-json-web-token-jwt/</guid><description>&lt;p>在程序开发中，用户认证授权是一个绕不过的重难点，以前的开发模式下，cookie 和 session 认证是主流，随着前后端分离的趋势，基于 Token 的认证方式成为主流。&lt;/p>
&lt;p>而 JWT(RFC 7519) 是基于 Token 认证方式的一种机制，是实现单点登录认证的一种有效方法。&lt;/p>
&lt;p>这里详细介绍其设计和使用方式。&lt;/p></description></item><item><title>GORM 操作简介</title><link>https://gohalo.github.io/cn/blog/golang-db-gorm-basic/</link><pubDate>Fri, 19 Jan 2018 21:09:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-db-gorm-basic/</guid><description>&lt;p>Object Relational Mapping, ORM 对象关系映射，用于将数据库中的数据与代码中的结构体进行映射，不同语言的实现方式略有区别，但是目的基本相同。&lt;/p>
&lt;p>GoLang 中有多种映射库，这里简单介绍常见的 GORM 使用方式。&lt;/p></description></item><item><title>GoLang 模板使用简介</title><link>https://gohalo.github.io/cn/blog/golang-template-introduce/</link><pubDate>Tue, 09 Jan 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-template-introduce/</guid><description>&lt;p>在前后端分离的时代，模板语言使用的已经很少了，不过很多特定的场景还是很有用的，这里介绍其基本使用方法。&lt;/p></description></item><item><title>ETCD 源码解析</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-details/</link><pubDate>Fri, 15 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-details/</guid><description>&lt;p>在上篇 &lt;a href="https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/">ETCD 示例源码&lt;/a> 中介绍了 ETCD 代码中 RAFT 相关的示例代码，接着介绍与 ETCD 相关的代码。&lt;/p></description></item><item><title>ETCD 示例源码</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/</link><pubDate>Wed, 15 Nov 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/</guid><description>&lt;p>现在已知的 Golang 版本的 RAFT 的开源实现主要有两个：一个是 CoreOS 的 etcd 中的实现，使用的项目有比如 tidb、cockroachdb 等；另外一个是 hashcorp 的 RAFT 实现，使用的项目有比如 consul、InfluxDB 等。&lt;/p>
&lt;p>相比而言，前者只实现了一个整体框架，很多的功能需要用户实现，难度增加但是更加灵活；而后者则是完整的实现，WAL、SnapShot、存储、序列化等。&lt;/p></description></item><item><title>GoLang Array VS. Slice</title><link>https://gohalo.github.io/cn/blog/golang-array-slice-concept-introduce/</link><pubDate>Wed, 18 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-array-slice-concept-introduce/</guid><description>&lt;p>两者十分类似，很容易造成混淆。&lt;/p></description></item><item><title>GoLang 日志模块使用介绍</title><link>https://gohalo.github.io/cn/blog/golang-log-module-introduce/</link><pubDate>Mon, 16 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-log-module-introduce/</guid><description>&lt;p>打印日志是最常规的需求，GoLang 的基础库只提供了简单的格式化功能，但是很多基础功能不存在，例如日志级别、文件切割等等。&lt;/p>
&lt;p>这里介绍 Uber 开发的一个日志库 ZAP 。&lt;/p></description></item><item><title>GoLang 网络编程</title><link>https://gohalo.github.io/cn/blog/golang-example-socket-introduce/</link><pubDate>Sat, 14 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-example-socket-introduce/</guid><description>&lt;p>Golang 对 TCP 做了很好的抽象，而且提供了很高的性能，其底层的 netpoller 通过非阻塞的 IO 多路复用实现，然后再结合协程的调度，使得用户在编程时实际是阻塞接口。&lt;/p></description></item><item><title>GoLang sync 模块介绍</title><link>https://gohalo.github.io/cn/blog/golang-common-module-sync-introduce/</link><pubDate>Sun, 11 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-sync-introduce/</guid><description/></item><item><title>Golang nil 解析</title><link>https://gohalo.github.io/cn/blog/golang-basic-concept-nil-introduce/</link><pubDate>Sat, 10 Jun 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-concept-nil-introduce/</guid><description/></item><item><title>Golang bytes 模块</title><link>https://gohalo.github.io/cn/blog/golang-common-module-bytes-introduce/</link><pubDate>Thu, 08 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-bytes-introduce/</guid><description>&lt;p>Golang 中的 bytes 包使用频率较高，主要提供了字节相关的操作，通常作为缓冲区使用。&lt;/p></description></item><item><title>Golang 调试方法</title><link>https://gohalo.github.io/cn/blog/golang-call-frame-debug-method-introduce/</link><pubDate>Thu, 08 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-call-frame-debug-method-introduce/</guid><description/></item><item><title>详细介绍 GoLang 的包管理机制</title><link>https://gohalo.github.io/cn/blog/golang-package-management/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-package-management/</guid><description>&lt;p>当拿到代码后，用户首先看到和接触的就是源码文件的布局、命名还有包的结构，代码漂亮、布局清晰、通俗易懂，就像是设计严谨的 API 一样。GoLang 的包管理经历了好几个阶段，从简单的通过环境变量管理，到现在完善的机制。&lt;/p>
&lt;p>相比其它语言，GoLang 的包管理机制对包、变量、代码格式，甚至代码组织结构等，都有详细的约束，这里详细介绍其包管理的规则。&lt;/p></description></item><item><title>GoLang JSON 编码解码</title><link>https://gohalo.github.io/cn/blog/golang-json-encode-decode-introduce/</link><pubDate>Fri, 07 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-json-encode-decode-introduce/</guid><description>&lt;p>随着 REST API 的兴起，基本上已经前后端分离，更多的返回格式是 json 字符串，这里简单讨论下在 GoLang 中如何编码和解码 JSON 结构。&lt;/p>
&lt;p>GoLang 提供了 &lt;code>encoding/json&lt;/code> 的标准库用于 JSON 的处理，简单记录 GoLang 中使用 JSON 的常用技巧。&lt;/p></description></item><item><title>GoLang 常用工具</title><link>https://gohalo.github.io/cn/blog/golang-some-third-tools/</link><pubDate>Mon, 08 Aug 2016 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-some-third-tools/</guid><description>&lt;p>这里简单介绍下 GoLang 中常用的工具，包括了 GVM、GDM、Goreman 等。&lt;/p></description></item><item><title>GoLang 实现 SSH 相关示例</title><link>https://gohalo.github.io/cn/blog/ssh-golang-examples/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-golang-examples/</guid><description>&lt;p>GoLang 提供了基础的 SSH 库，可以用来作为服务端或者客户端使用，这里整理了常见的用法。&lt;/p></description></item><item><title>GoLang 参数校验</title><link>https://gohalo.github.io/cn/blog/golang-validator-introduce/</link><pubDate>Sat, 12 Mar 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-validator-introduce/</guid><description>&lt;p>接口开发经常会遇到一个问题是后端需要大量代码进行参数校验，防止用户的恶意请求。最常见的如日期格式、用户年龄、性别等必须是正常的值，不能随意设置。&lt;/p>
&lt;p>这里介绍 GoLang 中的一个参数校验库。&lt;/p></description></item><item><title>GoLang Echo 中间件</title><link>https://gohalo.github.io/cn/blog/golang-echo-middleware/</link><pubDate>Tue, 06 Oct 2015 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-echo-middleware/</guid><description>&lt;p>Echo 中间件指的是可以拦截 http 请求的特殊函数，在请求和响应中间可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。&lt;/p></description></item><item><title>【专题】GoLang 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-golang/</link><pubDate>Wed, 06 Oct 2010 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-golang/</guid><description>&lt;p>GoLang 是谷歌 2009 年发布的开源编程语言，其开发人员都是计算机界大神一般的存在，提供了便捷的协程使用，具有很高的并发性。目前很多 Cloud Native 软件都是通过 GoLang 编写，例如 Docker、K8S、LXD 等等。&lt;/p></description></item></channel></rss>