<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Structure on</title><link>https://gohalo.github.io/cn/tags/structure/</link><description>Recent content in Structure on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 19 Sep 2022 21:15:12 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/structure/index.xml" rel="self" type="application/rss+xml"/><item><title>Perisistend Data Structure 详解</title><link>https://gohalo.github.io/cn/blog/concurrency-persistent-data-structure/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-persistent-data-structure/</guid><description/></item><item><title>优先队列详细介绍</title><link>https://gohalo.github.io/cn/blog/structure-heap/</link><pubDate>Mon, 17 Aug 2020 18:19:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-heap/</guid><description>&lt;p>堆 (Heap) 又被为优先队列 (Priority Queue)，通过堆可以按照元素的优先级取出元素，而不是按照元素进入队列的先后顺序取出元素。&lt;/p>
&lt;p>这里详细介绍其实现。&lt;/p></description></item><item><title>二叉搜索树</title><link>https://gohalo.github.io/cn/blog/structure-binary-search-tree/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-binary-search-tree/</guid><description/></item><item><title>并查集详细介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-union-find/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-union-find/</guid><description>&lt;p>并查集 Union-Find 算法，顾名思义，用作合并集合、查找集合元素，通常用来解决图论中动态连通性问题，当然也包括了分类。&lt;/p>
&lt;p>这里详细介绍基本概念。&lt;/p></description></item><item><title>自平衡二叉搜索树</title><link>https://gohalo.github.io/cn/blog/structure-avl-tree/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-avl-tree/</guid><description>&lt;p>为了保证树的高度，也就出现了如下的平衡二叉树，例如 AVL Tree、Red-Black Tree 等，两者都是针对可能出现的不同场景进行调整，从而达到了平衡状态，但是两者处理不平衡状态都不太好记忆，而且死板。&lt;/p>
&lt;p>这里先介绍下自平衡二叉树的实现。&lt;/p></description></item><item><title>树基本介绍</title><link>https://gohalo.github.io/cn/blog/structure-tree/</link><pubDate>Tue, 16 Jun 2020 18:43:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-tree/</guid><description>&lt;p>通过树可以用来描述层级结构数据，基本上有序列的地方就可以应用树，因为树结构即是一种序列索引结构。&lt;/p>
&lt;p>这里简单介绍常见的树结构。&lt;/p></description></item><item><title>数据结构 -- SkipList</title><link>https://gohalo.github.io/cn/blog/structure-skiplist-introduce/</link><pubDate>Fri, 20 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-skiplist-introduce/</guid><description>&lt;p>William Pugh 于 1990 年发表了 &lt;code>Skip lists: a probabilistic alternative to balanced trees&lt;/code> 论文，也就是设计初衷是作为替换平衡树的一种选择，这是一种随机化数据结构，基于并联的链表，其效率可比拟二叉查找树。&lt;/p>
&lt;p>同时，可以支持排序。&lt;/p></description></item></channel></rss>