<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>kernel on</title><link>https://gohalo.github.io/cn/tags/kernel/</link><description>Recent content in kernel on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 19 Jan 2019 20:19:30 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux PID 分配方法</title><link>https://gohalo.github.io/cn/blog/linux-pid-allocate-method-introduce/</link><pubDate>Sat, 19 Jan 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-pid-allocate-method-introduce/</guid><description>&lt;p>在 Linux 系统中，每个进程都有一个非负整型表示的唯一进程 ID，虽然在主机级别是唯一的，但是进程的 ID 可以重用，一个进程停止后，其它的进程可以复用该 ID 。&lt;/p>
&lt;p>Linux 采用延迟重用的算法，在大部分场景下会使得新进程 ID 不同于最近终止进程所使用的 ID，以防止将新进程误认为是使用同一 ID 的某个已终止的先前进程。&lt;/p>
&lt;p>这里主要讨论了 Linux 中分配进程 ID 的方法以及源码实现。&lt;/p></description></item><item><title>Linux Write API 简介</title><link>https://gohalo.github.io/cn/blog/linux-kernel-vfs-multi-write-methods-introduce/</link><pubDate>Tue, 08 Jan 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-vfs-multi-write-methods-introduce/</guid><description>&lt;p>之前其实已经介绍过，Linux 中有条设计原则，&amp;ldquo;一切都是文件&amp;rdquo; 。&lt;/p>
&lt;p>对于文件的操作除了 &lt;code>open()&lt;/code> &lt;code>close()&lt;/code> 之外，使用比较多的就是 &lt;code>read()&lt;/code> 和 &lt;code>write()&lt;/code> 函数了，为了适配不同的应用场景，实际上，Linux 还提供了 &lt;code>writev()&lt;/code> &lt;code>pwrite()&lt;/code> 之类的函数。&lt;/p>
&lt;p>那么，这些函数的区别、使用场景是什么。&lt;/p></description></item><item><title>Linux 进程退出码</title><link>https://gohalo.github.io/cn/blog/linux-process-exit-code-introduce/</link><pubDate>Sun, 04 Nov 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-exit-code-introduce/</guid><description>&lt;p>Linux 下进程的退出包括了正常退出和异常退出，正常退出包括了 A) &lt;code>main()&lt;/code> 函数中通过 &lt;code>return&lt;/code> 返回；B) 调用 &lt;code>exit()&lt;/code> 或者 &lt;code>_exit()&lt;/code> 退出。异常退出包括了 A) &lt;code>abort()&lt;/code> 函数；B) 收到了信号退出。&lt;/p>
&lt;p>不管是哪种退出方式，系统最终都会执行内核中的同一代码，并将进程的退出方式以返回码的方式保存下来。&lt;/p></description></item><item><title>容器之 CGroup</title><link>https://gohalo.github.io/cn/blog/linux-container-cgroup-introduce/</link><pubDate>Fri, 21 Sep 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-container-cgroup-introduce/</guid><description>&lt;p>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制进程组使用资源的机制，该项目最早是由 Google 的工程师 (主要时 Paul Menage 和 Rohit Seth) 在 2006 年发起，开始被称为进程容器 (Process Containers)。&lt;/p>
&lt;p>在 2007 年，因为 Linux 内核中容器这一名词太过广泛，为避免混乱，重命名为 cgroup ，并且合并到 2.6.24 版本的内核中。&lt;/p>
&lt;p>随着其功能逐渐完善，开始作为 LXC、容器等资源隔离机制的基础，这里详细介绍其使用机制。&lt;/p></description></item><item><title>Systemd 服务管理</title><link>https://gohalo.github.io/cn/blog/linux-systemd-notify-watchdog-introduce/</link><pubDate>Mon, 27 Aug 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-systemd-notify-watchdog-introduce/</guid><description>&lt;p>Systemd 提供了很多系统服务的基本功能，包括了系统的系统进程、启动级别、cgroup 管理、进程管理等等。&lt;/p>
&lt;p>这里简单介绍进程管理功能。&lt;/p></description></item><item><title>Linux OOM 简介</title><link>https://gohalo.github.io/cn/blog/kernel-memory-oom-killer-introduce/</link><pubDate>Wed, 01 Aug 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-oom-killer-introduce/</guid><description/></item><item><title>Linux Cache VS. Buffer</title><link>https://gohalo.github.io/cn/blog/linux-memory-buffer-vs-cache-details/</link><pubDate>Sat, 28 Jul 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-memory-buffer-vs-cache-details/</guid><description>&lt;p>实际上 Buffer 和 Cache 是两个用烂的词，在不同的场景下其语义会有所区别。在 Linux 的内存管理中，Buffer 是指 Buffer Cache(缓冲区缓存)，Cache 是指 Page Cache(页面缓存)。&lt;/p>
&lt;p>这里简单介绍其概念。&lt;/p></description></item><item><title>Linux Hang Task 简介</title><link>https://gohalo.github.io/cn/blog/linux-kernel-hang-task-panic-introduce/</link><pubDate>Sat, 30 Jun 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-hang-task-panic-introduce/</guid><description>&lt;p>长期以来，处于 D 状态的进程都是让人比较烦恼的问题，此时不能接收信号，不能 &lt;code>kill&lt;/code> 掉，用户对此基本是无能为力，而且也很难知道发生的原因，一般来说只能重启服务器恢复。&lt;/p>
&lt;p>正常来说 D 状态的任务只有在 IO 操作时会有，而且会很快完成，只有在极端的异常场景下才会出现问题，例如磁盘损坏、NFS 的 bug 等等，不过如果驱动写的完善的话，一般会增加超时机制，原则上不会出现永久的 D 状态进程。&lt;/p>
&lt;p>也就是说，只有在内核驱动不合理的时候可能会导致进程长期处于 D 状态，无法唤醒，类似于死锁状态。&lt;/p></description></item><item><title>Linux 信号 VS. 线程</title><link>https://gohalo.github.io/cn/blog/linux-signal-vs-thread/</link><pubDate>Thu, 07 Jun 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-signal-vs-thread/</guid><description>&lt;p>在开发多线程应用时，考虑到线程安全，一般会通过 &lt;code>pthread_mutex()&lt;/code> 去保护全局变量。如果应用中使用了信号，信号在被处理后应用程序还将正常运行，那么此时就需要正确的处理。&lt;/p>
&lt;p>一般来说，需要在指定的线程中以同步的方式处理，以避免由于处理异步信号而给程序运行带来的不确定性风险。&lt;/p></description></item><item><title>Linux 信号机制</title><link>https://gohalo.github.io/cn/blog/kernel-signal-introduce/</link><pubDate>Sat, 25 Nov 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-signal-introduce/</guid><description>&lt;p>软中断信号 (简称为信号) 是用来通知进程发生了异步事件，是在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。&lt;/p>
&lt;p>信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。&lt;/p>
&lt;p>进程之间可以互相通过系统调用 kill 发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。&lt;/p>
&lt;p>信号机制除了基本通知功能外，还可以传递附加信息。&lt;/p></description></item><item><title>Inotify 机制详解</title><link>https://gohalo.github.io/cn/blog/kernel-inotify-introduce/</link><pubDate>Wed, 11 Oct 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-inotify-introduce/</guid><description>日常工作中，经常会需要知道某些文件上的变化，一般是通过轮询机制检查文件的变化，不过这样非常低效。
Inotify 是一种文件变化通知机制，Linux 内核从 2.6.13 开始引入，而 BSD 和 Mac OS 系统中比较有名的是 kqueue，可以高效地实时跟踪文件系统的变化。
这里简单介绍其使用方法。
简介 # 可以通过如下方式查看是否支持 Inotify 机制。
$ grep INOTIFY_USER /boot/config-$(uname -r) CONFIG_INOTIFY_USER=y 如果输出 CONFIG_INOTIFY_USER=y 那么就表示系统支持 inotify 机制。
源码实现 # 在用户态主要通过三个系统调用，首先是要创建 inotify 实例。
#include &amp;lt;sys/inotify.h&amp;gt; int inotify_init(void); int inotify_init1(int flags); 每个 inotify 实例对应一个独立的排序的队列，文件系统的变化事件被称做 watches 的一个对象管理，每一个 watch 是一个二元组：
目标，可以是文件或目录； 事件掩码，应用希望关注的 inotify 事件，每位对应一个 inotify 事件。 Watch 对象通过 watch 描述符引用，其中，目录 watches 将返回在该目录下的所有文件上面发生的事件。
下面函数用于添加一个 watch 。
#include &amp;lt;sys/inotify.h&amp;gt; int inotify_add_watch(int fd, const char *pathname, uint32_t mask); 参数： fd 如上的 inotify_init() 返回的文件描述符； path 被监视的目标的路径名，可以是文件名或目录名； mask 事件掩码，在头文件 `linux/inotify.</description></item><item><title>CentOS 内核、软件升级</title><link>https://gohalo.github.io/cn/blog/centos-update-version/</link><pubDate>Fri, 01 Sep 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/centos-update-version/</guid><description>&lt;p>CentOS 使用 yum 管理包以及升级内核，不过为了保持稳定，一般官方仓库提供的内核版本往往小于 Linux 的正式版本。&lt;/p>
&lt;p>这里简单介绍如何使用三方仓库进行升级。&lt;/p></description></item><item><title>Linux 信号安全</title><link>https://gohalo.github.io/cn/blog/linux-signal-safe-introduce/</link><pubDate>Wed, 05 Apr 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-signal-safe-introduce/</guid><description>&lt;p>最近遇到比较奇葩的问题，在信号处理函数中，为了方便查看收到的是何信号，会打印相关的日志，不过也因此在连续收到信号时导致死锁。&lt;/p>
&lt;p>这里简单排查下原因，以及如何进行规避。&lt;/p></description></item><item><title>Linux 进程状态</title><link>https://gohalo.github.io/cn/blog/linux-process-state-introduce/</link><pubDate>Thu, 16 Feb 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-state-introduce/</guid><description>&lt;p>Linux 中的进程在不同的阶段会通过其状态显示，一般来说会有 7 种，相当于一个状态机运行。&lt;/p>
&lt;p>这里简单介绍，以及一些常见的特殊状态。&lt;/p></description></item><item><title>Linux 进程优先级</title><link>https://gohalo.github.io/cn/blog/linux-process-exec-priority-nice-introduce/</link><pubDate>Thu, 12 Jan 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-exec-priority-nice-introduce/</guid><description/></item><item><title>Linux IO 调度器</title><link>https://gohalo.github.io/cn/blog/linux-kernel-io-scheduler/</link><pubDate>Sun, 05 Jun 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-io-scheduler/</guid><description>&lt;p>用来决定块设备上 IO 操作提交顺序的方法，主要是用于提高吞吐量、降低响应时间。然而两者是相互矛盾的，为了尽量平衡这两者，Linux 内核提供了多种调度算法来适应不同的 IO 请求场景。&lt;/p>
&lt;p>这里简单介绍下 Linux 中的 IO 调度器。&lt;/p></description></item><item><title>Linux 内核模块</title><link>https://gohalo.github.io/cn/blog/kernel-modules/</link><pubDate>Tue, 23 Feb 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-modules/</guid><description>&lt;p>简单介绍下 Linux 中的内核模块编写，包括了内核签名机制的配置。&lt;/p></description></item><item><title>Linux 进程执行简介</title><link>https://gohalo.github.io/cn/blog/kernel-process-introduce/</link><pubDate>Thu, 05 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-process-introduce/</guid><description>&lt;p>简单介绍一下 Linux 中的常见的一些与进程相关的操作，主要是执行命令、守护进程等。&lt;/p></description></item><item><title>Kernel 映射文件</title><link>https://gohalo.github.io/cn/blog/kernel-memory-mmap-introduce/</link><pubDate>Fri, 16 Oct 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-mmap-introduce/</guid><description>&lt;p>mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。&lt;/p>
&lt;p>这里简单介绍下如何使用。&lt;/p></description></item><item><title>Linux IO 多路复用</title><link>https://gohalo.github.io/cn/blog/linux-program-io-multiplexing/</link><pubDate>Sat, 12 Sep 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-io-multiplexing/</guid><description>&lt;p>通过 IO 多路复用技术，系统内核缓冲 IO 数据，当某个 IO 准备好后，系统通知应用程序该 IO 可读或可写，这样应用程序可以马上完成相应的 IO 操作，而不需要等待系统完成相应 IO 操作，从而应用程序不必因等待 IO 操作而阻塞。&lt;/p>
&lt;p>这里简单介绍下 Linux 中 IO 多路复用的使用。&lt;/p></description></item><item><title>Kernel 进程相关</title><link>https://gohalo.github.io/cn/blog/kernel-process-details/</link><pubDate>Tue, 02 Jun 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-process-details/</guid><description>&lt;p>实际上一个进程，包括了代码、数据和分配给进程的资源，这是一个动态资源。&lt;/p>
&lt;p>这里简单介绍与进程相关的东西，例如进程创建、优先级、进程之间的关系、进程组和会话、进程状态等。&lt;/p></description></item><item><title>Kernel 内存杂项</title><link>https://gohalo.github.io/cn/blog/kernel-memory-tips/</link><pubDate>Sat, 21 Feb 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-tips/</guid><description>&lt;p>简单介绍下内核中与内存相关的内容。&lt;/p></description></item><item><title>Linux 进程切换</title><link>https://gohalo.github.io/cn/blog/linux-context-schedule/</link><pubDate>Mon, 17 Nov 2014 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-context-schedule/</guid><description>&lt;p>在本文中介绍了 Linux 的进程切换以及协程的相关文档，包括了上下文相关信息、Linux 进程切换的过程以及协程相关的信息。&lt;/p></description></item><item><title>Linux 内存-内核空间</title><link>https://gohalo.github.io/cn/blog/kernel-memory-management-from-kernel-view/</link><pubDate>Tue, 21 Oct 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-management-from-kernel-view/</guid><description>&lt;p>线性地址到物理地址的映射是通过 page table 完成的，内核会在启动分页机制前完成初始化；而且内核会将 A) 不可用物理地址空间，B) 内核代码以及内核初始数据结构对应的地址空间保留。&lt;/p>
&lt;p>接下来，看看内核中是如何管理内存的。&lt;/p></description></item><item><title>Linux 内存-用户空间</title><link>https://gohalo.github.io/cn/blog/kernel-memory-management-from-userspace-view/</link><pubDate>Sat, 27 Sep 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-management-from-userspace-view/</guid><description>&lt;p>简单介绍下 Linux 中用户空间的内存管理，包括了内存的布局、内存申请等操作。&lt;/p></description></item><item><title>Linux 共享内存</title><link>https://gohalo.github.io/cn/blog/linux-program-shared-memory/</link><pubDate>Wed, 10 Sep 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-shared-memory/</guid><description>&lt;p>共享内存应该是进程间通信最有效的方式，同一块物理内存被映射到两个不同进程 A、B 各自的地址空间；进程 A 可以立即看到进程 B 对共享内存中数据的更新，反之亦然。&lt;/p>
&lt;p>接下来简单介绍下与共享内存相关的内容。&lt;/p></description></item><item><title>Linux 网卡驱动的工作原理</title><link>https://gohalo.github.io/cn/blog/network-driver-works/</link><pubDate>Thu, 03 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-driver-works/</guid><description>&lt;p>如题所示，介绍网卡是如何接收数据，然后又是如何交给上层处理。因为鄙人的网卡驱动用的是 e1000e，所以就以此为例了。&lt;/p>
&lt;p>Just enjoy it.&lt;/p></description></item><item><title>Linux 内核 系统调用详解</title><link>https://gohalo.github.io/cn/blog/kernel-syscall/</link><pubDate>Sun, 23 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-syscall/</guid><description>&lt;p>Intel 的 x86 架构的 CPU 提供了 0 到 3 四个特权级，而在 Linux 操作系统中主要采用了 0 和 3 两个特权级，也就是我们通常所说的内核态和用户态。&lt;/p>
&lt;p>从用户态向内核态切换通常有 3 种情况： A) 系统调用(主动)，用户态的进程申请操作系统的服务，通常用软中断实现；B) 产生异常，如缺页异常、除0异常；C) 外设产生中断，如键盘、磁盘等。&lt;/p>
&lt;p>下面以系统调用来讲解。&lt;/p></description></item><item><title>Linux VFS 文件系统</title><link>https://gohalo.github.io/cn/blog/linux-kernel-virtual-file-system-introduce/</link><pubDate>Sat, 15 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-virtual-file-system-introduce/</guid><description>&lt;p>在次重申下，Linux 的设计理念是：一切都是文件！&lt;/p>
&lt;p>也就是在 Linux 中，一切设备皆是以文件的形式进行操作，如网络套接字、硬件设备等。这一切都是通过一个中间层实现的，被称为 VFS (Virtual File System) 。&lt;/p></description></item><item><title>Linux 启动过程</title><link>https://gohalo.github.io/cn/blog/kernel-bootstrap/</link><pubDate>Fri, 28 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-bootstrap/</guid><description>&lt;p>现在的 Linux 启动过程一般分成了两步，也就是首先调用 GRUB 作为通用的启动服务，然后可以选择 Windows 或者 Linux 加载。&lt;/p>
&lt;p>接下来，看看 Linux 的加载过程。&lt;/p></description></item><item><title>Linux 硬件启动</title><link>https://gohalo.github.io/cn/blog/kernel-hardware-startup/</link><pubDate>Tue, 25 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-hardware-startup/</guid><description>&lt;p>从内核加电之后，简单介绍如何从硬件加载启动。&lt;/p></description></item><item><title>Linux 内核编译</title><link>https://gohalo.github.io/cn/blog/kernel-compile/</link><pubDate>Sun, 23 Feb 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-compile/</guid><description>现在安装时，一般是发行版本已经编译创建好的通用内核，对于一些特定的需求，如嵌入式设置，那么可能就需要手动编译内核镜像。
这里简单介绍如何手动编译内核。
内核镜像介绍 # 通常 Unix 平台下的内核镜像称为 unix，Linux 也与之相似，不过随着虚拟内存 (Virtual Memory) 的发展，于是支持虚拟内存的内核在前面添加了 vm，其中 vmlinux 源自 vmunix 。现在 Linux 支持虚拟内存，不再像老的操作系统比如 DOS 会有 640KB 内存的限制。
在 DOS 的时代，采用的是 16 位段寻址方式，因此只能访问 1M 的空间。在这 1M 的 RAM 空间里，段址从 A000 起，被分配给了显示缓存、外部设备 ROM、BIOS ROM 等等。因此，一般情况下， dos 可供自己分配的也就是段 A000 之前的那部分了，这部分的大小为 640K 。
一般来说，一个可启动的内核镜像 (bootable kernel image) 是经过 zlib 算法压缩的，2.6.30 之后采用 LZMA 或者 BZIP2，vmlinuz 最后的 z 表示内核是压缩的，这也意味着内核中会有一段解压程序。
内核中包含了各种内核镜像的格式，如 vmlinux、zImage、bzImage、uImage 等，首先介绍一下内核中的常见内核文件。
vmlinux 是静态编译出来的最原始的 ELF 文件，包括了内核镜像、调试信息、符号表等内容；其中 &amp;ldquo;vm&amp;rdquo; 代表 &amp;ldquo;Virtual Memory&amp;rdquo;，现在一般都是虚拟内存模式，这个是相对于 8086 的实地址而言。 bzImage 是 vmlinux 经过 gzip 压缩后的文件，适用于大内核，&amp;ldquo;bz&amp;rdquo; 表示 &amp;ldquo;big zImage&amp;rdquo;。 uImage 是 uboot 专用的镜像文件，它是在 zImage 之前加上一个长度为 0x40 的头信息，包括了该镜像文件的类型、加载位置、生成时间、大小等信息。 在发行版本中，通常使用 vmlinuz 标示，而实际上是 bzImage 格式，可以通过 file 命令查看。</description></item><item><title>Linux 网络协议栈简介</title><link>https://gohalo.github.io/cn/blog/network-introduce/</link><pubDate>Thu, 23 Jan 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-introduce/</guid><description>&lt;p>Linux 的 TCP/IP 协议栈估计是目前最灵活、应用最广的网络协议栈了，具有清晰的层次结构以及清晰定义的原语和接口，不仅使得上层应用开发者可以无需关心下层架构或者内部机制，从而提供相对透明的操作网络。&lt;/p>
&lt;p>在本文中简单介绍一下与协议栈相关的内容。&lt;/p></description></item><item><title>Kernel 系统时钟</title><link>https://gohalo.github.io/cn/blog/kernel-timer-introduce/</link><pubDate>Tue, 02 Jul 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-timer-introduce/</guid><description/></item><item><title>Kernel 调度系统</title><link>https://gohalo.github.io/cn/blog/kernel-scheduler/</link><pubDate>Fri, 21 Jun 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-scheduler/</guid><description>&lt;p>操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级和高优先级进程的需要尽可能调和等等。&lt;/p>
&lt;p>什么时候以怎样的方式选择一个进程运行，就是所谓的调度策略 (Scheduling Policy)。&lt;/p>
&lt;p>本文中，介绍下 Linux Kernel 中时如何实现的。&lt;/p></description></item><item><title>Cache 能否回收</title><link>https://gohalo.github.io/cn/blog/linux-monitor-memory-cache-buffer-introduce/</link><pubDate>Sat, 20 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-memory-cache-buffer-introduce/</guid><description/></item><item><title>Linux 监控之 Memory</title><link>https://gohalo.github.io/cn/blog/linux-monitor-memory/</link><pubDate>Sat, 06 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-memory/</guid><description>&lt;p>在 Linux 的内存分配机制中，优先使用物理内存，当物理内存还有空闲时，不会释放其占用内存，就算占用内存的程序已经被关闭了，该程序所占用的内存用来做缓存使用，这样对于开启过的程序、或是读取刚存取过得数据会比较快，可以提高整体 IO 效率。&lt;/p></description></item><item><title>Kernel 内存映射</title><link>https://gohalo.github.io/cn/blog/kernel-memory-virtual-physical-map/</link><pubDate>Fri, 05 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-virtual-physical-map/</guid><description>&lt;p>现在的操作系统在内存使用时，一般为逻辑地址，那么逻辑地址和物理地址之间是怎样映射的，或者说，通过逻辑地址如何找到物理内存中的内容。&lt;/p>
&lt;p>其实，包括动态共享库，mmap 映射等，都使用到了虚拟内存，也就是逻辑地址的映射。&lt;/p>
&lt;p>这里，简单介绍下逻辑地址到物理地址的映射关系。&lt;/p></description></item><item><title>【专题】Linux 内核详解</title><link>https://gohalo.github.io/cn/blog/topic-linux-kernel/</link><pubDate>Fri, 21 May 2010 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-kernel/</guid><description/></item></channel></rss>