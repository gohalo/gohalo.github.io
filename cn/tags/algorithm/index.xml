<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on</title><link>https://gohalo.github.io/cn/tags/algorithm/</link><description>Recent content in algorithm on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 19 Sep 2022 21:15:12 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>Perisistend Data Structure 详解</title><link>https://gohalo.github.io/cn/blog/concurrency-persistent-data-structure/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-persistent-data-structure/</guid><description/></item><item><title>树状数组详解</title><link>https://gohalo.github.io/cn/blog/binary-indexed-tree/</link><pubDate>Sun, 23 May 2021 17:30:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/binary-indexed-tree/</guid><description>&lt;p>树状数组 Binary Indexed Tree 或以作者名字命名为 Fenwick Tree，最早由 Peter M. Fenwick 在 1994 年发表的 &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8917">A New Data Structure for Cumulative Frequency Tables&lt;/a>，起初是为了解决 Cumulative Frequency 的计算，现在也用于高效计算数列的前缀和、区间和。&lt;/p>
&lt;p>这里详细介绍其原理以及实现方式。&lt;/p></description></item><item><title>排序算法简介</title><link>https://gohalo.github.io/cn/blog/algorithm-sort-introduce/</link><pubDate>Sun, 08 Nov 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-sort-introduce/</guid><description/></item><item><title>优先队列详细介绍</title><link>https://gohalo.github.io/cn/blog/structure-heap/</link><pubDate>Mon, 17 Aug 2020 18:19:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-heap/</guid><description>&lt;p>堆 (Heap) 又被为优先队列 (Priority Queue)，通过堆可以按照元素的优先级取出元素，而不是按照元素进入队列的先后顺序取出元素。&lt;/p>
&lt;p>这里详细介绍其实现。&lt;/p></description></item><item><title>离散化数组介绍</title><link>https://gohalo.github.io/cn/blog/discretization-array/</link><pubDate>Mon, 10 Aug 2020 21:38:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/discretization-array/</guid><description>&lt;p>有时候需要用数组的值作为下标，有可能会是一个很大的值，那么就导致内存中保存不了，但实际上数组大小是有限的，那么此时就可以通过数组离散化进行处理。&lt;/p>
&lt;p>简单来说，离散化关心的是相对大小，而不是某个数具体多大。&lt;/p></description></item><item><title>二叉搜索树</title><link>https://gohalo.github.io/cn/blog/structure-binary-search-tree/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-binary-search-tree/</guid><description/></item><item><title>并查集详细介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-union-find/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-union-find/</guid><description>&lt;p>并查集 Union-Find 算法，顾名思义，用作合并集合、查找集合元素，通常用来解决图论中动态连通性问题，当然也包括了分类。&lt;/p>
&lt;p>这里详细介绍基本概念。&lt;/p></description></item><item><title>自平衡二叉搜索树</title><link>https://gohalo.github.io/cn/blog/structure-avl-tree/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-avl-tree/</guid><description>&lt;p>为了保证树的高度，也就出现了如下的平衡二叉树，例如 AVL Tree、Red-Black Tree 等，两者都是针对可能出现的不同场景进行调整，从而达到了平衡状态，但是两者处理不平衡状态都不太好记忆，而且死板。&lt;/p>
&lt;p>这里先介绍下自平衡二叉树的实现。&lt;/p></description></item><item><title>树基本介绍</title><link>https://gohalo.github.io/cn/blog/structure-tree/</link><pubDate>Tue, 16 Jun 2020 18:43:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-tree/</guid><description>&lt;p>通过树可以用来描述层级结构数据，基本上有序列的地方就可以应用树，因为树结构即是一种序列索引结构。&lt;/p>
&lt;p>这里简单介绍常见的树结构。&lt;/p></description></item><item><title>Bitmap 详细介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-bitmap-introduce/</link><pubDate>Sat, 28 Mar 2020 22:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-bitmap-introduce/</guid><description/></item><item><title>整数溢出</title><link>https://gohalo.github.io/cn/blog/integer-overflow/</link><pubDate>Sat, 28 Mar 2020 22:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/integer-overflow/</guid><description>&lt;p>这实际上是一个很严重的问题，包括 PostgreSQL、ZooKeeper 都可能会出现。&lt;/p></description></item><item><title>Bloom Filter 详细介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-bloomfilter-introduce/</link><pubDate>Mon, 27 Jan 2020 22:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-bloomfilter-introduce/</guid><description>&lt;p>BloomFilter 是一个哈希索引结构，采用类似 BitMap 的方式存储数据，所以空间利用率很高，其独特的地方在于使用多个哈希函数来避免哈希冲突。&lt;/p></description></item><item><title>二分查找详解 (闭区间)</title><link>https://gohalo.github.io/cn/blog/algorithm-binary-search-other/</link><pubDate>Wed, 20 Nov 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-binary-search-other/</guid><description>&lt;p>之前的文章已经详细介绍了二分查找，不过使用的是闭区间，这里再介绍一下开区间的实现细节，两种方法基本没有区别，可以选择其中一个。&lt;/p></description></item><item><title>二分查找详解</title><link>https://gohalo.github.io/cn/blog/algorithm-binary-search/</link><pubDate>Wed, 20 Nov 2019 19:58:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-binary-search/</guid><description>&lt;p>二分查找 (Binary Search) 是一种效率较高的查找方法，不过其对保存的数据有所要求，数据需要线性顺序存储，同时需要保证数据是有序排列的。&lt;/p>
&lt;p>虽然二分查找的思路很简单，却有很多的细节问题，如整型溢出、边界的递进等等，这里详细介绍其使用方法。&lt;/p></description></item><item><title>LSM 详解</title><link>https://gohalo.github.io/cn/blog/lsm-tree-introduce/</link><pubDate>Thu, 01 Aug 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lsm-tree-introduce/</guid><description>&lt;!-- The Log-Structured Merge-Tree (LSM-Tree) --></description></item><item><title>洗牌算法</title><link>https://gohalo.github.io/cn/blog/algorithm-shuffling-method-introduce/</link><pubDate>Thu, 01 Aug 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-shuffling-method-introduce/</guid><description>&lt;p>需要保证是一个公平的随机算法，首先介绍如何打乱，然后是如何判断已经打乱，也就是符合均匀分布，满足公平。&lt;/p></description></item><item><title>背包问题</title><link>https://gohalo.github.io/cn/blog/algorithm-knapsack-problem-introduce/</link><pubDate>Tue, 23 Apr 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-knapsack-problem-introduce/</guid><description>&lt;p>分治算法和动态规划都是将大问题拆解为小问题，前者针对同一个子问题可能会计算多次，而后者则会将中间结果记录下来，通过空间节约时间，而 &lt;code>0-1&lt;/code> 背包问题是最基本的动态规划问题。&lt;/p></description></item><item><title>基本算法介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-basic-concept/</link><pubDate>Wed, 20 Feb 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-basic-concept/</guid><description>&lt;p>这里简单介绍一下递归、分治算法、动态规划、贪心算法、回溯算法的区别和联系。&lt;/p></description></item><item><title>Huffman 编码简介</title><link>https://gohalo.github.io/cn/blog/huffman-introduce/</link><pubDate>Tue, 20 Nov 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/huffman-introduce/</guid><description>&lt;p>哈夫曼编码 Huffman Coding 是一种变长的前缀码，使用的算法是 David A. Huffman 还在 MIT 的学生时提出的，并且在 1952 年发表了名为 &lt;code>A Method for the Construction of Minimum-Redundancy Codes&lt;/code> 的文章。&lt;/p>
&lt;p>编码过程叫做哈夫曼编码，是一种普遍的熵编码技术，包括用于无损数据压缩领域。&lt;/p></description></item><item><title>【专题】算法详解</title><link>https://gohalo.github.io/cn/blog/topic-algorithm/</link><pubDate>Fri, 16 Jul 2010 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-algorithm/</guid><description>&lt;p>包括常见的基础数据结构、算法，也包含了类似 LeetCode 的刷题技巧。&lt;/p></description></item></channel></rss>