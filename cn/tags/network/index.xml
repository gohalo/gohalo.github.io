<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>network on</title><link>https://gohalo.github.io/cn/tags/network/</link><description>Recent content in network on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Thu, 21 Nov 2024 22:10:42 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/tags/network/index.xml" rel="self" type="application/rss+xml"/><item><title>Protobuf Rust 语言使用介绍</title><link>https://gohalo.github.io/cn/blog/protobuf-rust-usage/</link><pubDate>Thu, 21 Nov 2024 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-rust-usage/</guid><description>&lt;p>Prost 是一个用于序列化和反序列化 Google Protocol Buffers 协议的 Rust 库，支持消息嵌套、默认值、枚举类型等。&lt;/p></description></item><item><title>Socks 代理协议详解</title><link>https://gohalo.github.io/cn/blog/network-proxy-socks/</link><pubDate>Thu, 28 Apr 2022 21:39:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-proxy-socks/</guid><description>&lt;p>Socks 是一个代理协议，这里会对协议进行详细介绍，同时会介绍其使用场景。&lt;/p></description></item><item><title>Telnet 协议详解</title><link>https://gohalo.github.io/cn/blog/network-telnet-introduce/</link><pubDate>Thu, 28 Apr 2022 21:39:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-telnet-introduce/</guid><description>&lt;p>Telnet 是一个简单的远程终端协议，通过 TCP 连接登录到远端服务器，相比之前需要通过硬件终端连接服务器的方式要简单很多，但是因为没有加密容易导致信息泄漏，建议使用 SSH 而非 Telnet 协议。&lt;/p>
&lt;p>协议内部使用 Network Virtual Terminal, NVT，也就是所谓的虚拟网络终端，然后两端根据各自字符集等进行转换。&lt;/p></description></item><item><title>Curl 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-curl/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-curl/</guid><description>&lt;p>常用的 curl 相关命令整理。&lt;/p></description></item><item><title>Netcat 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-netcat/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-netcat/</guid><description>&lt;p>常用的 netcat 相关命令整理。&lt;/p></description></item><item><title>Wget 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-wget/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-wget/</guid><description>&lt;p>常用的 wget 相关命令整理。&lt;/p></description></item><item><title>Kubernets 网络示例</title><link>https://gohalo.github.io/cn/blog/kubernets-examples-nginx/</link><pubDate>Fri, 19 Mar 2021 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-examples-nginx/</guid><description>&lt;p>这里以 Nginx 为例，介绍几种常见的网络模型。&lt;/p></description></item><item><title>K8S 网络简介</title><link>https://gohalo.github.io/cn/blog/kubernets-network-introduce/</link><pubDate>Mon, 21 Dec 2020 20:30:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-network-introduce/</guid><description>简介 # K8S 中的网络以及 IP 地址都分了三层，分别为：
Node Network 各个 Node 之间的通讯方式，可以是物理网络或者虚拟网络； Pod Network 各个 Pod 之间通讯，Pod 可以在 Node 内部，也可以是跨 Node ； Service Network 也就是 Pod 对外部暴露的接口，创建 Service 时会新建一个 IP 。 与之对应的 IP 地址包括了：
Node IP 每个 Node 之间通讯时，分配的 IP 地址； Pod IP 每个 Pod 会分配一个 IP 地址，一般由 Pause 容器创建，一个 Node 中可以包含多个 Pod ； Cluster IP 对应了 Service 内部 IP ，作为服务的入口。 K8S 支持 Flannel、Calico、Weave Network 等多种 CNI 网络驱动。
Docker 网络 # 在 Docker 的后台服务启动之后，会创建一个 docker0 的网关，容器默认会分配在一个以 docker0 为默认网关的虚拟子网中。</description></item><item><title>GoLang WebSocket 编程</title><link>https://gohalo.github.io/cn/blog/golang-websocket-program/</link><pubDate>Tue, 28 Jul 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-websocket-program/</guid><description/></item><item><title>Websocket 协议详解</title><link>https://gohalo.github.io/cn/blog/network-websocket-introduce/</link><pubDate>Sat, 25 Jul 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-websocket-introduce/</guid><description>&lt;p>对于 HTTP 协议，通信只能由客户端发起，服务端无法主动向客户端推送信息，通过轮询方式就很消耗资源。&lt;/p>
&lt;p>为了达到实时响应以及良好的用户体验，通常通过 AJAX 实现异步无刷新请求功能，不过只能在浏览器异步请求服务器，也就是拉取；而推送一般通过类似 Comet 的技术，略显复杂。&lt;/p>
&lt;p>而 WebSocket 是一种全新的协议，将 TCP 的 Socket 应用在了 web page 上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工工作模式。&lt;/p>
&lt;p>这里详细介绍其实现。&lt;/p></description></item><item><title>Linux 网络配置</title><link>https://gohalo.github.io/cn/blog/linux-network-settings/</link><pubDate>Wed, 20 May 2020 21:29:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-settings/</guid><description>&lt;p>现在很多系统管理员仍在使用 ifconfig、route、arp 和 netstat 等命令行工具，来管理和排查各种网络配置。这套工具也就是 net-tools 包，源于 BSD TCP/IP 工具箱，但是自 2001 年以后基本就停滞不前。&lt;/p>
&lt;p>iproute 作为一套新的网络配置工具，旨在替换原有的 net-tools 工具包，这里大概介绍下两者的区别。&lt;/p></description></item><item><title>GoLang Echo 简介</title><link>https://gohalo.github.io/cn/blog/golang-echo-http-framework/</link><pubDate>Thu, 05 Mar 2020 22:28:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-echo-http-framework/</guid><description>&lt;p>echo web 框架是通过 GoLang 开发的一种高性能、可扩展、轻量级的 web 框架，只包含了 MVC 框架的 C 部分，也就是负责 URL 路由和控制器部分，对于 V 视图和 M 数据操作可以使用自己喜欢的工具库来实现。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>关于 OSCP 的基本概念以及使用介绍</title><link>https://gohalo.github.io/cn/blog/ssl-oscp-introduce/</link><pubDate>Thu, 15 Aug 2019 20:19:43 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssl-oscp-introduce/</guid><description>&lt;p>对于颁发的证书，如果因为一些特殊原因，例如私钥泄漏、证书信息有误、颁发了其它域名证书等等，这样，就需要吊销某些证书，这里关键就是浏览器或客户端如何知道当前使用的证书已经被吊销了。&lt;/p>
&lt;p>为了解决这一问题，引入了 Certificate Revocation List, CRL 和 Online Certificate Status Protocol, OCSP 技术，前者需要用户定期下载用于脱机使用，后者则可实时在线查询。&lt;/p></description></item><item><title>GoLang 反射简介</title><link>https://gohalo.github.io/cn/blog/golang-reflect-introduce/</link><pubDate>Sat, 06 Apr 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-reflect-introduce/</guid><description>&lt;p>与 C/C++ 不同，GoLang 的指针是不支持指针运算和转换，GoLang 是静态语言，所有变量必须标明其类型，不同类型变量不能执行赋值、比较、计算等操作；指针也有其对应的类型，在编译阶段同样会进行检查。&lt;/p>
&lt;p>同时，GoLang 在运行阶段提供了一定的灵活性。&lt;/p></description></item><item><title>常用 DNS 工具介绍</title><link>https://gohalo.github.io/cn/blog/dns-tools-usage/</link><pubDate>Fri, 22 Mar 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/dns-tools-usage/</guid><description>&lt;p>之前已经介绍了关于 DNS 常见的基本概念，这里会通过一些常见的命令行工具进行验证，例如 getent、nslookup、dig 等等。&lt;/p></description></item><item><title>KVM 网路配置介绍</title><link>https://gohalo.github.io/cn/blog/linux-kvm-network-setting/</link><pubDate>Tue, 12 Mar 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kvm-network-setting/</guid><description/></item><item><title>DNS 协议详解</title><link>https://gohalo.github.io/cn/blog/network-dns-protocol-details-introduce/</link><pubDate>Fri, 21 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-protocol-details-introduce/</guid><description>&lt;p>也就是做 DNS 解析时，客户端和服务端的通讯协议，详见 &lt;a href="https://www.ietf.org/rfc/rfc1035.txt">RFC1035 4.MESSAGES&lt;/a> 部分。&lt;/p>
&lt;p>这里简单介绍其基本概念。&lt;/p></description></item><item><title>Protobuf 序列化详解</title><link>https://gohalo.github.io/cn/blog/protobuf-protocol-serialize-details/</link><pubDate>Sat, 24 Nov 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-protocol-serialize-details/</guid><description>&lt;p>类似于 JSON、XML 格式，Protocol Buffer 是 Google 出品的一种轻量而且高效的结构化数据存储格式，性能比 JSON、XML 要强很多，包括其序列化、反序列化速度，数据压缩效果。&lt;/p>
&lt;p>当然，带来的问题是可读性不高。&lt;/p></description></item><item><title>HTTP2 HPACK 介绍</title><link>https://gohalo.github.io/cn/blog/network-http2-hpack-introduce/</link><pubDate>Fri, 16 Nov 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http2-hpack-introduce/</guid><description>&lt;p>Google 直接在 HTTP1.X 的基础上设计了 SPDY 协议，对头部使用 deflate 算法进行压缩，一并解决了多路复用和优先级等问题。而 HTTP2 的实现就是参考了 SPDY 协议，但是专门为头部压缩设计了一套压缩算法，就是这里的 HPACK 。&lt;/p></description></item><item><title>Linux Socket 端口使用</title><link>https://gohalo.github.io/cn/blog/linux-socket-port-range-introduce/</link><pubDate>Tue, 13 Nov 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-socket-port-range-introduce/</guid><description>&lt;p>Linux 使用的 TCP/IP 协议栈会使用四元组，在客户端与服务端建立链接的时候一般无需指定端口，可以直接使用系统默认指定的端口。&lt;/p>
&lt;p>当然，也可以指定固定的端口，不过此时可能会导致端口冲突。&lt;/p></description></item><item><title>HTTP2 协议简介</title><link>https://gohalo.github.io/cn/blog/network-http2-protocol-introduce/</link><pubDate>Tue, 16 Oct 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http2-protocol-introduce/</guid><description>&lt;p>HTTP2 也就是超文本传输协议第 2 版，基于 TCP 连接的一个上层协议，允许在一个 TCP 连接上多路复用，支持优先级、流量控制、服务器推送、首部HPACK压缩、&lt;/p>
&lt;p>保持了与 HTTP1 相同的基本语义，例如 方法语义 (GET PUST PUT DELETE 等)、状态码 (200 404 500 等)、URL 等等，相比来说做了如下的优化。&lt;/p>
&lt;p>通过单个 TCP 连接支持多个通道；头部压缩，解析会更快、更小等等。&lt;/p></description></item><item><title>Protobuf 协议简介</title><link>https://gohalo.github.io/cn/blog/protobuf-protocol-introduce/</link><pubDate>Thu, 24 May 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-protocol-introduce/</guid><description>&lt;p>Protobuf (Google Protocol Buffers) 是 google 开发的的一套用于数据存储，网络通信时用于协议编解码的工具库，与 XML 和 JSON 数据格式类似，但采用的是二进制的数据格式，具有更高的传输，打包和解包效率。&lt;/p>
&lt;p>相比 JSON 来说，Protobuf 的效率、编解码速度更快、数据体积更小，带来的问题是数据可读性变差，协议升级比较麻烦。&lt;/p></description></item><item><title>GoLang HTTP 使用简介</title><link>https://gohalo.github.io/cn/blog/golang-http-webserver-introduce/</link><pubDate>Fri, 27 Apr 2018 18:13:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-http-webserver-introduce/</guid><description>&lt;p>除去细节，理解 HTTP 构建的网络应用只要关注客户端和服务端的处理，服务器主要用来接收客户端的请求，然后返回响应，在接收请求并处理的过程中，最重要的莫过于路由 (Router)。&lt;/p>
&lt;p>这里简单介绍如何使用 &lt;code>net/http&lt;/code> 构建 HTTP 请求。&lt;/p></description></item><item><title>Linux 网络状态查看</title><link>https://gohalo.github.io/cn/blog/linux-network-status/</link><pubDate>Thu, 26 Apr 2018 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-status/</guid><description>&lt;p>直接通过 &lt;code>man 8 netstat&lt;/code> 查看帮助时就可以发现这样的一句话 &lt;code>This program is obsolete. Replacement for netstat is ss.&lt;/code>，而且后面还有几个相关的等价示例介绍。&lt;/p>
&lt;p>所以这里简单介绍与 ss 相关的指令。&lt;/p></description></item><item><title>JWT 简介</title><link>https://gohalo.github.io/cn/blog/golang-json-web-token-jwt/</link><pubDate>Tue, 13 Feb 2018 21:27:20 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-json-web-token-jwt/</guid><description>&lt;p>在程序开发中，用户认证授权是一个绕不过的重难点，以前的开发模式下，cookie 和 session 认证是主流，随着前后端分离的趋势，基于 Token 的认证方式成为主流。&lt;/p>
&lt;p>而 JWT(RFC 7519) 是基于 Token 认证方式的一种机制，是实现单点登录认证的一种有效方法。&lt;/p>
&lt;p>这里详细介绍其设计和使用方式。&lt;/p></description></item><item><title>TC 使用简介</title><link>https://gohalo.github.io/cn/blog/network-traffic-control-introduce/</link><pubDate>Fri, 01 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-traffic-control-introduce/</guid><description>&lt;p>网络的 IP 服务模型是尽力而为的，这样的模型不能体现某些流量的重要性，所以诞生了 QoS 技术，Linux 很早就提供了流量控制接口，命令行工具是 tc (Traffic Control)。&lt;/p></description></item><item><title>GoLang Array VS. Slice</title><link>https://gohalo.github.io/cn/blog/golang-array-slice-concept-introduce/</link><pubDate>Wed, 18 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-array-slice-concept-introduce/</guid><description>&lt;p>两者十分类似，很容易造成混淆。&lt;/p></description></item><item><title>GoLang 网络编程</title><link>https://gohalo.github.io/cn/blog/golang-example-socket-introduce/</link><pubDate>Sat, 14 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-example-socket-introduce/</guid><description>&lt;p>Golang 对 TCP 做了很好的抽象，而且提供了很高的性能，其底层的 netpoller 通过非阻塞的 IO 多路复用实现，然后再结合协程的调度，使得用户在编程时实际是阻塞接口。&lt;/p></description></item><item><title>Golang nil 解析</title><link>https://gohalo.github.io/cn/blog/golang-basic-concept-nil-introduce/</link><pubDate>Sat, 10 Jun 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-concept-nil-introduce/</guid><description/></item><item><title>libev 信号处理</title><link>https://gohalo.github.io/cn/blog/libev-source-code-signal-process-details/</link><pubDate>Sat, 15 Apr 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-source-code-signal-process-details/</guid><description>&lt;p>信号的处理非常敏感，如果处理不当很容易出现问题，如果在信号处理函数中使用了非信号安全函数，那么很容易发生死锁。&lt;/p>
&lt;p>这里简单介绍 libev 中是如何处理信号的。&lt;/p></description></item><item><title>libev 时间处理</title><link>https://gohalo.github.io/cn/blog/libev-timers/</link><pubDate>Mon, 20 Mar 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-timers/</guid><description>&lt;p>在之前的文章中介绍了 libev 库的基本概念以及常见的使用方法，其中与时间相关的内容只是简单介绍，不过这一部分涉及到的内容会比较多，而且杂，所以单独摘出来介绍下。&lt;/p></description></item><item><title>报文超过 MTU</title><link>https://gohalo.github.io/cn/blog/linux-network-mtu-oversize/</link><pubDate>Mon, 20 Feb 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-mtu-oversize/</guid><description>&lt;p>正常来说，通过 TCP 传输的报文应该不会超过 MTU 大小，一般是 1500 大小。&lt;/p>
&lt;p>但是，如果通过 tcpdump 获取报文，那么可能会出现报文大小超过 MTU 的报文，甚至超过 20K 。&lt;/p></description></item><item><title>Linux 惊群详解</title><link>https://gohalo.github.io/cn/blog/linux-details-of-thundering-herd/</link><pubDate>Mon, 06 Feb 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-details-of-thundering-herd/</guid><description>简言之，惊群现象就是当多个进程或线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。
这里对 Linux 中的惊群现象进行简单介绍。
惊群 # 关于惊群的解释可以查看 Wiki 的解释 Thundering herd problem 。
accept() # 常见的场景如下。
主进程执行 socket()+bind()+listen() 后，fork() 多个子进程，每个子进程都通过 accept() 循环处理这个 socket；此时，每个进程都阻塞在 accpet() 调用上，当一个新连接到来时，所有的进程都会被唤醒，但其中只有一个进程会 accept() 成功，其余皆失败，重新休眠。这就是 accept 惊群。
如果只用一个进程去 accept 新连接，并通过消息队列等同步方式使其他子进程处理这些新建的连接，那么将会造成效率低下；因为这个进程只能用来 accept 连接，该进程可能会造成瓶颈。
而实际上，对于 Linux 来说，这只是历史上的问题，现在的内核都解决该问题，也即只会唤醒一个进程。可以通过如下程序进行测试，只会激活一个进程。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/wait.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #define PROCESS_NUM 10 int main() { int fd = socket(PF_INET, SOCK_STREAM, 0); int connfd; int pid, i, status; char sendbuff[1024]; struct sockaddr_in serveraddr; printf(&amp;#34;Listening 0.</description></item><item><title>事件驱动库 libev 使用详解</title><link>https://gohalo.github.io/cn/blog/libev-basic-introduce/</link><pubDate>Fri, 30 Dec 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-basic-introduce/</guid><description>&lt;p>libev 是一个通过 C 语言编写的，高性能的事件循环库，支持多种事件类型，与此类似的事件循环库还有 libevent、libubox 等，相比来说这个库要简单很多，在此详细介绍下 libev 相关的内容。&lt;/p></description></item><item><title>libev 源码详解</title><link>https://gohalo.github.io/cn/blog/libev-source-code-introduce/</link><pubDate>Thu, 15 Dec 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-source-code-introduce/</guid><description>&lt;p>libev 内部结构比较简单，只提供了基本的处理逻辑，其中核心主要分成了几部分：文件描述符处理。&lt;/p></description></item><item><title>Ping 协议详细介绍</title><link>https://gohalo.github.io/cn/blog/network-icmp-ping-introduce/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-icmp-ping-introduce/</guid><description>&lt;p>Internet Control Message Protocol, ICMP(RFC-792) 基于 IP 协议，工作在七层协议的第三层，主要用来解析网络路由情况，通过返回错误信息进行分析定位。&lt;/p>
&lt;p>这里详细介绍其使用方式。&lt;/p></description></item><item><title>HTTP 协议简介</title><link>https://gohalo.github.io/cn/blog/network-http-introduce/</link><pubDate>Fri, 09 Sep 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http-introduce/</guid><description>&lt;p>HTTP 协议在 TCP/IP 协议之上，目前已经成为了互联网的基础协议，也是网页开发的必备知识，这里简单介绍下 HTTP 协议的历史演变、设计思路，以及相关的解析实现。&lt;/p></description></item><item><title>Webserver 简介</title><link>https://gohalo.github.io/cn/blog/webserver-introduce/</link><pubDate>Wed, 23 Mar 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/webserver-introduce/</guid><description>&lt;p>简单介绍一下 webserver，其中很大一部分是关于一些小型软件的介绍。&lt;/p></description></item><item><title>libevent</title><link>https://gohalo.github.io/cn/blog/linux-libevent/</link><pubDate>Fri, 12 Feb 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-libevent/</guid><description>&lt;p>libevent 是一个轻量级的开源的高性能的事件库，适用于 windows、linux、bsd 等多种平台，根据不同的平台，会选择使用 select、epoll、kqueue 等系统调用管理事件机制。&lt;/p>
&lt;p>下面简单介绍下。&lt;/p></description></item><item><title>ARP 协议详解</title><link>https://gohalo.github.io/cn/blog/network-arp-introduce/</link><pubDate>Tue, 15 Dec 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-arp-introduce/</guid><description>&lt;p>地址解析协议 Address Resolution Protocol, ARP 是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，在 IPv4 中极其重要。&lt;/p></description></item><item><title>SNMP 协议详解</title><link>https://gohalo.github.io/cn/blog/network-snmp-introduce/</link><pubDate>Sat, 17 Oct 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-snmp-introduce/</guid><description>&lt;p>简单记录下 Linux 常见的通讯协议，如 SNMP 协议。&lt;/p></description></item><item><title>GoLang Echo 中间件</title><link>https://gohalo.github.io/cn/blog/golang-echo-middleware/</link><pubDate>Tue, 06 Oct 2015 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-echo-middleware/</guid><description>&lt;p>Echo 中间件指的是可以拦截 http 请求的特殊函数，在请求和响应中间可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。&lt;/p></description></item><item><title>Linux IP 隧道技术</title><link>https://gohalo.github.io/cn/blog/network-ip-tunneling/</link><pubDate>Sun, 13 Sep 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-ip-tunneling/</guid><description>&lt;p>隧道是一种封装技术，它利用一种网络协议来传输另一种网络协议，即利用一种网络传输协议，将其它协议产生的数据报文封装在它自己的报文中，然后在网络中传输。&lt;/p>
&lt;p>隧道可以看做是一条虚拟的点对点连接，隧道的两端需要对数据报文进行封装及解封装，常用的是基于 IP 的隧道。&lt;/p>
&lt;p>在此简单介绍下隧道技术。&lt;/p></description></item><item><title>Linux 网络超时与重传</title><link>https://gohalo.github.io/cn/blog/network-timeout-retries/</link><pubDate>Mon, 17 Aug 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-timeout-retries/</guid><description>&lt;p>在此介绍重传，为了保证可靠性，在 TCP 的三次握手、数据传输、链接关闭阶段都有响应的重传机制。那么，重传的次数都是有那些参数指定？tcp_retries1 和 tcp_retries2 到底有什么区别？什么是 orphan socket ？&lt;/p></description></item><item><title>Linux 网络半链接、链接队列</title><link>https://gohalo.github.io/cn/blog/network-synack-queue/</link><pubDate>Wed, 05 Aug 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-synack-queue/</guid><description>&lt;p>我们知道在建立链接阶段，需要完成三次握手，而这一阶段是在内核中完成，为此保存了两个队列：半链接队列 (SYN队列)、链接队列 (Accepted队列)。&lt;/p>
&lt;p>那么，这两个队列分别对应到内核中的那些成员？队列的大小由那些参数决定？当队列满了之后，对应用的影响是什么？其报错的内容是什么？&lt;/p>
&lt;p>在这篇文章里大致介绍下。&lt;/p></description></item><item><title>Linux 的防火墙</title><link>https://gohalo.github.io/cn/blog/network-netfilter-iptables/</link><pubDate>Tue, 23 Jun 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-netfilter-iptables/</guid><description>&lt;p>Linux 防火墙是由 Netfilter 和 iptables 两个组件组成，其中前者在内核空间中；后者是一个用户程序，用于插入、修改和删除相应的防火墙规则。&lt;/p>
&lt;p>通过 Netfilter+iptables 可以实现数据包过滤、网络地址转换和数据报文处理等功能。&lt;/p></description></item><item><title>cares 异步 DNS 简介</title><link>https://gohalo.github.io/cn/blog/network-dns-async-resolve-introduce/</link><pubDate>Sat, 18 Apr 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-async-resolve-introduce/</guid><description>&lt;p>c-ares 是一个 C89 实现的异步请求 DNS 的实现，一些常见的软件 (如 curl、NodeJS、WireShark 等等) 都使用了这一软件库。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>DNS 配置文件 resolv.conf 简介</title><link>https://gohalo.github.io/cn/blog/network-dns-resolv-conf-usage-introduce/</link><pubDate>Mon, 30 Mar 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-resolv-conf-usage-introduce/</guid><description>&lt;p>Linux 中可以通过 &lt;code>/etc/resolv.conf&lt;/code> 文件配置 DNS 服务器的地址，不过目前该文件大部分是通过一些工具自动配置的，例如 NetworkManager ，那么这就可能会导致在重启网络服务后该配置文件被刷新。&lt;/p>
&lt;p>这里简单介绍其使用方式。&lt;/p></description></item><item><title>DNS 的基本概念详解</title><link>https://gohalo.github.io/cn/blog/network-dns-basic-introduce/</link><pubDate>Thu, 19 Mar 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-basic-introduce/</guid><description>&lt;p>在通过浏览器访问某个网站时，或者说访问网络上的服务器时，可以直接使用 IP 地址，但是对于人类来说很难记忆，为此引入了域名，而为了可以做到自动解析，于时就有了 DNS 。&lt;/p>
&lt;p>这里详细介绍 DNS 的基本概念。&lt;/p></description></item><item><title>Linux 网络负载均衡</title><link>https://gohalo.github.io/cn/blog/network-load-balancing/</link><pubDate>Mon, 24 Nov 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-load-balancing/</guid><description>&lt;p>对于一个每秒处理百万请求的网站来说，通常是有整个集群提供服务的，而如何做到负载均衡呢？&lt;/p></description></item><item><title>Linux 网络加速</title><link>https://gohalo.github.io/cn/blog/network-speedup-introduce/</link><pubDate>Mon, 27 Oct 2014 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-speedup-introduce/</guid><description>&lt;p>硬件与 CPU 进行信息沟通有两种方式，一种是中断，另一种是轮询。中断是硬件主动产生中断信号，中断控制器将信号传递给 CPU，此时 CPU 会停下手中的工作，执行中断任务；轮询则是 CPU 主动，定时查询硬件设备的状态，是否处理硬件请求。&lt;/p>
&lt;p>随着网络带宽越来越大，实际由中断带来的 CPU 负载越来越大，这也就导致了 NAPI 的出现。&lt;/p>
&lt;p>不过这不是本文要讲的重点，本文着重看下网络针对 SMP 所做的优化。&lt;/p></description></item><item><title>分布式缓存 memcached</title><link>https://gohalo.github.io/cn/blog/memcached-introduce/</link><pubDate>Sun, 19 Oct 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/memcached-introduce/</guid><description>&lt;p>通常 Web 应用的数据都会持久化到数据库中，随着应用数据量以及访问量的增加，就会导致数据库负担加重，从而导致网站的延迟。&lt;/p>
&lt;p>Memcached 是一个高性能的分布式内存缓存服务器，用于缓存数据库的查询结果，从而减少数据库的访问次数，提高动态 Web 应用的速度、提高扩展性。&lt;/p></description></item><item><title>Linux 中的 loopback 设备</title><link>https://gohalo.github.io/cn/blog/linux-network-loopback/</link><pubDate>Thu, 02 Oct 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-loopback/</guid><description>&lt;p>我们知道，在 Linux 设备中有一个 lo 设备，在此稍微介绍下。&lt;/p></description></item><item><title>TCP/IP 协议之 TIME_WAIT</title><link>https://gohalo.github.io/cn/blog/network-tcpip-timewait/</link><pubDate>Tue, 29 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-tcpip-timewait/</guid><description>&lt;p>&lt;code>TIME_WAIT&lt;/code> 是 TCP 协议栈中比较特殊的状态，其主要目的是保证不同的链接不会相互干扰，但是对于一些高性能的场景，就可能由于较多的 &lt;code>TIME_WAIT&lt;/code> 状态最终导致链接不可用。&lt;/p>
&lt;p>如下简单介绍如何充分利用该状态。&lt;/p></description></item><item><title>TCP/IP 协议简介</title><link>https://gohalo.github.io/cn/blog/network-tcpip-introduce/</link><pubDate>Mon, 07 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-tcpip-introduce/</guid><description>&lt;p>TCP 协议是 &amp;ldquo;面向连接&amp;rdquo; 的，整个过程被分为几个阶段：准备、协商、建立连接、管理以及最后的连接终止，同时可以管理多个链接。&lt;/p>
&lt;p>接下来，我们看看 TCP 协议是如何实现的。&lt;/p></description></item><item><title>Linux 网卡驱动的工作原理</title><link>https://gohalo.github.io/cn/blog/network-driver-works/</link><pubDate>Thu, 03 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-driver-works/</guid><description>&lt;p>如题所示，介绍网卡是如何接收数据，然后又是如何交给上层处理。因为鄙人的网卡驱动用的是 e1000e，所以就以此为例了。&lt;/p>
&lt;p>Just enjoy it.&lt;/p></description></item><item><title>Linux 中的 socketfs</title><link>https://gohalo.github.io/cn/blog/network-socketfs/</link><pubDate>Mon, 10 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-socketfs/</guid><description>&lt;p>BSD socket 是用户程序与网络协议栈之间的接口层，用户通过调用 socket API 将报文传给协议栈，以及从协议栈读取报文。实际上，Linux 对于网络提供了一个与虚拟文件系统相似的接口，也就是可以通过 socket 接口打开一个类似的文件，而内核中实际是通过 sockfs 文件系统实现的。&lt;/p>
&lt;p>接下来我们就在这篇文章中查看下与 socketfs 相关的内容。&lt;/p></description></item><item><title>Linux 网络协议栈简介</title><link>https://gohalo.github.io/cn/blog/network-introduce/</link><pubDate>Thu, 23 Jan 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-introduce/</guid><description>&lt;p>Linux 的 TCP/IP 协议栈估计是目前最灵活、应用最广的网络协议栈了，具有清晰的层次结构以及清晰定义的原语和接口，不仅使得上层应用开发者可以无需关心下层架构或者内部机制，从而提供相对透明的操作网络。&lt;/p>
&lt;p>在本文中简单介绍一下与协议栈相关的内容。&lt;/p></description></item><item><title>【专题】Linux 网络相关</title><link>https://gohalo.github.io/cn/blog/topic-linux-network/</link><pubDate>Sat, 10 Apr 2010 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-network/</guid><description/></item></channel></rss>