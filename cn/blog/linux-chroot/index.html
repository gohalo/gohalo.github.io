<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux Chroot | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="chroot 也就是 change root directory，也就是改变程序执行时所参考的根目录位置。在 Linux 系统中，系统默认的目录结构都是以 &amp;ldquo;/&amp;quot;，即是以根 (root) 开始的，而在使用 chroot 之后，系统的目录结构将以指定的位置作为 &amp;ldquo;/&amp;rdquo; 位置。
应用场景比较多，如安全中的蜜罐、系统启动时用的 initrd、嵌入式系统挂载的 NFS、Linux From Scratch 的编译过程等等。
在此，简单介绍下 chroot 。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux Chroot</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-01-13</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/command/ role=button>command</a></div></div><hr><div class=content><p>chroot 也就是 change root directory，也就是改变程序执行时所参考的根目录位置。在 Linux 系统中，系统默认的目录结构都是以 &ldquo;/"，即是以根 (root) 开始的，而在使用 chroot 之后，系统的目录结构将以指定的位置作为 &ldquo;/&rdquo; 位置。</p><p>应用场景比较多，如安全中的蜜罐、系统启动时用的 initrd、嵌入式系统挂载的 NFS、Linux From Scratch 的编译过程等等。</p><p>在此，简单介绍下 chroot 。</p><p><img alt="chroot logo" src=images/chroot-logo.png class="mx-auto d-block"></p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>在经过 chroot 之后，系统读取到的目录和文件将不在是旧系统根下的而是新根下 (即被指定的新的位置) 的目录结构和文件，因此它带来的好处大致有以下的几个:</p><ul><li><p>在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，限制了用户的权力，这样就增强了系统的安全性。</p></li><li><p>chroot 后，是一个与原系统根下文件不相关的目录结构。那么，在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发，例如 LFS 。</p></li><li><p>切换系统的根位置最明显的就是在系统启动时，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的系统目录的 init；另外的就是急救系统。</p></li></ul><p>在 Linux 中，实际上是有标准的目录结构的，其中包括了目录的命名、属性、权限等，可以参考 <a href=http://www.pathname.com/fhs/>Filesystem Hierarchy Standard, FHS</a>。FHS 希望可以让使用者了解到已安装软件放置于那个目录下，所以希望软件开发商、操作系统制作者等都能够遵循 FHS 的标准。</p><p>上面扯的有点多，实际上构建一个 chroot 环境只需要一些简单的目录以及配置文件等，接下来看看如何构建一个 chroot 环境。</p><a class=anchor id=搭建环境></a><h1>搭建环境 <a href=#%e6%90%ad%e5%bb%ba%e7%8e%af%e5%a2%83 aria-hidden=true>#</a></h1><p>注意，我们构建的 chroot 环境是基于当前架构的，比如现在使用的是 X86 机器，那么搭建的运行环境就是基于 X86 机器的。如果想在 X86 上构建一个基于 NFS 的 ARM 测试环境，那么就要用到了交叉编译工具，重新编译所有的二进制文件，目前用的较多的是 busybox；在此就不过多讨论了。</p><p>当然，我们仅仅是搭建一个基本的运行环境，然后按需添加写可执行文件。因为架构是一样的，那么我们就可以直接在本机上复制所需要的文件，基本步骤大致如下：</p><ol><li>创建所必须的目录，如 /lib、/lib64、/bin、/sbin、/etc 等。</li><li>复制基本的可执行文件，如 bash、env、ln、cat、ls、mv、cp、rm、mkdir 等。</li><li>复制上述执行文件依赖的库文件，这一步可以自动执行。</li><li>创建所必须的文件，以及环境变量，如 /dev/console、/etc/passwd、/etc/shadow 等。</li></ol><p>上述的操作比较繁琐，我们直接通过一个简单的脚本 <a href=reference/chroot_create.sh>chroot_create.sh</a> 完成上述的操作，需要注意的是，这个脚本只在 CentOS 上测试过，对于像 Debian、Gentoo 等其它的发布版本，可能需要修改。</p><p>上述的脚本运行时需要用 root 权限，相关的操作可以直接查看 &ndash;help 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>-h, --help
</span></span><span class=line><span class=cl>    直接查看帮助
</span></span><span class=line><span class=cl>-c, --create
</span></span><span class=line><span class=cl>    先搭建环境，然后执行chroot命令；默认操作是直接执行chroot
</span></span><span class=line><span class=cl>--root
</span></span><span class=line><span class=cl>    指定根目录，默认是在当前目录下创建一个 root 目录
</span></span><span class=line><span class=cl>--verbose
</span></span><span class=line><span class=cl>    显示操作的详细信息，包括复制了那些文件等。
</span></span></code></pre></div><p>常见的命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># chroot_create.sh                  # 在当前目录下创建root，并切换到该目录
</span></span><span class=line><span class=cl># chroot_chreate.sh -h              # 查看帮助
</span></span><span class=line><span class=cl># chroot_chreate.sh -v dir          # 指定root目录，显示详细信息，下面相同
</span></span><span class=line><span class=cl># chroot_chreate.sh --root dir
</span></span><span class=line><span class=cl># chroot_chreate.sh --root=dir
</span></span><span class=line><span class=cl># chroot_chreate.sh -d dir          # 直接调转到相应的目录
</span></span></code></pre></div><p>在脚本的开头包括了一些用户可以修改的配置，如通过 cmdlist 添加执行的命令、user_process() 函数会在创建 root 环境时调用、before_enter_jail() 会在执行 chroot 命令前执行。</p><p>chroot 时可以执行命令，在此如果不使用 /usr/bin/env -i 则会将当前的环境便令传入 chroot 目录中，为了提供统一的环境，建议使用上述的参数。</p><a class=anchor id=调试></a><h2>调试 <a href=#%e8%b0%83%e8%af%95 aria-hidden=true>#</a></h2><p>通常在打算包含一些命令时，会发现报错，那么可以将 strace 命令添加进去，对命令进行调试。例如，通过如下命令查看 sudo 的运行情况，根据其访问的文件来进行设置，可能需要复制或者创建某些文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ strace sudo
</span></span></code></pre></div><a class=anchor id=i-have-no-name></a><h4>I have no name! <a href=#i-have-no-name aria-hidden=true>#</a></h4><p>虽然添加了 /etc/passwd(644) /etc/shadow(644) 文件 (此时不需要 /etc/group) ，但是仍有上述的问题。通过 strace `which whoami` 可以发现，访问了 /etc/nsswitch.conf 文件，因此需要添加该配置文件。</p><p>如果只需要解决上述的问题，根据配置文件中的设置，也就是只设置了 file ，因此只需要添加 /lib/i386-linux-gnu/libnss_files.so.2 即可。</p><a class=anchor id=添加-iptables></a><h4>添加 iptables <a href=#%e6%b7%bb%e5%8a%a0-iptables aria-hidden=true>#</a></h4><p>此时需要添加 /lib/xtables 目录下的内容，也可以根据需要添加，如对于双网卡的设置，只需要添加如下的动态链接库即可 libipt_MASQUERADE.so 。</p><a class=anchor id=动态链接库></a><h4>动态链接库 <a href=#%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%ba%93 aria-hidden=true>#</a></h4><p>稍微再啰嗦下"动态链接库&rdquo;，通过 strace 可以发现，很多命令都会查找动态链接库，通常会按照一定的目录顺序查找。为了加快查找速度可设置 LD_LIBRARY_PATH=/lib 或者使用 ldconfig 命令。</p><p>如果使用 ldconfig ，实际调用的是 ldconfig.real，在执行完 ldconfig 命令后，将会生成 /etc/ld.so.cache 文件。</p><a class=anchor id=源码解析></a><h1>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h1><p>chroot 在 coreutils 中实现，实际是通过 chdir+chroot+execvp 实现，代码可以参考如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span> <span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>chroot</span> <span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=n>optind</span><span class=p>])</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>error</span> <span class=p>(</span><span class=n>EXIT_CANCELED</span><span class=p>,</span> <span class=n>errno</span><span class=p>,</span> <span class=nf>_</span><span class=p>(</span><span class=s>&#34;cannot change root directory to %s&#34;</span><span class=p>),</span> <span class=n>argv</span><span class=p>[</span><span class=n>optind</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>chdir</span> <span class=p>(</span><span class=s>&#34;/&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>error</span> <span class=p>(</span><span class=n>EXIT_CANCELED</span><span class=p>,</span> <span class=n>errno</span><span class=p>,</span> <span class=nf>_</span><span class=p>(</span><span class=s>&#34;cannot chdir to root directory&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>execvp</span> <span class=p>(</span><span class=n>argv</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>argv</span><span class=p>);</span> <span class=cm>/* Execute the given command.  */</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>chroot 在内核中的实现是 sys_chroot()，该函数实际上是设置当前进程的 current->fs->root 变量。之所以使用 chdir 是因为，很多系统在实现 chroot 时，并不会改变当前的路径，因此通常需要先通过 chdir 更改路径。</p><p>chroot 相关的内容也可以参考 <a href=https://www.ibm.com/developerworks/cn/linux/l-cn-chroot/ title="理解 chroot">理解 chroot</a>，在此就不过多介绍了。</p><a class=anchor id=风险></a><h2>风险 <a href=#%e9%a3%8e%e9%99%a9 aria-hidden=true>#</a></h2><p>在使用 chroot 时，其中的一个用途是制作一个 Jail 做隔离，限制某些应用的权限，但是实际上如果使用不当，仍有可能突破该 Jail 。</p><p>突破的方法也很简单，就是循环利用 chdir("..") 即可，估计内核中的代码是没有做根路经的检查的。当然，解决办法也很简单，就是在 jail 中不要使用 root 用户，那么这样也不会造成太大的危害。</p><p>本来是有篇文章介绍的，现在已经成为了死链。</p><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><p>在 chroot 环境中，如果要执行 ps 命令将会失败，需要挂载 proc 文件系统，不过会显示所有的进程，包括原用户的进程。</p><p>也就是说，采用 chroot 的方法只是对目录做了一些简单的隔离，而对于 CPU、磁盘、网络等资源，实际上是没有隔离的。目前比较流行的是采用类似 LXC 的解决方案，如 systemd ，可以参考 <a href=https://linux.cn/article-4678-1.html>systemd-nspawn 快速指南</a> ，也就是 systemd 用以替换 chroot 的方案。</p><p>最后介绍一个比较奇葩的工具 supermin ，可以用来创建一个很小的内核镜像，不过是使用 OCaml 语言写的。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#搭建环境>搭建环境</a><ul><li><a href=#调试>调试</a></li></ul></li><li><a href=#源码解析>源码解析</a><ul><li><a href=#风险>风险</a></li></ul></li><li><a href=#其它>其它</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>