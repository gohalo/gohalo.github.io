<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>TCP/IP 协议简介 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="TCP 协议是 &amp;ldquo;面向连接&amp;rdquo; 的，整个过程被分为几个阶段：准备、协商、建立连接、管理以及最后的连接终止，同时可以管理多个链接。
接下来，我们看看 TCP 协议是如何实现的。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>TCP/IP 协议简介</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-04-07</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/network/ role=button>network</a></div></div><hr><div class=content><p>TCP 协议是 &ldquo;面向连接&rdquo; 的，整个过程被分为几个阶段：准备、协商、建立连接、管理以及最后的连接终止，同时可以管理多个链接。</p><p>接下来，我们看看 TCP 协议是如何实现的。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>如上，TCP 可以同时管理多个连接，因此需要赋予每个连接一个唯一的标识进行识别，这个标识就是连接两端的 IP 以及端口号 (共4个key)，从而保证了连接后续的建立、管理和中断都是独立分开的。</p><p>对于各个状态迁移采用 FSM (Finite State Machine，有限状态机) 进行描述，其包含了如下的几种状态：</p><ul><li>state：在一个给定的时间，协议应用（protocol software）的环境以及状态的详细说明；</li><li>transition：从一个状态到另一个状态的动作；</li><li>event：引起状态间切换的事件；</li><li>action：设备在切换到另一个状态之前，所做的对于 event 的回应。</li></ul><p>下图是一个 TCP 有限状态机的简化版本。</p><p><img alt="TCP/IP Finite State Machine FSM" src=images/The-TCP-Finite-State-MachineFSM.png class="mx-auto d-block"></p><a class=anchor id=tcb></a><h2>TCB <a href=#tcb aria-hidden=true>#</a></h2><p>由于每个连接都是独立的，所以我们使用了一个定制的数据结构来将与连接相关的信息分别存储，这个就是 TCB (Transmission Control Block，传输控制模块)。</p><p>在连接启动建立之前，内核会做一些准备工作，其中之一就是建立起维护连接信息的 TCB ，而且两端的 TCB 都是由两端自己的设备去维护。</p><p>TCB 保存了与连接相关的所有的重要信息，比如两端端口号，用于连接识别；用于管理连接数据流的 buffer 的内存指针；TCB 也用于窗口切换机制，用来保存所接收到的数据中有哪些已经被确认和尚未被确认的变量，当前窗口大小等等。</p><a class=anchor id=报文头部></a><h2>报文头部 <a href=#%e6%8a%a5%e6%96%87%e5%a4%b4%e9%83%a8 aria-hidden=true>#</a></h2><p>按照 OSI 的七层模型，ARP 工作在第二层 (Data Link，Frame)，IP 在第三层 (Network, Packet)，第四层 (Transport, Segment)。数据依次打包，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p><p><img alt="TCP/IP Protocal Header" src=images/TCP-Header.png class="mx-auto d-block"></p><p>上图是 TCP 头部，来自 <a href=http://nmap.org/book/tcpip-ref.html>nmap tcpip-ref</a>，需要注意的是 A) TCP 包是没有 IP 地址，那是 IP 层的事，但是有源端口和目标端口。</p><p>上图中比较重要的是，A) Sequence Number 是包的序号，用来解决网络包乱序问题；B) Acknowledgement Number 用于确认收到包，用来解决丢包问题；C) Window 又叫 Advertised-Window 或者 Sliding Window 滑动窗口，用于解决流控；D) TCP Flag ，也就是包的类型，主要是用于操控 TCP 的状态机的。</p><a class=anchor id=三次握手建立连接></a><h1>三次握手，建立连接 <a href=#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5 aria-hidden=true>#</a></h1><p>三次握手主要用于建立连接，主要过程如下所示。</p><p><img alt="TCP/IP Three Way Handshaking" src=images/Three-Way-Handshaking.png class="mx-auto d-block"></p><p>简单看下连接的建立过程，在建立链接之前，server 已经处于 LISTEN 状态，而客户端处于 CLOSED 状态。</p><ol><li>第一次握手，客户端设置 TCB 并发送 SYN(syn=j) 包到服务器，尝试建立连接，而客户端进入 SYN-SENT 状态，等待服务器确认。</li><li>第二次握手，服务器收到 SYN 包，必须确认客户的 SYN(ack=j+1)，同时自己也发送一个 SYN (syn=k) 包，也即 SYN+ACK 包，此时服务器进入 SYN_RECEIVED 状态，同时将该链接保存在半连接队列。</li><li>第三次握手，客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1)，客户端进入 ESTABLISHED 状态；当服务器接收到 ACK 后也进入 ESTABLISHED 状态，完成三次握手。</li></ol><p>注意，对于服务端会将 ESTABLISHED 状态的连接移入 accept 队列，等待应用调用 accept() 。</p><p>可以看到，在服务端，建立连接涉及两个队列：</p><ul><li>半连接队列，保存了处于 SYN_RECV 状态的连接，表示服务器已经收到 SYN 包，并向客户发出确认，在等待客户端的确认。队列长度由 net.ipv4.tcp_max_syn_backlog 设置，一般默认值为 512 或者 1024，超过这个数量，系统将不再接受新的 TCP 连接请求。</li><li>连接队列，保存 ESTABLISHED 状态的连接。队列长度为 min(net.core.somaxconn, backlog)，其中 backlog 是调用 listen(int sockfd, int backlog) 时设置。</li></ul><a class=anchor id=序列号同步></a><h2>序列号同步 <a href=#%e5%ba%8f%e5%88%97%e5%8f%b7%e5%90%8c%e6%ad%a5 aria-hidden=true>#</a></h2><p>通过 TCP 的三次握手，除了建立链接之外，设备上的 TCP 层也进行一些必须的信息交换，包括了 A) 第一次数据传输时使用的序列号，B) 有关如何操作该连接的一些参数。这一过程一般被称为 “序列号同步(Sequence Number Synchronization)”，这是建立连接过程中一个很重要的部分。</p><p><img alt="TCP/IP Server Client Process" src=images/tcpip_server-client-process.jpg class="mx-auto d-block"></p><p>在建立链接时，双方需要相互通知自己的初始序列号 (Inital Sequence Number, ISN)，也就是 Synchronize Sequence Numbers。如上图中的 x 和 y，该值会作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序，TCP 也就是用这个序号来拼接数据。</p><p>可以通过如下图的方式查看序列号是如何变化的，也就是使用 Wireshark 菜单中的 Statistics => Flow Graph… 。</p><p><img alt="TCP/IP Sequence Number Process" src=images/tcpip_sequence-number-process.jpg class="mx-auto d-block"></p><p>你可以看到，序列号的增加是和传输的字节数相关的。上图中，三次握手后，来了两个长度为 1440 的包，而第二个包的 SeqNum 就成了1441，然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。</p><p>注意：Wireshark 抓包程序看3次握手，会发现SeqNum总是为0，这是为了显示更友好，使用了相对序号，只要在右键菜单中的 protocol preference 中取消掉就可以看到 “Absolute SeqNum” 了。</p><p>更加详细的可以参考 <a href=/cn/blog/linux-network-tools-wireshark/>Wireshark</a>，或者参考 <a href=http://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/>Understanding TCP Sequence and Acknowledgment Numbers</a> 。</p><a class=anchor id=序列号相关></a><h2>序列号相关 <a href=#%e5%ba%8f%e5%88%97%e5%8f%b7%e7%9b%b8%e5%85%b3 aria-hidden=true>#</a></h2><p>有一个问题，我们为什么不能每次都把数据的第一位的序号编为 1，或者一个固定值 ? 如果采用固定的序列号，可能会导致不同链接的数据流混乱。</p><p>假设我们在 A 和 B 之间建立起了一个连接， A 向 B 发送了一个 byte1 到 byte30 的消息，但是此时网络出现问题，这个数据流被延迟了，最后，这个连接中断。此时我们重启了 A 到 B 的连接， A 向 B 发送了一个以 1 为序列开头的数据流，然而此时可能之前的 byte1 到 byte30 发送到了 B ， B 也会认为这 30 个 byte 可能就是来自于后来新连接从而接受，那么此时就出现了错误。</p><p>为此，在 RFC793 中规定，ISN 会使用一个与时间绑定的计数器，在 TCP 层启动的时候初始化，每 4 微秒自增 1，直到溢出归 0，这样，一个 ISN 周期大约是 4.55 小时。</p><p>因为，我们假设我们的 TCP Segment 在网络上的存活时间不会超过 Maximum Segment Lifetime，只要 MSL 的值小于 4.55 小时，那么，我们就不会重用到 ISN。</p><p>这种解决方式会带来另外一个问题，就是 ISN 变得可以被预测：可以通过分析连接的之前的 ISN 然后预测后来的 ISN ，这就造成了一个安全隐患，这个漏洞在过去曾经被利用发起国著名的 Mitnick 攻击。为了解决这个问题，现在使用的随机数代理的自增。</p><a class=anchor id=syn-超时与-syn-flood-攻击></a><h2>SYN 超时与 SYN Flood 攻击 <a href=#syn-%e8%b6%85%e6%97%b6%e4%b8%8e-syn-flood-%e6%94%bb%e5%87%bb aria-hidden=true>#</a></h2><p>在建立链接时，如果服务端接到了客户端发的 SYN 后回了 SYN-ACK 后客户端掉线了，服务端没有收到客户端回来的 ACK，那么这个连接处于一个中间状态，即没成功，也没失败。于是，服务端对于在一定时间内没收到 ACK 的请求会重发 SYN-ACK。</p><p>在 Linux 中，默认重试次数为 5 次，重试的间隔时间分别为 1s, 2s, 4s, 8s, 16s，在第 5 次发出后还要等 32s 都知道第 5 次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP 才会把断开这个连接。</p><p>SYN Flood 攻击就是给服务器发了一个 SYN 后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 SYN 连接的队列耗尽，让正常的连接请求不能处理。</p><p>对于正常请求，应该调整三个 TCP 参数：A) tcp_synack_retries 减少重试次数；B) tcp_max_syn_backlog 增大SYN连接数；C) tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</p><a class=anchor id=tcp-sync-cookies></a><h2>TCP SYNC cookies <a href=#tcp-sync-cookies aria-hidden=true>#</a></h2><p>SYN Cookie 是对 TCP 服务器端的三次握手协议作一些修改，专门用来防范 SYN Flood 攻击。</p><p>其原理是，在 TCP 服务器收到 TCP SYN 包并返回 TCP SYN+ACK 包时，不分配一个专门的数据区，而是根据这个 SYN 包计算出一个 cookie 值。在收到 TCP ACK 包时，TCP 服务器在根据那个 cookie 值检查这个 TCP ACK 包的合法性。如果合法，再分配专门的数据区进行处理未来的 TCP 连接。</p><p>于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。</p><a class=anchor id=四次握手关闭连接></a><h1>四次握手，关闭连接 <a href=#%e5%9b%9b%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%85%b3%e9%97%ad%e8%bf%9e%e6%8e%a5 aria-hidden=true>#</a></h1><p>关闭相对来说要复杂，这是由于两端设备都在相互的发送/接收数据，当一端告诉对端 “我打算关闭这个连接” 时，而对端以及相应的应用程序可能完全不知道自己的对端正在打算关闭这个连接，所以为了能够优雅的关闭当期的连接并且还要保证不会产生数据丢失，这个步骤就会相对的复杂一些。</p><p>通过信息同步，当两端的程序都意识到 “这个连接就要被关闭” 并且已经停止发送数据的时候才能真正的开始着手关闭这个连接。而对于连接的一端来说，连接的关闭意味着自己停止发送数据，但是还可以接受从对端传来的数据，直到对端也停止发送。</p><p>说是四次握手，而实际上是两次，这是因为 TCP 是全双工的，发送方和接收方都需要 FIN 和 ACK，只不过，有一方是被动的，所以看上去就成了所谓的四次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达 TIME_WAIT 状态。</p><a class=anchor id=标准连接关闭过程></a><h2>标准连接关闭过程 <a href=#%e6%a0%87%e5%87%86%e8%bf%9e%e6%8e%a5%e5%85%b3%e9%97%ad%e8%bf%87%e7%a8%8b aria-hidden=true>#</a></h2><p>两端通过发送 FIN 消息来告知对端自己将关闭连接，当对端接收到 FIN 消息以后，会返回一个 ACK 消息告知 FIN 消息已经收到。只有当双方都发送了 FIN 并且接收到了 ACK 才会被认为已经完全的断开。</p><p><img alt="TCP/IP Four Way Handshake" src=images/tcpip_Four-Way-Handshake.png class="mx-auto d-block"></p><a class=anchor id=同时关闭></a><h2>同时关闭 <a href=#%e5%90%8c%e6%97%b6%e5%85%b3%e9%97%ad aria-hidden=true>#</a></h2><p>如下图所示，在这个过程中有很多是相对称的地方，状态对称，动作和结果也对称。在 CLOSED 状态时，也就是没有连接时， TCP 层会保证所有重要的数据已经发送到应用层，有时候可以理解成是一个 “push” 。 TCB 也会在连接关闭完成后被销毁。</p><p>关键点：就像连接可以通过两端同时主动 OPEN 建立，连接也可以通过两端同时中断来完成关闭。在这种情况下，转换过程会有一些不同，两端的设备都是先用 ACK 回复对端发来的 FIN ，然后再等待接受返回的 ACK ，最后再经过 2 倍 MSL 来确保消息和数据已经传输完成，终于关闭了连接。</p><p><img alt="TCP/IP Four Way Handshake Sync" src=images/tcpip_Four-Way-Handshake-Sync.png class="mx-auto d-block"></p><a class=anchor id=close-wait-和-time-wait></a><h2>CLOSE-WAIT 和 TIME-WAIT <a href=#close-wait-%e5%92%8c-time-wait aria-hidden=true>#</a></h2><p>收到 FIN 消息的服务器可能会在 CLOSE-WAIT 状态等待相当长的一段时间，直到对应的应用程序告诉它 “我已经准备好关闭连接了”。TCP 不能假设自己会需要等待多久，在这一段时间里， Server 可能仍在发送数据，而 Client 则一直在接受，但是 Client 已经不会再发给 Server 数据了。</p><p>到最后，Server 终于发出了 FIN 消息要关闭自己这一端的连接了，那么起初发送 FIN 消息的机器即 Client 会返回一个 ACK 进行确认。但是 Client 不能在发送完 ACK 立刻就进入 CLOSED 状态，因为它必须要等待 ACK 确确实实的已经发送到了对端，正常情况下这个过程很快，但是还是要考虑不正常情况可能造成的延迟。</p><p>从 TIME_WAIT 到 CLOSED 有一个 2*MSL 的超时设置 (RFC793 定义为 2min，而 Linux 设置为 30s)，这么作主要有两个原因：</p><ul><li>要确保足够长的时间能让 ACK 到达连接对端，并且还有可能会要求重传，如果被动关闭的那方没有收到 ACK，就会触发被动端重发 FIN，一来一去正好 2 个 MSL。</li></ul><ul><li>第二个原因就是需要为即将关闭的当前连接和后继的新连接之间提供一个 &ldquo;缓冲间隔&rdquo;，避免不同链接数据造成混乱的可能。主要防止上一次连接中的包，迷路后重新出现，影响新连接 (经过2MSL，上一次连接中所有的重复包都会消失)。</li></ul><p>TCP 标准规定 TIME-WAIT 时间是两倍的 MSL，在现在的网络中，这是一个常量，所以 TCP 层允许程序使用一个较小的值去代替，只要能保证工作正常即可。</p><p>MSL (最大分段生存期) 用以指明 TCP 报文在 Internet 上最长生存时间，每个具体的 TCP 实现都必须选择一个确定的 MSL 值。RFC1122 建议是 2 分钟，但 BSD 传统实现采用了 30 秒。</p><p>可以参考 <a href=http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html>TIME_WAIT and its design implications for protocols and scalable client server systems</a>。</p><a class=anchor id=滑动窗口></a><h1>滑动窗口 <a href=#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3 aria-hidden=true>#</a></h1><p>TCP 需要保证数据传输的质量，会对发送的数据进行跟踪，解决可靠传输以及包乱续的问题。这种数据管理主要有以下两大关键功能：A) 可靠性，保证数据确实到达目的地，未到达，则能够发现并重传；B) 数据流控，管理数据的发送速率，以使接收设备不致于过载。</p><p>要完成这些任务，整个协议围绕滑动窗口确认机制来进行。所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。所以，TCP 引入了一些技术来做网络流控，滑动窗口就是其中之一。</p><p>TCP 头有一个字段 Window，用于接收端告诉发送端自己还有多少缓冲区可以接收数据，于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p><p><img alt="TCP/IP Slide Window" src=images/tcpip-slide-window-struct.jpg class="mx-auto d-block"></p><p>上图是发送和接收端的相关数据结构，可以看到：</p><ul><li>接收端 LastByteRead 指向了 TCP 缓冲区中读到的位置，NextByteExpected 指向的是收到的连续包的最后一个位置，LastByteRcved 指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li><li>发送端的 LastByteAcked 指向了被接收端 Ack 过的位置（表示成功发送确认），LastByteSent 表示发出去了，但还没有收到成功确认的 Ack，LastByteWritten 指向的是上层应用正在写的地方。</li></ul><p>于是，接收端在给发送端回 ACK 中会汇报自己的 <code>AdvertisedWindow = MaxRcvBuffer - LastByteRcvd - 1</code>；而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</p><p><img alt="TCP/IP Slide Window" src=images/tcpip-slide-window-send.png class="mx-auto d-block"></p><p>上图中的黑框就是滑动窗口，整个缓冲区被分成了四个部分：#1 已收到 ACK 确认的数据；#2 已经发送但还没收到 ACK；#3 在窗口但还没有发出，接收方还有空间；#4 窗口以外的数据，接收方没空间。</p><a class=anchor id=zero-window></a><h2>Zero Window <a href=#zero-window aria-hidden=true>#</a></h2><p><img alt="TCP/IP Zero Window" src=images/tcpip-tcpswflow.png class="mx-auto d-block"></p><p>上图是一个处理缓慢的 Server 把 Client 的 TCP Sliding Window 给降成 0 ，此时 Client 将不再发送数据，如果接收方一会儿 Window Size 可用了，怎么通知发送端呢？</p><p>TCP 使用 Zero Window Probe, ZWP 技术，也就是说，发送端在窗口变成 0 后，会发 ZWP 包让接收方响应它的 Window 大小，一般会重试 3 次，第次间隔约 30-60s，如果 3 次后仍为 0 ，有的协议实现就会发 RST 把链接断了。</p><a class=anchor id=silly-window-syndrome></a><h2>Silly Window Syndrome <a href=#silly-window-syndrome aria-hidden=true>#</a></h2><p>如果接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小；到最后，如果接收方只能腾出几个字节并告诉发送方现在有几个字节的 window，而发送方会义无反顾地发送这几个字节。</p><a class=anchor id=拥塞控制></a><h1>拥塞控制 <a href=#%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6 aria-hidden=true>#</a></h1><p>TCP 通过 Sliding Window 来做流控 (Flow Control)，但是这种方式依赖于连接的发送端和接收端，并不知道网络中间发生了什么。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>关于 TCP/IP 协议可以参考 《TCP/IP 详解 卷1：协议》，以及 RFC793 等一系列的标准，如下是一些比较经典的参考。</p><ul><li><a href=/reference/linux/network/IP_TCP_UDP_Header.pdf>IP_TCP_UDP_Header 本地文档</a>，包括了 IP、TCP、UDP 头部信息，以及 TCP 状态转换，也就是比较经典的格式。</li><li><a href=http://blog.csdn.net/xiongyingzhuantu/article/details/38665549>网络基本功</a> 一系列网路基本知识的介绍，包括了整个链路；<a href=http://coolshell.cn/articles/11564.html>TCP 的那些事儿</a> 在 CoolShell 中的关于 TCP 协议的介绍，包括上述的图片。</li><li><a href=htp://www.tcpipguide.com/index.htm>The TCP/IP Guide</a> 很好的介绍 TCP 概念的资料，可以参考 [本地文档](/reference/linux/The TCP-IP Guide - A Comprehensive Illustrated Internet Protocols Reference.pdf)，可以参考 TCP Fundamentals and General Operation 相关章节；<a href=http://nmap.org/book/tcpip-ref.html>Nmap Network Scanning</a> 实际是 NMAP 的介绍，不过有很多相关协议的介绍。</li><li><a href=http://blog.csdn.net/column/details/high-perf-network.html>高性能网络编程</a> 包括了对网络协议的详细介绍。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#tcb>TCB</a></li><li><a href=#报文头部>报文头部</a></li></ul></li><li><a href=#三次握手建立连接>三次握手，建立连接</a><ul><li><a href=#序列号同步>序列号同步</a></li><li><a href=#序列号相关>序列号相关</a></li><li><a href=#syn-超时与-syn-flood-攻击>SYN 超时与 SYN Flood 攻击</a></li><li><a href=#tcp-sync-cookies>TCP SYNC cookies</a></li></ul></li><li><a href=#四次握手关闭连接>四次握手，关闭连接</a><ul><li><a href=#标准连接关闭过程>标准连接关闭过程</a></li><li><a href=#同时关闭>同时关闭</a></li><li><a href=#close-wait-和-time-wait>CLOSE-WAIT 和 TIME-WAIT</a></li></ul></li><li><a href=#滑动窗口>滑动窗口</a><ul><li><a href=#zero-window>Zero Window</a></li><li><a href=#silly-window-syndrome>Silly Window Syndrome</a></li></ul></li><li><a href=#拥塞控制>拥塞控制</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>