<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>MySQL 复制源码解析 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="MySQL 主从复制通过 binlog 实现，从库通过 dump 协议来交互数据的，binlog 复制的基本逻辑处理单元为 event 。
在本文中，我们看看源码是如何执行的。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>MySQL 复制源码解析</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2019-10-04</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/database/ role=button>database</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/mysql/ role=button>mysql</a></div></div><hr><div class=content><p>MySQL 主从复制通过 binlog 实现，从库通过 dump 协议来交互数据的，binlog 复制的基本逻辑处理单元为 event 。</p><p>在本文中，我们看看源码是如何执行的。</p><p><img alt="gtid source code" src=images/replicatioin-sourcecode-logo.jpg class="mx-auto d-block"></p><a class=anchor id=执行命令></a><h1>执行命令 <a href=#%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4 aria-hidden=true>#</a></h1><p>配置主备复制时，都是通过各种的 SQL 指令配置的；所以呢，首先看看这些命令的入口，以及命令是如何执行的。</p><p>其中，与复制相关的命令主要包括了如下几个：<code>change master</code>、<code>show slave stat</code>、<code>show master stat</code>、<code>start slave</code>、<code>stop slave</code> 等命令。</p><p>如下是上述命令在源码中的实际入口，可以根据不同命令入口查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>mysql_execute_command</span><span class=p>(</span><span class=n>THD</span> <span class=o>*</span><span class=n>thd</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>first_level</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef HAVE_REPLICATION
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>case</span> <span class=nl>SQLCOM_CHANGE_MASTER</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>check_global_access</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>SUPER_ACL</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>goto</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span><span class=o>=</span> <span class=n>change_master_cmd</span><span class=p>(</span><span class=n>thd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>SQLCOM_SHOW_SLAVE_STAT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Accept one of two privileges */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>check_global_access</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>SUPER_ACL</span> <span class=o>|</span> <span class=n>REPL_CLIENT_ACL</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>goto</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span><span class=o>=</span> <span class=n>show_slave_status_cmd</span><span class=p>(</span><span class=n>thd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>SQLCOM_SHOW_MASTER_STAT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Accept one of two privileges */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>check_global_access</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>SUPER_ACL</span> <span class=o>|</span> <span class=n>REPL_CLIENT_ACL</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>goto</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span> <span class=o>=</span> <span class=n>show_master_status</span><span class=p>(</span><span class=n>thd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>SQLCOM_SLAVE_START</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>res</span><span class=o>=</span> <span class=n>start_slave_cmd</span><span class=p>(</span><span class=n>thd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>SQLCOM_SLAVE_STOP</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>    If the client thread has locked tables, a deadlock is possible.
</span></span></span><span class=line><span class=cl><span class=cm>    Assume that
</span></span></span><span class=line><span class=cl><span class=cm>    - the client thread does LOCK TABLE t READ.
</span></span></span><span class=line><span class=cl><span class=cm>    - then the master updates t.
</span></span></span><span class=line><span class=cl><span class=cm>    - then the SQL slave thread wants to update t,
</span></span></span><span class=line><span class=cl><span class=cm>      so it waits for the client thread because t is locked by it.
</span></span></span><span class=line><span class=cl><span class=cm>    - then the client thread does SLAVE STOP.
</span></span></span><span class=line><span class=cl><span class=cm>      SLAVE STOP waits for the SQL slave thread to terminate its
</span></span></span><span class=line><span class=cl><span class=cm>      update t, which waits for the client thread because t is locked by it.
</span></span></span><span class=line><span class=cl><span class=cm>    To prevent that, refuse SLAVE STOP if the
</span></span></span><span class=line><span class=cl><span class=cm>    client thread has locked tables
</span></span></span><span class=line><span class=cl><span class=cm>  */</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>thd</span><span class=o>-&gt;</span><span class=n>locked_tables_mode</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>      <span class=n>thd</span><span class=o>-&gt;</span><span class=n>in_active_multi_stmt_transaction</span><span class=p>()</span> <span class=o>||</span> <span class=n>thd</span><span class=o>-&gt;</span><span class=n>global_read_lock</span><span class=p>.</span><span class=n>is_acquired</span><span class=p>())</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>my_message</span><span class=p>(</span><span class=n>ER_LOCK_OR_ACTIVE_TRANSACTION</span><span class=p>,</span>
</span></span><span class=line><span class=cl>               <span class=n>ER</span><span class=p>(</span><span class=n>ER_LOCK_OR_ACTIVE_TRANSACTION</span><span class=p>),</span> <span class=n>MYF</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>res</span><span class=o>=</span> <span class=n>stop_slave_cmd</span><span class=p>(</span><span class=n>thd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif </span><span class=cm>/* HAVE_REPLICATION */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>注意下面的命令 <code>COM_REGISTER_SLAVE</code> 会直接在 <code>dispatch_command()</code> 函数中执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>dispatch_command</span><span class=p>(</span><span class=n>THD</span> <span class=o>*</span><span class=n>thd</span><span class=p>,</span> <span class=k>const</span> <span class=n>COM_DATA</span> <span class=o>*</span><span class=n>com_data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=k>enum</span> <span class=nc>enum_server_command</span> <span class=n>command</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span> <span class=p>(</span><span class=n>command</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>case</span> <span class=nl>COM_REGISTER_SLAVE</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TODO: access of protocol_classic should be removed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>register_slave</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>thd</span><span class=o>-&gt;</span><span class=n>get_protocol_classic</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>get_raw_packet</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>      <span class=n>thd</span><span class=o>-&gt;</span><span class=n>get_protocol_classic</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>get_packet_length</span><span class=p>()))</span>
</span></span><span class=line><span class=cl>      <span class=n>my_ok</span><span class=p>(</span><span class=n>thd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=启动备库></a><h1>启动备库 <a href=#%e5%90%af%e5%8a%a8%e5%a4%87%e5%ba%93 aria-hidden=true>#</a></h1><p>首先，在会在备库执行 <code>change master</code> 函数，将主库信息写入到备库。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mysql_execute_command()
</span></span><span class=line><span class=cl> |-check_global_access()          ← 查看用户是否有权限
</span></span><span class=line><span class=cl> |-change_master_cmd()            ← 判断是否创建channel，调用如下函数
</span></span><span class=line><span class=cl>   |-change_master()              ← 命令的实际入口函数
</span></span></code></pre></div><p>在编译源码的时候需要开启 <code>HAVE_REPLICATION</code> 的宏定义，在备库上执行 <code>start slave</code> 命令后，会在 <code>sql_parse.cc</code> 中执行 <code>SQLCOM_SLAVE_START</code> 分支，实际执行的是 <code>start_slave()</code> 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mysql_execute_command()
</span></span><span class=line><span class=cl> |-start_slave_cmd()
</span></span><span class=line><span class=cl>   |-start_slave()
</span></span><span class=line><span class=cl>     |-start_slave_threads()
</span></span><span class=line><span class=cl>       |-start_slave_thread()                ← 先启动IO线程，无误再启动SQL线程
</span></span><span class=line><span class=cl>       | |-handle_slave_io()                 ← IO线程处理函数
</span></span><span class=line><span class=cl>       |
</span></span><span class=line><span class=cl>       |-start_slave_thread()
</span></span><span class=line><span class=cl>         |-handle_slave_sql()                ← SQL线程处理函数
</span></span></code></pre></div><p>备库中有两类处理线程，也就对应了两个函数 <code>handle_slave_sql()</code> 和 <code>handle_slave_io()</code>，分别用于从主库读取数据，以及将主库数据写入到备库。</p><p>接下来依次查看这两类处理线程。</p><a class=anchor id=连接主库></a><h1>连接主库 <a href=#%e8%bf%9e%e6%8e%a5%e4%b8%bb%e5%ba%93 aria-hidden=true>#</a></h1><p>首先，查看下 Slave 如何注册并请求 Master 的 binlog，也就是对应备库的 IO 线程。其中 Slave IO 线程对应的入口函数为 <code>handle_slave_io()</code>，大致处理流程为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>handle_slave_io()
</span></span><span class=line><span class=cl>  |-my_thread_init()                ← 0) 线程初始化
</span></span><span class=line><span class=cl>  |-init_slave_thread()
</span></span><span class=line><span class=cl>  |-RUN_HOOK()                      ←    调用relay_io-&gt;thread_start钩子函数
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-safe_connect()                  ← 1) 以标准的连接方式连上master
</span></span><span class=line><span class=cl>  |-get_master_version_and_clock()       并获取主库的所需信息
</span></span><span class=line><span class=cl>  |-get_master_uuid()
</span></span><span class=line><span class=cl>  |-io_thread_init_commands()
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-register_slave_on_master()      ← 2) 把自己注册到master上去
</span></span><span class=line><span class=cl>  | |-net_store_data()              ←    设置数据包
</span></span><span class=line><span class=cl>  | |-simple_command()              ←    S把自己的ID、IP、端口、用户名提交给M，用于注册
</span></span><span class=line><span class=cl>  | |                               ←    **上述会发送COM_REGISTER_SLAVE命令**
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |                                 ###1BEGIN while循环中检测io_slave_killed()
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-request_dump()                  ← 3) 开始请求数据，向master请求binlog数据
</span></span><span class=line><span class=cl>  | |-RUN_HOOK()                    ←    调用relay_io-&gt;before_request_transmit()
</span></span><span class=line><span class=cl>  | |-int2store()                   ←    会根据是否为GTID作区分
</span></span><span class=line><span class=cl>  | |-simple_command()              ←    发送dump数据请求
</span></span><span class=line><span class=cl>  | |                               ←    **执行COM_BINLOG_DUMP_GTID/COM_BINLOG_DUMP命令**
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |                                 ###2BEGIN while循环中检测io_slave_killed()
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-read_event()                    ← 4) 读取event并存放到本地relay log中
</span></span><span class=line><span class=cl>  | |-cli_safe_read()               ←    等待主库将binlog数据发过来
</span></span><span class=line><span class=cl>  |   |-my_net_read()
</span></span><span class=line><span class=cl>  |-RUN_HOOK()                      ←    调用relay_io-&gt;after_read_event()
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-queue_event()                   ← 5) 将接收到的event保存在relaylog中
</span></span><span class=line><span class=cl>  |-RUN_HOOK()                      ←    调用relay_io-&gt;after_queue_event()
</span></span><span class=line><span class=cl>  |-flush_master_info()
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |                                 ###2END
</span></span><span class=line><span class=cl>  |                                 ###1END
</span></span></code></pre></div><p>如上所述，当备库注册到主库时，会发送 <code>COM_REGISTER_SLAVE</code> 命令；请求 binlog 日志时则会根据是否使用 GTID，发送 <code>COM_BINLOG_DUMP_GTID/COM_BINLOG_DUMP</code> 命令。</p><p>接下来看下主库是如何处理备库的 binlog 请求，这里相关的命令都会在 <code>dispatch_command()</code> 函数中进行处理，其核心的内容为。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>dispatch_command</span><span class=p>(</span><span class=n>THD</span> <span class=o>*</span><span class=n>thd</span><span class=p>,</span> <span class=k>const</span> <span class=n>COM_DATA</span> <span class=o>*</span><span class=n>com_data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=k>enum</span> <span class=nc>enum_server_command</span> <span class=n>command</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>switch</span> <span class=p>(</span><span class=n>command</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef HAVE_REPLICATION
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>case</span> <span class=nl>COM_REGISTER_SLAVE</span><span class=p>:</span>    <span class=c1>// 注册slave
</span></span></span><span class=line><span class=cl><span class=c1></span>          <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>register_slave</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=p>(</span><span class=n>uchar</span><span class=o>*</span><span class=p>)</span><span class=n>packet</span><span class=p>,</span> <span class=n>packet_length</span><span class=p>))</span>
</span></span><span class=line><span class=cl>              <span class=n>my_ok</span><span class=p>(</span><span class=n>thd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#ifdef EMBEDDED_LIBRARY
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>case</span> <span class=nl>COM_BINLOG_DUMP_GTID</span><span class=p>:</span>
</span></span><span class=line><span class=cl>          <span class=n>error</span><span class=o>=</span> <span class=n>com_binlog_dump_gtid</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>packet</span><span class=p>,</span> <span class=n>packet_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=nl>COM_BINLOG_DUMP</span><span class=p>:</span>
</span></span><span class=line><span class=cl>          <span class=n>error</span><span class=o>=</span> <span class=n>com_binlog_dump</span><span class=p>(</span><span class=n>thd</span><span class=p>,</span> <span class=n>packet</span><span class=p>,</span> <span class=n>packet_length</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>下面以 <code>COM_BINLOG_DUMP</code> 为例介绍 master 是怎么发送 <code>binlog event</code> 给 slave 的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>dispatch_command()
</span></span><span class=line><span class=cl> |-com_binlog_dump_gtid()           ← COM_BINLOG_DUMP_GTID
</span></span><span class=line><span class=cl> |-com_binlog_dump()                ← COM_BINLOG_DUMP
</span></span><span class=line><span class=cl>   |-kill_zombie_dump_threads()     ← 如果同一个备库注册，会移除跟该备库匹配的binlog dump线程
</span></span><span class=line><span class=cl>   |-mysql_binlog_send()            ← 上述两个命令都会执行到此处
</span></span><span class=line><span class=cl>     |                              ← 会打开文件，在指定位置读取文件，将event按照顺序发给备库
</span></span><span class=line><span class=cl>     |-Binlog_sender::run()         ← 调用rpl_binlog_sender.cc中的发送
</span></span><span class=line><span class=cl>       |-init()
</span></span><span class=line><span class=cl>       | |-init_heartbeat_period()  ← 启动心跳
</span></span><span class=line><span class=cl>       | |-transmit_start()         ← RUN_HOOK()，binlog_transmit_delegate
</span></span><span class=line><span class=cl>       |
</span></span><span class=line><span class=cl>       |-###BEGIN while()循环，只要没有错误，线程未被杀死，则一直执行
</span></span><span class=line><span class=cl>       |-open_binlog_file()
</span></span><span class=line><span class=cl>       |-send_binlog()              ← 发送二进制日志
</span></span><span class=line><span class=cl>       | |-send_events()
</span></span><span class=line><span class=cl>       |   |-after_send_hook()
</span></span><span class=line><span class=cl>       |     |-RUN_HOOK()           ← 调用binlog_transmit-&gt;after_send_event()钩子函数
</span></span><span class=line><span class=cl>       |
</span></span><span class=line><span class=cl>       |-set_last_file()
</span></span><span class=line><span class=cl>       |-end_io_cache()
</span></span><span class=line><span class=cl>       |-mysql_file_close()
</span></span><span class=line><span class=cl>       |-###END
</span></span></code></pre></div><p>综上所述，MySQL 复制需要 Slave 先注册到 Master，再向 Master 提交 binlog 和 POS，请求发送 binlog；Master 接收到请求后，先做一系列验证，打开本地 binlog 文件，按照内部 event 的顺序，依序发给 slave。</p><a class=anchor id=备库应用日志></a><h1>备库应用日志 <a href=#%e5%a4%87%e5%ba%93%e5%ba%94%e7%94%a8%e6%97%a5%e5%bf%97 aria-hidden=true>#</a></h1><p>我们知道，在主库中会利用多线程机制并发执行，而复制时，在 5.6 之前只会有一个 SQL 线程，就导致复制延迟成为 MySQL 最为诟病的问题之一。</p><p>在 5.6 版本中，MySQL 提供了基于 schema 或者说是数据库的并行复制功能，不过对于很多单库的应用场景下，性能提升有限；5.7 开始，提供了基于组提交的并行复制技术，基本可以被认为是真正意义上的并行复制技术。</p><a class=anchor id=源码解析></a><h2>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h2><p>与 MySQL 备库中提供的多线程并发机制相关的，有两个函数的入口：<code>handle_slave_worker()</code> 和 <code>handle_slave_sql()</code>；前者为真正的工作函数，后者作为协调器会启动和分配 worker 线程。</p><p>其中，<code>handle_slave_sql()</code> 主要调用了 <code>slave_worker_exec_job_group()</code>，该函数会利用 C++ 的多态性，调用相应 event 的 <code>do_apply_event()</code> 虚函数，以便将不同的 event 操作在备机上重做一遍。</p><p>如下是 <code>handle_slave_sql()</code> 函数的调用逻辑。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>handle_slave_sql()                              ← ###作为协调线程
</span></span><span class=line><span class=cl> |-my_thread_init()
</span></span><span class=line><span class=cl> |-init_slave_thread()
</span></span><span class=line><span class=cl> |-slave_start_workers()                          MTS(Multi-Threaded Slave)
</span></span><span class=line><span class=cl> | |-init_hash_workers()
</span></span><span class=line><span class=cl> | |-slave_start_single_worker()
</span></span><span class=line><span class=cl> |   |-Rpl_info_factory::create_worker()
</span></span><span class=line><span class=cl> |   |-###                                      ← 如下操作是在一个线程里
</span></span><span class=line><span class=cl> |   |-handle_slave_worker()                    ← ###对于复制的并行执行线程
</span></span><span class=line><span class=cl> |     |-my_thread_init()
</span></span><span class=line><span class=cl> |     |-init_slave_thread()
</span></span><span class=line><span class=cl> |     |                                        ← 在while循环中执行
</span></span><span class=line><span class=cl> |     |-slave_worker_exec_job_group()
</span></span><span class=line><span class=cl> |       |-pop_jobs_item()                      ← 获取具体的event(ev)，会阻塞等待==&lt;&lt;&lt;==
</span></span><span class=line><span class=cl> |       |                                      ← 在while循环中执行
</span></span><span class=line><span class=cl> |       |-is_gtid_event()
</span></span><span class=line><span class=cl> |       |-worker-&gt;slave_worker_exec_event(ev)
</span></span><span class=line><span class=cl> |         |-ev-&gt;do_apply_event_worker()        ← 调用该函数应用event
</span></span><span class=line><span class=cl> |           |-do_apply_event()                 ← 利用C++多态性执行对应的event
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-### 如下从IO线程中读取数据
</span></span><span class=line><span class=cl> |-sql_slave_killed()                           ← 只要线程未kill则一直执行
</span></span><span class=line><span class=cl>   |-exec_relay_log_event()
</span></span><span class=line><span class=cl>     |-next_event()                             ← 从cache或者relaylog中读取event
</span></span><span class=line><span class=cl>     | |-sql_slave_killed()                     ← 只要线程未kill则一直执行
</span></span><span class=line><span class=cl>     | |-Log_event::read_log_event()            ← 读取记录，第一参数为IO_CACHE
</span></span><span class=line><span class=cl>     |   |-my_b_read()                          ← 从磁盘读取头部，并检查头部信息是否合法
</span></span><span class=line><span class=cl>     |   |-Log_event::read_log_event()          ← 处理读取到缓存中的数据，第一个参数为char*
</span></span><span class=line><span class=cl>     |     | ... ...
</span></span><span class=line><span class=cl>     |     |-Write_rows_log_event()             ← 根据不同的event类型，创建ev对象
</span></span><span class=line><span class=cl>     |     |-Update_rows_log_event()
</span></span><span class=line><span class=cl>     |     |-Delete_rows_log_event()
</span></span><span class=line><span class=cl>     |     | ... ...
</span></span><span class=line><span class=cl>     |
</span></span><span class=line><span class=cl>     |-apply_event_and_update_pos()             ← 执行event并修改当前读的位置
</span></span><span class=line><span class=cl>       |-append_item_to_jobs()                  ← 发送给workers线程==&gt;&gt;&gt;==
</span></span></code></pre></div><p>首先，看下 SQL 线程的处理流程，也就是从 <code>read_log_event()</code> 函数中读取处理；这里会根据事件的类型来调用相应的构造函数，这里只关心 ROW 模式的事件处理：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Log_event</span><span class=o>*</span> <span class=n>Log_event</span><span class=o>::</span><span class=n>read_log_event</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>buf</span><span class=p>,</span> <span class=n>uint</span> <span class=n>event_len</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>**</span><span class=n>error</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=k>const</span> <span class=n>Format_description_log_event</span> <span class=o>*</span><span class=n>description_event</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>my_bool</span> <span class=n>crc_check</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span><span class=p>(</span><span class=n>event_type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=cp>#if defined(HAVE_REPLICATION)
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>case</span> <span class=n>binary_log</span><span class=o>::</span><span class=nl>WRITE_ROWS_EVENT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ev</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Write_rows_log_event</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>event_len</span><span class=p>,</span> <span class=n>description_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>binary_log</span><span class=o>::</span><span class=nl>UPDATE_ROWS_EVENT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ev</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Update_rows_log_event</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>event_len</span><span class=p>,</span> <span class=n>description_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>binary_log</span><span class=o>::</span><span class=nl>DELETE_ROWS_EVENT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ev</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Delete_rows_log_event</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>event_len</span><span class=p>,</span> <span class=n>description_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>binary_log</span><span class=o>::</span><span class=nl>TRANSACTION_CONTEXT_EVENT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ev</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Transaction_context_log_event</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>event_len</span><span class=p>,</span> <span class=n>description_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>binary_log</span><span class=o>::</span><span class=nl>VIEW_CHANGE_EVENT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=n>ev</span> <span class=o>=</span> <span class=k>new</span> <span class=n>View_change_log_event</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>event_len</span><span class=p>,</span> <span class=n>description_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如下是 <code>do_apply_event_worker()</code> 函数的代码，event 是 binlog 的最小单元，所有的 event 的父类是 <code>Log_event</code>(抽象基类)，它定义了一系列虚函数，其中就包括我们这里调用的函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>inline int Log_event::do_apply_event_worker(Slave_worker *w)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  DBUG_EXECUTE_IF(&#34;crash_in_a_worker&#34;,
</span></span><span class=line><span class=cl>                  {
</span></span><span class=line><span class=cl>                    /* we will crash a worker after waiting for
</span></span><span class=line><span class=cl>                    2 seconds to make sure that other transactions are
</span></span><span class=line><span class=cl>                    scheduled and completed */
</span></span><span class=line><span class=cl>                    if (w-&gt;id == 2)
</span></span><span class=line><span class=cl>                    {
</span></span><span class=line><span class=cl>                      DBUG_SET(&#34;-d,crash_in_a_worker&#34;);
</span></span><span class=line><span class=cl>                      my_sleep(2000000);
</span></span><span class=line><span class=cl>                      DBUG_SUICIDE();
</span></span><span class=line><span class=cl>                    }
</span></span><span class=line><span class=cl>                  });
</span></span><span class=line><span class=cl>  return do_apply_event(w);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>对于 <code>do_apply_event()</code> 实现可以查看 <code>sql/log_event.cc</code> 文件内容。</p><a class=anchor id=事件简介></a><h1>事件简介 <a href=#%e4%ba%8b%e4%bb%b6%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>在 INSERT、UPDATE、DELETE 事件中，实际执行父类 <code>Rows_log_event::do_apply_event()</code>，接下来，简单说明下数据是怎么应用到备库。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Write_rows_log_event
</span></span><span class=line><span class=cl>Update_rows_log_event
</span></span><span class=line><span class=cl>Delete_rows_log_event
</span></span><span class=line><span class=cl>    如上三个事件都是调用其基类Rows_log_event::do_apply_event()；
</span></span></code></pre></div><p>其中 <code>Rows_log_event::do_apply_event()</code> 函数的部分调用代码逻辑如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>Rows_log_event</span><span class=o>::</span><span class=n>do_apply_event</span><span class=p>(</span><span class=n>Relay_log_info</span> <span class=k>const</span> <span class=o>*</span><span class=n>rli</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>table</span><span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>m_table</span><span class=o>=</span> <span class=k>const_cast</span><span class=o>&lt;</span><span class=n>Relay_log_info</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>rli</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>m_table_map</span><span class=p>.</span><span class=n>get_table</span><span class=p>(</span><span class=n>m_table_id</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>table</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>m_rows_lookup_algorithm</span> <span class=o>!=</span> <span class=n>ROW_LOOKUP_NOT_NEEDED</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=o>!</span><span class=n>is_any_column_signaled_for_table</span><span class=p>(</span><span class=n>table</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>m_cols</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>error</span><span class=o>=</span> <span class=n>HA_ERR_END_OF_FILE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>goto</span> <span class=n>AFTER_MAIN_EXEC_ROW_LOOP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>m_rows_lookup_algorithm</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=nl>ROW_LOOKUP_HASH_SCAN</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>do_apply_row_ptr</span><span class=o>=</span> <span class=o>&amp;</span><span class=n>Rows_log_event</span><span class=o>::</span><span class=n>do_hash_scan_and_update</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=nl>ROW_LOOKUP_INDEX_SCAN</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>do_apply_row_ptr</span><span class=o>=</span> <span class=o>&amp;</span><span class=n>Rows_log_event</span><span class=o>::</span><span class=n>do_index_scan_and_update</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=nl>ROW_LOOKUP_TABLE_SCAN</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>do_apply_row_ptr</span><span class=o>=</span> <span class=o>&amp;</span><span class=n>Rows_log_event</span><span class=o>::</span><span class=n>do_table_scan_and_update</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>case</span> <span class=nl>ROW_LOOKUP_NOT_NEEDED</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DBUG_ASSERT</span><span class=p>(</span><span class=n>get_general_type_code</span><span class=p>()</span> <span class=o>==</span> <span class=n>binary_log</span><span class=o>::</span><span class=n>WRITE_ROWS_EVENT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* No need to scan for rows, just apply it */</span>
</span></span><span class=line><span class=cl>        <span class=n>do_apply_row_ptr</span><span class=o>=</span> <span class=o>&amp;</span><span class=n>Rows_log_event</span><span class=o>::</span><span class=n>do_apply_row</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>DBUG_ASSERT</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span><span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>AFTER_MAIN_EXEC_ROW_LOOP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>error</span><span class=o>=</span> <span class=p>(</span><span class=k>this</span><span class=o>-&gt;*</span><span class=n>do_apply_row_ptr</span><span class=p>)(</span><span class=n>rli</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>handle_idempotent_and_ignored_errors</span><span class=p>(</span><span class=n>rli</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>error</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* this advances m_curr_row */</span>
</span></span><span class=line><span class=cl>      <span class=n>do_post_row_operations</span><span class=p>(</span><span class=n>rli</span><span class=p>,</span> <span class=n>error</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>error</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>m_curr_row</span> <span class=o>!=</span> <span class=n>m_rows_end</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>首先，通过 <code>get_table()</code> 调用，从 <code>table map</code> 中获得对应的 table 信息，然后根据不同的类型通过 <code>do_apply_row_ptr</code> 函数指针指向的函数，将事件对应操作应用到备库。</p><p>如上代码所示，<code>do_apply_row_ptr</code> 函数指针可能指向以下几种不同的函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>do_hash_scan_and_update
</span></span><span class=line><span class=cl>do_index_scan_and_update
</span></span><span class=line><span class=cl>do_table_scan_and_update
</span></span><span class=line><span class=cl>do_apply_row
</span></span></code></pre></div><p>对于 insert 操作，不用查找数据，会直接调用 <code>do_apply_row()</code>，调用逻辑如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>do_apply_row()
</span></span><span class=line><span class=cl> |-do_exec_row()
</span></span><span class=line><span class=cl>   |-write_row()
</span></span><span class=line><span class=cl>     |-ha_start_bulk_insert()
</span></span></code></pre></div><p>也就是说，它直接把这一行数据交给了存储引擎，让存储引擎把数据给插进去。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>MySQL 中与复制相关的内容，可以参考官方文档 <a href=http://dev.mysql.com/doc/refman/en/replication.html>MySQL Reference Manual - Replication</a>。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#执行命令>执行命令</a></li><li><a href=#启动备库>启动备库</a></li><li><a href=#连接主库>连接主库</a></li><li><a href=#备库应用日志>备库应用日志</a><ul><li><a href=#源码解析>源码解析</a></li></ul></li><li><a href=#事件简介>事件简介</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>