<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>TCP/IP 协议之 TIME_WAIT | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="TIME_WAIT 是 TCP 协议栈中比较特殊的状态，其主要目的是保证不同的链接不会相互干扰，但是对于一些高性能的场景，就可能由于较多的 TIME_WAIT 状态最终导致链接不可用。
如下简单介绍如何充分利用该状态。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>TCP/IP 协议之 TIME_WAIT</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-04-29</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/network/ role=button>network</a></div></div><hr><div class=content><p><code>TIME_WAIT</code> 是 TCP 协议栈中比较特殊的状态，其主要目的是保证不同的链接不会相互干扰，但是对于一些高性能的场景，就可能由于较多的 <code>TIME_WAIT</code> 状态最终导致链接不可用。</p><p>如下简单介绍如何充分利用该状态。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>如下是 TCP 的状态转换图，主动关闭链接的一端会进入 <code>TIME_WAIT</code> 状态。</p><p><img alt="TCP/IP Finite State Machine FSM" src=images/The-TCP-Finite-State-MachineFSM.png class="mx-auto d-block"></p><p>可以通过如下命令统计当前不同状态的链接数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 建议使用后者，要快很多
</span></span><span class=line><span class=cl># netstat -ant | awk &#39;/^tcp/ {++state[$NF]} END {for(key in state) print key,state[key]}&#39; | sort -rnk2
</span></span><span class=line><span class=cl># ss -ant | awk &#39;!/^State/ {++state[$1]} END {for(key in state) print key,state[key]}&#39; | sort -rnk2
</span></span></code></pre></div><p>如上，<code>TIME_WAIT</code> 是在发起主动关闭一方，完成四次挥手后 TCP 状态转换为 <code>TIME_WAIT</code> 状态，并且该状态会保持两个 MSL 。</p><p>在 Linux 里一个 MSL 为 30s，不可配置，在 <code>include/net/tcp.h</code> 中定义如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define TCP_TIMEWAIT_LEN (60*HZ) </span><span class=cm>/* how long to wait to destroy TIME-WAIT
</span></span></span><span class=line><span class=cl><span class=cm>                                  * state, about 60 seconds */</span><span class=cp>
</span></span></span></code></pre></div><a class=anchor id=原因></a><h2>原因 <a href=#%e5%8e%9f%e5%9b%a0 aria-hidden=true>#</a></h2><p>之所以采用两个 MSL 主要是为了可靠安全的关闭 TCP 连接。</p><a class=anchor id=报文延迟></a><h4>报文延迟 <a href=#%e6%8a%a5%e6%96%87%e5%bb%b6%e8%bf%9f aria-hidden=true>#</a></h4><p>最常见的是为了防止前一个链接的延迟报文被下一个链接接收，当然这两个链接的四元组 (source address, source port, destination address, destination port) 是相同的，而且序列号 sequence 也是在特定范围内的。</p><p>虽然满足上述场景的概率很小，但是对于 fast connections 以及滑动窗口很大时，会增加出现这种场景的概率。关于 <code>TIME_WAIT</code> 详细讨论可以参考 <a href=https://tools.ietf.org/html/rfc1337>rfc1337</a> 。</p><p>下图是一个延迟延迟报文，在原链接已经正常关闭，并使用相同的端口建立了新链接，那么上个链接发送的报文可能混入新的链接中。</p><p><img alt="timewait duplicate segment" src=images/tcpip_timewait_duplicate_segment.png class="mx-auto d-block"></p><a class=anchor id=确保远端以关闭></a><h4>确保远端以关闭 <a href=#%e7%a1%ae%e4%bf%9d%e8%bf%9c%e7%ab%af%e4%bb%a5%e5%85%b3%e9%97%ad aria-hidden=true>#</a></h4><p>当发送的最后一个 ACK 丢失后，远端处于 LAST_ACK 状态，在此状态时，如果没有收到最后的 ACK 报文，那么就会重发 FIN 。</p><p>如下图，当 FIN 丢失，那么被动关闭方会处于 LAST_ACK 状态，那么尝试重新建立链接时，会直接发送一个 RST 关闭链接，影响新链接创建。</p><p><img alt="timewait last ack" src=images/tcpip_timewait_last_ack.png class="mx-auto d-block"></p><p>注意，处于 <code>LAST_ACK</code> 状态的链接，如果没有收到最后一个 ACK 报文，那么就会一致重发 FIN 报文，直到如下条件：</p><ol><li>由于超时自动关闭链接；</li><li>收到了 ACK 报文然后关闭链接；</li><li>收到了 RST 报文并关闭链接。</li></ol><p>简言之，通过 2MSL 等待时间，保证前一个链接的报文已经在网络上消失，保证双方都已经正常关闭链接。</p><a class=anchor id=产生影响></a><h1>产生影响 <a href=#%e4%ba%a7%e7%94%9f%e5%bd%b1%e5%93%8d aria-hidden=true>#</a></h1><p>当有较多链接处于 <code>TIME_WAIT</code> 状态 (可以通过 <code>ss -tan state time-wait | wc -l</code> 查看)，那么一般会有如下几个方面的影响：</p><ol><li>占用文件描述符 (fd) ，会导致无法创建相同类型的链接；</li><li>内核中 socket 结构体占用的内存资源；</li><li>额外的 CPU 消耗。</li></ol><p>接下来，一个一个看看其影响。</p><a class=anchor id=文件描述符></a><h2>文件描述符 <a href=#%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6 aria-hidden=true>#</a></h2><p>一个链接在 <code>TIME_WAIT</code> 保存一分钟，那么相同四元组 (saddr, sport, daddr, dport) 的链接就无法创建；实际上，如果从内核角度看，实际上根据配置项，还可能包含了 sequence 以及 timestamp 。</p><p>如果服务器是挂载在一个 L7 Load-Balancer 之后的，那么源地址是相同的，而 Linux 中的 Port 分配范围是通过 <code>net.ipv4.ip_local_port_range</code> 参数配置的，默认是 3W 左右的可用端口，那么平均是每秒 500 个链接。</p><p>在客户端，那么就会报 <code>EADDRNOTAVAIL (Cannot assign requested address)</code> 错误，而服务端的排查相比来说要复杂的多，如下可以查看当前与客户端的链接数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- sport就是Local Address列对应的端口
</span></span><span class=line><span class=cl># ss -tan &#39;sport = :80&#39; | awk &#39;/^TIME-WAIT/ {print $(NF)&#34; &#34;$(NF-1)}&#39; | \
</span></span><span class=line><span class=cl>    sed &#39;s/:[^ ]*//g&#39; | sort | uniq -c | sort -rn
</span></span></code></pre></div><p>针对这一场景，那么就是如何增加四元组，按照难度依次列举如下：</p><ol><li>客户端添加更多的端口范围，设置 <code>net.ipv4.ip_local_port_range</code>；</li><li>服务端增加监听端口，例如额外增加 81、82、83 &mldr;；</li></ol><p>注意，在客户端，不同版本的内核其行为也略有区别，老版本内核会查找空闲的本地二元组 (source address, source port)，此时增加服务端的 IP 以及 port 时不会增大链接数；而 Linux 3.2 之后，对于不同的四元组那么可以复用本地的二元组。</p><p>最后就是调整 <code>net.ipv4.tcp_tw_reuse</code> 和 <code>net.ipv4.tcp_tw_recycle</code> 参数，不过在一些场景下可能会有问题，所以尽量不要使用，下面再详细介绍。</p><a class=anchor id=内存></a><h2>内存 <a href=#%e5%86%85%e5%ad%98 aria-hidden=true>#</a></h2><p>假设每秒要处理 1W 的链接，那么在 Linux 中处于 <code>TIME_WAIT</code> 状态的链接数就有 60W ，这样的话是否会消耗很多的内存资源？</p><p>首先，应用端的 <code>TIME_WAIT</code> 状态链接已经关闭，所以不会消耗资源；主要资源的消耗在内核中。内核中保存了三个不同的结构体：</p><a class=anchor id=hash-table></a><h4>HASH TABLE <a href=#hash-table aria-hidden=true>#</a></h4><p><code>connection hash table</code> 用于快速定位一个现有的链接，例如接收到一个报文快速定位到链接结构体。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ dmesg | grep &#34;TCP established hash table&#34;
</span></span><span class=line><span class=cl>[    0.292951] TCP established hash table entries: 65536 (order: 7, 524288 bytes)
</span></span></code></pre></div><p>可以在内核启动时通过 <code>thash_entries</code> 参数设置，系统启动时会调用 <code>alloc_large_system_hash()</code> 函数初始化，并打印上述的启动日志信息。</p><p>内核中，处于 <code>TIME_WAIT</code> 状态的链接使用的是 <code>struct tcp_timewait_sock</code> 结构体，而其它状态则使用的是 <code>struct tcp_sock</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>inet_timewait_sock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sock_common</span>  <span class=n>__tw_common</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>                     <span class=n>tw_timeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>volatile</span> <span class=kt>unsigned</span> <span class=kt>char</span>  <span class=n>tw_substate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span>           <span class=n>tw_rcv_wscale</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>__be16</span> <span class=n>tw_sport</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=nl>tw_ipv6only</span>     <span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=nl>tw_transparent</span>  <span class=p>:</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=nl>tw_pad</span>          <span class=p>:</span> <span class=mi>6</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=nl>tw_tos</span>          <span class=p>:</span> <span class=mi>8</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=nl>tw_ipv6_offset</span>  <span class=p>:</span> <span class=mi>16</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span>            <span class=n>tw_ttd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inet_bind_bucket</span> <span class=o>*</span><span class=n>tw_tb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>hlist_node</span>        <span class=n>tw_death_node</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>tcp_timewait_sock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inet_timewait_sock</span> <span class=n>tw_sk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>    <span class=n>tw_rcv_nxt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>    <span class=n>tw_snd_nxt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>    <span class=n>tw_rcv_wnd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>    <span class=n>tw_ts_offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>    <span class=n>tw_ts_recent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span>   <span class=n>tw_ts_recent_stamp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><a class=anchor id=time_wait></a><h4>TIME_WAIT <a href=#time_wait aria-hidden=true>#</a></h4><p>用于判断处于 <code>TIME_WAIT</code> 状态的 socket 还有多长时间过期，与上述的 hash 表使用相同的结构体，也就是对应了 <code>struct inet_timewait_sock</code> 结构体中的 <code>struct hlist_node tw_death_node</code> 。</p><a class=anchor id=hash-table-1></a><h4>HASH TABLE <a href=#hash-table-1 aria-hidden=true>#</a></h4><p><code>bind hash table</code> 用于保存本地已经保存的端口以及相关参数，用于绑定 listen 端口以及查找可用端口。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ dmesg | grep &#34;TCP bind hash table&#34;
</span></span><span class=line><span class=cl>[    0.293146] TCP bind hash table entries: 65536 (order: 8, 1048576 bytes)
</span></span></code></pre></div><p>这里每个元素使用 <code>struct inet_bind_socket</code> 结构体，大小与 connection 相同。</p><p>重点关注两个 hash 表使用的内存即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># slabtop -o | grep -E &#39;(^  OBJS|tw_sock_TCP|tcp_bind_bucket)&#39;
</span></span><span class=line><span class=cl>  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME                   
</span></span><span class=line><span class=cl> 50955  49725  97%    0.25K   3397       15     13588K tw_sock_TCP            
</span></span><span class=line><span class=cl> 44840  36556  81%    0.06K    760       59      3040K tcp_bind_bucket
</span></span></code></pre></div><a class=anchor id=内核参数调优></a><h1>内核参数调优 <a href=#%e5%86%85%e6%a0%b8%e5%8f%82%e6%95%b0%e8%b0%83%e4%bc%98 aria-hidden=true>#</a></h1><p>相关参数可以查看内核文档 <a href=https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>ip-sysctl.txt</a> ，仅摘取与此相关的参数介绍：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>tcp_tw_reuse - BOOLEAN
</span></span><span class=line><span class=cl>    Allow to reuse TIME-WAIT sockets for new connections when it is
</span></span><span class=line><span class=cl>    safe from protocol viewpoint. Default value is 0.
</span></span><span class=line><span class=cl>    It should not be changed without advice/request of technical experts.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>tcp_tw_recycle - BOOLEAN
</span></span><span class=line><span class=cl>    Enable fast recycling TIME-WAIT sockets. Default value is 0.
</span></span><span class=line><span class=cl>    It should not be changed without advice/request of technical experts.
</span></span></code></pre></div><p>注意，在使用上述参数时，需要先开启 tcp_timestamps 参数，否则这里的配置时无效的，也就是需要开启如下参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 查看当前状态
</span></span><span class=line><span class=cl># sysctl net.ipv4.tcp_tw_reuse
</span></span><span class=line><span class=cl># sysctl net.ipv4.tcp_tw_recycle
</span></span><span class=line><span class=cl># sysctl net.ipv4.tcp_timestamps
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 将对应的参数开启
</span></span><span class=line><span class=cl># sysctl net.ipv4.tcp_tw_reuse=1
</span></span><span class=line><span class=cl># sysctl net.ipv4.tcp_tw_recycle=1
</span></span><span class=line><span class=cl># sysctl net.ipv4.tcp_timestamps=1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 写入到配置文件，持久化，并使配置立即生效
</span></span><span class=line><span class=cl># cat &lt;&lt; EOF &gt;&gt; /etc/sysctl.conf
</span></span><span class=line><span class=cl>net.ipv4.tcp_tw_reuse = 1
</span></span><span class=line><span class=cl>net.ipv4.tcp_tw_recycle = 1
</span></span><span class=line><span class=cl>net.ipv4.tcp_timestamps = 1
</span></span><span class=line><span class=cl>EOF
</span></span><span class=line><span class=cl># /sbin/sysctl -p
</span></span></code></pre></div><a class=anchor id=tcp_tw_reuse></a><h2>tcp_tw_reuse <a href=#tcp_tw_reuse aria-hidden=true>#</a></h2><p>如上所述，<code>TIME_WAIT</code> 状态主要是为了防止延迟报文影响新链接，不过在有些场景下可以确保不会出现这种情况。</p><p><a href=https://tools.ietf.org/html/rfc1323>RFC 1323</a> 提供了一个 TCP 扩展项，其中定义了两个四字节的时间戳选项，第一个是发送时的发送端时间戳，第二个是从远端接收报文的最近时间戳。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>TCP Timestamps Option (TSopt):
</span></span><span class=line><span class=cl>    +-------+-------+---------------------+---------------------+
</span></span><span class=line><span class=cl>    |Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|
</span></span><span class=line><span class=cl>    +-------+-------+---------------------+---------------------+
</span></span><span class=line><span class=cl>        1       1              4                     4
</span></span></code></pre></div><p>在开启了 <code>net.ipv4.tcp_tw_reuse</code> 参数后，对于 <strong>outgoing</strong> 的链接，Linux 会复用处于 <code>TIME_WAIT</code> 状态的资源，当然时间戳要大于前一个链接的最近时间戳，这也就意味着一般一秒之后就可以重新使用该链接。</p><p>对于上面说的第一种异常场景，也就是延迟报文被新链接接收，这一场景通过 timestamp 就可以判断上个链接的报文已经过期，从而会直接丢弃。</p><p>对于第二种场景，也即防止远端处于 <code>LAST_ACK</code> 状态，此时当复用处于 <code>TIME_WAIT</code> 状态的链接时，第一个发送的 SYN 报文，由于对方校验时间戳不通过，会直接丢弃，并重发一个 <code>FIN</code> 报文，由于此时处于 <code>SYN_SENT</code> 状态，则会发送一个 RST 报文关闭对端的链接。</p><p>接下来，就可以正常创建新链接，只是时间会略有增加。</p><p><img alt="tcpip timewait last ack reuse" src=images/tcpip_timewait_last_ack_reuse.png class="mx-auto d-block"></p><a class=anchor id=tcp_tw_recycle></a><h2>tcp_tw_recycle <a href=#tcp_tw_recycle aria-hidden=true>#</a></h2><p>同样需要开启 timestamp 参数，不过会影响到 <strong>incoming 和 outcoming</strong> 。</p><p>正常来说，处于 <code>TIME_WAIT</code> 状态的超时时间为 <code>TCP_TIMEWAIT_LEN</code> ，也即 60s；当开启了该参数后，该 socket 的释放时间与 RTO (通过RTT计算) 相关。</p><p>关于当前链接的 RTO 可以通过 <code>ss --info sport = :2112 dport = :4057</code> 命令查看。</p><p>这一过程的处理可以查看源码中的 <code>tcp_time_wait()</code> 函数，内容摘取如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>tcp_death_row</span><span class=p>.</span><span class=n>sysctl_tw_recycle</span> <span class=o>&amp;&amp;</span> <span class=n>tp</span><span class=o>-&gt;</span><span class=n>rx_opt</span><span class=p>.</span><span class=n>ts_recent_stamp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>recycle_ok</span> <span class=o>=</span> <span class=n>icsk</span><span class=o>-&gt;</span><span class=n>icsk_af_ops</span><span class=o>-&gt;</span><span class=nf>remember_stamp</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>......</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>timeo</span> <span class=o>&lt;</span> <span class=n>rto</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>timeo</span> <span class=o>=</span> <span class=n>rto</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>recycle_ok</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>tw</span><span class=o>-&gt;</span><span class=n>tw_timeout</span> <span class=o>=</span> <span class=n>rto</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>tw</span><span class=o>-&gt;</span><span class=n>tw_timeout</span> <span class=o>=</span> <span class=n>TCP_TIMEWAIT_LEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>state</span> <span class=o>==</span> <span class=n>TCP_TIME_WAIT</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>timeo</span> <span class=o>=</span> <span class=n>TCP_TIMEWAIT_LEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>inet_twsk_schedule</span><span class=p>(</span><span class=n>tw</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>tcp_death_row</span><span class=p>,</span> <span class=n>timeo</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=n>TCP_TIMEWAIT_LEN</span><span class=p>);</span>
</span></span></code></pre></div><p>在内核源码可以发现 <code>tcp_tw_recycle</code> 和 <code>tcp_timestamps</code> 都开启的条件下，如果 60s 内同一源 IP 主机的 socket connect 请求中的 timestamp 必须是递增的。</p><p>可以从 TCP 的三次握手时的 SYN 包的处理函数中，也就是 <code>tcp_conn_request()</code> 函数中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>tcp_peer_is_proven</span><span class=p>(</span><span class=k>struct</span> <span class=n>request_sock</span> <span class=o>*</span><span class=n>req</span><span class=p>,</span> <span class=k>struct</span> <span class=n>dst_entry</span> <span class=o>*</span><span class=n>dst</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>paws_check</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>timestamps</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>tcp_metrics_block</span> <span class=o>*</span><span class=n>tm</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>dst</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>rcu_read_lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>tm</span> <span class=o>=</span> <span class=nf>__tcp_get_metrics_req</span><span class=p>(</span><span class=n>req</span><span class=p>,</span> <span class=n>dst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>paws_check</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tm</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 判断表示该源ip的上次tcp通讯发生在60s内
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>(</span><span class=n>u32</span><span class=p>)</span><span class=nf>get_seconds</span><span class=p>()</span> <span class=o>-</span> <span class=n>tm</span><span class=o>-&gt;</span><span class=n>tcpm_ts_stamp</span> <span class=o>&lt;</span> <span class=n>TCP_PAWS_MSL</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 该条件判断表示该源ip的上次tcp通讯的timestamp 大于本次tcp
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>((</span><span class=n>s32</span><span class=p>)(</span><span class=n>tm</span><span class=o>-&gt;</span><span class=n>tcpm_ts</span> <span class=o>-</span> <span class=n>req</span><span class=o>-&gt;</span><span class=n>ts_recent</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>TCP_PAWS_WINDOW</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>             <span class=o>!</span><span class=n>timestamps</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tm</span> <span class=o>&amp;&amp;</span> <span class=nf>tcp_metric_get</span><span class=p>(</span><span class=n>tm</span><span class=p>,</span> <span class=n>TCP_METRIC_RTT</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>tm</span><span class=o>-&gt;</span><span class=n>tcpm_ts_stamp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>rcu_read_unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tcp_conn_request</span><span class=p>(</span><span class=k>struct</span> <span class=n>request_sock_ops</span> <span class=o>*</span><span class=n>rsk_ops</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>const</span> <span class=k>struct</span> <span class=n>tcp_request_sock_ops</span> <span class=o>*</span><span class=n>af_ops</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tcp_death_row</span><span class=p>.</span><span class=n>sysctl_tw_recycle</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 本机系统开启tcp_tw_recycle选项
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>bool</span> <span class=n>strict</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>dst</span> <span class=o>=</span> <span class=n>af_ops</span><span class=o>-&gt;</span><span class=nf>route_req</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fl</span><span class=p>,</span> <span class=n>req</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>strict</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>dst</span> <span class=o>&amp;&amp;</span> <span class=n>strict</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=o>!</span><span class=nf>tcp_peer_is_proven</span><span class=p>(</span><span class=n>req</span><span class=p>,</span> <span class=n>dst</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>tmp_opt</span><span class=p>.</span><span class=n>saw_tstamp</span><span class=p>))</span> <span class=p>{</span> <span class=c1>// 该socket支持tcp_timestamp
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>NET_INC_STATS_BH</span><span class=p>(</span><span class=nf>sock_net</span><span class=p>(</span><span class=n>sk</span><span class=p>),</span> <span class=n>LINUX_MIB_PAWSPASSIVEREJECTED</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>drop_and_release</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上述种的状态统计可以查看 <code>/proc/net/netstat</code> 文件中的 <code>PAWSPassive</code> 。</p><a class=anchor id=nat></a><h3>NAT <a href=#nat aria-hidden=true>#</a></h3><p>不过上述的修改，在 NAT 场景下可能会引起更加复杂的问题，在 <a href=https://tools.ietf.org/html/rfc1323>rfc1323</a> 中，有如下描述。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>An additional mechanism could be added to the TCP, a per-host
</span></span><span class=line><span class=cl>cache of the last timestamp received from any connection.
</span></span><span class=line><span class=cl>This value could then be used in the PAWS mechanism to reject
</span></span><span class=line><span class=cl>old duplicate segments from earlier incarnations of the
</span></span><span class=line><span class=cl>connection, if the timestamp clock can be guaranteed to have
</span></span><span class=line><span class=cl>ticked at least once since the old connection was open.  This
</span></span><span class=line><span class=cl>would require that the TIME-WAIT delay plus the RTT together
</span></span><span class=line><span class=cl>must be at least one tick of the sender&#39;s timestamp clock.
</span></span><span class=line><span class=cl>Such an extension is not part of the proposal of this RFC.
</span></span></code></pre></div><p>大概意思是说 TCP 可以缓存从每个主机收到报文的最新时间戳，后续请求的时间戳如果小于缓存时间戳，则认为该报文无效，数据包会被丢弃。</p><p>如上所述，这一行为在 Linux 中在 <code>tcp_timestamps</code> 和 <code>tcp_tw_recycle</code> 都开启时使用，而前者默认是开启的，所以当 <code>tcp_tw_recycle</code> 被开启后，实际上这种行为就被激活了，那么当客户端或服务端以 NAT 方式构建的时候就可能出现问题。</p><a class=anchor id=问题排查></a><h1>问题排查 <a href=#%e9%97%ae%e9%a2%98%e6%8e%92%e6%9f%a5 aria-hidden=true>#</a></h1><p>针对上述讨论的部分异常，简单讨论下常见的场景。</p><a class=anchor id=eaddrnotavail></a><h2>EADDRNOTAVAIL <a href=#eaddrnotavail aria-hidden=true>#</a></h2><p>在客户端尝试建立链接时，如果报 <code>EADDRNOTAVAIL (Cannot assign requested address)</code> 错误，而且查看可能是已经达到了最大的端口可用数量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 查看内核端口可用范围
</span></span><span class=line><span class=cl>$ sysctl net.ipv4.ip_local_port_range
</span></span><span class=line><span class=cl>net.ipv4.ip_local_port_range = 32768 60999
</span></span><span class=line><span class=cl>----- 上述范围是闭区间，实际可用的端口数量是
</span></span><span class=line><span class=cl>$ echo $((60999-32768+1))
</span></span><span class=line><span class=cl>28232
</span></span></code></pre></div><p>针对这一故障场景，可以通过如下步骤修复：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 增加本地可用端口数量，这里是临时修改
</span></span><span class=line><span class=cl>$ sysctl net.ipv4.ip_local_port_range=&#34;10240 61000&#34;
</span></span><span class=line><span class=cl>----- 减少TIME_WAIT连接状态
</span></span><span class=line><span class=cl>$ sysctl net.ipv4.tcp_tw_reuse=1
</span></span></code></pre></div><a class=anchor id=nat-1></a><h2>NAT <a href=#nat-1 aria-hidden=true>#</a></h2><p>当进行 SNAT 转换时，也即是在服务端看到的都是同一个 IP，那么对于服务端而言这些客户端实际上等同于一个，而客户端的时间戳会存在差异，那么服务端就会出现时间戳错乱的现象，进而直接丢弃时间戳小的数据包。</p><p>这类问题的现象是，客户端明发送的 SYN 报文，但服务端没有响应 ACK，可以通过下面命令来确认数据包不断被丢弃的现象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ netstat -s | grep timestamp
</span></span><span class=line><span class=cl>... packets rejects in established connections because of timestamp
</span></span></code></pre></div><p>所以，如果无法确定没有使用 NAT ，那么为了安全起见，需要禁止 tcp_tw_recycle 。</p><a class=anchor id=tcp_max_tw_buckets></a><h2>tcp_max_tw_buckets <a href=#tcp_max_tw_buckets aria-hidden=true>#</a></h2><p>该参数用于设置 <code>TIME_WAIT</code> 状态的 socket 数，超过该限制后就会删除掉，此时系统日志里会显示： <code>TCP: time wait bucket table overflow</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># sysctl net.ipv4.tcp_max_tw_buckets=100000
</span></span></code></pre></div><p>如果是 NAT 网络环境又存在大量访问，会产生各种连接不稳定断开的情况。</p><a class=anchor id=总结></a><h1>总结 <a href=#%e6%80%bb%e7%bb%93 aria-hidden=true>#</a></h1><p>处于 <code>TIME_WAIT</code> 状态的链接，最大的消耗不是内存或者 CPU，而是四元组对应的资源，所以最有效的方式是增加端口范围、增加地址等。</p><p>在 <strong>服务端</strong>，除非确定没有使用 NAT ，否则不要配置 <code>tcp_tw_recycle</code> 参数；另外，<code>tcp_tw_reuse</code> 参数对 incoming 报文无效。</p><p>在 <strong>客户端</strong>，可以直接开启 <code>tcp_tw_reuse</code> 参数，而 <code>tcp_tw_recycle</code> 参数的作用不是很大。</p><p>另外，在设计协议时，尽量不要让客户端先关闭链接，最好让服务端去处理这种场景。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>一篇很不错的文章，可以参考 <a href=https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux>Coping with the TCP TIME-WAIT state on busy Linux servers</a> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#原因>原因</a></li></ul></li><li><a href=#产生影响>产生影响</a><ul><li><a href=#文件描述符>文件描述符</a></li><li><a href=#内存>内存</a></li></ul></li><li><a href=#内核参数调优>内核参数调优</a><ul><li><a href=#tcp_tw_reuse>tcp_tw_reuse</a></li><li><a href=#tcp_tw_recycle>tcp_tw_recycle</a></li></ul></li><li><a href=#问题排查>问题排查</a><ul><li><a href=#eaddrnotavail>EADDRNOTAVAIL</a></li><li><a href=#nat-1>NAT</a></li><li><a href=#tcp_max_tw_buckets>tcp_max_tw_buckets</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>