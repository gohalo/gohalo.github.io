<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>MySQL 组提交 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="组提交 (group commit) 是为了优化写日志时的刷磁盘问题，从最初只支持 InnoDB redo log 组提交，到 5.6 官方版本同时支持 redo log 和 binlog 组提交，大大提高了 MySQL 的事务处理性能。
下面将以 InnoDB 存储引擎为例，详细介绍组提交在各个阶段的实现原理。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>MySQL 组提交</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2017-10-01</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/database/ role=button>database</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/mysql/ role=button>mysql</a></div></div><hr><div class=content><p>组提交 (group commit) 是为了优化写日志时的刷磁盘问题，从最初只支持 InnoDB redo log 组提交，到 5.6 官方版本同时支持 redo log 和 binlog 组提交，大大提高了 MySQL 的事务处理性能。</p><p>下面将以 InnoDB 存储引擎为例，详细介绍组提交在各个阶段的实现原理。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>自 5.1 之后，binlog 和 innodb 采用类似两阶段提交的方式，不过不支持 group commit；在 5.6 中，将 binlog 的 commit 阶段分为三个阶段：<code>flush stage</code>、<code>sync stage</code> 以及 <code>commit stage</code>。</p><p>这三个阶段中，每个阶段都会去维护一个队列，各个列表的定义如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Mutex_queue</span> <span class=n>m_queue</span><span class=p>[</span><span class=n>STAGE_COUNTER</span><span class=p>];</span>
</span></span></code></pre></div><p>如上，每个阶段都在维护一个队列，第一个进入该队列的作为 leader 线程，否则作为 follower 线程；leader 线程会收集 follower 的事务，并负责做 sync，follower 线程等待 leader 通知操作完成。</p><p>尽管维护了三个队列，但队列中所有的 THD 实际上都是通过 <code>next_to_commit</code> 连接起来。binlog 在事务提交阶段，也就是在 <code>MYSQL_BIN_LOG::ordered_commit()</code> 函数中，开始 3 个阶段的流程。</p><p>接下来，看看 MySQL 中事务是如何提交的。</p><a class=anchor id=事务提交></a><h1>事务提交 <a href=#%e4%ba%8b%e5%8a%a1%e6%8f%90%e4%ba%a4 aria-hidden=true>#</a></h1><p>接下来，看看 InnoDB 和 binlog 提交的流程。</p><a class=anchor id=二阶段提交></a><h2>二阶段提交 <a href=#%e4%ba%8c%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4 aria-hidden=true>#</a></h2><p>详细介绍下二阶段提交的过程。</p><a class=anchor id=未开启binlog时></a><h3>未开启binlog时 <a href=#%e6%9c%aa%e5%bc%80%e5%90%afbinlog%e6%97%b6 aria-hidden=true>#</a></h3><p>InnoDB 通过 redo 和 undo 日志来恢复数据库 (safe crash recovery)，当数据恢复时，通过 redo 日志将所有已经在存储引擎内部提交的事务应用 redo log 恢复，所有已经 prepared 但是没有 commit 的事务则会通过 undo log 做回滚。</p><p>然后客户端连接时就能看到已经提交的数据存在数据库内，未提交被回滚地数据需要重新执行。</p><a class=anchor id=开启binlog时></a><h3>开启binlog时 <a href=#%e5%bc%80%e5%90%afbinlog%e6%97%b6 aria-hidden=true>#</a></h3><p>为了保证存储引擎和 MySQL 的 binlog 保持一致，引入二阶段提交 (two phase commit, 2pc) 。</p><p>因为备库通过 binlog 重放主库提交的事务，假设主库存储引擎已经提交而 binlog 没有保持一致，则会使备库数据丢失造成主备数据不一致。</p><a class=anchor id=二阶段提交-1></a><h3>二阶段提交 <a href=#%e4%ba%8c%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4-1 aria-hidden=true>#</a></h3><p>如下是二阶段提交流程。</p><p><img alt="group commit 2pc" src=images/groupcommit_2pc.png class="mx-auto d-block"></p><p>详细执行流程为：</p><ol><li>InnoDB 的事务 Prepare 阶段，即 SQL 已经成功执行并生成 redo 和 undo 的内存日志；</li><li>binlog 提交，通过 <code>write()</code> 将 binlog 内存日志数据写入文件系统缓存；</li><li><code>fsync()</code> 将 binlog 文件系统缓存日志数据永久写入磁盘；</li><li>InnoDB 内部提交，commit 阶段在存储引擎内提交，通过 <code>innodb_flush_log_at_trx_commit</code> 参数控制，使 undo 和 redo 永久写入磁盘。</li></ol><p>开启 binlog 的 MySQL 在崩溃恢复 (crash recovery) 时：</p><ul><li>在 prepare 阶段崩溃，恢复时该事务未写入 binlog 且 InnoDB 未提交，该事务直接回滚；</li><li>在 binlog 已经 fsync() 永久写入 binlog，但 InnoDB 未来得及 commit 时崩溃；恢复时，将会从 binlog 中获取提交的信息，重做该事务并提交，使 InnoDB 和 binlog 始终保持一致。</li></ul><p>以上提到单个事务的二阶段提交过程，能够保证 InnoDB 和 binlog 保持一致，但是在并发的情况下怎么保证存储引擎和 binlog 提交的顺序一致？当并发提交的时，如果两者不一致会造成什么影响？</p><a class=anchor id=组提交异常></a><h1>组提交异常 <a href=#%e7%bb%84%e6%8f%90%e4%ba%a4%e5%bc%82%e5%b8%b8 aria-hidden=true>#</a></h1><p>首先看看，对于上述的问题，当并发提交的时，如果两者不一致会造成什么影响？</p><p><img alt="group commit 2pc" src=images/groupcommit_2pc_concurrency_bug.png class="mx-auto d-block"></p><p>如上所示，事务按照 <code>T1</code>、<code>T2</code>、<code>T3</code> 顺序开始执行，并依相同次序按照写入 binlog 日志文件系统缓存，调用 <code>fsync()</code> 进行一次组提交，将日志文件永久写入磁盘。</p><p>但是存储引擎提交的顺序为 <code>T2</code>、<code>T3</code>、<code>T1</code>，当 <code>T2</code>、<code>T3</code> 提交事务之后做了一个 On-line 的备份程序新建一个 slave 来做复制；而搭建备库时，<code>CHANGE MASTER TO</code> 的日志偏移量在 <code>T3</code> 事务之后。</p><p>那么事务 <code>T1</code> 在备机恢复 MySQL 数据库时，发现 <code>T1</code> 未在存储引擎内提交，那么在恢复时，<code>T1</code> 事务就会被回滚，此时就会导致主备数据不一致。</p><p><strong>结论</strong>：需要保证 binlog 的写入顺序和 InnoDB 事务提交顺序一致，用于 xtrabackup 备份恢复。</p><a class=anchor id=早期解决方案></a><h2>早期解决方案 <a href=#%e6%97%a9%e6%9c%9f%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-hidden=true>#</a></h2><p>早期，使用 <code>prepare_commit_mutex</code> 保证顺序，只有当上一个事务 commit 后释放锁，下个事务才可以进行 prepara 操作，并且在每个事务过程中 binlog 没有 <code>fsync()</code> 的调用。</p><p><img alt="group commit 2pc concurrency mutex" src=images/groupcommit_2pc_concurrency_mutex.png class="mx-auto d-block"></p><p>由于内存数据写入磁盘的开销很大，如果频繁 <code>fsync()</code> 把日志数据永久写入磁盘，数据库的性能将会急剧下降。为此提供 <code>sync_binlog</code> 参数来设置多少个 binlog 日志产生的时候调用一次 <code>fsync()</code> 把二进制日志刷入磁盘来提高整体性能，该参数的设置作用为：</p><ul><li><code>sync_binlog=0</code> 二进制日志 <code>fsync()</code> 的操作基于系统自动执行。</li><li><code>sync_binlog=1</code> 每次事务提交都会调用 <code>fsync()</code>，最大限度保证数据安全，但影响性能。</li><li><code>sync_binlog=N</code> 当数据库崩溃时，可能会丢失 <code>N-1</code> 个事务。</li></ul><p><code>prepare_commit_mutex</code> 的锁机制会严重影响高并发时的性能，而且 binlog 也无法执行组提交。</p><a class=anchor id=改进方案></a><h2>改进方案 <a href=#%e6%94%b9%e8%bf%9b%e6%96%b9%e6%a1%88 aria-hidden=true>#</a></h2><p>接下来，看看如何保证 binlog 写入顺序和存储引擎提交顺序是一致的，并且能够进行 binlog 的组提交？5.6 引入了组提交，并将提交过程分成 Flush stage、Sync stage、Commit stage 三个阶段。</p><p>这样，事务提交时分为了如下的阶段：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>InnoDB, Prepare
</span></span><span class=line><span class=cl>    SQL已经成功执行并生成了相应的redo和undo内存日志；
</span></span><span class=line><span class=cl>Binlog, Flush Stage
</span></span><span class=line><span class=cl>    所有已经注册线程都将写入binlog缓存；
</span></span><span class=line><span class=cl>Binlog, Sync Stage
</span></span><span class=line><span class=cl>    binlog缓存将sync到磁盘，sync_binlog=1时该队列中所有事务的binlog将永久写入磁盘；
</span></span><span class=line><span class=cl>InnoDB, Commit stage
</span></span><span class=line><span class=cl>    leader根据顺序调用存储引擎提交事务；
</span></span></code></pre></div><p>每个 Stage 阶段都有各自的队列，从而使每个会话的事务进行排队，提高并发性能。</p><p>如果当一个线程注册到一个空队列时，该线程就做为该队列的 leader，后注册到该队列的线程均为 follower，后续的操作，都由 leader 控制队列中 follower 行为。</p><p>leader 同时会带领当前队列的所有 follower 到下一个 stage 去执行，当遇到下一个 stage 为非空队列时，leader 会变成 follower 注册到此队列中；<strong>注意</strong>：follower 线程绝不可能变成 leader 。</p><a class=anchor id=配置参数></a><h2>配置参数 <a href=#%e9%85%8d%e7%bd%ae%e5%8f%82%e6%95%b0 aria-hidden=true>#</a></h2><p>与 binlog 组提交相关的参数主要包括了如下两个参数。</p><a class=anchor id=binlog_max_flush_queue_time></a><h3>binlog_max_flush_queue_time <a href=#binlog_max_flush_queue_time aria-hidden=true>#</a></h3><p>单位为微妙，用于从 flush 队列中取事务的超时时间，这主要是防止并发事务过高，导致某些事务的 RT 上升，详细的内容可以查看函数 <code>MYSQL_BIN_LOG::process_flush_stage_queue()</code> 。</p><p><strong>注意</strong>：该参数在 5.7 之后已经取消了。</p><a class=anchor id=binlog_order_commits></a><h3>binlog_order_commits <a href=#binlog_order_commits aria-hidden=true>#</a></h3><p>当设置为 0 时，事务可能以和 binlog 不同的顺序提交，其性能会有稍微提升，但并不是特别明显.</p><a class=anchor id=源码解析></a><h1>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h1><p>binlog 的组提交是通过 Stage_manager 管理，其中比较核心内容如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stage_manager</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=nc>StageID</span> <span class=p>{</span>         <span class=c1>// binlog的组提交包括了三个阶段
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>FLUSH_STAGE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>SYNC_STAGE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>COMMIT_STAGE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>STAGE_COUNTER</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Mutex_queue</span> <span class=n>m_queue</span><span class=p>[</span><span class=n>STAGE_COUNTER</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>组提交 (Group Commit) 三阶段流程，详细实现如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MYSQL_BIN_LOG::ordered_commit()           ← 执行事务顺序提交，binlog group commit的主流程
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-#########&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     ← 进入Stage_manager::FLUSH_STAGE阶段
</span></span><span class=line><span class=cl> |-change_stage(..., &amp;LOCK_log)
</span></span><span class=line><span class=cl> | |-stage_manager.enroll_for()           ← 将当前线程加入到m_queue[FLUSH_STAGE]中
</span></span><span class=line><span class=cl> | |
</span></span><span class=line><span class=cl> | |                                      ← (follower)返回true
</span></span><span class=line><span class=cl> | |-mysql_mutex_lock()                   ← (leader)对LOCK_log加锁，并返回false
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-finish_commit()                        ← (follower)对于follower则直接返回
</span></span><span class=line><span class=cl> | |-ha_commit_low()
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-process_flush_stage_queue()            ← (leader)对于follower则直接返回
</span></span><span class=line><span class=cl> | |-fetch_queue_for()                    ← 通过stage_manager获取队列中的成员
</span></span><span class=line><span class=cl> | | |-fetch_and_empty()                  ← 获取元素并清空队列
</span></span><span class=line><span class=cl> | |-ha_flush_log()
</span></span><span class=line><span class=cl> | |-flush_thread_caches()                ← 对于每个线程做该操作
</span></span><span class=line><span class=cl> | |-my_b_tell()                          ← 判断是否超过了max_bin_log_size，如果是则切换binlog文件
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-flush_cache_to_file()                  ← (follower)将I/O Cache中的内容写到文件中
</span></span><span class=line><span class=cl> |-RUN_HOOK()                             ← 调用HOOK函数，也就是binlog_storage-&gt;after_flush()
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-#########&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     ← 进入Stage_manager::SYNC_STAGE阶段
</span></span><span class=line><span class=cl> |-change_stage()
</span></span><span class=line><span class=cl> |-sync_binlog_file()
</span></span><span class=line><span class=cl> | |-mysql_file_sync()
</span></span><span class=line><span class=cl> |   |-my_sync()
</span></span><span class=line><span class=cl> |     |-fdatasync()                      ← 调用系统API写入磁盘，也可以是fsync()
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-#########&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                     ← 进入Stage_manager::COMMIT_STAGE阶段
</span></span><span class=line><span class=cl> |-change_stage()                         ← 该阶段会受到binlog_order_commits参数限制
</span></span><span class=line><span class=cl> |-process_commit_stage_queue()           ← 会遍厉所有线程，然后调用如下存储引擎接口
</span></span><span class=line><span class=cl> | |-ha_commit_low()
</span></span><span class=line><span class=cl> |   |-ht-&gt;commit()                       ← 调用存储引擎handlerton-&gt;commit()
</span></span><span class=line><span class=cl> |   |                                    ← ### 注意，实际调用如下的两个函数
</span></span><span class=line><span class=cl> |   |-binlog_commit()
</span></span><span class=line><span class=cl> |   |-innobase_commit()
</span></span><span class=line><span class=cl> |-process_after_commit_stage_queue()     ← 提交之后的后续处理，例如semisync
</span></span><span class=line><span class=cl> | |-RUN_HOOK()                           ← 调用transaction-&gt;after_commit
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-stage_manager.signal_done()            ← 通知其它线程事务已经提交
</span></span><span class=line><span class=cl> |
</span></span><span class=line><span class=cl> |-finish_commit()
</span></span></code></pre></div><p>在 <code>enroll_for()</code> 函数中，刚添加的线程如果是队列的第一个线程，就将其设置为 leader 线程；否则就是 follower 线程，此时线程会睡眠，直到被 leader 唤醒 (m_cond_done) 。</p><p>注意，<code>binlog_max_flush_queue_time</code> 参数已经取消。</p><a class=anchor id=commit-stage></a><h2>commit stage <a href=#commit-stage aria-hidden=true>#</a></h2><p>如上所述，commit 阶段会受到参数 <code>binlog_order_commits</code> 的影响，当该参数关闭时，会直接释放 <code>LOCK_sync</code>，各个 session 自行进入 InnoDB commit 阶段，这样不会保证 binlog 和事务 commit 的顺序一致。</p><p>当然，如果你不关注两者的一致性，那么可以关闭这个选项来稍微提高点性能；当打开了上述的参数，才会进入 commit stage 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#事务提交>事务提交</a><ul><li><a href=#二阶段提交>二阶段提交</a></li></ul></li><li><a href=#组提交异常>组提交异常</a><ul><li><a href=#早期解决方案>早期解决方案</a></li><li><a href=#改进方案>改进方案</a></li><li><a href=#配置参数>配置参数</a></li></ul></li><li><a href=#源码解析>源码解析</a><ul><li><a href=#commit-stage>commit stage</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>