<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Ping 协议详细介绍 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="Internet Control Message Protocol, ICMP(RFC-792) 基于 IP 协议，工作在七层协议的第三层，主要用来解析网络路由情况，通过返回错误信息进行分析定位。
这里详细介绍其使用方式。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Ping 协议详细介绍</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2016-10-16</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/network/ role=button>network</a></div></div><hr><div class=content><p>Internet Control Message Protocol, ICMP(RFC-792) 基于 IP 协议，工作在七层协议的第三层，主要用来解析网络路由情况，通过返回错误信息进行分析定位。</p><p>这里详细介绍其使用方式。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>ICMP 报文封装在 IP 报文内部，通过 <code>RAW_SOCK</code> 接收到的报文同时会包含 IP 头部信息，这也就意味着在使用时，需要将 IP 的头先拆掉，然后再获取 ICMP 报文。</p><p>IP 报文头为 20 字节，详细的内容这里就不介绍了。</p><a class=anchor id=icmp-报文></a><h2>ICMP 报文 <a href=#icmp-%e6%8a%a5%e6%96%87 aria-hidden=true>#</a></h2><p>ICMP 报文头根据 <code>type</code> 和 <code>code</code> 的不同，其对应的大小也有所区别，而 Ping 使用的就是 ICMP 报文，其报头为 8 字节，数据报长度最大为 64K 字节。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0                   1                   2                   3
</span></span><span class=line><span class=cl>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span></span><span class=line><span class=cl>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class=line><span class=cl>|     Type      |     Code      |          Checksum             |
</span></span><span class=line><span class=cl>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class=line><span class=cl>|           Identifier          |        Sequence Number        |
</span></span><span class=line><span class=cl>+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class=line><span class=cl>|     Data ...
</span></span><span class=line><span class=cl>+-+-+-+-+-+-+-
</span></span></code></pre></div><p>Ping 使用的是发送和接受格式，其中 <code>Type(8)</code> 是请求报文，而 <code>Type(0)</code> 是应答报文。</p><p>注意，如果需要扫描多个个主机，那么返回的报文中只有 <code>ID</code> 以及 <code>SEQ</code>，所以，可以将相关的信息添加到 Data 字段中，这个字段是二进制的，可以以 <code>\0'</code> 终止。</p><a class=anchor id=代码实现></a><h1>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 aria-hidden=true>#</a></h1><p>在接收时通过如下方式实现，常用于 socket 的发送接收消息，函数声明如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>sendmsg</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>msghdr</span> <span class=o>*</span><span class=n>msg</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>recvmsg</span><span class=p>(</span><span class=kt>int</span> <span class=n>sockfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>msghdr</span> <span class=o>*</span><span class=n>msg</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/socket.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>iovec</span> <span class=p>{</span>                   <span class=cm>/* Scatter/gather array items */</span>
</span></span><span class=line><span class=cl>   <span class=kt>void</span>  <span class=o>*</span><span class=n>iov_base</span><span class=p>;</span>              <span class=cm>/* Starting address */</span>
</span></span><span class=line><span class=cl>   <span class=kt>size_t</span> <span class=n>iov_len</span><span class=p>;</span>               <span class=cm>/* Number of bytes to transfer */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>msghdr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>void</span>         <span class=o>*</span><span class=n>msg_name</span><span class=p>;</span>       <span class=cm>/* optional address */</span>
</span></span><span class=line><span class=cl>   <span class=kt>socklen_t</span>     <span class=n>msg_namelen</span><span class=p>;</span>    <span class=cm>/* size of address */</span>
</span></span><span class=line><span class=cl>   <span class=k>struct</span> <span class=n>iovec</span> <span class=o>*</span><span class=n>msg_iov</span><span class=p>;</span>        <span class=cm>/* scatter/gather array */</span>
</span></span><span class=line><span class=cl>   <span class=kt>size_t</span>        <span class=n>msg_iovlen</span><span class=p>;</span>     <span class=cm>/* # elements in msg_iov */</span>
</span></span><span class=line><span class=cl>   <span class=kt>void</span>         <span class=o>*</span><span class=n>msg_control</span><span class=p>;</span>    <span class=cm>/* ancillary data, see below */</span>
</span></span><span class=line><span class=cl>   <span class=kt>size_t</span>        <span class=n>msg_controllen</span><span class=p>;</span> <span class=cm>/* ancillary data buffer len */</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span>           <span class=n>msg_flags</span><span class=p>;</span>      <span class=cm>/* flags on received message */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>看起来比较复杂，实际上结构成员可以分为四组：</p><ul><li>套接口地址成员 <code>msg_name</code> 与 <code>msg_namelen</code>；</li><li>IO 向量引用 <code>msg_iov</code> 与 <code>msg_iovlen</code>；</li><li>附属数据缓冲区成员 <code>msg_control</code> 与 <code>msg_controllen</code>；</li><li>接收信息标记位 <code>msg_flags</code>，详细可以查看 <code>man</code> 手册。</li></ul><p>其中 <code>msg_control</code> 指向的是一个 <code>struct cmsghdr</code> 结构体。</p><a class=anchor id=其它></a><h2>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h2><p>ICMP 报文在 Linux C 中通过 <code>struct icmp[netinet/ip_icmp.h]</code> 定义，而报文中的消息体，则根据不同 <code>TYPE</code>、<code>CODE</code> 会有所区别。</p><p>在 C 中，通过 <code>union</code> 进行适配，为了方便使用，同时又定义了很多辅助的宏定义。</p><a class=anchor id=socket-选项></a><h1>Socket 选项 <a href=#socket-%e9%80%89%e9%a1%b9 aria-hidden=true>#</a></h1><p>这也是比较常规的设置，这里简单介绍下，可以通过 <code>setsockopt()</code> 设置相关的参数，常用的参数如下。</p><ul><li><code>SOL_SOCKET</code> <code>SO_BINDTODEVICE</code> 绑定到某个网络设备上，也就是从某个指定的网卡发送数据。</li><li><code>SOL_SOCKET</code> <code>SO_MARK</code> 用来添加标记，然后作策略路由之类的动作。</li><li><code>SOL_SOCKET</code> <code>SO_TIMESTAMP</code> 让协议栈接受到一个网络帧时为其打上时间戳，并将此时间戳作为一笔附加数据，与网络帧数据一起递交到上层协议。</li></ul><a class=anchor id=mark-标记></a><h2>Mark 标记 <a href=#mark-%e6%a0%87%e8%ae%b0 aria-hidden=true>#</a></h2><p>用于将特定的数据包打上标签，供 <code>iptables</code> 配合 <code>TC</code> 做 <code>QOS</code> 流量限制、应用策略路由等。</p><p>系统可用模块，对 CentOS 而言可通过 <code>ls /usr/lib64/xtables/ | grep -i mark</code> 查看，其中大写的为标记模块，小写的为匹配模块。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 查看关于Mark标记的帮助信息
</span></span><span class=line><span class=cl># iptables -j MARK --help
</span></span><span class=line><span class=cl># iptables -m mark --help
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 将所有TCP数据标记1
</span></span><span class=line><span class=cl># iptables -t mangle -A PREROUTING -p tcp -j MARK --set-mark 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 匹配标记1的数据并保存数据包中的MARK到连接中
</span></span><span class=line><span class=cl># iptables -t mangle -A PREROUTING -p tcp -m mark --mark 1 -j CONNMARK --save-mark
</span></span></code></pre></div><a class=anchor id=策略路由></a><h2>策略路由 <a href=#%e7%ad%96%e7%95%a5%e8%b7%af%e7%94%b1 aria-hidden=true>#</a></h2><p>标签并不是设置在数据包内容中，而是在内核中数据包的载体上，如果需要在数据包内容中设置标签，可以使用 TOS 规则目标，也就是修改 IP 数据包头的 TOS 值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 将从网络接口tun0进入的、目标端口为5222的TCP数据包设置mark值为1
</span></span><span class=line><span class=cl># iptables -t mangle -A PREROUTING -j MARK --set-mark 1 -i tun0 -p tcp --dport 5222
</span></span></code></pre></div><p>接着，根据设置的 mark 值可用来设定策略路由，比如，把 mark 值为 1 的数据包交由网关 192.168.0.1 转发。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 1. 确定一张空路由表，这里选定300
</span></span><span class=line><span class=cl># ip route show table 300
</span></span><span class=line><span class=cl>----- 2. 在表中添加路由条目
</span></span><span class=line><span class=cl># ip route add default via 192.168.0.1 table 300
</span></span><span class=line><span class=cl>----- 3. 查看当前路由规则
</span></span><span class=line><span class=cl># ip rule list
</span></span><span class=line><span class=cl>----- 4. 为mark值为1的数据包指定路由表策略
</span></span><span class=line><span class=cl># ip rule add fwmark 0x1 table 300
</span></span></code></pre></div><p>通过这种方法，可以使用 iptables 根据匹配规则设置 mark，再由路由模块根据 mark 值进行路由决策，从而实现复杂的策略路由。</p><a class=anchor id=timestamp></a><h2>TIMESTAMP <a href=#timestamp aria-hidden=true>#</a></h2><p>也就是在内核的协议栈中，在接收到报文之后以及交接给上层协议栈处理之前，添加时间戳，这样计算的时间戳就不再依赖应用层的响应速度，尤其是当采用了类似 cgroup 的资源限制。</p><a class=anchor id=socket-缓冲区></a><h2>Socket 缓冲区 <a href=#socket-%e7%bc%93%e5%86%b2%e5%8c%ba aria-hidden=true>#</a></h2><p>使用 <code>RAW_SOCKET</code> 时，例如发送 ICMP 报文，因为不存在 TCP 中的滑动窗口、限流等机制，在流量过大时极易引起报文在缓冲区的静默丢失。此时可以通过 tcpdump 获取，但是无法通过 <code>read()</code>、<code>recvmsg()</code> 等接口无法接收到数据。</p><p>接收缓冲区的大小可以使用 <code>setsockopt()</code> 设置 <code>SO_RCVBUF</code> 选项，其默认和最大值可以通过如下命令查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat /proc/sys/net/core/rmem_default
</span></span><span class=line><span class=cl>$ cat /proc/sys/net/core/rmem_max
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat /proc/sys/net/core/wmem_default
</span></span><span class=line><span class=cl>$ cat /proc/sys/net/core/wmem_max
</span></span></code></pre></div><p>在设置 Socket 的时候，如果期望设置的缓存大于上述的 max ，实际上会得到两倍于 max 值。</p><a class=anchor id=ttl></a><h2>TTL <a href=#ttl aria-hidden=true>#</a></h2><p>Time To Live, TTL 存活时间，表示这个 PING 数据包能在网络上存活多少时间，实际上就是用来表示可以被路由转发多少次，在 IP 头中通过 8bits 表示。</p><p>执行 Ping 操作时，会在本机发送一个数据包，正常来说，数据包会经过一定的路由到达目的主机。不过，由于很多原因可能会导致一些数据包不能正常传送到目的主句，为了防止由于数据包一直传输导致网络负载增加，增加的 TTL 作为包的存活时间。</p><p>当数据包传送到一个路由器之后，TTL 就自动减 1，如果减到 0 了还是没有传送到目的主机，那么就自动丢弃，此时一般是 Request timed out 了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>64 bytes from 192.168.9.1: icmp_seq=1 ttl=60 time=0.909 ms
</span></span></code></pre></div><p>目前测试来看，当 ICMP 报文发送之后，其返回的报文实际上会重新设置(依赖目标机器的设置)，也即是说 TTL 的值是单程的。</p><p>在 Linux 命令行中，可以通过 <code>-t</code> 参数进行设置。例如，返回的 TTL 为 60，那么你可以初步猜测对端设置的初始 TTL 为 64，那么通过 <code>-t 2</code> 设置时候，就会出现 <code>Time to live exceeded</code> 的报错。</p><a class=anchor id=系统设置></a><h3>系统设置 <a href=#%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae aria-hidden=true>#</a></h3><p>Windows 一般在 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code> 注册表中设置。</p><p>在 Linux 中，可以通过如下方式修改默认的 TTL 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 临时修改
</span></span><span class=line><span class=cl># sysctl net.ipv4.ip_default_ttl=129
</span></span><span class=line><span class=cl># echo 129 &gt; /proc/sys/net/ipv4/ip_default_ttl
</span></span><span class=line><span class=cl>----- 保存到配置文件中
</span></span><span class=line><span class=cl>$ cat /etc/sysctl.conf
</span></span><span class=line><span class=cl>net.ipv4.ip_default_ttl=129
</span></span></code></pre></div><p>各个系统的默认值如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Linux              64/255
</span></span><span class=line><span class=cl>Windows NT/2000/XP 128
</span></span><span class=line><span class=cl>Windows 98         32
</span></span><span class=line><span class=cl>UNIX               255
</span></span></code></pre></div><a class=anchor id=qos></a><h2>QoS <a href=#qos aria-hidden=true>#</a></h2><p>Quality of Service, QoS 服务质量，提供的质量越好，表示有越低的延迟、丢包、抖动等，同时其吞吐量和可靠性要更高。简单来说，就是利用包的特定标志位，告诉路由器如何处理包，是先还是后。</p><p>在第二层 (Link Layer) 和第三层 (IP) 都有标示位，其中 IP 层采用的是 8Bits，包括 IPv4 和 IPv6，只是其位置不同。</p><a class=anchor id=其它-1></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83-1 aria-hidden=true>#</a></h1><a class=anchor id=非-root-套接字></a><h2>非 root 套接字 <a href=#%e9%9d%9e-root-%e5%a5%97%e6%8e%a5%e5%ad%97 aria-hidden=true>#</a></h2><p>新版本的内核中提供了低权限的 Socket 访问方式，不过内核会自动过滤报文，所以，不太适合大批量的监控，这里仅简单介绍下。</p><p>ICMP 套接字的目的是允许在不设置 SUID 或者 CAP_NET_RAW 权限的时候允许 ping 程序的使用，详细的实现可以查看内核的邮件列表 <a href=https://lkml.org/lkml/2011/5/10/389>add IPPROTO_ICMP socket kind</a> 。</p><p>是否支持是通过内核的 <code>net.ipv4.ping_group_range</code> 指定，这是一对整数，指定了允许使用 ICMP 套接字的组 ID 的范围，默认为 <code>1 0</code> 也就意味着没有人能够使用这个特性。</p><p>可以通过如下命令修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># sysctl -w net.ipv4.ping_group_range=&#39;0 10&#39;
</span></span></code></pre></div><p>然后可以通过如下方式创建 ICMP 的套接字。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import socket
</span></span><span class=line><span class=cl>sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_ICMP)
</span></span></code></pre></div><p>如果系统不支持这个特性，在创建套接字的时候会得到 <code>Protocol not supported</code> 的错误，而如果没有权限，则会得到 <code>Permission denied</code> 的错误。</p><p>它的类型和 UDP 套接字一样，是 <code>SOCK_DGRAM</code> 而非 <code>SOCK_RAW</code>，这也就意味着你不会收到 20 字节的 IP 头，而且内核会计算校验和，并且填充 ICMP ID，在接收到响应后，内核会只把相应 ID 的 ICMP 响应返回给程序，不需要自己或者要求内核过滤了。</p><a class=anchor id=抓包></a><h2>抓包 <a href=#%e6%8a%93%e5%8c%85 aria-hidden=true>#</a></h2><p>可以通过如下命令获取包，如果使用的 IPv6 需要将 icmp 替换为 icmp6 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- ICMP echo request
</span></span><span class=line><span class=cl># tcpdump -nni eth0 -e icmp[icmptype] == 8
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- ICMP echo reply
</span></span><span class=line><span class=cl># tcpdump -nni eth0 -e icmp[icmptype] == 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 保存到文件中
</span></span><span class=line><span class=cl># tcpdump -nni eth0 -w /tmp/icmp.pcap -e icmp[icmptype] == 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 读取文件
</span></span><span class=line><span class=cl># tcpdump -nn -r icmp.pcap
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>---- 只过滤icmp报文
</span></span><span class=line><span class=cl># tcpdump -nni eth0 icmp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>---- 针对某台主机的报文
</span></span><span class=line><span class=cl># tcpdump -nni eth0 icmp and host 10.80.97.129
</span></span><span class=line><span class=cl># nohup tcpdump -w /var/log/icmp-10.80.97.129.cap -nni eth0 icmp and host 10.80.97.129 &amp;
</span></span></code></pre></div><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><ul><li>可以参考 <a href=https://github.com/octo/liboping>Github liboping</a>、<a href=https://courses.cs.vt.edu/cs4254/fall04/slides/raw_6.pdf>Raw Sockets and ICMP</a> 。</li><li>关于各个操作系统的默认 TTL 可以参考 <a href=https://subinsb.com/default-device-ttl-values/>Default TTL (Time To Live) Values of Different OS</a> 。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#icmp-报文>ICMP 报文</a></li></ul></li><li><a href=#代码实现>代码实现</a><ul><li><a href=#其它>其它</a></li></ul></li><li><a href=#socket-选项>Socket 选项</a><ul><li><a href=#mark-标记>Mark 标记</a></li><li><a href=#策略路由>策略路由</a></li><li><a href=#timestamp>TIMESTAMP</a></li><li><a href=#socket-缓冲区>Socket 缓冲区</a></li><li><a href=#ttl>TTL</a></li><li><a href=#qos>QoS</a></li></ul></li><li><a href=#其它-1>其它</a><ul><li><a href=#非-root-套接字>非 root 套接字</a></li><li><a href=#抓包>抓包</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>