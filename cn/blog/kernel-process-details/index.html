<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Kernel 进程相关 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="实际上一个进程，包括了代码、数据和分配给进程的资源，这是一个动态资源。
这里简单介绍与进程相关的东西，例如进程创建、优先级、进程之间的关系、进程组和会话、进程状态等。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Kernel 进程相关</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2015-06-02</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a></div></div><hr><div class=content><p>实际上一个进程，包括了代码、数据和分配给进程的资源，这是一个动态资源。</p><p>这里简单介绍与进程相关的东西，例如进程创建、优先级、进程之间的关系、进程组和会话、进程状态等。</p><a class=anchor id=进程></a><h1>进程 <a href=#%e8%bf%9b%e7%a8%8b aria-hidden=true>#</a></h1><p>一个进程，包括了代码、数据和分配给进程的资源。</p><a class=anchor id=初始进程></a><h2>初始进程 <a href=#%e5%88%9d%e5%a7%8b%e8%bf%9b%e7%a8%8b aria-hidden=true>#</a></h2><p>在 Linux 中，进程基本都是通过复制其它进程的结构来实现的，利用 slabs 来动态分配，系统没有提供用于创建进程的接口。</p><p>唯一的一个例外是第一个 <code>task_struct</code>，这是由一个静态或者说是固化的结构表示的 (<code>init_task</code>)，该进程的 <code>PID=0</code>，可以参看 <code>arch/x86/kernel/init_task.c</code>，也可以称之为空闲进程。</p><p>当内核执行到 <code>sched_init()</code> 时，<code>task_struct</code> 的核心 <code>TR</code>、<code>LDT</code> 就被手工设置好了，这时，0 号进程就有了，而在 <code>sched_init()</code> 之前，是没有 &ldquo;进程&rdquo; 这个概念的，而 <code>init(PID=1)</code> 进程是 0 号进程 <code>fork()</code> 出来的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct task_struct init_task = INIT_TASK(init_task);
</span></span></code></pre></div><p>查看 <code>INIT_TASK()</code> 宏定义时，会发现很多有意思的东西，如 <code>init_task</code> 的栈通过 <code>.stack = &amp;init_thread_info</code> 指定，而该栈实际时通过如下的方式静态分配。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>union thread_union init_thread_union __init_task_data = { INIT_THREAD_INFO(init_task) };
</span></span></code></pre></div><p>定义中的 <code>__init_task_data</code> 表明该内核栈所在的区域位于内核映像的 <code>init data</code> 区，可以通过编译完内核后所产生的 System.map 来看到该变量及其对应的逻辑地址。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat System.map-`uname -r` | grep init_thread_union
</span></span><span class=line><span class=cl>ffffffff818fc000 D init_thread_union
</span></span></code></pre></div><p>而内核在无进程的情况下，将一直从初始化部分的代码执行到 <code>start_kernel()</code>，然后再到其最后一个函数调用 <code>rest_init()</code>，在该函数中将产生第一个进程 <code>PID=1</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>start_kernel()
</span></span><span class=line><span class=cl> |-rest_init()
</span></span><span class=line><span class=cl>   |-kernel_thread()        实际上调用kernel_init()创建第一个进程PID=1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>kernel_init()
</span></span><span class=line><span class=cl> |-run_init_process()
</span></span><span class=line><span class=cl>   |-do_execve()
</span></span></code></pre></div><p>最后 <code>init_task</code> 任务会变成 <code>idle</code> 进程。</p><p>在 Linux 系统中，可创建进程的最大值是由 <code>max_threads@kernel/fork.c</code> 变量确定的，也可以通过 <code>/proc/sys/kernel/threads-max</code> 查看/更改此值。</p><a class=anchor id=fork></a><h2>fork <a href=#fork aria-hidden=true>#</a></h2><p>通过 <code>fork()</code> 将创建一个与原来进程几乎完全相同的进程，系统给新的进程分配资源，例如存储数据和代码的空间，然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同，相当于克隆了一个自己。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>            <span class=c1>// vfork(); error
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;error in fork!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// child process
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34; child: PID is %d, count is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>                 <span class=c1>// parent process
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;parent: PID is %d, count is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>(),</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在语句 <code>fork()</code> 之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同。其中 fork() 的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：</p><ol><li>在父进程中，fork() 返回新创建子进程的进程 ID；</li><li>在子进程中，fork() 返回 0；</li><li>如果出现错误，fork() 返回一个负值；</li></ol><p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</p><a class=anchor id=执行流程></a><h2>执行流程 <a href=#%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b aria-hidden=true>#</a></h2><ol><li>进程可以看做程序的一次执行过程。在 linux 下，每个进程有唯一的 PID 标识进程。 PID 是一个从 1 到 32768 的正整数，其中 1 一般是特殊进程 init ，其它进程从 2 开始依次编号。当用完 32768 后，从 2 重新开始。</li><li>Linux 中有一个叫进程表的结构用来存储当前正在运行的进程。可以使用 <code>ps aux</code> 命令查看所有正在运行的进程。</li><li>进程在 linux 中呈树状结构， init 为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。</li><li>fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</li></ol><p><img alt="process fork" src=images/process-fork.gif class="mx-auto d-block"></p><p>上图表示一个含有 fork 的程序，而 fork 语句可以看成将程序切为 A、B 两个部分。然后整个程序会如下运行：</p><ol><li>设由 shell 直接执行程序，生成了进程 M 。 M 执行完 Part.A 的所有代码。</li><li>当执行到 pid = fork(); 时， M 启动一个进程 S ，S 是 M 的子进程，和 M 是同一个程序的进程。S 继承 M 的所有变量、环境变量、程序计数器的当前值。</li><li>在 M 进程中，fork() 将 S 的 PID 返回给变量 pid ，并继续执行 Part.B 的代码。</li><li>在进程 S 中，将 0 赋给 pid ，并继续执行 Part.B 的代码。</li></ol><p>这里有三个点非常关键:</p><ul><li>M 执行了所有程序，而 S 只执行了 Part.B ，即 fork() 后面的程序，(这是因为 S 继承了 M 的 PC-程序计数器)。</li><li>S 继承了 fork() 语句执行时当前的环境，而不是程序的初始环境。</li><li>M 中 fork() 语句启动子进程 S ，并将 S 的 PID 返回，而 S 中的 fork() 语句不启动新进程，仅将 0 返回。</li></ul><a class=anchor id=举例></a><h3>举例 <a href=#%e4%b8%be%e4%be%8b aria-hidden=true>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pid1</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>pid2</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;pid1:%d, pid2:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pid1</span><span class=p>,</span> <span class=n>pid2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于如上的程序，在执行之后将会生成 4 个进程，如果其中一个进程的输出结果是 <code>pid1:1001, pid2:1002</code> ，那么其他的分别为。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pid1:1001, pid2:0
</span></span><span class=line><span class=cl>pid1:0, pid2:1003
</span></span><span class=line><span class=cl>pid1:0, pid2:0
</span></span></code></pre></div><p>实际的执行过程如下所示：</p><p><img alt="process fork" src=images/process-fork-2.gif class="mx-auto d-block"></p><p>最后的实际执行过程为：</p><ol><li>从 shell 中执行此程序，启动了一个进程，我们设这个进程为 P0 ，设其 PID 为 XXX (解题过程不需知道其 PID)。</li><li>当执行到 pid1 = fork(); 时， P0 启动一个子进程 P1 ，由题目知 P1 的 PID 为 1001 。我们暂且不管 P1 。</li><li>P0 中的 fork 返回 1001 给 pid1 ，继续执行到 pid2 = fork(); ，此时启动另一个新进程，设为 P2 ，由题目知 P2 的 PID 为 1002 。同样暂且不管 P2 。</li><li>P0 中的第二个 fork 返回 1002 给 pid2 ，继续执行完后续程序，结束。所以， P0 的结果为 “pid1:1001, pid2:1002” 。</li><li>再看 P2 ， P2 生成时， P0 中 pid1=1001 ，所以 P2 中 pid1 继承 P0 的 1001 ，而作为子进程 pid2=0 。 P2 从第二个 fork 后开始执行，结束后输出 “pid1:1001, pid2:0” 。</li><li>接着看 P1 ， P1 中第一条 fork 返回 0 给 pid1 ，然后接着执行后面的语句。而后面接着的语句是 pid2 = fork(); 执行到这里， P1 又产生了一个新进程，设为 P3 。先不管 P3 。</li><li>P1 中第二条 fork 将 P3 的 PID 返回给 pid2 ，由预备知识知 P3 的 PID 为 1003 ，所以 P1 的 pid2=1003 。 P1 继续执行后续程序，结束，输出 “pid1:0, pid2:1003” 。</li><li>P3 作为 P1 的子进程，继承 P1 中 pid1=0 ，并且第二条 fork 将 0 返回给 pid2 ，所以 P3 最后输出 “pid1:0, pid2:0” 。</li><li>至此，整个执行过程完毕。</li></ol><a class=anchor id=进程创建></a><h1>进程创建 <a href=#%e8%bf%9b%e7%a8%8b%e5%88%9b%e5%bb%ba aria-hidden=true>#</a></h1><p>进程和线程相关的函数在内核中，最终都会调用 <code>do_fork()</code>，只是最终传入的参数不同。</p><p>其中在用户空间中与进程相关的接口有 <code>fork()</code>、<code>vfork()</code>、<code>clone()</code>、<code>exec()</code>；线程相关的有 <code>pthread_create</code> (glibc) 和 <code>kernel_thread</code> (Kernel内部函数)，<code>pthread_create()</code> 是对 <code>clone()</code> 的封装，<code>kernel_thread()</code> 用于创建内核线程，两者最终同样会调用 <code>do_fork()</code>。</p><a class=anchor id=区别></a><h2>区别 <a href=#%e5%8c%ba%e5%88%ab aria-hidden=true>#</a></h2><p><code>fork()</code> 会创建新的进程；<code>exec()</code> 的原进程将会被新的进程替换；而 <code>vfork()</code> 其实就是 <code>fork()</code> 的部分过程，通过简化来提高效率。</p><p><code>fork()</code> 是进程资源的完全复制，包括进程的 <code>PCB(task_struct)</code>、线程的系统堆栈、进程的用户空间、进程打开的设备等，而在 <code>clone()</code> 中其实只有前两项是被复制了的，后两项都与父进程共享，对共享数据的保护必须有上层应用来保证。</p><p><code>vfork()</code> 与 <code>fork()</code> 主要区别:</p><ul><li><code>fork()</code> 子进程拷贝父进程的数据段，堆栈段；<code>vfork()</code> 子进程与父进程共享数据段。</li><li><code>fork()</code> 父子进程的执行次序不确定；<code>vfork()</code> 保证子进程先运行，在调用 <code>exec()</code> 或 <code>exit()</code> 之前与父进程数据是共享的，在它调用 <code>exec()</code> 或 <code>exit()</code> 之后父进程才可能被调度运行，否则会发生错误。</li><li>如果在此之前子进程有依赖于父进程的进一步动作，如调用函数，则会导致错误。</li></ul><p><code>fork()</code> 在执行复制时，采用 &ldquo;写时复制&rdquo;，开始的时候内存并没有被复制，而是共享的，直到有一个进程去写某块内存时，它才被复制。实际操作时，内核先将这些内存设为只读，当它们被写时，CPU 出现访存异常，内核捕捉异常，复制空间，并改属性为可写。</p><p>但是，&ldquo;写时复制&rdquo; 其实还是有复制，进程的 mm 结构、页表都还是被复制了，而 <code>vfork()</code> 会忽略所有关于内存的东西，父子进程的内存是完全共享的。</p><p>不过此时，父子进程共用着栈，如果两个进程并行执行，那么可能会导致调用栈出错。所以，<code>vfork()</code> 有个限制，当子进程生成后，父进程在 <code>vfork()</code> 中被内核挂起，直到子进程有了自己的内存空间 <code>(exec**)</code> 或退出 <code>(_exit)</code>。</p><p>并且，在此之前，子进程不能从调用 <code>vfork()</code> 的函数中返回，同时，不能修改栈上变量、不能继续调用除 <code>_exit()</code> 或 <code>exec()</code> 系列之外的函数，否则父进程的数据可能被改写。</p><p>虽然 <code>vfork()</code> 的限制很多，但是对于 shell 来说却非常适合。</p><a class=anchor id=源码解析></a><h2>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h2><p>如下是内核中的接口，<code>do_fork()</code> 返回的是子进程的 PID。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// kernel/fork.c
</span></span><span class=line><span class=cl>do_fork(SIGCHLD, 0, 0, NULL, NULL);                           // sys_fork
</span></span><span class=line><span class=cl>do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0, 0, NULL, NULL);  // sys_vfork
</span></span><span class=line><span class=cl>do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr);  // sys_clone
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>do_fork() @ kernel/fork.c
</span></span><span class=line><span class=cl>  |-... ...                            // 做一些参数的检查工作，主要是针对flag
</span></span><span class=line><span class=cl>  |-copy_process()                     // 复制一个进程描述符，PID不同
</span></span><span class=line><span class=cl>  |  |-security_task_create()          // 安全模块的回调函数
</span></span><span class=line><span class=cl>  |  |-dup_task_struct()               // 新建task_struct和thread_info，并将当前进程相应的结构完全复制过去
</span></span><span class=line><span class=cl>  |  |-atomic_read()                   // 判断是否超过了进程数
</span></span><span class=line><span class=cl>  |  |-copy_creds()                    // 应该是安全相关的设置
</span></span><span class=line><span class=cl>  |  |-... ...                         // 判断创建的进程是否超了进程的总量等
</span></span><span class=line><span class=cl>  |  |-sched_fork()                    // 调度相关初始化
</span></span><span class=line><span class=cl>  |  |-copy_xxx()                      // 根据传入的flag复制相应的数据结构
</span></span><span class=line><span class=cl>  |  |-alloc_pid()                     // 为新进程获取一个有效的PID
</span></span><span class=line><span class=cl>  |  |-sched_fork()                    // 父子进程平分共享的时间片
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-wake_up_new_task()                 // 如果创建成功则执行
</span></span><span class=line><span class=cl>  |-wait_for_vfork_done()              // 如果是vfork()等待直到子进程exit()或者exec()
</span></span></code></pre></div><p><code>clone_flags</code> 由 4 个字节组成，最低的一个字节为子进程结束时发送给父进程的信号代码，<code>fork/vfork</code> 为 <code>SIGCHLD</code>，<code>clone</code> 可以指定；剩余的三个字节则是各种 <code>clone()</code> 标志的组合，用于选择复制父进程那些资源。</p><p>内核有意选择子进程首先执行。因为一般子进程都会马上调用 exec 函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能开始向地址空间写入。</p><a class=anchor id=pid分配></a><h2>PID分配 <a href=#pid%e5%88%86%e9%85%8d aria-hidden=true>#</a></h2><p>pid 分配的范围是 0~32767，<code>struct pidmap</code> 用来标示 pid 是不是已经分配出去了，采用位图的方式，每个字节表示 8 个 PID，为了表示 32768 个进程号要用 32768/8=4096 个字节，也即一个 page，结构体中的 nr_free 表示剩余 PID 的数量。</p><p>PID 相关的一些操作实际上就是 bitmap 的操作，常见的如下。</p><ul><li>int test_and_set_bit(int offset, void *addr);<br>将 offset 在 pidmap 变量当中相应的位置为 1，并返回旧值；也就是申请到一个 pid 号之后，修改位标志，其中 addr 是 pidmap.page 变量的地址。</li><li>void clear_bit(int offset, void *addr);<br>将 offset 在 pidmap 变量当中相应的位置为 0，也就是释放一个 pid 后，修改位标志，其中 addr 是 pidmap.page 变量的地址。</li><li>int find_next_zero_bit(void *addr, int size, int offset);<br>从 offset 开始，找下一个是 0 (也就是可以分配) 的 pid 号，其中 addr 是 pidmap.page 变量的地址，size 是一个页的大小。</li><li>int alloc_pidmap();<br>分配一个 pid 号。</li><li>void free_pidmap(int pid);<br>回收一个 pid 号。</li></ul><p>目前 Linux 通过 PID 命名空间进行隔离，其中有一个变量 last_pid 用于标示上一次分配出去的 pid 编号。</p><p>在内核中通过移位操作来实现根据 PID 查找地址，可以想象抽象出一张表，这个表有 32 列，1024行，这个刚好是一个页的大小，可以参考相应程序的示例。</p><a class=anchor id=系统进程遍历></a><h2>系统进程遍历 <a href=#%e7%b3%bb%e7%bb%9f%e8%bf%9b%e7%a8%8b%e9%81%8d%e5%8e%86 aria-hidden=true>#</a></h2><p>在内核中，会通过双向链表保存任务列表，可以将 <code>init_task</code> 作为链表的开头，然后进行迭代。</p><p>可以通过内核模块 <code>procsview</code> 进行查看，通过 <code>printk</code> 将所有的进程打印出来，结果可以通过 <code>tail -f /var/log/messages</code> 查看。</p><p>可以通过宏定义 <code>next_task()@include/linux/sched.h</code> 简化任务列表的迭代，该宏会返回下一个任务的 <code>task_struct</code> 引用；<code>current</code> 标识当前正在运行的进程，这实际是一个宏，在 <code>arch/x86/include/asm/current.h</code> 中定义。</p><p>通过 Make 进行编译，用 <code>insmod procsview.ko</code> 插入模块对象，用 <code>rmmod procsview</code> 删除它。插入后，<code>/var/log/messages</code> 可显示输出，其中有一个空闲任务 (称为 swapper) 和 init 任务 (pid 1)。</p><a class=anchor id=进程关系></a><h1>进程关系 <a href=#%e8%bf%9b%e7%a8%8b%e5%85%b3%e7%b3%bb aria-hidden=true>#</a></h1><p>在 <code>task_struct</code> 结构中，保存了一些字段，用来维护各个进程之间的关系。</p><p>在 Linux 中，线程是通过轻量级进程 (LWP) 实现，会为每个进程和线程分配一个 PID，同时我们希望由一个进程产生的轻量级进程具有相同的 PID，这样当我们向进程发送信号时，此信号可以影响进程及进程产生的轻量级进程。</p><p>为此，采用线程组 (可以理解为轻量级进程组) 的概念，在线程组内，每个线程都使用此线程组内第一个线程 (thread group leader) 的 pid，并将此值存入tgid，当我们使用 <code>getpid()</code> 函数得到进程 ID 时，其实操作系统返回的是 <code>task_struct</code> 的 tgid 字段，而非 pid 字段。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct task_struct {
</span></span><span class=line><span class=cl>    pid_t pid; pid_t tgid;            // 用于标示线程和线程组ID
</span></span><span class=line><span class=cl>    struct task_struct *real_parent;  // 实际父进程real parent process
</span></span><span class=line><span class=cl>    struct task_struct *parent;       // SIGCHLD的接受者，由wait4()报告
</span></span><span class=line><span class=cl>    struct list_head children;        // 子进程列表
</span></span><span class=line><span class=cl>    struct list_head sibling;         // 兄弟进程列表
</span></span><span class=line><span class=cl>    struct task_struct *group_leader; // 线程组的leader
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>$ ps -eo  uid,pid,ppid,pgid,sid,pidns,tty,comm
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>getpid()[tgid]、gettid()[pid]、getppid()[real_parent]、getsid()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>getuid()、getgid()、geteuid()、getegid()、getgroups()、getresuid()、getresgid()、getpgid()、&lt;br&gt;&lt;br&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>getpgrp()/getpgid()/setpgid()        // 获取或者设置进程组
</span></span></code></pre></div><p><code>gettid()</code> 返回线程号，如果是单线程与 <code>getpid()</code> 相同，该值在整个 Linux 系统内是唯一的；<code>pthread_self()</code> 返回的线程号只能保证在进程中是唯一的。</p><p><img alt="process relations" src=images/process-relations.jpg class="mx-auto d-block"></p><p>下面是内核提供的系统调用，实现有点复杂，可以通过注释查看返回的 <code>task_strcut</code> 中的值。</p><p>Linux 中的进程组是为了方便对进程进行管理，假设要完成一个任务，需要同时并发 100 个进程，当用户处于某种原因要终止这个任务时，可以将这些进程设置备为同一个进程组，然后向进程组发送信号。</p><p>进程必定属于一个进程组，也只能属于一个进程组；一个进程组中可以包含多个进程，进程组的生命周期从被创建开始，到其内所有进程终止或离开该组。</p><p>由于 Linux 是多用户多任务的分时系统，所以必须要支持多个用户同时使用一个操作系统，当一个用户登录一次系统就形成一次会话。</p><p>一个或多个进程组可以组成会话，由其中一个进程建立，该进程叫做会话的领导进程 (session leader)，会话领导进程的 PID 成为识别会话的 SID(session ID)；一个会话可包含多个进程组，但只能有一个前台进程组。</p><p>会话中的每个进程组称为一个作业 (job)，bash(Bourne-Again shell) 支持作业控制，而 sh(Bourne shell) 并不支持。</p><p>会话可以有一个进程组成为会话的前台工作 (foreground)，而其他的进程组是后台工作 (background)。每个会话可以连接一个控制终端 (control terminal)，当控制终端有输入输出时，都传递给该会话的前台进程组，由终端产生的信号，比如 <code>CTRL+Z</code>、<code>CTRL+\</code> 会传递到前台进程组。</p><p>会话的意义在于将多个工作囊括在一个终端，并取其中的一个工作作为前台，来直接接收该终端的输入输出以及终端信号，其他工作在后台运行。一般开始于用户登录，终止于用户退出，此期间所有进程都属于这个会话期。</p><p>一个工作可以通过 fg 从后台工作变为前台工作，如 <code>fg %1</code> 。</p><a class=anchor id=进程组和会话期></a><h2>进程组和会话期 <a href=#%e8%bf%9b%e7%a8%8b%e7%bb%84%e5%92%8c%e4%bc%9a%e8%af%9d%e6%9c%9f aria-hidden=true>#</a></h2><p>当通过 SSH 或者 telent 远程登录到 Linux 服务器时，如果执行一个长时间运行的任务，如果关掉窗口或者断开连接，这个任务就会被杀掉，一切都半途而废了，这主要是因为 <code>SIGHUP</code> 信号。</p><p>在 Linux/Unix 中，有这样几个概念：</p><ul><li>进程组 (process group): 一个或多个进程的集合，每一个进程组有唯一一个进程组 ID ，即进程组长进程的 ID 。</li><li>会话期 (session): 一个或多个进程组的集合，有唯一一个会话期首进程 (session leader)，会话期 ID 为首进程的 ID 。</li><li>会话期可以有一个单独的控制终端（controlling terminal）。与控制终端连接的会话期首进程叫做控制进程（controlling process）。当前与终端交互的进程称为前台进程组，其余进程组称为后台进程组。</li></ul><p>根据 POSIX.1 的定义，挂断信号 (SIGHUP) 默认的动作是终止程序；当终端接口检测到网络连接断开，将挂断信号发送给控制进程 (会话期首进程)；如果会话期首进程终止，则该信号发送到该会话期前台进程组；一个进程退出导致一个孤儿进程组中产生时，如果任意一个孤儿进程组进程处于 STOP 状态，发送 SIGHUP 和 SIGCONT 信号到该进程组中所有进程。</p><p>因此当网络断开或终端窗口关闭后，控制进程收到 SIGHUP 信号退出，会导致该会话期内其他进程退出。</p><p>打开两个 SSH 终端窗口，或者两个 gnome-terminal，在其中一个运行 top 命令。在另一个终端窗口，找到 top 的进程 ID 为 24317 ，其父进程 ID 为 24230 ，即登录 shell 。使用 pstree 命令可以更清楚地看到这个关系。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># top
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># ps -ef | grep top
</span></span><span class=line><span class=cl>UID        PID  PPID  C STIME    TTY       TIME CMD
</span></span><span class=line><span class=cl>andy     24317 24230  2 13:45 pts/16   00:00:05 top
</span></span><span class=line><span class=cl>andy     24526 24419  0 13:48 pts/17   00:00:00 grep --color=auto top
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># pstree -H 24317 | grep top
</span></span><span class=line><span class=cl>|-sshd-+-sshd-+-sshd---bash---top
</span></span></code></pre></div><p>使用 <code>ps -xj</code> 命令可以看到，登录 shell (PID 24230) 和 top 在同一个会话期， shell 为会话期首进程，所在进程组 PGID 为 24230， top 所在进程组 PGID 为 24317 ，为前台进程组。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>~$ ps -xj | grep 24230
</span></span><span class=line><span class=cl> PPID   PID  PGID   SID    TTY   TPGID STAT   UID   TIME COMMAND
</span></span><span class=line><span class=cl>24229 24230 24230 24230 pts/16   24317 Ss    1000   0:00 -bash
</span></span><span class=line><span class=cl>24230 24317 24317 24230 pts/16   24317 S+    1000   0:18 top
</span></span><span class=line><span class=cl>24419 24543 24542 24419 pts/17   24542 S+    1000   0:00 grep --color=auto 2423
</span></span></code></pre></div><p>关闭第一个 SSH 窗口，在另一个窗口中可以看到 top 也被杀掉了，如果我们可以忽略 SIGHUP 信号，关掉窗口应该就不会影响程序的运行了。</p><p>nohup 命令可以达到这个目的，如果程序的标准输出/标准错误是终端， nohup 默认将其重定向到 nohup.out 文件。值得注意的是 nohup 命令只是使得程序忽略 SIGHUP 信号，还需要使用标记 <code>&</code> 把它放在后台运行。</p><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><a class=anchor id=指定cpu></a><h2>指定CPU <a href=#%e6%8c%87%e5%ae%9acpu aria-hidden=true>#</a></h2><p>Affinity 是进程的一个属性，这个属性指明了进程调度器能够把这个进程调度到哪些 CPU 上，可以利用 CPU affinity 把一个或多个进程绑定到一个或多个 CPU 上。</p><p>CPU Affinity 分为 soft affinity 和 hard affinity； soft affinity 仅是一个建议，如果不可避免，调度器还是会把进程调度到其它的 CPU 上；hard affinity 是调度器必须遵守的规则。</p><p>增加 CPU 缓存的命中率。CPU 之间是不共享缓存的，如果进程频繁的在各个 CPU 间进行切换，需要不断的使旧 CPU 的 cache 失效。如果进程只在某个 CPU 上执行，则不会出现失效的情况。</p><p>另外，在多个线程操作的是相同的数据的情况下，如果把这些线程调度到一个处理器上，大大的增加了 CPU 缓存的命中率。但是可能会导致并发性能的降低。如果这些线程是串行的，则没有这个影响。</p><p>适合 time-sensitive 应用，在 real-time 或 time-sensitive 应用中，我们可以把系统进程绑定到某些 CPU 上，把应用进程绑定到剩余的 CPU 上。</p><p>CPU 集可以认为是一个掩码，每个设置的位都对应一个可以合法调度的 CPU，而未设置的位则对应一个不可调度的 CPU。换而言之，线程都被绑定了，只能在那些对应位被设置了的处理器上运行。通常，掩码中的所有位都被置位了，也就是可以在所有的 CPU 中调度。</p><p>另外可以通过 <a href=http://sourceforge.net/projects/schedutils/>schedutils</a> 或者 python-schedutils 进行设置，后者现在更加常见。</p><a class=anchor id=杀死进程的n中方法></a><h2>杀死进程的N中方法 <a href=#%e6%9d%80%e6%ad%bb%e8%bf%9b%e7%a8%8b%e7%9a%84n%e4%b8%ad%e6%96%b9%e6%b3%95 aria-hidden=true>#</a></h2><p>查看进程通常可以通过如下命令</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ps -ef
</span></span><span class=line><span class=cl>$ ps -aux
</span></span><span class=line><span class=cl>......
</span></span><span class=line><span class=cl>smx    1827     1   4 11:38 ?        00:27:33 /usr/lib/firefox-3.6.18/firefox-bin
</span></span><span class=line><span class=cl>......
</span></span></code></pre></div><p>此时如果我想杀了火狐的进程就在终端输入：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -s 9 1827
</span></span></code></pre></div><p>其中 <code>-s 9</code> 制定了传递给进程的信号是 9，即强制、尽快终止进程。</p><p>无论是 <code>ps -ef</code> 还是 <code>ps -aux</code>，每次都要在一大串进程信息里面查找到要杀的进程，看的眼都花了。因此通过如下的方法进行改进。</p><a class=anchor id=使用grep></a><h3>使用grep <a href=#%e4%bd%bf%e7%94%a8grep aria-hidden=true>#</a></h3><p>把 ps 的查询结果通过管道给 grep 查找包含特定字符串的进程。管道符 <code>|</code> 用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ps -ef | grep firefox
</span></span><span class=line><span class=cl>smx    1827     1   4 11:38 ?        00:27:33 /usr/lib/firefox-3.6.18/firefox-bin
</span></span><span class=line><span class=cl>smx    12029  1824  0 21:54 pts/0    00:00:00 grep --color=auto firefox
</span></span><span class=line><span class=cl>$ kill -s 9 1827
</span></span></code></pre></div><a class=anchor id=使用pgrep></a><h3>使用pgrep <a href=#%e4%bd%bf%e7%94%a8pgrep aria-hidden=true>#</a></h3><p>pgrep 的 p 表明了这个命令是专门用于进程查询的 grep 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pgrep firefox
</span></span><span class=line><span class=cl>1827
</span></span><span class=line><span class=cl>$ kill -s 9 1827
</span></span></code></pre></div><a class=anchor id=使用pidof></a><h3>使用pidof <a href=#%e4%bd%bf%e7%94%a8pidof aria-hidden=true>#</a></h3><p>实际就是 pid of xx，字面翻译过来就是 xx 的 PID ，和 pgrep 相比稍显不足的是，pidof 必须给出进程的全名。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pidof firefox-bin
</span></span><span class=line><span class=cl>1827
</span></span><span class=line><span class=cl>$kill -s 9 1827
</span></span></code></pre></div><p>无论是使用 ps 然后慢慢查找进程 PID 还是用 grep 查找包含相应字符串的进程，亦或者用 pgrep 直接查找包含相应字符串的进程 PID ，然后手动输入给 Kill 杀掉，都稍显麻烦。</p><a class=anchor id=一步完成></a><h3>一步完成 <a href=#%e4%b8%80%e6%ad%a5%e5%ae%8c%e6%88%90 aria-hidden=true>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ps -ef | grep firefox | grep -v grep | cut -c 9-15 | xargs kill -s 9
</span></span></code></pre></div><a class=anchor id=使用-pgreppidof></a><h3>使用 pgrep/pidof <a href=#%e4%bd%bf%e7%94%a8-pgreppidof aria-hidden=true>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pgrep firefox | xargs kill -s 9
</span></span></code></pre></div><a class=anchor id=使用awk></a><h3>使用awk <a href=#%e4%bd%bf%e7%94%a8awk aria-hidden=true>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ps -ef | grep firefox | awk &#39;{print $2}&#39; | xargs kill -9
</span></span><span class=line><span class=cl>kill: No such process
</span></span></code></pre></div><a class=anchor id=替换-xargs></a><h3>替换 xargs <a href=#%e6%9b%bf%e6%8d%a2-xargs aria-hidden=true>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -s 9 `ps -aux | grep firefox | awk &#39;{print $2}&#39;`
</span></span></code></pre></div><a class=anchor id=换成-pgrep></a><h3>换成 pgrep <a href=#%e6%8d%a2%e6%88%90-pgrep aria-hidden=true>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ kill -s 9 `pgrep firefox`
</span></span></code></pre></div><a class=anchor id=使用-pkill></a><h3>使用 pkill <a href=#%e4%bd%bf%e7%94%a8-pkill aria-hidden=true>#</a></h3><p>pkill＝pgrep+kill。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pkill -9 firefox
</span></span></code></pre></div><p>说明："-9" 即发送的信号是9，pkill与kill在这点的差别是：pkill无须 “ｓ”，终止信号等级直接跟在 “-“ 后面。</p><a class=anchor id=使用-killall></a><h3>使用 killall <a href=#%e4%bd%bf%e7%94%a8-killall aria-hidden=true>#</a></h3><p>killall和pkill是相似的,不过如果给出的进程名不完整，killall会报错。pkill或者pgrep只要给出进程名的一部分就可以终止进程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ killall -9 firefox
</span></span></code></pre></div><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><ul><li><a href=http://blog.csdn.net/ctthuangcheng/article/details/8914613>神奇的vfork (local)</a>，一个针对错误使用 vfork() 时的场景分新。</li><li><a href=http://blog.csdn.net/zhoudaxia/article/details/7366832>进程描述和进程创建</a>，用于描述进程，其中包括了进程创建以及退出，一篇不错的文章。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#进程>进程</a><ul><li><a href=#初始进程>初始进程</a></li><li><a href=#fork>fork</a></li><li><a href=#执行流程>执行流程</a></li></ul></li><li><a href=#进程创建>进程创建</a><ul><li><a href=#区别>区别</a></li><li><a href=#源码解析>源码解析</a></li><li><a href=#pid分配>PID分配</a></li><li><a href=#系统进程遍历>系统进程遍历</a></li></ul></li><li><a href=#进程关系>进程关系</a><ul><li><a href=#进程组和会话期>进程组和会话期</a></li></ul></li><li><a href=#其它>其它</a><ul><li><a href=#指定cpu>指定CPU</a></li><li><a href=#杀死进程的n中方法>杀死进程的N中方法</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>