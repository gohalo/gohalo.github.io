<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>libev 源码详解 | GoHalo</title><link rel=stylesheet href=/static/syntax.css><link rel=stylesheet href=https://gohalo.github.io/main.c459e32cfef70be8c28586c3b8bc93e2.css integrity="md5-xFnjLP73C+jChYbDuLyT4g==" crossorigin=anonymous><style type=text/css>.content-body p{text-indent:2em}.content-body li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="libev 内部结构比较简单，只提供了基本的处理逻辑，其中核心主要分成了几部分：文件描述符处理。
"><link rel=canonical href=https://gohalo.github.io/cn/blog/libev-source-code-introduce/><script type=application/ld+json>{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://gohalo.github.io/#/schema/person/1","name":"","url":"https://gohalo.github.io/","sameAs":[],"image":{"@type":"ImageObject","@id":"https://gohalo.github.io/#/schema/image/1","url":"https://gohalo.github.io/\u003cnil\u003e","width":null,"height":null,"caption":""}},{"@type":"WebSite","@id":"https://gohalo.github.io/#/schema/website/1","url":"https://gohalo.github.io/","name":"GoHalo","description":"","publisher":{"@id":"https://gohalo.github.io/#/schema/person/1"}},{"@type":"WebPage","@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/","url":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/","name":"libev 源码详解","description":"","isPartOf":{"@id":"https://gohalo.github.io/#/schema/website/1"},"about":{"@id":"https://gohalo.github.io/#/schema/person/1"},"datePublished":"2016-12-30T18:49:39CET","dateModified":"2016-12-30T18:49:39CET","breadcrumb":{"@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/#/schema/breadcrumb/1"},"primaryImageOfPage":{"@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/#/schema/image/2"},"inLanguage":"","potentialAction":[{"@type":"ReadAction","target":["https://gohalo.github.io/cn/blog/libev-source-code-introduce/"]}]},{"@type":"BreadcrumbList","@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/#/schema/breadcrumb/1","name":"Breadcrumbs","itemListElement":[{"@type":"ListItem","position":1,"item":{"@type":"WebPage","@id":"https://gohalo.github.io/","url":"https://gohalo.github.io/","name":"Home"}},{"@type":"ListItem","position":2,"item":{"@type":"WebPage","@id":"https://gohalo.github.io/cn/","url":"https://gohalo.github.io/cn/","name":"Cn"}},{"@type":"ListItem","position":3,"item":{"@type":"WebPage","@id":"https://gohalo.github.io/cn/blog/","url":"https://gohalo.github.io/cn/blog/","name":"Blog"}},{"@type":"ListItem","position":4,"item":{"@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://gohalo.github.io/#/schema/article/1","headline":"libev 源码详解","description":"","isPartOf":{"@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/"},"mainEntityOfPage":{"@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/"},"datePublished":"2016-12-30T18:49:39CET","dateModified":"2016-12-30T18:49:39CET","author":{"@id":"https://gohalo.github.io/#/schema/person/2"},"publisher":{"@id":"https://gohalo.github.io/#/schema/person/1"},"image":{"@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/#/schema/image/2"}}]},{"@context":"https://schema.org","@graph":[{"@type":"Person","@id":"https://gohalo.github.io/#/schema/person/2","name":null,"sameAs":[]}]},{"@context":"https://schema.org","@graph":[{"@type":"ImageObject","@id":"https://gohalo.github.io/cn/blog/libev-source-code-introduce/#/schema/image/2","url":null,"contentUrl":null,"caption":"libev 源码详解"}]}]}</script><meta name=theme-color content><link rel=icon href=https://gohalo.github.io/favicon.ico sizes=any><link rel=icon type=image/svg+xml href=https://gohalo.github.io/logo.svg><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/site.webmanifest></head><body class="blog single"><div class=sticky-top><div class=header-bar></div><header class="navbar navbar-expand-lg navbar-light doks-navbar"><nav class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class="btn btn-menu order-2 d-block d-lg-none" type=button data-bs-toggle=offcanvas data-bs-target=#offcanvasDoks aria-controls=offcanvasDoks aria-label="Open main menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg></button><div class="offcanvas offcanvas-end border-0 py-lg-1" tabindex=-1 id=offcanvasDoks data-bs-backdrop=true aria-labelledby=offcanvasDoksLabel><div class="header-bar d-lg-none"></div><div class="offcanvas-header d-lg-none"><h2 class="h5 offcanvas-title ps-2" id=offcanvasDoksLabel><a class=text-dark href=/cn/>GoHalo</a></h2><button type=button class="btn-close text-reset me-2" data-bs-dismiss=offcanvas aria-label="Close main menu"></button></div><div class="offcanvas-body p-4 p-lg-0"><ul class="nav flex-column flex-lg-row align-items-lg-center mt-2 mt-lg-0 ms-lg-2 me-lg-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle ps-0 py-1" href=# id=navbarDropdownMenuLink role=button data-bs-toggle=dropdown aria-expanded=false>项目
<span class=dropdown-caret><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-down"><polyline points="6 9 12 15 18 9"/></svg></span></a><ul class="dropdown-menu dropdown-menu-main shadow rounded border-0" aria-labelledby=navbarDropdownMenuLink><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class=dropdown-item href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/cn/blog/>博客</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class="nav-link ps-0 py-1" href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg><small class="ms-2 d-lg-none">GitHub</small></a></li></ul></div></div></nav></header></div><div class="wrap container-xxl" role=document><div class=content><article><div class="row justify-content-center"><nav class="toc d-none d-xl-block col-xl-3"><div class=d-xl-none><button class="btn btn-outline-primary btn-sm doks-toc-toggle collapsed" type=button data-bs-toggle=collapse data-bs-target=#onThisPage aria-controls=doks-docs-nav aria-expanded=false aria-label="Toggle On this page navigation">
<span>页面目录</span>
<span><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-expand" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Expand</title><polyline points="7 13 12 18 17 13"/><polyline points="7 6 12 11 17 6"/></svg><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" class="doks doks-collapse" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>Collapse</title><polyline points="17 11 12 6 7 11"/><polyline points="17 18 12 13 7 18"/></svg></span></button><div class=collapse id=onThisPage><div class="card card-body mt-3 py-1"><div class=page-links><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#结构体>结构体</a></li></ul></li><li><a href=#多实例支持>多实例支持</a><ul><li><a href=#结构体-1>结构体</a></li></ul></li><li><a href=#系统时间>系统时间</a></li><li><a href=#初始化>初始化</a></li><li><a href=#主循环>主循环</a></li><li><a href=#io-watcher>IO Watcher</a><ul><li><a href=#数据结构>数据结构</a></li><li><a href=#fd_reify>fd_reify()</a></li><li><a href=#多路复用>多路复用</a></li><li><a href=#filestat-watcher>Filestat Watcher</a></li><li><a href=#其它>其它</a></li></ul></li><li><a href=#async-watcher>Async Watcher</a></li><li><a href=#杂项>杂项</a><ul><li><a href=#代码优化>代码优化</a></li><li><a href=#ev_feature_api>EV_FEATURE_API</a></li><li><a href=#内存分配>内存分配</a></li><li><a href=#处理回调>处理回调</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#结构体>结构体</a></li></ul></li><li><a href=#多实例支持>多实例支持</a><ul><li><a href=#结构体-1>结构体</a></li></ul></li><li><a href=#系统时间>系统时间</a></li><li><a href=#初始化>初始化</a></li><li><a href=#主循环>主循环</a></li><li><a href=#io-watcher>IO Watcher</a><ul><li><a href=#数据结构>数据结构</a></li><li><a href=#fd_reify>fd_reify()</a></li><li><a href=#多路复用>多路复用</a></li><li><a href=#filestat-watcher>Filestat Watcher</a></li><li><a href=#其它>其它</a></li></ul></li><li><a href=#async-watcher>Async Watcher</a></li><li><a href=#杂项>杂项</a><ul><li><a href=#代码优化>代码优化</a></li><li><a href=#ev_feature_api>EV_FEATURE_API</a></li><li><a href=#内存分配>内存分配</a></li><li><a href=#处理回调>处理回调</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></nav><div class="blog-wrapper col-md-12 col-xl-9"><div class=blog-header><h1>libev 源码详解</h1><div class="blog-meta mb-3"><span class=ms-2><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-calendar-check" viewBox="0 0 16 16"><path d="M10.854 7.146a.5.5.0 010 .708l-3 3a.5.5.0 01-.708.0l-1.5-1.5a.5.5.0 11.708-.708L7.5 9.793l2.646-2.647a.5.5.0 01.708.0z"/><path d="M3.5.0a.5.5.0 01.5.5V1h8V.5a.5.5.0 011 0V1h1a2 2 0 012 2v11a2 2 0 01-2 2H2a2 2 0 01-2-2V3a2 2 0 012-2h1V.5a.5.5.0 01.5-.5zM1 4v10a1 1 0 001 1h12a1 1 0 001-1V4H1z"/></svg></span><span class=mx-2>2016-12-30</span>
<span class=mx-2><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentcolor" class="bi bi-tags" viewBox="0 0 16 16"><path d="M3 2v4.586l7 7L14.586 9l-7-7H3zM2 2a1 1 0 011-1h4.586a1 1 0 01.707.293l7 7a1 1 0 010 1.414l-4.586 4.586a1 1 0 01-1.414.0l-7-7A1 1 0 012 6.586V2z"/><path d="M5.5 5a.5.5.0 110-1 .5.5.0 010 1zm0 1a1.5 1.5.0 100-3 1.5 1.5.0 000 3zM1 7.086a1 1 0 00.293.707L8.75 15.25l-.043.043a1 1 0 01-1.414.0l-7-7A1 1 0 010 7.586V3a1 1 0 011-1v5.086z"/></svg></span><a class="btn btn-light" href=https://gohalo.github.io/tags/linux/ role=button>linux</a>
<a class="btn btn-light" href=https://gohalo.github.io/tags/network/ role=button>network</a></div></div><hr><div class=content-body><p>libev 内部结构比较简单，只提供了基本的处理逻辑，其中核心主要分成了几部分：文件描述符处理。</p><h1 id=简介>简介 <a href=#%e7%ae%80%e4%bb%8b class=anchor aria-hidden=true>#</a></h1><p>libev 通过观察器 (watcher) 来监听各种事件，watcher 包括了事件类型、优先级、触发条件和回调函数等参数；将其注册到事件循环上，在满足注册的条件时，会触发观察器，调用它的回调函数。</p><p>其中相关事件类型的宏定义如下，其中部分是用来标示不同类型触发的事件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>enum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_UNDEF</span>    <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=mh>0xFFFFFFFF</span><span class=p>,</span> <span class=cm>/* guaranteed to be invalid */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_NONE</span>     <span class=o>=</span>            <span class=mh>0x00</span><span class=p>,</span> <span class=cm>/* no events */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_READ</span>     <span class=o>=</span>            <span class=mh>0x01</span><span class=p>,</span> <span class=cm>/* ev_io detected read will not block */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_WRITE</span>    <span class=o>=</span>            <span class=mh>0x02</span><span class=p>,</span> <span class=cm>/* ev_io detected write will not block */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV__IOFDSET</span> <span class=o>=</span>            <span class=mh>0x80</span><span class=p>,</span> <span class=cm>/* internal use only */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_IO</span>       <span class=o>=</span>         <span class=n>EV_READ</span><span class=p>,</span> <span class=cm>/* alias for type-detection */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_TIMER</span>    <span class=o>=</span>      <span class=mh>0x00000100</span><span class=p>,</span> <span class=cm>/* timer timed out */</span>
</span></span><span class=line><span class=cl><span class=cp>#if EV_COMPAT3
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=n>EV_TIMEOUT</span>  <span class=o>=</span>        <span class=n>EV_TIMER</span><span class=p>,</span> <span class=cm>/* pre 4.0 API compatibility */</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=n>EV_PERIODIC</span> <span class=o>=</span>      <span class=mh>0x00000200</span><span class=p>,</span> <span class=cm>/* periodic timer timed out */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_SIGNAL</span>   <span class=o>=</span>      <span class=mh>0x00000400</span><span class=p>,</span> <span class=cm>/* signal was received */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_CHILD</span>    <span class=o>=</span>      <span class=mh>0x00000800</span><span class=p>,</span> <span class=cm>/* child/pid had status change */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_STAT</span>     <span class=o>=</span>      <span class=mh>0x00001000</span><span class=p>,</span> <span class=cm>/* stat data changed */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_IDLE</span>     <span class=o>=</span>      <span class=mh>0x00002000</span><span class=p>,</span> <span class=cm>/* event loop is idling */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_PREPARE</span>  <span class=o>=</span>      <span class=mh>0x00004000</span><span class=p>,</span> <span class=cm>/* event loop about to poll */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_CHECK</span>    <span class=o>=</span>      <span class=mh>0x00008000</span><span class=p>,</span> <span class=cm>/* event loop finished poll */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_EMBED</span>    <span class=o>=</span>      <span class=mh>0x00010000</span><span class=p>,</span> <span class=cm>/* embedded event loop needs sweep */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_FORK</span>     <span class=o>=</span>      <span class=mh>0x00020000</span><span class=p>,</span> <span class=cm>/* event loop resumed in child */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_CLEANUP</span>  <span class=o>=</span>      <span class=mh>0x00040000</span><span class=p>,</span> <span class=cm>/* event loop resumed in child */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_ASYNC</span>    <span class=o>=</span>      <span class=mh>0x00080000</span><span class=p>,</span> <span class=cm>/* async intra-loop signal */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_CUSTOM</span>   <span class=o>=</span>      <span class=mh>0x01000000</span><span class=p>,</span> <span class=cm>/* for use by user code */</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_ERROR</span>    <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=mh>0x80000000</span>  <span class=cm>/* sent when an error occurs */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>libev 中的观察器分为 4 种状态：初始化、启动/活动、等待、停止。</p><p>首先需要对 watcher 初始化，可通过 <code>ev_TYPE_init()</code> 或者 <code>ev_init()</code>+<code>ev_TYPE_set()</code> 初始化，两者等效；实际就是设置对应结构体的初始值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define ev_io_init(ev,cb,fd,events)              \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_io_set ((ev),(fd),(events)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_timer_init(ev,cb,after,repeat)        \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_timer_set ((ev),(after),(repeat)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_periodic_init(ev,cb,ofs,ival,rcb)     \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_periodic_set ((ev),(ofs),(ival),(rcb)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_signal_init(ev,cb,signum)             \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_signal_set ((ev), (signum)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_child_init(ev,cb,pid,trace)           \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_child_set ((ev),(pid),(trace)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_stat_init(ev,cb,path,interval)        \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_stat_set ((ev),(path),(interval)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_idle_init(ev,cb)                      \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_idle_set ((ev)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_prepare_init(ev,cb)                   \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_prepare_set ((ev)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_check_init(ev,cb)                     \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_check_set ((ev)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_embed_init(ev,cb,other)               \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_embed_set ((ev),(other)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_fork_init(ev,cb)                      \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_fork_set ((ev)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_cleanup_init(ev,cb)                   \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_cleanup_set ((ev)); } while (0)
</span></span></span><span class=line><span class=cl><span class=cp>#define ev_async_init(ev,cb)                     \
</span></span></span><span class=line><span class=cl><span class=cp>    do { ev_init ((ev), (cb)); ev_async_set ((ev)); } while (0)
</span></span></span></code></pre></div><p>接下来，通过 <code>ev_TYPE_start()</code>、<code>ev_TYPE_stop()</code> 来启动、停止观察器，停止同时会释放内存。</p><h2 id=结构体>结构体 <a href=#%e7%bb%93%e6%9e%84%e4%bd%93 class=anchor aria-hidden=true>#</a></h2><p>libev 通过 C 语言实现，其中通过宏实现了一种类似的继承机制，也就是其中各种 Watchers 的部分成员变量是相同的，只有少部分成员为各自独有，接下来简单介绍下。</p><p>每个 watcher 都会包含 <code>EV_WATCHER</code> 宏定义的内容，该宏实际会包含如下内容，其中 type 对应类型，如 <code>ev_io</code> 等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp># define EV_CB_DECLARE(type) void (*cb)(EV_P_ struct type *w, int revents);
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define EV_WATCHER(type) \
</span></span></span><span class=line><span class=cl><span class=cp>  int active;          </span><span class=cm>/* private，是否激活，通过start()/stop()处理 */</span><span class=cp> \
</span></span></span><span class=line><span class=cl><span class=cp>  int pending;         </span><span class=cm>/* private，有事件就绪等待处理，对应了等待队列的下标 */</span><span class=cp> \
</span></span></span><span class=line><span class=cl><span class=cp>  EV_DECL_PRIORITY     </span><span class=cm>/* private，定义优先级，如果没有使用优先级则是空 */</span><span class=cp> \
</span></span></span><span class=line><span class=cl><span class=cp>  EV_COMMON            </span><span class=cm>/* rw，私有数据，一般是void *data */</span><span class=cp> \
</span></span></span><span class=line><span class=cl><span class=cp>  EV_CB_DECLARE (type) </span><span class=cm>/* private，回调函数 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define EV_WATCHER_LIST(type)           \
</span></span></span><span class=line><span class=cl><span class=cp>  EV_WATCHER (type)                     \
</span></span></span><span class=line><span class=cl><span class=cp>  struct ev_watcher_list *next; </span><span class=cm>/* private */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define EV_WATCHER_TIME(type)           \
</span></span></span><span class=line><span class=cl><span class=cp>  EV_WATCHER (type)                     \
</span></span></span><span class=line><span class=cl><span class=cp>  ev_tstamp at;                 </span><span class=cm>/* private */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>ev_watcher</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>EV_WATCHER</span> <span class=p>(</span><span class=n>ev_watcher</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ev_watcher</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>ev_watcher_list</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>EV_WATCHER_LIST</span> <span class=p>(</span><span class=n>ev_watcher_list</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ev_watcher_list</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>ev_io</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>EV_WATCHER_LIST</span> <span class=p>(</span><span class=n>ev_io</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>     <span class=cm>/* ro */</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>events</span><span class=p>;</span> <span class=cm>/* ro */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ev_io</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>ev_timer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>EV_WATCHER_TIME</span> <span class=p>(</span><span class=n>ev_timer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ev_tstamp</span> <span class=n>repeat</span><span class=p>;</span> <span class=cm>/* rw */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ev_timer</span><span class=p>;</span>
</span></span></code></pre></div><p>如上的 <code>ev_watcher</code> 结构体可以时为 &ldquo;基类&rdquo;，通过宏 <code>EV_WATCHER</code> 定义了它的所有成员；而像 IO Watcher、Signal Watcher 是以链表的形式进行组织的，所以在 <code>ev_watcher</code> 基类的基础上，定义了 <code>ev_watcher</code> 的子类 <code>ev_watcher_list</code> 。</p><h1 id=多实例支持>多实例支持 <a href=#%e5%a4%9a%e5%ae%9e%e4%be%8b%e6%94%af%e6%8c%81 class=anchor aria-hidden=true>#</a></h1><p>默认 <code>ev_loop</code> 是主循环，保存了与循环相关的很多变量，而 <code>EV_MULTIPLICITY</code> 是一个条件编译的宏，表明是否支持有多个 <code>ev_loop</code> 实例存在，表现在源码中表示是否需要传递 <code>struct ev_loop *loop</code> 参数，一般来说，每个线程中有且仅有一个 <code>ev_loop</code> 实例。</p><p>例如，可以在多线程编程中每个线程使用一个实例。</p><h2 id=结构体-1>结构体 <a href=#%e7%bb%93%e6%9e%84%e4%bd%93-1 class=anchor aria-hidden=true>#</a></h2><p>其中最为关键的代码如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#if EV_MULTIPLICITY
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=k>struct</span> <span class=n>ev_loop</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>ev_tstamp</span> <span class=n>ev_rt_now</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=cp>#define ev_rt_now ((loop)-&gt;ev_rt_now)
</span></span></span><span class=line><span class=cl><span class=cp></span>		<span class=cp>#define VAR(name,decl) decl;
</span></span></span><span class=line><span class=cl><span class=cp></span>		<span class=cp>#include</span> <span class=cpf>&#34;ev_vars.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>		<span class=cp>#undef VAR
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=p>};</span>
</span></span><span class=line><span class=cl>	<span class=cp>#include</span> <span class=cpf>&#34;ev_wrap.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=k>static</span> <span class=k>struct</span> <span class=n>ev_loop</span> <span class=n>default_loop_struct</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* needs to be initialised to make it a definition despite extern */</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>ev_loop</span> <span class=o>*</span><span class=n>ev_default_loop_ptr</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=cm>/* needs to be initialised to make it a definition despite extern */</span>
</span></span><span class=line><span class=cl>	<span class=n>ev_tstamp</span> <span class=n>ev_rt_now</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=cp>#define VAR(name,decl) static decl;
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=cp>#include</span> <span class=cpf>&#34;ev_vars.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=cp>#undef VAR
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=k>static</span> <span class=kt>int</span> <span class=n>ev_default_loop_ptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>如果支持多个 event loop，那么 <code>ev_default_loop_ptr</code> 就是一个静态的 <code>struct ev_loop</code> 类型的结构体，其中包含了各种成员，比如 <code>ev_tstamp ev_rt_now;</code> <code>int pendingpri;</code> 等等。</p><p>如果不支持多个 event loop，则上述的 <code>struct ev_loop</code> 结构就不存在，其成员都是以静态变量的形式进行定义，而 <code>ev_default_loop_ptr</code> 也只是一个 int 变量，用来表明 loop 是否已经初始化成功。</p><p>使用方式可以查看之前的示例。</p><h1 id=系统时间>系统时间 <a href=#%e7%b3%bb%e7%bb%9f%e6%97%b6%e9%97%b4 class=anchor aria-hidden=true>#</a></h1><p>在介绍代码的详细处理逻辑之前，先简单介绍下与时间相关的内容，看下 libev 是如何使用时间的，因为该库中很多与时间相关的操作。</p><p>在 <code>libev.m4</code> 中，定义了与之相关的宏，如下所示。</p><pre tabindex=0><code>AC_CHECK_FUNCS(clock_gettime, [], [
   dnl on linux, try syscall wrapper first
   if test $(uname) = Linux; then
      AC_MSG_CHECKING(for clock_gettime syscall)
      AC_LINK_IFELSE([AC_LANG_PROGRAM(
         [#include &lt;unistd.h&gt;
          #include &lt;sys/syscall.h&gt;
          #include &lt;time.h&gt;],
         [struct timespec ts; int status = syscall (SYS_clock_gettime, CLOCK_REALTIME, &amp;ts)])],
         [ac_have_clock_syscall=1
          AC_DEFINE(HAVE_CLOCK_SYSCALL, 1, Define to 1 to use the syscall interface for clock_gettime)
          AC_MSG_RESULT(yes)],
         [AC_MSG_RESULT(no)])
   fi
   if test -z &#34;$LIBEV_M4_AVOID_LIBRT&#34; &amp;&amp; test -z &#34;$ac_have_clock_syscall&#34;; then
      AC_CHECK_LIB(rt, clock_gettime)
      unset ac_cv_func_clock_gettime
      AC_CHECK_FUNCS(clock_gettime)
   fi
])

AC_CHECK_FUNCS(nanosleep, [], [
   if test -z &#34;$LIBEV_M4_AVOID_LIBRT&#34;; then
      AC_CHECK_LIB(rt, nanosleep)
      unset ac_cv_func_nanosleep
      AC_CHECK_FUNCS(nanosleep)
   fi
])
</code></pre><p><code>clock_gettime()</code> 函数的调用有两种方式，分别是系统调用和 <code>-lrt</code> 库；在上述的 <code>libev.m4</code> 中，会进行检测，首先会检测 <code>clock_gettime()</code> 系统调用是否可用，如果可用会定义 <code>HAVE_CLOCK_SYSCALL</code> 宏。</p><p>libev 提供了单调递增 (monotonic) 以及实时时间 (realtime) 两种记时方式，其宏定义的方式如下，而 <code>HAVE_CLOCK_SYSCALL</code> 和 <code>HAVE_CLOCK_GETTIME</code> 的详见 libev.m4 中定义，优先使用 <code>SYS_clock_gettime()</code> 系统调用 API 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp># if HAVE_CLOCK_SYSCALL
</span></span></span><span class=line><span class=cl><span class=cp>#  ifndef EV_USE_CLOCK_SYSCALL
</span></span></span><span class=line><span class=cl><span class=cp>#   define EV_USE_CLOCK_SYSCALL 1
</span></span></span><span class=line><span class=cl><span class=cp>#   ifndef EV_USE_REALTIME
</span></span></span><span class=line><span class=cl><span class=cp>#    define EV_USE_REALTIME  0
</span></span></span><span class=line><span class=cl><span class=cp>#   endif
</span></span></span><span class=line><span class=cl><span class=cp>#   ifndef EV_USE_MONOTONIC
</span></span></span><span class=line><span class=cl><span class=cp>#    define EV_USE_MONOTONIC 1
</span></span></span><span class=line><span class=cl><span class=cp>#   endif
</span></span></span><span class=line><span class=cl><span class=cp>#  endif
</span></span></span><span class=line><span class=cl><span class=cp># elif !defined EV_USE_CLOCK_SYSCALL
</span></span></span><span class=line><span class=cl><span class=cp>#  define EV_USE_CLOCK_SYSCALL 0
</span></span></span><span class=line><span class=cl><span class=cp># endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp># if HAVE_CLOCK_GETTIME
</span></span></span><span class=line><span class=cl><span class=cp>#  ifndef EV_USE_MONOTONIC
</span></span></span><span class=line><span class=cl><span class=cp>#   define EV_USE_MONOTONIC 1
</span></span></span><span class=line><span class=cl><span class=cp>#  endif
</span></span></span><span class=line><span class=cl><span class=cp>#  ifndef EV_USE_REALTIME
</span></span></span><span class=line><span class=cl><span class=cp>#   define EV_USE_REALTIME  0
</span></span></span><span class=line><span class=cl><span class=cp>#  endif
</span></span></span><span class=line><span class=cl><span class=cp># else
</span></span></span><span class=line><span class=cl><span class=cp>#  ifndef EV_USE_MONOTONIC
</span></span></span><span class=line><span class=cl><span class=cp>#   define EV_USE_MONOTONIC 0
</span></span></span><span class=line><span class=cl><span class=cp>#  endif
</span></span></span><span class=line><span class=cl><span class=cp>#  ifndef EV_USE_REALTIME
</span></span></span><span class=line><span class=cl><span class=cp>#   define EV_USE_REALTIME  0
</span></span></span><span class=line><span class=cl><span class=cp>#  endif
</span></span></span><span class=line><span class=cl><span class=cp># endif
</span></span></span></code></pre></div><p>优先使用系统调用和单调递增时间，在 CentOS 7 中通常定义为。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define HAVE_CLOCK_GETTIME 1
</span></span></span><span class=line><span class=cl><span class=cp>#define EV_USE_REALTIME  0
</span></span></span><span class=line><span class=cl><span class=cp>#define EV_USE_MONOTONIC 1
</span></span></span></code></pre></div><p>在如下的初始化函数中介绍详细的细节。</p><h1 id=初始化>初始化 <a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 class=anchor aria-hidden=true>#</a></h1><p>无论是通过 <code>EV_DEFAULT</code> 宏还是 <code>ev_default_loop()</code> 函数进行初始化，实际上功能都相同，也就是都调用了 <code>ev_default_loop(0)</code> 进行初始化，该函数中会调用 <code>loop_init()</code> 。</p><p>如下主要介绍 <code>loop_init()</code> 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef EV_HAVE_EV_TIME
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>ev_tstamp</span>
</span></span><span class=line><span class=cl><span class=nf>ev_time</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=n>EV_THROW</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#if EV_USE_REALTIME
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>expect_true</span> <span class=p>(</span><span class=n>have_realtime</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>struct</span> <span class=n>timespec</span> <span class=n>ts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>clock_gettime</span> <span class=p>(</span><span class=n>CLOCK_REALTIME</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ts</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>ts</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>+</span> <span class=n>ts</span><span class=p>.</span><span class=n>tv_nsec</span> <span class=o>*</span> <span class=mf>1e-9</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>  <span class=k>struct</span> <span class=n>timeval</span> <span class=n>tv</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nf>gettimeofday</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>tv</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>tv</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>+</span> <span class=n>tv</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>*</span> <span class=mf>1e-6</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>inline_size</span> <span class=n>ev_tstamp</span>
</span></span><span class=line><span class=cl><span class=nf>get_clock</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#if EV_USE_MONOTONIC
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=k>if</span> <span class=p>(</span><span class=nf>expect_true</span> <span class=p>(</span><span class=n>have_monotonic</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>struct</span> <span class=n>timespec</span> <span class=n>ts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=nf>clock_gettime</span> <span class=p>(</span><span class=n>CLOCK_MONOTONIC</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ts</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>ts</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>+</span> <span class=n>ts</span><span class=p>.</span><span class=n>tv_nsec</span> <span class=o>*</span> <span class=mf>1e-9</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>ev_time</span> <span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>noinline</span> <span class=n>ecb_cold</span> <span class=nf>loop_init</span> <span class=p>(</span><span class=n>EV_P_</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span> <span class=n>EV_THROW</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>backend</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 如果backend还没有确定
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>origflags</span> <span class=o>=</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if EV_USE_REALTIME
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>have_realtime</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>struct</span> <span class=n>timespec</span> <span class=n>ts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>clock_gettime</span> <span class=p>(</span><span class=n>CLOCK_REALTIME</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>have_realtime</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#if EV_USE_MONOTONIC
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>have_monotonic</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=k>struct</span> <span class=n>timespec</span> <span class=n>ts</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>          <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>clock_gettime</span> <span class=p>(</span><span class=n>CLOCK_MONOTONIC</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ts</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>have_monotonic</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>      <span class=cm>/* pid check not overridable via env */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef _WIN32
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVFLAG_FORKCHECK</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>curpid</span> <span class=o>=</span> <span class=nf>getpid</span> <span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVFLAG_NOENV</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=nf>enable_secure</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>          <span class=o>&amp;&amp;</span> <span class=nf>getenv</span> <span class=p>(</span><span class=s>&#34;LIBEV_FLAGS&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>flags</span> <span class=o>=</span> <span class=nf>atoi</span> <span class=p>(</span><span class=nf>getenv</span> <span class=p>(</span><span class=s>&#34;LIBEV_FLAGS&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>ev_rt_now</span>          <span class=o>=</span> <span class=nf>ev_time</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>mn_now</span>             <span class=o>=</span> <span class=nf>get_clock</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>now_floor</span>          <span class=o>=</span> <span class=n>mn_now</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>rtmn_diff</span>          <span class=o>=</span> <span class=n>ev_rt_now</span> <span class=o>-</span> <span class=n>mn_now</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#if EV_FEATURE_API
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=n>invoke_cb</span>          <span class=o>=</span> <span class=n>ev_invoke_pending</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>      <span class=n>io_blocktime</span>       <span class=o>=</span> <span class=mf>0.</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>timeout_blocktime</span>  <span class=o>=</span> <span class=mf>0.</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>backend</span>            <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>backend_fd</span>         <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>sig_pending</span>        <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#if EV_ASYNC_ENABLE
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=n>async_pending</span>      <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=n>pipe_write_skipped</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>pipe_write_wanted</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>evpipe</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span>         <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>evpipe</span> <span class=p>[</span><span class=mi>1</span><span class=p>]</span>         <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#if EV_USE_INOTIFY
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=n>fs_fd</span>              <span class=o>=</span> <span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVFLAG_NOINOTIFY</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=o>-</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#if EV_USE_SIGNALFD
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=n>sigfd</span>              <span class=o>=</span> <span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVFLAG_SIGNALFD</span>  <span class=o>?</span> <span class=o>-</span><span class=mi>2</span> <span class=o>:</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVBACKEND_MASK</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>flags</span> <span class=o>|=</span> <span class=nf>ev_recommended_backends</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if EV_USE_IOCP
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>backend</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVBACKEND_IOCP</span>  <span class=p>))</span> <span class=n>backend</span> <span class=o>=</span> <span class=nf>iocp_init</span>   <span class=p>(</span><span class=n>EV_A_</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#if EV_USE_PORT
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>backend</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVBACKEND_PORT</span>  <span class=p>))</span> <span class=n>backend</span> <span class=o>=</span> <span class=nf>port_init</span>   <span class=p>(</span><span class=n>EV_A_</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#if EV_USE_KQUEUE
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>backend</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVBACKEND_KQUEUE</span><span class=p>))</span> <span class=n>backend</span> <span class=o>=</span> <span class=nf>kqueue_init</span> <span class=p>(</span><span class=n>EV_A_</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#if EV_USE_EPOLL
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>backend</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVBACKEND_EPOLL</span> <span class=p>))</span> <span class=n>backend</span> <span class=o>=</span> <span class=nf>epoll_init</span>  <span class=p>(</span><span class=n>EV_A_</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#if EV_USE_POLL
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>backend</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVBACKEND_POLL</span>  <span class=p>))</span> <span class=n>backend</span> <span class=o>=</span> <span class=nf>poll_init</span>   <span class=p>(</span><span class=n>EV_A_</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#if EV_USE_SELECT
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>backend</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVBACKEND_SELECT</span><span class=p>))</span> <span class=n>backend</span> <span class=o>=</span> <span class=nf>select_init</span> <span class=p>(</span><span class=n>EV_A_</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>      <span class=nf>ev_prepare_init</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>pending_w</span><span class=p>,</span> <span class=n>pendingcb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if EV_SIGNAL_ENABLE || EV_ASYNC_ENABLE
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=nf>ev_init</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>pipe_w</span><span class=p>,</span> <span class=n>pipecb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=nf>ev_set_priority</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>pipe_w</span><span class=p>,</span> <span class=n>EV_MAXPRI</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中有两个比较重要的时间变量，也就是 <code>ev_rt_now</code> 和 <code>mn_now</code>，前者表示当前的日历时间，也就是自 1970.01.01 以来的秒数，该值通过 <code>gettimeofday()</code> 得到。</p><h1 id=主循环>主循环 <a href=#%e4%b8%bb%e5%be%aa%e7%8e%af class=anchor aria-hidden=true>#</a></h1><p>在介绍各个 Watcher 的流程之前，首先看下主循环的执行过程。</p><p>该函数通常是在各个事件初始化完成之后调用，也就是等待操作系统的事件，然后调用已经注册的回调函数，并一直重复循环执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>ev_run</span> <span class=p>(</span><span class=n>EV_P_</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>++</span><span class=n>loop_depth</span><span class=p>;</span>      <span class=c1>// 如果定义了EV_FEATURE_API宏
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>loop_done</span> <span class=o>=</span> <span class=n>EVBREAK_CANCEL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_INVOKE_PENDING</span><span class=p>;</span> <span class=c1>// 在执行前确认所有的事件已经执行
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nf>ev_verify</span> <span class=p>(</span><span class=n>EV_A</span><span class=p>);</span>  <span class=c1>// 当EV_VERIFY &gt;= 2时，用于校验当前的结构体是否正常
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>curpid</span><span class=p>))</span> <span class=cm>/* penalise the forking check even more */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=nf>getpid</span> <span class=p>()</span> <span class=o>!=</span> <span class=n>curpid</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>curpid</span> <span class=o>=</span> <span class=nf>getpid</span> <span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>postfork</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* we might have forked, so queue fork handlers */</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>postfork</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>forkcnt</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>queue_events</span> <span class=p>(</span><span class=nf>EV_A_</span> <span class=p>(</span><span class=n>W</span> <span class=o>*</span><span class=p>)</span><span class=n>forks</span><span class=p>,</span> <span class=n>forkcnt</span><span class=p>,</span> <span class=n>EV_FORK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>EV_INVOKE_PENDING</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* queue prepare watchers (and execute them) */</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>preparecnt</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=nf>queue_events</span> <span class=p>(</span><span class=nf>EV_A_</span> <span class=p>(</span><span class=n>W</span> <span class=o>*</span><span class=p>)</span><span class=n>prepares</span><span class=p>,</span> <span class=n>preparecnt</span><span class=p>,</span> <span class=n>EV_PREPARE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>          <span class=n>EV_INVOKE_PENDING</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>loop_done</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* we might have forked, so reify kernel state if necessary */</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>postfork</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>loop_fork</span> <span class=p>(</span><span class=n>EV_A</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* update fd-related kernel structures */</span>
</span></span><span class=line><span class=cl>      <span class=nf>fd_reify</span> <span class=p>(</span><span class=n>EV_A</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* calculate blocking time */</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ev_tstamp</span> <span class=n>waittime</span>  <span class=o>=</span> <span class=mf>0.</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ev_tstamp</span> <span class=n>sleeptime</span> <span class=o>=</span> <span class=mf>0.</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* remember old timestamp for io_blocktime calculation */</span>
</span></span><span class=line><span class=cl>        <span class=n>ev_tstamp</span> <span class=n>prev_mn_now</span> <span class=o>=</span> <span class=n>mn_now</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* 会更新当前时间mn_now和ev_rt_now，如果发现时间被调整，则调用
</span></span></span><span class=line><span class=cl><span class=cm>         * timers_reschedule()函数调整堆loop-&gt;timers()中的每个节点。
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=nf>time_update</span> <span class=p>(</span><span class=n>EV_A_</span> <span class=mf>1e100</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* from now on, we want a pipe-wake-up */</span>
</span></span><span class=line><span class=cl>        <span class=n>pipe_write_wanted</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>ECB_MEMORY_FENCE</span><span class=p>;</span> <span class=cm>/* make sure pipe_write_wanted is visible before we check for potential skips */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>expect_true</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>EVRUN_NOWAIT</span> <span class=o>||</span> <span class=n>idleall</span> <span class=o>||</span> <span class=o>!</span><span class=n>activecnt</span> <span class=o>||</span> <span class=n>pipe_write_skipped</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>waittime</span> <span class=o>=</span> <span class=n>MAX_BLOCKTIME</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>timercnt</span><span class=p>)</span> <span class=p>{</span>    <span class=c1>// 如果有定时器存在则重新计算等待时间
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>ev_tstamp</span> <span class=n>to</span> <span class=o>=</span> <span class=nf>ANHE_at</span> <span class=p>(</span><span class=n>timers</span> <span class=p>[</span><span class=n>HEAP0</span><span class=p>])</span> <span class=o>-</span> <span class=n>mn_now</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>waittime</span> <span class=o>&gt;</span> <span class=n>to</span><span class=p>)</span> <span class=n>waittime</span> <span class=o>=</span> <span class=n>to</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>periodiccnt</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 如果定义了EV_PERIODIC_ENABLE宏
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>ev_tstamp</span> <span class=n>to</span> <span class=o>=</span> <span class=nf>ANHE_at</span> <span class=p>(</span><span class=n>periodics</span> <span class=p>[</span><span class=n>HEAP0</span><span class=p>])</span> <span class=o>-</span> <span class=n>ev_rt_now</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>waittime</span> <span class=o>&gt;</span> <span class=n>to</span><span class=p>)</span> <span class=n>waittime</span> <span class=o>=</span> <span class=n>to</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* don&#39;t let timeouts decrease the waittime below timeout_blocktime */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>waittime</span> <span class=o>&lt;</span> <span class=n>timeout_blocktime</span><span class=p>))</span> <span class=c1>// 默认timeout_blocktime为0
</span></span></span><span class=line><span class=cl><span class=c1></span>              <span class=n>waittime</span> <span class=o>=</span> <span class=n>timeout_blocktime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* at this point, we NEED to wait, so we have to ensure */</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* to pass a minimum nonzero value to the backend */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>waittime</span> <span class=o>&lt;</span> <span class=n>backend_mintime</span><span class=p>))</span>
</span></span><span class=line><span class=cl>              <span class=n>waittime</span> <span class=o>=</span> <span class=n>backend_mintime</span><span class=p>;</span>  <span class=c1>// 不同的后端最小等待时间不同
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>            <span class=cm>/* extra check because io_blocktime is commonly 0 */</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>io_blocktime</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>sleeptime</span> <span class=o>=</span> <span class=n>io_blocktime</span> <span class=o>-</span> <span class=p>(</span><span class=n>mn_now</span> <span class=o>-</span> <span class=n>prev_mn_now</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>sleeptime</span> <span class=o>&gt;</span> <span class=n>waittime</span> <span class=o>-</span> <span class=n>backend_mintime</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                  <span class=n>sleeptime</span> <span class=o>=</span> <span class=n>waittime</span> <span class=o>-</span> <span class=n>backend_mintime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=nf>expect_true</span> <span class=p>(</span><span class=n>sleeptime</span> <span class=o>&gt;</span> <span class=mf>0.</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>ev_sleep</span> <span class=p>(</span><span class=n>sleeptime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>waittime</span> <span class=o>-=</span> <span class=n>sleeptime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if EV_FEATURE_API
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=o>++</span><span class=n>loop_count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=cm>/* 调用IO复用函数，例如epoll_poll()，在此需要保证阻塞时间小于loop-&gt;timers，
</span></span></span><span class=line><span class=cl><span class=cm>         * 以及loop-&gt;periodics的栈顶元素的触发时间。
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=nf>assert</span> <span class=p>((</span><span class=n>loop_done</span> <span class=o>=</span> <span class=n>EVBREAK_RECURSE</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span> <span class=cm>/* assert for side effect */</span>
</span></span><span class=line><span class=cl>        <span class=nf>backend_poll</span> <span class=p>(</span><span class=n>EV_A_</span> <span class=n>waittime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>assert</span> <span class=p>((</span><span class=n>loop_done</span> <span class=o>=</span> <span class=n>EVBREAK_CANCEL</span><span class=p>,</span> <span class=mi>1</span><span class=p>));</span> <span class=cm>/* assert for side effect */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>pipe_write_wanted</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=cm>/* just an optimisation, no fence needed */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>ECB_MEMORY_FENCE_ACQUIRE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pipe_write_skipped</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>assert</span> <span class=p>((</span><span class=s>&#34;libev: pipe_w not active, but pipe not written&#34;</span><span class=p>,</span> <span class=nf>ev_is_active</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>pipe_w</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>            <span class=nf>ev_feed_event</span> <span class=p>(</span><span class=n>EV_A_</span> <span class=o>&amp;</span><span class=n>pipe_w</span><span class=p>,</span> <span class=n>EV_CUSTOM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* update ev_rt_now, do magic */</span>
</span></span><span class=line><span class=cl>        <span class=nf>time_update</span> <span class=p>(</span><span class=n>EV_A_</span> <span class=n>waittime</span> <span class=o>+</span> <span class=n>sleeptime</span><span class=p>);</span> <span class=c1>// 更新时间，防止timejump
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* 如果栈顶元素的超时时间已经超过了当前时间，则将栈顶元素的监控器添加到
</span></span></span><span class=line><span class=cl><span class=cm>       * loop-&gt;pendings中，并调整堆结构，接着判断栈顶元素是否仍超时，一致重复，
</span></span></span><span class=line><span class=cl><span class=cm>       * 直到栈顶元素不再超时。
</span></span></span><span class=line><span class=cl><span class=cm>       */</span>
</span></span><span class=line><span class=cl>      <span class=nf>timers_reify</span> <span class=p>(</span><span class=n>EV_A</span><span class=p>);</span> <span class=cm>/* relative timers called last */</span>
</span></span><span class=line><span class=cl>      <span class=nf>periodics_reify</span> <span class=p>(</span><span class=n>EV_A</span><span class=p>);</span> <span class=cm>/* absolute timers called first */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* queue idle watchers unless other events are pending */</span>
</span></span><span class=line><span class=cl>      <span class=nf>idle_reify</span> <span class=p>(</span><span class=n>EV_A</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* queue check watchers, to be executed first */</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=n>checkcnt</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>queue_events</span> <span class=p>(</span><span class=nf>EV_A_</span> <span class=p>(</span><span class=n>W</span> <span class=o>*</span><span class=p>)</span><span class=n>checks</span><span class=p>,</span> <span class=n>checkcnt</span><span class=p>,</span> <span class=n>EV_CHECK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=cm>/* 按照优先级，顺序遍厉loop-&gt;pendings数组，调用其中每个监视器的回调函数 */</span>
</span></span><span class=line><span class=cl>      <span class=n>EV_INVOKE_PENDING</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=nf>expect_true</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>activecnt</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>loop_done</span>
</span></span><span class=line><span class=cl>        <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=p>(</span><span class=n>EVRUN_ONCE</span> <span class=o>|</span> <span class=n>EVRUN_NOWAIT</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>loop_done</span> <span class=o>==</span> <span class=n>EVBREAK_ONE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>loop_done</span> <span class=o>=</span> <span class=n>EVBREAK_CANCEL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if EV_FEATURE_API
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=o>--</span><span class=n>loop_depth</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>activecnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h1 id=io-watcher>IO Watcher <a href=#io-watcher class=anchor aria-hidden=true>#</a></h1><p>除了作为 IO 事件，很多的事件在内核中会转换为类似的方式。</p><p>对 IO 事件的监控的函数，会在 <code>loop_init()</code> 中初始化 <code>backend_poll</code> 函数变量，正是通过该函数监控 IO 事件，如下是一个简单的示例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>cb</span> <span class=p>(</span><span class=k>struct</span> <span class=n>ev_loop</span> <span class=o>*</span><span class=n>loop</span><span class=p>,</span> <span class=n>ev_io</span> <span class=o>*</span><span class=n>w</span><span class=p>,</span> <span class=kt>int</span> <span class=n>revents</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>ev_io_stop</span> <span class=p>(</span><span class=n>loop</span><span class=p>,</span> <span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// .. read from stdin here (or from w-&gt;fd) and handle any I/O errors
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>ev_io</span> <span class=n>watcher</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>ev_io_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>watcher</span><span class=p>,</span> <span class=n>cb</span><span class=p>,</span> <span class=n>STDIN_FILENO</span><span class=p>,</span> <span class=n>EV_READ</span><span class=p>);</span>  <span class=c1>// 初始化，第三个是文件描述符，第四个是监听事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>ev_io_start</span><span class=p>(</span><span class=n>EV_A_</span> <span class=o>&amp;</span><span class=n>watcher</span><span class=p>);</span>
</span></span></code></pre></div><p>其中，<code>ev_io_init()</code> 用来设置结构体的参数，除了初始化通用的变量之外，还包括 IO 观察器对应的 fd 和 event 。</p><h2 id=数据结构>数据结构 <a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 class=anchor aria-hidden=true>#</a></h2><p>对于 IO 事件，无非就是添加到列表中，然后判断是否需要通过类似 <code>epoll</code> 系统接口进行修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=n>ev_watcher</span> <span class=o>*</span><span class=n>W</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=n>ev_watcher_list</span> <span class=o>*</span><span class=n>WL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>WL</span> <span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>reify</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>emask</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>unused</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>egen</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ANFD</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>W</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>ANPENDING</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ANFD</span> <span class=n>andfs</span><span class=p>[];</span>    <span class=c1>// 保存了所有IO事件，文件描述符作为其序号
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>fchangecnt</span><span class=p>;</span>  <span class=c1>// 记录被修改的fd个数，用来判断是否调用epoll调整监听事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>fdchanges</span><span class=p>[];</span> <span class=c1>// 记录具体被修改的事件，每次循环时根据这里进行更新
</span></span></span></code></pre></div><p>在 Linux 中，文件句柄会按照顺序增加，在 libev 中直接使用数组保存已经打开的文件句柄，而对应的数组序号就是文件句柄。</p><p>这也就意味着，如果中间有句柄没有注册事件，那么就可能会有空洞。</p><h3 id=ev_io_start>ev_io_start() <a href=#ev_io_start class=anchor aria-hidden=true>#</a></h3><p>作用是设置 <code>ANFD anfds[]</code>，其中文件描述符为其序号，并将相应的 IO Watcher 插入到对应 fd 的链表中。由于对应 fd 的监控条件已有改动了，同时会在 <code>int fdchanges[]</code> 中记录下该 fd ，并在后续的步骤中调用系统的接口修改对该 fd 监控条件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=n>noinline</span> <span class=nf>ev_io_start</span> <span class=p>(</span><span class=n>EV_P_</span> <span class=n>ev_io</span> <span class=o>*</span><span class=n>w</span><span class=p>)</span> <span class=n>EV_THROW</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>w</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nf>expect_false</span> <span class=p>(</span><span class=nf>ev_is_active</span> <span class=p>(</span><span class=n>w</span><span class=p>)))</span> <span class=c1>// 如果已经启动则直接退出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>EV_FREQUENT_CHECK</span><span class=p>;</span>                   <span class=c1>// 通过ev_verify()校验数据格式是否正常
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=nf>ev_start</span> <span class=p>(</span><span class=nf>EV_A_</span> <span class=p>(</span><span class=n>W</span><span class=p>)</span><span class=n>w</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>            <span class=c1>// 设置watch-&gt;active变量
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>array_needsize</span> <span class=p>(</span><span class=n>ANFD</span><span class=p>,</span> <span class=n>anfds</span><span class=p>,</span> <span class=n>anfdmax</span><span class=p>,</span> <span class=n>fd</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>array_init_zero</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nf>wlist_add</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>anfds</span><span class=p>[</span><span class=n>fd</span><span class=p>].</span><span class=n>head</span><span class=p>,</span> <span class=p>(</span><span class=n>WL</span><span class=p>)</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// 添加到fdchanges[]数组中
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nf>fd_change</span> <span class=p>(</span><span class=n>EV_A_</span> <span class=n>fd</span><span class=p>,</span> <span class=n>w</span><span class=o>-&gt;</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EV__IOFDSET</span> <span class=o>|</span> <span class=n>EV_ANFD_REIFY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>w</span><span class=o>-&gt;</span><span class=n>events</span> <span class=o>&amp;=</span> <span class=o>~</span><span class=n>EV__IOFDSET</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>EV_FREQUENT_CHECK</span><span class=p>;</span>                   <span class=c1>// 如上，通过ev_verify()校验数据格式是否正常
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p><img src=images/io_watcher_anfds.png alt="libev io watcher" title="libev io watcher"></p><p>调用 <code>ev_run()</code> 开始等待事件的触发，该函数中首先会调用 <code>fd_reify()</code>，该函数根据 <code>fdchanges[]</code> 中记录的描述符，将该描述符上的事件添加到 backend 所使用的数据结构中；调用 <code>time_update()</code> 更新当前时间。</p><p>接着计算超时时间，并调用 <code>backend_poll()</code> 开始等待事件的发生，如果事件在规定时间内触发的话，则会调用 <code>fd_event()</code> 将触发的监视器记录到 pendings 中；</p><p>backend 监听函数 (如 <code>select()</code>、<code>poll()</code>、<code>epoll_wait()</code> 等) 返回后，再次调用 <code>time_update()</code> 更新时间，然后调用 <code>ev_invoke_pending()</code> ，依次处理 pendings 中的监视器，调用该监视器的回调函数。</p><h2 id=fd_reify>fd_reify() <a href=#fd_reify class=anchor aria-hidden=true>#</a></h2><p>该函数在 <code>ev_run()</code> 的每轮循环中都会调用；会将 fdchanges 中记录的这些新事件一个个的处理，并调用后端 IO 复用的 backend_modify 宏。</p><h2 id=多路复用>多路复用 <a href=#%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8 class=anchor aria-hidden=true>#</a></h2><p>当前支持的多路复用通过如下方式定义，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* method bits to be ored together */</span>
</span></span><span class=line><span class=cl><span class=k>enum</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>EVBACKEND_SELECT</span>  <span class=o>=</span> <span class=mh>0x00000001U</span><span class=p>,</span> <span class=cm>/* about anywhere */</span>
</span></span><span class=line><span class=cl>  <span class=n>EVBACKEND_POLL</span>    <span class=o>=</span> <span class=mh>0x00000002U</span><span class=p>,</span> <span class=cm>/* !win */</span>
</span></span><span class=line><span class=cl>  <span class=n>EVBACKEND_EPOLL</span>   <span class=o>=</span> <span class=mh>0x00000004U</span><span class=p>,</span> <span class=cm>/* linux */</span>
</span></span><span class=line><span class=cl>  <span class=n>EVBACKEND_KQUEUE</span>  <span class=o>=</span> <span class=mh>0x00000008U</span><span class=p>,</span> <span class=cm>/* bsd */</span>
</span></span><span class=line><span class=cl>  <span class=n>EVBACKEND_DEVPOLL</span> <span class=o>=</span> <span class=mh>0x00000010U</span><span class=p>,</span> <span class=cm>/* solaris 8 */</span> <span class=cm>/* NYI */</span>
</span></span><span class=line><span class=cl>  <span class=n>EVBACKEND_PORT</span>    <span class=o>=</span> <span class=mh>0x00000020U</span><span class=p>,</span> <span class=cm>/* solaris 10 */</span>
</span></span><span class=line><span class=cl>  <span class=n>EVBACKEND_ALL</span>     <span class=o>=</span> <span class=mh>0x0000003FU</span><span class=p>,</span> <span class=cm>/* all known backends */</span>
</span></span><span class=line><span class=cl>  <span class=n>EVBACKEND_MASK</span>    <span class=o>=</span> <span class=mh>0x0000FFFFU</span>  <span class=cm>/* all future backends */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>而在通过 configure 进行编译时，会对宏进行处理，以 epoll 为例，可以查看 ev.c 中的内容；在通过 configure 编译时，如果支持 EPOLL 会在 config.h 中生成 <code>HAVE_POLL</code> 和 <code>HAVE_POLL_H</code> 宏定义。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp># if HAVE_POLL &amp;&amp; HAVE_POLL_H
</span></span></span><span class=line><span class=cl><span class=cp>#  ifndef EV_USE_POLL
</span></span></span><span class=line><span class=cl><span class=cp>#   define EV_USE_POLL EV_FEATURE_BACKENDS
</span></span></span><span class=line><span class=cl><span class=cp>#  endif
</span></span></span><span class=line><span class=cl><span class=cp># else
</span></span></span><span class=line><span class=cl><span class=cp>#  undef EV_USE_POLL
</span></span></span><span class=line><span class=cl><span class=cp>#  define EV_USE_POLL 0
</span></span></span><span class=line><span class=cl><span class=cp># endif
</span></span></span></code></pre></div><p>之后调用 <code>ev_recommended_backends()</code> 得到当前系统支持的 backend 类型，比如 select、poll、epoll 等；然后，接下来就是根据系统支持的 backend，按照一定的优先顺序，去初始化 backend 。</p><h2 id=filestat-watcher>Filestat Watcher <a href=#filestat-watcher class=anchor aria-hidden=true>#</a></h2><p>监控 Makefile 是否有变化，可以通过修改文件触发事件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>filestat_cb</span> <span class=p>(</span><span class=k>struct</span> <span class=n>ev_loop</span> <span class=o>*</span><span class=n>loop</span><span class=p>,</span> <span class=n>ev_stat</span> <span class=o>*</span><span class=n>w</span><span class=p>,</span> <span class=kt>int</span> <span class=n>revents</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// &#34;Makefile&#34; changed in some way
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>attr</span><span class=p>.</span><span class=n>st_nlink</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span> <span class=p>(</span><span class=s>&#34;Makefile current size  %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>attr</span><span class=p>.</span><span class=n>st_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span> <span class=p>(</span><span class=s>&#34;Makefile current atime %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>attr</span><span class=p>.</span><span class=n>st_mtime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span> <span class=p>(</span><span class=s>&#34;Makefile current mtime %ld</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=kt>long</span><span class=p>)</span><span class=n>w</span><span class=o>-&gt;</span><span class=n>attr</span><span class=p>.</span><span class=n>st_mtime</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span> <span class=cm>/* you shalt not abuse printf for puts */</span>
</span></span><span class=line><span class=cl>        <span class=nf>puts</span> <span class=p>(</span><span class=s>&#34;wow, Makefile is not there, expect problems. &#34;</span>
</span></span><span class=line><span class=cl>              <span class=s>&#34;if this is windows, they already arrived</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>ev_stat</span> <span class=n>makefile</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>ev_stat_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>makefile</span><span class=p>,</span> <span class=n>filestat_cb</span><span class=p>,</span> <span class=s>&#34;Makefile&#34;</span><span class=p>,</span> <span class=mf>0.</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nf>ev_stat_start</span><span class=p>(</span><span class=n>loop</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>makefile</span><span class=p>);</span>
</span></span></code></pre></div><h2 id=其它>其它 <a href=#%e5%85%b6%e5%ae%83 class=anchor aria-hidden=true>#</a></h2><p>也就是 <code>ev_prepare</code>、<code>ev_check</code>、<code>ev_idle</code>，这三个类型的实际上是事件循环的扩展。</p><ul><li>ev_prepare 在事件循环发生阻塞前会被触发。</li></ul><h1 id=async-watcher>Async Watcher <a href=#async-watcher class=anchor aria-hidden=true>#</a></h1><p>在 libev 库中，有很大一部分的数据结构是通过数组存储，以 async 的信号处理为例，其大致的处理过程如下。</p><p>async 的所有信号保存在 <code>ev_async *[]</code> 数组中，其中 <code>asyncmax</code> 保存了当前内存空间支持的最大事件数，而 <code>asynccnt</code> 为当前有效事件数。</p><p>如下是启动时的数组处理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>ev_start</span><span class=p>(</span><span class=nf>EV_A_</span> <span class=p>(</span><span class=n>W</span><span class=p>)</span><span class=n>w</span><span class=p>,</span> <span class=o>++</span><span class=n>asynccnt</span><span class=p>);</span>  <span class=c1>// 将w-&gt;active设置为序号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nf>array_needsize</span><span class=p>(</span><span class=n>ev_async</span> <span class=o>*</span><span class=p>,</span> <span class=n>asyncs</span><span class=p>,</span> <span class=n>asyncmax</span><span class=p>,</span> <span class=n>asynccnt</span><span class=p>,</span> <span class=n>EMPTY2</span><span class=p>);</span> <span class=c1>// 判断空间是否足够
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>asyncs</span><span class=p>[</span><span class=n>asynccnt</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>w</span><span class=p>;</span>          <span class=c1>// 添加到数组中
</span></span></span></code></pre></div><p>停止时的处理流程如下，也就是将最后一个事件与 w 对应事件交换。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>active</span> <span class=o>=</span> <span class=nf>ev_active</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>asyncs</span><span class=p>[</span><span class=n>active</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>asyncs</span><span class=p>[</span><span class=o>--</span><span class=n>asynccnt</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=nf>ev_active</span><span class=p>(</span><span class=n>asyncs</span><span class=p>[</span><span class=n>active</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span> <span class=o>=</span> <span class=n>active</span><span class=p>;</span>
</span></span></code></pre></div><p>这里实际上会使用 pipe 将异步信号转换为文件的句柄操作，因为 pipe 写满会导致阻塞，所以在代码中有很大一部分时对触发事件的同步处理。</p><h1 id=杂项>杂项 <a href=#%e6%9d%82%e9%a1%b9 class=anchor aria-hidden=true>#</a></h1><h2 id=代码优化>代码优化 <a href=#%e4%bb%a3%e7%a0%81%e4%bc%98%e5%8c%96 class=anchor aria-hidden=true>#</a></h2><p>libev 可以通过很多宏进行调优，默认会通过 EV_FEATURES 宏定义一些特性，定义如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifndef EV_FEATURES
</span></span></span><span class=line><span class=cl><span class=cp># if defined __OPTIMIZE_SIZE__
</span></span></span><span class=line><span class=cl><span class=cp>#  define EV_FEATURES 0x7c  </span><span class=cm>/* 0111 1100 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp># else
</span></span></span><span class=line><span class=cl><span class=cp>#  define EV_FEATURES 0x7f  </span><span class=cm>/* 0111 1111 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp># endif
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define EV_FEATURE_CODE     ((EV_FEATURES) &amp;  1) </span><span class=cm>/* 0000 0001 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EV_FEATURE_DATA     ((EV_FEATURES) &amp;  2) </span><span class=cm>/* 0000 0010 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EV_FEATURE_CONFIG   ((EV_FEATURES) &amp;  4) </span><span class=cm>/* 0000 0100 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EV_FEATURE_API      ((EV_FEATURES) &amp;  8) </span><span class=cm>/* 0000 1000 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EV_FEATURE_WATCHERS ((EV_FEATURES) &amp; 16) </span><span class=cm>/* 0001 0000 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EV_FEATURE_BACKENDS ((EV_FEATURES) &amp; 32) </span><span class=cm>/* 0010 0000 */</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#define EV_FEATURE_OS       ((EV_FEATURES) &amp; 64) </span><span class=cm>/* 0100 0000 */</span><span class=cp>
</span></span></span></code></pre></div><h2 id=ev_feature_api>EV_FEATURE_API <a href=#ev_feature_api class=anchor aria-hidden=true>#</a></h2><p>用来做深度的定制化操作，例如在调用 <code>epoll_wait()</code> 之前可以设置回调函数，替换掉默认的 <code>ev_invoke_pending()</code> 函数，对循环调用次数做统计等等。</p><h2 id=内存分配>内存分配 <a href=#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d class=anchor aria-hidden=true>#</a></h2><p>实际上，在代码中，可以看到很多数组会通过 <code>array_needsize()</code> 函数分配内存，简单来说，为了防止频繁申请内存，每次都会尝试申请 <code>MALLOC_ROUND</code> 宏指定大小的内存，一般是 4K 。</p><p>如下是在 <code>ev_timer_start()</code> 函数中的使用方法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>array_needsize</span><span class=p>(</span><span class=n>ANHE</span><span class=p>,</span> <span class=n>timers</span><span class=p>,</span> <span class=n>timermax</span><span class=p>,</span> <span class=nf>ev_active</span> <span class=p>(</span><span class=n>w</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>EMPTY2</span><span class=p>);</span>
</span></span></code></pre></div><p>简单来说，<code>ANHE</code> 表示数组中的成员类型；<code>timers</code> 表示数组的基地址；<code>timermax</code> 表示当其值，因为可能会预分配一部分内存，所以在分配完成后，同时会将真正分配的内存数返回；<code>ev_active(w)+1</code> 表示需要申请的大小。</p><p>在分配内存时，默认会采用 <code>realloc()</code> 函数，如果想要自己定义，可以通过 <code>ev_set_allocator()</code> 函数进行设置。</p><h2 id=处理回调>处理回调 <a href=#%e5%a4%84%e7%90%86%e5%9b%9e%e8%b0%83 class=anchor aria-hidden=true>#</a></h2><p>触发的事件会通过 <code>ev_feed_event()</code> 函数将相关的事件保存到一个二维 pendings 数组中，也就是说该数组记录了所有已经触发的事件，其中第一个维度是优先级，而第二个维度是已经触发的事件。</p><pre tabindex=0><code>pendings[PRI][NUMS];
pendingmax[PRI]; 最大数组
pendingcnt[PRI]; 当前事件数
</code></pre><h1 id=参考>参考 <a href=#%e5%8f%82%e8%80%83 class=anchor aria-hidden=true>#</a></h1><p>源码可以从 <a href=http://freecode.com/projects/libev>freenode - libev</a> 上下载，不过最近的更新是 2011 年，也可以从 <a href=https://github.com/enki/libev>github</a> 上下载，或者下载 <a href=/reference/linux/libev-4.22.tar.bz2>本地保存版本 libev-4.22</a>；帮助文档可以参考 <a href=/reference/linux/libev.html>本地文档</a> 。</p><p>对于 python ，提供了相关的扩展 <a href=http://packages.python.org/pyev/>Python libev interface - pyev</a> 。</p><p>魅族内核团队的相关文章，一篇介绍内核如何实现信号处理，<a href=http://kernel.meizu.com/linux-signal.html>Linux Signal</a> 。</p></div></div></div></article><div class=related-posts><hr><div class="row justify-content-center"><div class=col><h2 class=section-title>相关阅读</h2></div></div><ul><li><a class=text-body href=/cn/blog/libev-basic-introduce/>事件驱动库 libev 使用详解</a></li><li><a class=text-body href=/cn/blog/ssh-golang-examples/>GoLang 实现 SSH 相关示例</a></li><li><a class=text-body href=/cn/blog/ssh-port-forwarding/>SSH 代理设置</a></li></ul></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class="order-first order-lg-last text-center"><ul class=list-inline><li class=list-inline-item><a href=/privacy-policy/>隐私声明</a></li></ul></div></div><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2024 GoHalo. All Rights Reserved.</div></div></div></footer></body></html>