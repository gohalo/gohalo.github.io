<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>博客 on</title><link>https://gohalo.github.io/cn/blog/</link><description>Recent content in 博客 on</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 12 Jan 2025 22:28:19 +0800</lastBuildDate><atom:link href="https://gohalo.github.io/cn/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust RPIT AFIT 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/rust-rpit/</link><pubDate>Sun, 12 Jan 2025 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-rpit/</guid><description/></item><item><title>Protobuf Rust 语言使用介绍</title><link>https://gohalo.github.io/cn/blog/protobuf-rust-usage/</link><pubDate>Thu, 21 Nov 2024 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-rust-usage/</guid><description>&lt;p>Prost 是一个用于序列化和反序列化 Google Protocol Buffers 协议的 Rust 库，支持消息嵌套、默认值、枚举类型等。&lt;/p></description></item><item><title>Rust 并行执行库 Rayon 详解</title><link>https://gohalo.github.io/cn/blog/rust-third-rayon/</link><pubDate>Sat, 09 Nov 2024 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-rayon/</guid><description/></item><item><title>Datafusion 使用简介</title><link>https://gohalo.github.io/cn/blog/warehouse-datafusion-introduce/</link><pubDate>Wed, 16 Oct 2024 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/warehouse-datafusion-introduce/</guid><description>基本上分成了 OLAP Batch Streaming
算子落盘 # 存在 spill_count 指标， spill_record_batches read_spill_as_stream
SQL # SQL 解析依赖 SQLParser 实现，在 datafusion::sql 中将 sqlparser 重新导出，有也就意味着如下两种使用方式相同。
use datafusion::sql::sqlparser::parser::ParserError; use sqlparser::parser::ParserError; 而 DataFusion 是在 SQLParser 基础上的定制化开发，可以根据场景配置不同的方言 Dialect，常见的如 MySQL、PostgreSQL 等。
Plan # LogicalPlan # 逻辑执行计划。
ExecutionPlan # 物理执行计划节点，支持流式、并行读取数据，包含了 Projection Filter Limit 算子，当执行 execute() 方法时，只是将物理执行计划生成 RecordBatchStream 算子，形成数据流算子树，当执行 collect() 操作时才开始真正的数据流动。
会通过 DefaultPhysicalPlanner 生成执行计划，也可以通过实现 PhysicalPlanner 特征扩展。最终会通过 create_physical_plan 方法将逻辑计划转换为物理计划，每个节点是 ExecutionPlan 类型。
执行计划树时，会从根节点开始执行 execute 方法，这里不会开始处理数据，而是将物理算子转换为 RecordBatchStream 类型，只有当执行类似 collect 时才会真正执行。
TableProvider # 用于自定义表或者数据源，其中核心的是 scan 函数</description></item><item><title>向量搜索简介</title><link>https://gohalo.github.io/cn/blog/database-vector-search/</link><pubDate>Sat, 21 Sep 2024 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-vector-search/</guid><description/></item><item><title>数据库 WAL 简介</title><link>https://gohalo.github.io/cn/blog/database-wal-introduce/</link><pubDate>Sat, 21 Sep 2024 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-wal-introduce/</guid><description>&lt;p>包括 BTree 和 LSMTree 的实现，原地更新会导致很多随机写，常规实现是通过 Write Ahead Log, WAL 顺序写入到日志文件中，然后后台更新数据，同时还支持容灾、故障恢复。&lt;/p></description></item><item><title>数据库事务简介</title><link>https://gohalo.github.io/cn/blog/database-transaction-basic-introduce/</link><pubDate>Sat, 21 Sep 2024 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-transaction-basic-introduce/</guid><description>简介 # 当前很多数据库的 ACID 特性会基于 MVCC Snapshot Isolation 来实现，这样读写不会相互阻塞，同时能够提供原子能力。另外，关于 MySQL 的可以参考 InnoDB 隔离级别 中的介绍。
ACID # 是 Atomic 原子性、Consistency 一致性、Isolation 隔离性、Durability 持久化的简写，如下简单整理相关基本概念。
Atomic: 要么全部生效 (Commit)，要么全部撤销 (Rollback)，不会出现中间态 &amp;gt; 日志管理 Redo 相关修改操作需要在提交前落盘 Undo 用于故障恢复以及事务回退 Consistency: 并发执行过程中，确保数据的合法性，满足完整性约束 &amp;gt; 业务层面保证，转账不会出现已经扣减但是未收到情况 &amp;gt; 各种约束，例如唯一性、外键、触发器等 Isolation: 确保并发事务是可串行化的，可见性和性能的均衡 &amp;gt; 并发控制，消除可能带来的异常，脏读、不可重复读、幻读等 通常会采用两阶段锁、MVCC/Snapshot、时间戳、乐观并发控制 &amp;gt; 隔离级别 未提交读 (Read Uncommitted) 已提交读 (Read Committed) 可重复读 (Repeatable Read) 可串行化 (Serializability) Snapshot (Snapshot Isolation) Durability: 保证已经提交数据不会丢失 &amp;gt; 缓冲区脏页刷新，可以是异步，同时考虑污染 &amp;gt; Checkpoint 机制，防止日志无限膨胀 &amp;gt; Redo/Undo 用于故障恢复 &amp;gt; 复制，可以是逻辑复制、物理复制，不同场景要求不同 MVCC # 自从发明了 Multi-Version Concurrency Control, MVCC 之后，几乎所有的数据库都开始抛弃 (部分抛弃) 性能较差的两阶段锁的并发控制，所以，后续兴起分布式系统几乎都采用 MVCC 的并发控制方案。</description></item><item><title>数据库分布式事务简介</title><link>https://gohalo.github.io/cn/blog/database-distributed-transaction/</link><pubDate>Sat, 21 Sep 2024 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-distributed-transaction/</guid><description>&lt;p>分布式事务与传统的单机事务要复杂很多，由此衍生出来多种算法，这里简单介绍。&lt;/p></description></item><item><title>本地缓存详解</title><link>https://gohalo.github.io/cn/blog/local-cache-introduce/</link><pubDate>Fri, 20 Sep 2024 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/local-cache-introduce/</guid><description/></item><item><title>ToyDB 简介</title><link>https://gohalo.github.io/cn/blog/database-toydb-introduce/</link><pubDate>Thu, 12 Sep 2024 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-toydb-introduce/</guid><description>&lt;p>一个 Rust 编写的分布式数据库实现，麻雀虽小五脏俱全。&lt;/p></description></item><item><title>Rust 高级语法之 PhantomData</title><link>https://gohalo.github.io/cn/blog/rust-advanced-phantomdata/</link><pubDate>Thu, 29 Aug 2024 23:45:55 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-phantomdata/</guid><description>&lt;p>这个名字很直接，幽灵数据，不过使用时经常会有些疑问。&lt;/p></description></item><item><title>Ray 源码解析</title><link>https://gohalo.github.io/cn/blog/ray-source-code/</link><pubDate>Fri, 16 Aug 2024 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ray-source-code/</guid><description/></item><item><title>Torch MNIST 使用示例</title><link>https://gohalo.github.io/cn/blog/pytorch-mnist/</link><pubDate>Fri, 16 Aug 2024 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/pytorch-mnist/</guid><description/></item><item><title>Hudi Schema Evolution 详解</title><link>https://gohalo.github.io/cn/blog/hudi-schema-evolution/</link><pubDate>Mon, 22 Jul 2024 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-schema-evolution/</guid><description/></item><item><title>Hudi 安装部署</title><link>https://gohalo.github.io/cn/blog/hudi-environment-prepare/</link><pubDate>Tue, 16 Jul 2024 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-environment-prepare/</guid><description>&lt;p>这里简单介绍如何部署 &lt;code>Spark&lt;/code> 相关的 &lt;code>Hudi&lt;/code> 环境。&lt;/p></description></item><item><title>Rust 调用 C 使用示例</title><link>https://gohalo.github.io/cn/blog/rust-ffi-rust-invoke-c/</link><pubDate>Mon, 24 Jun 2024 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-ffi-rust-invoke-c/</guid><description>&lt;p>简单介绍 Rust 调用 C 常用的示例代码。&lt;/p></description></item><item><title>C 调用 Rust 使用示例</title><link>https://gohalo.github.io/cn/blog/rust-ffi-c-invoke-rust/</link><pubDate>Thu, 20 Jun 2024 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-ffi-c-invoke-rust/</guid><description>&lt;p>整理 C 调用 Rust 时需要注意的事项。&lt;/p></description></item><item><title>Neovim 插件管理工具</title><link>https://gohalo.github.io/cn/blog/neovim-plugins-management/</link><pubDate>Wed, 12 Jun 2024 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-plugins-management/</guid><description>&lt;p>历史曾经推荐使用 &lt;a href="https://gohalo.github.io/cn/blog/neovim-plugins-management-legacy-packer/">Packer.nvim&lt;/a> 作为插件管理工具，不过该插件从 2023.08 开始不再维护，所以就有了 &lt;a href="https://github.com/folke/lazy.nvim">lazy.nvim&lt;/a> 插件。&lt;/p>
&lt;p>这里详细介绍其使用。&lt;/p></description></item><item><title>Hudi 元数据表详解</title><link>https://gohalo.github.io/cn/blog/hudi-metadata-table/</link><pubDate>Thu, 23 May 2024 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-metadata-table/</guid><description/></item><item><title>Hudi 示例样板</title><link>https://gohalo.github.io/cn/blog/hudi-some-examples/</link><pubDate>Mon, 20 May 2024 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-some-examples/</guid><description/></item><item><title>Rust 设计模式</title><link>https://gohalo.github.io/cn/blog/rust-design-pattern/</link><pubDate>Fri, 19 Apr 2024 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-design-pattern/</guid><description/></item><item><title>Rust Pin Unpin 使用介绍</title><link>https://gohalo.github.io/cn/blog/rust-pin-introduce/</link><pubDate>Mon, 26 Feb 2024 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-pin-introduce/</guid><description/></item><item><title>人工神经网络</title><link>https://gohalo.github.io/cn/blog/artificial-neural-network/</link><pubDate>Tue, 13 Feb 2024 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/artificial-neural-network/</guid><description/></item><item><title>Rust Java JNI 调用简介</title><link>https://gohalo.github.io/cn/blog/rust-java-binding-jni/</link><pubDate>Fri, 26 Jan 2024 20:39:48 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-java-binding-jni/</guid><description>&lt;p>JNI 是 Java 提供的一套与其它语言相互调用的标准，主要是 C 语言，所以，从理论上只要支持 C ABI 的语言都可以和 Java 语言相互调用，而 Rust 就是其中之一。&lt;/p></description></item><item><title>数据库优化器之即时编译</title><link>https://gohalo.github.io/cn/blog/database-jit-introduce/</link><pubDate>Sat, 30 Dec 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-jit-introduce/</guid><description>&lt;p>代码生成或者说即时编译在数据库中使用比较多，常见的包括了用户输入的表达式、查询、存储过程等，会将其编译成二进制代码再执行，相比解释执行的方式运行效率要高很多。&lt;/p></description></item><item><title>SIMD Intrinsic 指令详细介绍</title><link>https://gohalo.github.io/cn/blog/simd-intrinsic-introduce/</link><pubDate>Sun, 24 Dec 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-intrinsic-introduce/</guid><description>&lt;p>不同的平台、CPU 支持的 SIMD 指令不同，这里简单整理使用过程中常用的技巧。&lt;/p></description></item><item><title>Rust Tokio 简介</title><link>https://gohalo.github.io/cn/blog/rust-async-tokio-introduce/</link><pubDate>Sat, 16 Dec 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-async-tokio-introduce/</guid><description>&lt;p>Tokio 是当前 Rust 异步编程使用最广泛的多线程解决方案，除了异步运行态，还包括了各种周边的实现，例如 HTTP 实现 hyper、gRPC 实现 tonic、trace 实现 tracing 等等。&lt;/p></description></item><item><title>损失函数 - 交叉熵详解</title><link>https://gohalo.github.io/cn/blog/loss-function-cross-entropy/</link><pubDate>Wed, 13 Dec 2023 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/loss-function-cross-entropy/</guid><description>&lt;p>Cross Entropy 交叉熵是深度学习中经常使用的概念，用作损失函数评估目标和预测值之间的差异。&lt;/p></description></item><item><title>分布式系统时间处理</title><link>https://gohalo.github.io/cn/blog/database-clock-introduce/</link><pubDate>Sat, 09 Dec 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-clock-introduce/</guid><description>&lt;p>在分布式系统中，需要解决事务的时序问题，包括 MVCC、ACID 等，当前常用的有 Logical Clock、True Time、Hybrid Logic Clock、Timestamp Oracle 等。&lt;/p>
&lt;p>这里简单介绍其基本概念。&lt;/p></description></item><item><title>流处理简介</title><link>https://gohalo.github.io/cn/blog/database-streaming-introduce/</link><pubDate>Sat, 09 Dec 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-streaming-introduce/</guid><description>&lt;p>当前流处理使用最广泛的还是 Flink、Spark Streaming，只是两者基于历史演进策略不同，实现的流处理细节也略有区别。&lt;/p></description></item><item><title>LLM 使用简介</title><link>https://gohalo.github.io/cn/blog/llm-from-scratch/</link><pubDate>Fri, 08 Dec 2023 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llm-from-scratch/</guid><description>&lt;p>主要是 Karpathy 的相关实现，通过简单的示例、资源介绍 LLM 相关的概念。&lt;/p></description></item><item><title>LLM 本地运行</title><link>https://gohalo.github.io/cn/blog/llm-local-running/</link><pubDate>Fri, 08 Dec 2023 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llm-local-running/</guid><description/></item><item><title>SIMD 多平台动态转发</title><link>https://gohalo.github.io/cn/blog/simd-multi-version/</link><pubDate>Sun, 12 Nov 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-multi-version/</guid><description>&lt;p>对于 SIMD 优化来说，不同平台支持不同的指令，如果使用宏定义，那么必然会导致多个发行二进制版本，可以通过如下方式实现单个二进制发行包。&lt;/p></description></item><item><title>数据库优化之子查询</title><link>https://gohalo.github.io/cn/blog/database-optimize-subquery/</link><pubDate>Fri, 10 Nov 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-optimize-subquery/</guid><description>&lt;p>子查询允许用户直接引用外层查询的列，有很强的语义表达能力，所以被广泛使用，例如在 TPCH 的 22 个查询中，有 13 个查询都包含子查询。&lt;/p>
&lt;p>这也是 SQL 优化器中的难点之一，通常需要进行去关联化操作，将其改写为类似 SemiJoin 这种更高效的算子。&lt;/p></description></item><item><title>GoLang Promethus 监控系统</title><link>https://gohalo.github.io/cn/blog/golang-monitor-prometheus/</link><pubDate>Wed, 08 Nov 2023 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-monitor-prometheus/</guid><description>&lt;p>这里通过 Prometheus 提供的客户端库添加相关的指标，并通过 HTTP 暴露相关指标。&lt;/p></description></item><item><title>SSH 登陆失败常见问题排查</title><link>https://gohalo.github.io/cn/blog/ssh-login-failed/</link><pubDate>Wed, 08 Nov 2023 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-login-failed/</guid><description/></item><item><title>Temporal 微服务架构</title><link>https://gohalo.github.io/cn/blog/golang-framework-temporal/</link><pubDate>Wed, 08 Nov 2023 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-framework-temporal/</guid><description/></item><item><title>LLVM 即时编译</title><link>https://gohalo.github.io/cn/blog/llvm-jit-introduce/</link><pubDate>Sun, 29 Oct 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llvm-jit-introduce/</guid><description>&lt;p>当前大部分的一些三方编译器都会依赖于 LLVM 框架，除了经常使用的 clang 编译器之外，还可以作为一个框架使用。&lt;/p></description></item><item><title>数据库优化器之 Join 顺序</title><link>https://gohalo.github.io/cn/blog/database-join-order-introduce/</link><pubDate>Sun, 29 Oct 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-join-order-introduce/</guid><description>&lt;p>多表 Join 处理在现实业务中很常见，通常其执行效率和 Join 的顺序息息相关。&lt;/p></description></item><item><title>数据库优化器之统计信息</title><link>https://gohalo.github.io/cn/blog/database-statistics-introduce/</link><pubDate>Sun, 29 Oct 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-statistics-introduce/</guid><description/></item><item><title>数据库执行器初探</title><link>https://gohalo.github.io/cn/blog/database-execute-engine-introduce/</link><pubDate>Sun, 29 Oct 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-execute-engine-introduce/</guid><description/></item><item><title>Rust 迭代器的生命周期管理</title><link>https://gohalo.github.io/cn/blog/rust-advanced-iterator-lifetime/</link><pubDate>Thu, 26 Oct 2023 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-iterator-lifetime/</guid><description>&lt;p>很多场景下可以通过迭代器简化代码编写。&lt;/p></description></item><item><title>Rust 序列化、反序列化实现</title><link>https://gohalo.github.io/cn/blog/rust-third-serde/</link><pubDate>Mon, 23 Oct 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-serde/</guid><description>&lt;p>Serde 是序列化和反序列化 Rust 数据结构的库，支持 JSON、BSON、YAML 等多种常用格式，并且可以自定义序列化和反序列化方式。&lt;/p></description></item><item><title>数据库优化器初探</title><link>https://gohalo.github.io/cn/blog/database-optimizer-introduce/</link><pubDate>Sun, 22 Oct 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-optimizer-introduce/</guid><description>&lt;p>查询优化器是数据库中比较难懂的部分，其它的还有事务处理，尤其是融合了隔离级别以及不同的锁、MVCC 实现之后。&lt;/p></description></item><item><title>OpenTelemetry 标准详解</title><link>https://gohalo.github.io/cn/blog/monitor-opentelemetry-introduce/</link><pubDate>Sat, 21 Oct 2023 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/monitor-opentelemetry-introduce/</guid><description>&lt;p>OpenTelemetry, OTel 是一个中立开源的可观测性框架，用于仪表化、生成、收集和导出诸如跟踪、度量、日志等遥测数据。&lt;/p></description></item><item><title>Rust Trait 详解</title><link>https://gohalo.github.io/cn/blog/rust-advanced-syntax-trait/</link><pubDate>Mon, 16 Oct 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-syntax-trait/</guid><description>&lt;p>Rust 中的 Trait 有点像其它语言的接口，不过实际上略有不同。&lt;/p></description></item><item><title>Rust 宏编程详解</title><link>https://gohalo.github.io/cn/blog/rust-advanced-syntax-macro/</link><pubDate>Mon, 16 Oct 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-syntax-macro/</guid><description>&lt;p>也可以称为元数据编程，&lt;/p></description></item><item><title>SIMD 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/simd-basic-concept-introduce/</link><pubDate>Tue, 03 Oct 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-basic-concept-introduce/</guid><description/></item><item><title>ClickHouse 使用详解</title><link>https://gohalo.github.io/cn/blog/clickhouse-basic-introduce/</link><pubDate>Fri, 29 Sep 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/clickhouse-basic-introduce/</guid><description/></item><item><title>ClickHouse 问题排查调优技巧</title><link>https://gohalo.github.io/cn/blog/clickhouse-debug-tunning/</link><pubDate>Fri, 29 Sep 2023 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/clickhouse-debug-tunning/</guid><description/></item><item><title>TPCH 标准测试集</title><link>https://gohalo.github.io/cn/blog/benchmark-tpch-introduce/</link><pubDate>Sat, 23 Sep 2023 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/benchmark-tpch-introduce/</guid><description>&lt;p>由事务处理委员会提供的基准测试集。&lt;/p></description></item><item><title>StarRocks Catalog 基本介绍</title><link>https://gohalo.github.io/cn/blog/starrocks-catalog-introduce/</link><pubDate>Thu, 21 Sep 2023 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/starrocks-catalog-introduce/</guid><description/></item><item><title>StarRocks DDL 基本介绍</title><link>https://gohalo.github.io/cn/blog/starrocks-ddl-introduce/</link><pubDate>Thu, 21 Sep 2023 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/starrocks-ddl-introduce/</guid><description/></item><item><title>Spark 示例代码</title><link>https://gohalo.github.io/cn/blog/spark-example-code/</link><pubDate>Wed, 20 Sep 2023 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/spark-example-code/</guid><description>&lt;p>整理一些常用的 Spark 相关示例代码。&lt;/p></description></item><item><title>Rust 异步流式编程详解</title><link>https://gohalo.github.io/cn/blog/rust-async-stream-program/</link><pubDate>Sat, 16 Sep 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-async-stream-program/</guid><description/></item><item><title>Rust 命令行参数解析库</title><link>https://gohalo.github.io/cn/blog/rust-third-clap/</link><pubDate>Sun, 10 Sep 2023 18:39:45 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-clap/</guid><description>&lt;p>当使用命令行时，参数管理通常比较复杂，尤其是随着子参数增多，通过 clap 三方库可以很方便进行管理。&lt;/p></description></item><item><title>Hudi 常用命令</title><link>https://gohalo.github.io/cn/blog/hudi-cheatsheet/</link><pubDate>Tue, 22 Aug 2023 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-cheatsheet/</guid><description/></item><item><title>Linux Perf 工具使用介绍</title><link>https://gohalo.github.io/cn/blog/performance-perf-introduce/</link><pubDate>Tue, 01 Aug 2023 22:19:04 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/performance-perf-introduce/</guid><description>&lt;p>Perf 全名是 Performance Event，在 Linux 2.6.31 以后内建的系统性能分析工具，由内核社区维护和发展，不仅可以用于应用程序的性能统计分析，也可以应用于内核代码的性能统计和分析。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>Google Trace Viewer</title><link>https://gohalo.github.io/cn/blog/google-chrome-trace/</link><pubDate>Fri, 21 Jul 2023 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/google-chrome-trace/</guid><description>&lt;p>在 Chrome 中的 &lt;a href="chrome://tracing/">chrome://tracing&lt;/a> 提供了简单有效的 Trace 可视化方案，作为 Performance Profile、Timeline Tracing 都很方便。&lt;/p></description></item><item><title>RDP 通讯协议详解</title><link>https://gohalo.github.io/cn/blog/rdp-windows-protocol/</link><pubDate>Sun, 16 Jul 2023 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rdp-windows-protocol/</guid><description>&lt;p>有过 Windows 使用经验的人对于远程桌面（Remote Desktop Protocol ，RDP）一定不会陌生。RDP 是由微软公司开发的一种专有协议，它为用户提供了通过网络连接到另一台计算机的图形界面。在使用上，用户需要使用 RDP 客户端软件，而在远程另一台计算机则需要运行 RDP 服务器软件。&lt;/p></description></item><item><title>Wireshark 工具使用</title><link>https://gohalo.github.io/cn/blog/linux-network-tools-wireshark/</link><pubDate>Sun, 16 Jul 2023 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-tools-wireshark/</guid><description>&lt;p>Wireshark (之前被称为 Ethereal) 是一个网络封包分析软件，接收网络封包，并尽可能显示出最为详细的网络报文资料，这里详细介绍其使用方式。&lt;/p></description></item><item><title>通过 Wireshark 解析 TLS 报文</title><link>https://gohalo.github.io/cn/blog/wireshark-decrypt-tls-ssl/</link><pubDate>Sun, 16 Jul 2023 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/wireshark-decrypt-tls-ssl/</guid><description>&lt;p>SSL/TLS 是目前使用最广泛的安全通讯协议，最常见的 HTTPS 也是建立在该协议之上的，尤其是 TLSv1.3 版本更新之后，其性能、安全性得以有效提升，在带来安全性的同时，在开发阶段很难对通讯协议进行调试。&lt;/p>
&lt;p>通过 Wireshark 可以分析绝大部分的 TCP/IP 协议流量，包括了 TLS 协议，可以用来分析协议的工作方式或者排查问题。&lt;/p></description></item><item><title>Rust 生命周期管理</title><link>https://gohalo.github.io/cn/blog/rust-life-time/</link><pubDate>Thu, 15 Jun 2023 20:02:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-life-time/</guid><description>&lt;p>所有权 Ownership 是 Rust 的核心功能之一，使得 Rust 无需垃圾回收，却仍然可以保证内存安全。&lt;/p></description></item><item><title>Linux Trace 工具使用介绍</title><link>https://gohalo.github.io/cn/blog/performance-trace-introduce/</link><pubDate>Sun, 21 May 2023 22:19:04 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/performance-trace-introduce/</guid><description>&lt;p>这部分内容是内核 hacker 的最爱，能够支持 &lt;code>tracepoints&lt;/code>、&lt;code>kprobes&lt;/code>、&lt;code>uprobes&lt;/code> 等实现,提供了跟踪常见的一些能力，包括事件追踪, 可选择过滤器和参数; 事件计数和时间采样，内核概览；基于函数的路径追踪等。&lt;/p></description></item><item><title>SIMD 编译器优化</title><link>https://gohalo.github.io/cn/blog/simd-compiler-optimize/</link><pubDate>Sun, 23 Apr 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-compiler-optimize/</guid><description/></item><item><title>K8S Controller 使用详解</title><link>https://gohalo.github.io/cn/blog/kubernets-crd-controller-details/</link><pubDate>Tue, 28 Mar 2023 21:33:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-crd-controller-details/</guid><description>简介 # 在构建自定义的 Operator 时会涉及到如下几种组件：
client-go 底层用于与 K8S API 进行交互，支持资源的 CRUD 操作，包含了 ClientSet、DynamicClient、RESTClient 三种。 controller-runtime 封装了控制器的处理框架，底层会调用 client-go 库。 kubebuilder 可以很方便渲染出 Controller 整个框架，该框架使用的就是 controller-runtime 模块。 operator-sdk 同样基于 controller-runtime 实现，而且同时使用了 kubebuilder 来构建 Go 项目。 简单来说，当前 Controller 的编写包含了 OperatorSDK、Kubebuilder、ClientGo 三种方式，前两者提供了更加实用的封装，而 ClientGo 相对来说要简单很多，这里简单介绍 Kubebuilder 的使用方式。
Kubebuilder # Kubebuilder 由 K8S Special Interest Group, SIG API Machinery 拥有和维护，用于帮助开发者创建 CRD 并生成 Controller 脚手架，包含了如下的组件：
Client 封装了对资源的操作，修改会直接访问 APIServer ，而查询则会访问本地 Cache 信息。 Cache 负责生成 SharedInformer，会监听 GVK 下的 GVR 变化，然后触发 Controller 的 Reconcile 逻辑。 Manager 管理协调多个 Controller，提供共有依赖以及基础服务(例如保活)，负责初始化 Controller、Cache、Client 的工作。 Finzlizers 用于处理资源的预删除逻辑，保障资源被删除后能够从 Cache 中读取到，清理相关的其它资源。 Builder 构造器，提供了一系列配置接口，可以通过链式条用进行组装，最终为 Reconciler 生成相应的 Controller 对象。 示例 # 可以直接从 GitHub Release 上下载对应的二进制文件。</description></item><item><title>Rust 并发编程简介</title><link>https://gohalo.github.io/cn/blog/rust-concurrency-introduce/</link><pubDate>Sun, 26 Feb 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-concurrency-introduce/</guid><description>&lt;p>除了常规的多线程并发之外，同时还会介绍一些与 Rust 相关的并发编程技巧。&lt;/p></description></item><item><title>Rust 异步编程简介</title><link>https://gohalo.github.io/cn/blog/rust-async-program-introduce/</link><pubDate>Sun, 26 Feb 2023 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-async-program-introduce/</guid><description>&lt;p>异步编程是一个并发编程模型，当前大部分语言都已经支持，只是实现方式略有不同。&lt;/p></description></item><item><title>CPU 硬件介绍</title><link>https://gohalo.github.io/cn/blog/concurrency-hardware-introduce/</link><pubDate>Sun, 19 Feb 2023 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-hardware-introduce/</guid><description>&lt;p>CPU 的发展因为受制于制造工艺和成本限制，CPU 的频率、内存的访问速度都没有太多质的突破，但是两者直接的访问处理速度相差越来越大。所以，目前在 CPU 和内存之间包含了多级缓存，用来提高 CPU 的处理速度。&lt;/p>
&lt;p>现在的多数 CPU 都集成了几层的 Cache ，为了维持与主存的关系，经常能够看到 2-ways 4-ways Cache，它是什么意思呢？Cache 和内存地址是怎么对应起来的呢？&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>SIMD 常用示例</title><link>https://gohalo.github.io/cn/blog/simd-some-examples/</link><pubDate>Thu, 12 Jan 2023 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/simd-some-examples/</guid><description/></item><item><title>PyTorch 使用简介</title><link>https://gohalo.github.io/cn/blog/python-pytorch-package-introduce/</link><pubDate>Tue, 13 Dec 2022 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-pytorch-package-introduce/</guid><description/></item><item><title>损失函数</title><link>https://gohalo.github.io/cn/blog/machine-learning-algorithms-loss-functions/</link><pubDate>Tue, 13 Dec 2022 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/machine-learning-algorithms-loss-functions/</guid><description>均方差 # 如下梳理常用的一些实现。
Mean Absolute Error, MAE 平均绝对误差。
$$ \frac{1}{n} \sum \limits_{i=1}^{n} \lvert y_i – \hat{y}_i \rvert $$
Mean Square Error, MSE 均方误差。真实值与预测值差值的平方然后求和平均，常用作线性回归的损失函数。
$$\frac{1}{n} \sum_{i=1}^{n}(y_i - \hat y_i)^2$$
Root Mean Square Error, RMSE 均方根误差。衡量观测值与真实值之间的偏差，常用来作为机器学习模型预测结果衡量的标准。
$$ \sqrt{ \frac{1}{n} \sum_{i=1}^{n}(y_i - \hat y_i)^2 }$$
Root Mean Squared Log Error, RMSLE 均方根对数误差。
$$\sqrt{ \frac{1}{n} \sum_{i=1}^{n} (log(\hat{y}_i + 1) – log(y_i + 1))^2 }$$
实际上，很多的比赛采用的是 RMSLE ，例如 Kaggle ，对于异常值来说，RMSE 会快速的增加，而 RMSLE 因为取了对数就不会。</description></item><item><title>梯度下降算法</title><link>https://gohalo.github.io/cn/blog/math-gradient-descent-optimize-method/</link><pubDate>Tue, 13 Dec 2022 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-gradient-descent-optimize-method/</guid><description>梯度下降法 # 所谓的梯度实际上就是多元函数的 导数，对于 $n$ 元函数 $f(x_1,x_2, \cdots, x_n)$ 的梯度是一个长度为 $n$ 的向量，其中向量中第 $k$ 个元素为函数 $f$ 对 $x_k$ 的偏导数。
$$ \nabla f(x_1, x_2, \cdots, x_n) = \left( \frac{\partial f}{\partial x_1}, \frac{\partial f}{\partial x_2}, \cdots, \frac{\partial f}{\partial x_n} \right) $$
从几何意义上来说，这个向量的指向是函数变化最快的方向。
import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def Rosenbrock(x, y): return (1 - x) ** 2 + 100 * (y - x ** 2) ** 2 step = 0.</description></item><item><title>CRD 使用详解</title><link>https://gohalo.github.io/cn/blog/kubernets-crd-sample/</link><pubDate>Mon, 12 Dec 2022 19:17:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-crd-sample/</guid><description>&lt;p>在 K8S 1.7 开始支持 Custom Resource Define, CRD 自定义资源，这样可以动态注册到集群中，就与其它资源类似可以通过 kubectl 来管理该资源了。注意，此时的 CRD 仅仅是资源的定义而已，需要一个 Controller 去监听 CRD 的各种事件来添加自定义的业务逻辑。&lt;/p></description></item><item><title>Tokio 源码解析</title><link>https://gohalo.github.io/cn/blog/rust-async-tokio-source-code/</link><pubDate>Sat, 10 Dec 2022 20:02:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-async-tokio-source-code/</guid><description>Runtime # 在使用时需要提供异步运行时环境，创建的任务会在这个环境里运行，可以选择单线程或者多线程，而且可以同时存在。对于 IO 类型任务建议使用多线程，但是多线程间的通信会变的复杂，从而加重了线程间切换的开销，可能导致某些场景下性能可能降低。
用户态的协程实现是基于协作时的调度策略，详细可以参考 Making the Tokio scheduler 10x faster 中的介绍。
在代码内部，会通过 scheduler::Handle::current() 获取当前 Handle 实现，相关代码调用逻辑如下。
// runtime/scheduler/mod.rs use crate::runtime::context; impl Handle { pub(crate) fn current() -&amp;gt; Handle { match context::with_current(Clone::clone) { Ok(handle) =&amp;gt; handle, Err(e) =&amp;gt; panic!(&amp;#34;{}&amp;#34;, e), } } } // runtime/context/current.rs pub(crate) fn with_current&amp;lt;F, R&amp;gt;(f: F) -&amp;gt; Result&amp;lt;R, TryCurrentError&amp;gt; where F: FnOnce(&amp;amp;scheduler::Handle) -&amp;gt; R, { match CONTEXT.try_with(|ctx| ctx.current.handle.borrow().as_ref().map(f)) { Ok(Some(ret)) =&amp;gt; Ok(ret), Ok(None) =&amp;gt; Err(TryCurrentError::new_no_context()), Err(_access_error) =&amp;gt; Err(TryCurrentError::new_thread_local_destroyed()), } } 其中 CONTEXT 是一个 TLS 变量，会在 runtime.</description></item><item><title>RCU 详解</title><link>https://gohalo.github.io/cn/blog/concurrency-rcu-introduce/</link><pubDate>Mon, 05 Dec 2022 19:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-rcu-introduce/</guid><description>&lt;p>RCU 的本质是用空间换时间，是对读写锁的一种优化加强。&lt;/p></description></item><item><title>原子操作使用介绍</title><link>https://gohalo.github.io/cn/blog/concurrency-atomic-operation/</link><pubDate>Mon, 05 Dec 2022 19:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-atomic-operation/</guid><description>&lt;p>实际上目前大部分的语言都提供了原子操作的能力，包括了 GoLang、JAVA、C/C++、Rust 等等，当然这些能力大部分都需要硬件平台的支撑。&lt;/p>
&lt;p>这里简单介绍 GCC 以及 C/C++ 中提供的一些原子操作指令。&lt;/p></description></item><item><title>Python 调用动态库</title><link>https://gohalo.github.io/cn/blog/python-dynamic-library-usage/</link><pubDate>Sun, 27 Nov 2022 18:39:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-dynamic-library-usage/</guid><description>&lt;p>通过 Python 可以直接调用动态库，通常有两种方式，使用 ctypes 进行封装，还可以对 C/C++ 库直接封装成动态库，这样可以直接使用。&lt;/p>
&lt;p>这里不再介绍 ctypes 的相关使用，详细介绍下如何直接使用动态库。&lt;/p></description></item><item><title>CRC 循环校验详解</title><link>https://gohalo.github.io/cn/blog/crc-basic-introduce/</link><pubDate>Sun, 20 Nov 2022 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/crc-basic-introduce/</guid><description>&lt;p>Cyclic Redundancy Check, CRC 循环冗余校验，通常用于网络、文件等校验，校验码的长度固定，而且从检错的正确率与速度成本之间比较好的平衡，使其称为当前最常见的数据校验方式。&lt;/p></description></item><item><title>Snapshot Isolation 详解</title><link>https://gohalo.github.io/cn/blog/database-snapshot-isolation-introduce/</link><pubDate>Sun, 20 Nov 2022 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-snapshot-isolation-introduce/</guid><description>&lt;p>对于数据库领域来说，这应该是最基础的概念了，谈到事务隔离级别。&lt;/p></description></item><item><title>分布式锁详解</title><link>https://gohalo.github.io/cn/blog/database-distributed-locking/</link><pubDate>Sun, 20 Nov 2022 20:52:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-distributed-locking/</guid><description/></item><item><title>K8S 本地集群 Kind 使用介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-minimal-kind-cluster/</link><pubDate>Sat, 12 Nov 2022 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-minimal-kind-cluster/</guid><description>&lt;p>kind 是 Kubernetes in Docker 的简写，是一个使用 Docker 容器作为 Nodes，在本地创建和运行 Kubernetes 群集的工具，适用于在本机创建 Kubernetes 群集环境进行开发和测试，而且支持离线部署。&lt;/p></description></item><item><title>Arrow 内存列式数据存储格式</title><link>https://gohalo.github.io/cn/blog/warehouse-format-arrow/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/warehouse-format-arrow/</guid><description>&lt;p>定义了内存布局格式，从而允许在不同的系统之间高效地共享数据，通过减少不必要的序列化和反序列化成本，从而提高不同系统间传递数据效率。&lt;/p></description></item><item><title>AVRO 元数据格式</title><link>https://gohalo.github.io/cn/blog/warehouse-format-avro/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/warehouse-format-avro/</guid><description>&lt;p>这是一个数据序列化系统。&lt;/p></description></item><item><title>Flight 通讯协议</title><link>https://gohalo.github.io/cn/blog/warehouse-protocol-flight/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/warehouse-protocol-flight/</guid><description>&lt;p>最初 Flight 专注于 Arrow 这种列式存储格式，通过 gRPC 作底层传输优化。&lt;/p></description></item><item><title>Rust Chrono</title><link>https://gohalo.github.io/cn/blog/rust-third-chrono/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-chrono/</guid><description/></item><item><title>Rust 常用日志三方库介绍</title><link>https://gohalo.github.io/cn/blog/rust-third-log/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-log/</guid><description>&lt;p>类似于 JAVA 中的 &lt;code>slf4j&lt;/code> 库，Rust 中对应了 &lt;code>log&lt;/code> 库，其提供了基本的标准接口，由官方进行维护，这里简单介绍。&lt;/p></description></item><item><title>Thrift 简介</title><link>https://gohalo.github.io/cn/blog/thrift-format-introduce/</link><pubDate>Wed, 09 Nov 2022 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/thrift-format-introduce/</guid><description/></item><item><title>Cargo 包管理工具</title><link>https://gohalo.github.io/cn/blog/rust-cargo-package-management/</link><pubDate>Wed, 26 Oct 2022 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-cargo-package-management/</guid><description>&lt;p>Rust 提供了 Cargo 的构建系统和软件包管理器，可以用来构建代码、下载库或依赖项等等，在安装 Rust 时会同时安装 Cargo 相关的程序。&lt;/p>
&lt;p>这里详细介绍 Cargo 的使用方式。&lt;/p></description></item><item><title>GoLang 常用模块</title><link>https://gohalo.github.io/cn/blog/golang-basic-module/</link><pubDate>Wed, 26 Oct 2022 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-module/</guid><description>&lt;p>简单介绍常见的模块，例如 fmt、unsafe、signal、container 等。&lt;/p></description></item><item><title>线程本地变量介绍</title><link>https://gohalo.github.io/cn/blog/concurrency-thread-local-storage/</link><pubDate>Fri, 21 Oct 2022 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-thread-local-storage/</guid><description>在多线程程序中，所有线程共享程序中的变量，对于全局变量，所有线程都可以访问修改，如果希望么个线程单独使用，那么就需要 Thread Local Storage, TLS 了。
简言之，表面是一个全局变量，所有线程都可以使用它，而实际实现时，它的值在每一个线程中又是单独存储的。
示例 # TSD 的使用方法简单介绍如下：
声明一个类型为 pthread_key_t 类型的全局变量，后续所有的操作都会用到该变量； 在创建线程前调用 pthread_key_create() 创建该变量，入参为上面的变量以及清理函数(为 NULL 时调用默认的清理函数)； 启动线程，在不同的线程中分别通过 pthread_setspcific() 和 pthread_getspecific() 函数设置以及获取变量。 使用的函数声明如下。
int pthread_key_create(pthread_key_t *key, void (*destructor)(void*)); int pthread_setspecific(pthread_key_t key, const void *value); void *pthread_getspecific(pthread_key_t key); 如下是一个简单示例。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;pthread.h&amp;gt; pthread_key_t key; struct test_struct { // 用于测试的结构 int i; float k; }; void *child1(void *arg) { struct test_struct struct_data; struct_data.i = 10; struct_data.</description></item><item><title>Rust Iced 使用详解</title><link>https://gohalo.github.io/cn/blog/rust-third-iced/</link><pubDate>Wed, 19 Oct 2022 23:49:58 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-iced/</guid><description/></item><item><title>git 开源代码提交流程</title><link>https://gohalo.github.io/cn/blog/git-tips-opensource-workflow/</link><pubDate>Wed, 12 Oct 2022 23:05:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-tips-opensource-workflow/</guid><description>&lt;p>这里以 GitHub 上的工作流程为例，讲解如何维护、提交代码。&lt;/p></description></item><item><title>原子操作内存序介绍</title><link>https://gohalo.github.io/cn/blog/concurrency-atomic-memory-order/</link><pubDate>Sat, 01 Oct 2022 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-atomic-memory-order/</guid><description>&lt;p>当多个线程同时访问一个变量时，会导致数据竞争问题，会导致结果未定义。而且从实现来说，即时是一条语句，从硬件层面仍不能保证读写操作是原子的，例如变量在寄存器中，修改后才写入内存。&lt;/p>
&lt;p>通常使用的是 Mutex 操作，不过常用的还有原子操作。&lt;/p></description></item><item><title>Rust 高级语法</title><link>https://gohalo.github.io/cn/blog/rust-advanced-syntax/</link><pubDate>Thu, 29 Sep 2022 23:45:55 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-syntax/</guid><description>&lt;p>这里简单介绍基本常用的语法。&lt;/p></description></item><item><title>Hudi 基本介绍</title><link>https://gohalo.github.io/cn/blog/hudi-basic-introduce/</link><pubDate>Wed, 21 Sep 2022 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-basic-introduce/</guid><description>&lt;p>Hadoop Updates and Incrementals, Hudi 是一个 Uber 开源的 Data Lakes 的解决方案。&lt;/p></description></item><item><title>Kerberos 基本介绍</title><link>https://gohalo.github.io/cn/blog/kerberos-basic-introduce/</link><pubDate>Wed, 21 Sep 2022 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kerberos-basic-introduce/</guid><description>&lt;p>通常用于身份认证。&lt;/p></description></item><item><title>RocksDB 基本介绍</title><link>https://gohalo.github.io/cn/blog/rocksdb-basic-introduce/</link><pubDate>Wed, 21 Sep 2022 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rocksdb-basic-introduce/</guid><description>&lt;p>通过 CPP 开发的嵌入式 KV 数据库，源自 LevelDB 但是进行了极大的优化。&lt;/p></description></item><item><title>RocksDB 相关工具使用</title><link>https://gohalo.github.io/cn/blog/rocksdb-some-tools/</link><pubDate>Wed, 21 Sep 2022 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rocksdb-some-tools/</guid><description>&lt;p>简单整理部分常用的工具。&lt;/p></description></item><item><title>BoltDB 数据库详细介绍</title><link>https://gohalo.github.io/cn/blog/golang-boltdb-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-boltdb-introduce/</guid><description>&lt;p>ETCD 后端存储采用的是 BBolt 存储引擎，其前身是 BoltDB ，这是一款 golang 实现的嵌入式 KV 存储引擎，参考的是 LMDB，支持事务、ACID、MVCC、ZeroCopy、BTree等特性。&lt;/p></description></item><item><title>CrossTerm 使用详解</title><link>https://gohalo.github.io/cn/blog/rust-third-crossterm/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-third-crossterm/</guid><description/></item><item><title>Flink 使用介绍</title><link>https://gohalo.github.io/cn/blog/flink-basic-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/flink-basic-introduce/</guid><description>&lt;p>分布式计算框架，可以对有界 (批) 和无界 (流) 数据进行处理。&lt;/p></description></item><item><title>Hudi Streamer 数据导入示例 TPCH</title><link>https://gohalo.github.io/cn/blog/hudi-streamer-example-tpch/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-streamer-example-tpch/</guid><description/></item><item><title>Hudi Streamer 简介</title><link>https://gohalo.github.io/cn/blog/hudi-streamer-usage/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-streamer-usage/</guid><description>&lt;p>提供了实时的数据倒入方式，其源端可以是 Kafka 或者文件。&lt;/p></description></item><item><title>LMDB 详细介绍</title><link>https://gohalo.github.io/cn/blog/lmdb-database-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lmdb-database-introduce/</guid><description>&lt;p>LMDB 是 OpenLDAP 项目开发的嵌入式存储引擎，通过 mmap 实现，提供了 B+Tree 索引，并提供了 Multi Version Concurrent Control, MVCC 功能。&lt;/p>
&lt;p>这里简单介绍其使用方法，以及相关的实现。&lt;/p></description></item><item><title>Perisistend Data Structure 详解</title><link>https://gohalo.github.io/cn/blog/concurrency-persistent-data-structure/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-persistent-data-structure/</guid><description/></item><item><title>Rust 基本语法</title><link>https://gohalo.github.io/cn/blog/rust-basic-syntax/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-basic-syntax/</guid><description>&lt;p>这里简单介绍基本常用的语法。&lt;/p></description></item><item><title>Rust 字符串详解</title><link>https://gohalo.github.io/cn/blog/rust-string-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-string-introduce/</guid><description>&lt;p>很多语言中的字符串非常简单，但 Rust 与常规的语言有所区别。&lt;/p></description></item><item><title>Rust 常用特征详解</title><link>https://gohalo.github.io/cn/blog/rust-advanced-some-trait/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-some-trait/</guid><description/></item><item><title>Rust 智能指针</title><link>https://gohalo.github.io/cn/blog/rust-smart-pointer-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-smart-pointer-introduce/</guid><description>&lt;p>Rust 中有所有权的概念，常见的赋值、函数传参、函数返回值等场景，都可能会发生所有权的转移，而某些场景下，只是想使用一下，所以就有了引用。&lt;/p></description></item><item><title>Rust 类型转换</title><link>https://gohalo.github.io/cn/blog/rust-type-conversion-cast/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-type-conversion-cast/</guid><description/></item><item><title>Spark Native 加速</title><link>https://gohalo.github.io/cn/blog/spark-native-execution-engine/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/spark-native-execution-engine/</guid><description/></item><item><title>Spark 使用介绍</title><link>https://gohalo.github.io/cn/blog/spark-basic-introduce/</link><pubDate>Mon, 19 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/spark-basic-introduce/</guid><description>&lt;p>开源的集群运算框架，与 Hadoop 在执行 MapReduce 需要落盘不同，Spark 的数据会尽量在内存中进行计算。&lt;/p></description></item><item><title>Rust 中的错误处理</title><link>https://gohalo.github.io/cn/blog/rust-handle-error/</link><pubDate>Fri, 16 Sep 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-handle-error/</guid><description>&lt;p>Rust 中将错误分成了正常的业务错误 Resut 以及崩溃 panic 处理。&lt;/p></description></item><item><title>NeoVim 基本环境配置</title><link>https://gohalo.github.io/cn/blog/neovim-basic-usage/</link><pubDate>Fri, 02 Sep 2022 21:14:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-basic-usage/</guid><description>&lt;p>最开始 NeoVim 是 Vim 的功能增强，但是随着不断开发，功能越来越完善，而且已经分道扬镳，现在已经成为了更加接近现代的开发工具，尤其是随着 &lt;a href="https://neovim.io/charter/">Vision&lt;/a> 计划的开发，也包括了其子项目 &lt;a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter&lt;/a>。&lt;/p></description></item><item><title>Linux 用户管理</title><link>https://gohalo.github.io/cn/blog/linux-user-account-management/</link><pubDate>Fri, 26 Aug 2022 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-user-account-management/</guid><description>&lt;p>Linux 是一个多用户多任务的分时操作系统，可以允许多个用户同时登陆，通过账户管理，可以方便系统管理员对用户进行跟踪，控制系统资源的访问，也可以帮助用户组织文件，并为用户提供安全性保护。&lt;/p>
&lt;p>对于普通用户来说，每个账号都拥有一个惟一的用户名以及口令，只有在输入正确之后才可以进入系统以及主目录。&lt;/p>
&lt;p>这里详细介绍与用户管理相关的内容。&lt;/p></description></item><item><title>使用 C API 执行 Linux 用户相关操作</title><link>https://gohalo.github.io/cn/blog/linux-user-manage-c-api/</link><pubDate>Fri, 26 Aug 2022 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-user-manage-c-api/</guid><description>&lt;p>通过 glibc 提供的 API 可以获取用户信息、切换用户等操作，在使用的时候有很多注意事项，例如可能会遇到即使用户存在仍读取失败，密码的密文是如何生成的等等。&lt;/p>
&lt;p>这里会进行简单介绍一些常见的问题以及如何规避。&lt;/p></description></item><item><title>Ray 计算框架详解</title><link>https://gohalo.github.io/cn/blog/ray-compute-engine/</link><pubDate>Tue, 16 Aug 2022 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ray-compute-engine/</guid><description/></item><item><title>HDFS 基本介绍</title><link>https://gohalo.github.io/cn/blog/hdfs-basic-introduce/</link><pubDate>Thu, 21 Jul 2022 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hdfs-basic-introduce/</guid><description>&lt;p>Hadoop Distributed File System, HDFS&lt;/p></description></item><item><title>Kafka 常用命令</title><link>https://gohalo.github.io/cn/blog/kafka-commands-cheatsheet/</link><pubDate>Wed, 22 Jun 2022 21:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kafka-commands-cheatsheet/</guid><description>&lt;p>整理 Kafka 常用的命令，可以用于快速查询。&lt;/p></description></item><item><title>Hive 基本介绍</title><link>https://gohalo.github.io/cn/blog/hive-basic-introduce/</link><pubDate>Tue, 21 Jun 2022 22:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hive-basic-introduce/</guid><description>&lt;p>Hive 是由 Facebook 开发建立在 Hadoop 之上的数据仓库，初衷是为了减少复杂 MR 程序的编写工作，其本身不存储和处理数据，依赖 HDFS 存储数据和 MR 处理数据，有类 SQL 语言的 HiveQL，其不完全支持 SQL 标准，例如不支持更新、索引、事务，子查询和连接操作也有很多限制。&lt;/p></description></item><item><title>GoLang 国际化</title><link>https://gohalo.github.io/cn/blog/golang-i18n-introduce/</link><pubDate>Fri, 17 Jun 2022 23:19:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-i18n-introduce/</guid><description>简介 # 有两个容易混淆的概念：A) 本地化 L10n，将软件翻译为本地语言的过程，通常是翻译人员的职责；B) 国际化 i18n，使得软件可以被本地化，通常是开发人员的职责。
代码中有很多需要与人交互的内容，一般需要做一些国际化的处理，通常步骤如下：
从源码中获取需要翻译的字符串。 翻译字符串，有很多的平台支持，甚至有些是免费的。 应用已经翻译的字符串，可以是通过数据库、配置文件方式读取，也可以编译成二进制甚至生成代码。 使用已经翻译字符，包括了 Web 使用 Accept-Language 以及主机上的 LANGUAGE 环境变量。 实际上已经有个 https://golang.org/x/text 代码包支持，官方声明如下。
a repository of text-related packages related to internationalization (i18n) and localization (l10n) 。
其中的 message 库主要用于上述的步骤三，以类似 fmt 的接口来输出已经翻译的字符串，如下是简单示例。
package main import ( &amp;#34;golang.org/x/text/message&amp;#34; &amp;#34;golang.org/x/text/language&amp;#34; ) func main() { p := message.NewPrinter(language.BritishEnglish) p.Printf(&amp;#34;There are %v flowers in our garden.\n&amp;#34;, 1500) p = message.NewPrinter(language.Greek) p.Printf(&amp;#34;There are %v flowers in our garden.</description></item><item><title>draw.io 一款开源免费流程图绘制软件</title><link>https://gohalo.github.io/cn/blog/draw-tools-online/</link><pubDate>Sun, 12 Jun 2022 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/draw-tools-online/</guid><description>&lt;p>这是一款免费开源的图形绘制软件，支持丰富的模板，可以直接嵌入现有图片，包括 SVG 格式，还可以自定义图形，甚至编辑数学表达式。&lt;/p>
&lt;p>这里简单整理常见用法。&lt;/p></description></item><item><title>Bootstrap 使用介绍</title><link>https://gohalo.github.io/cn/blog/web-bootstrap-introduce/</link><pubDate>Fri, 20 May 2022 20:37:53 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-bootstrap-introduce/</guid><description>&lt;p>Bootstrap 来自 Twitter，基于 HTML、CSS、JavaScript，是目前最受欢迎的前端框架，它简洁灵活，使得 Web 开发更加快捷。&lt;/p>
&lt;p>在这里我们看下 bootstrap 以及一些 html、css 等相关的内容。&lt;/p></description></item><item><title>Socks 代理协议详解</title><link>https://gohalo.github.io/cn/blog/network-proxy-socks/</link><pubDate>Thu, 28 Apr 2022 21:39:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-proxy-socks/</guid><description>&lt;p>Socks 是一个代理协议，这里会对协议进行详细介绍，同时会介绍其使用场景。&lt;/p></description></item><item><title>Telnet 协议详解</title><link>https://gohalo.github.io/cn/blog/network-telnet-introduce/</link><pubDate>Thu, 28 Apr 2022 21:39:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-telnet-introduce/</guid><description>&lt;p>Telnet 是一个简单的远程终端协议，通过 TCP 连接登录到远端服务器，相比之前需要通过硬件终端连接服务器的方式要简单很多，但是因为没有加密容易导致信息泄漏，建议使用 SSH 而非 Telnet 协议。&lt;/p>
&lt;p>协议内部使用 Network Virtual Terminal, NVT，也就是所谓的虚拟网络终端，然后两端根据各自字符集等进行转换。&lt;/p></description></item><item><title>版本管理</title><link>https://gohalo.github.io/cn/blog/version-control-concept/</link><pubDate>Thu, 28 Apr 2022 21:39:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/version-control-concept/</guid><description>&lt;p>介绍一些版本相关的基本概念。&lt;/p></description></item><item><title>SCSS 基本语法介绍</title><link>https://gohalo.github.io/cn/blog/web-scss-introduce/</link><pubDate>Tue, 19 Apr 2022 22:17:13 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-scss-introduce/</guid><description>&lt;p>SCSS 是 SASS3 引入的新语法，其语法完全兼容 CSS3，同时继承了 SASS 的强大功能。&lt;/p></description></item><item><title>Gossip 协议详解</title><link>https://gohalo.github.io/cn/blog/gossip-distribute-protocol/</link><pubDate>Sat, 16 Apr 2022 21:18:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gossip-distribute-protocol/</guid><description/></item><item><title>Rust 模块文件配置</title><link>https://gohalo.github.io/cn/blog/rust-module-introduce/</link><pubDate>Sat, 16 Apr 2022 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-module-introduce/</guid><description/></item><item><title>Rust 测试</title><link>https://gohalo.github.io/cn/blog/rust-testing-introduce/</link><pubDate>Sat, 16 Apr 2022 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-testing-introduce/</guid><description>&lt;p>Rust 支持常规的单元测试、集成测试等，甚至还支持文档测试。&lt;/p></description></item><item><title>Rust 模式匹配详解</title><link>https://gohalo.github.io/cn/blog/rust-syntax-match/</link><pubDate>Tue, 29 Mar 2022 23:05:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-syntax-match/</guid><description>&lt;p>在 Rust 中没有 &lt;code>switch&lt;/code> 语句，但是提供了匹配器 &lt;code>matcher&lt;/code>，相比其它语言中的 &lt;code>switch&lt;/code> 要更强大。&lt;/p></description></item><item><title>K8S 包管理工具 Helm 介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-helm-introduce/</link><pubDate>Mon, 21 Mar 2022 19:50:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-helm-introduce/</guid><description>&lt;p>Helm 是 K8S 中的包管理器，可以非常方便的完成应用的安装、卸载、升级等，Chart 是 Helm 的打包格式，其内部包含了一组相关的 K8S 资源。&lt;/p></description></item><item><title>Linux Core 文件详细介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-core-introduce/</link><pubDate>Thu, 17 Mar 2022 22:19:04 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-core-introduce/</guid><description>Core 文件又称为 Core Dump 文件，对于线上的服务而言，也就意味着进程异常；而且，如果进程占用内存很大，但是 dump 到磁盘上，也会花很长时间。
当然，Core 虽然会终止掉当前进程，但是也会保留下第一手的现场数据，包括了进程被终止时内存、CPU寄存器等信息，可以供后续开发人员进行调试。
接下来，看看 MySQL 中 Core 文件的处理。
简介 # 在开发一个程序时，程序可能会在运行过程中异常终止或者崩溃，这时操作系统就会把程序挂掉时的内存状态记录下来，并写入一个叫做 Core 的文件中，这种行为就叫做 Core Dump 操作，通过这个文件可以方便的进行调试。
在使用半导体作为内存的材料前，人类使用的是线圈作为内存的材料，线圈叫做 Core，用线圈制作的内存就是 Core Memory。
除了内存信息之外，还有些关键的程序运行状态也会同时 dump 下来，例如寄存器信息 (包括程序指针、栈指针等)、内存管理信息、其他处理器和操作系统状态和信息；而这些信息对于编程人员诊断和调试程序是非常有帮助。
A core dump is the recorded state of the working memory of a computer program at a specific time, generally when the program has terminated abnormally (crashed). In practice, other key pieces of program state are usually dumped at the same time, including the processor registers, which may include the program counter and stack pointer, memory management information, and other processor and operating system flags and information.</description></item><item><title>Rust 常用标准库介绍</title><link>https://gohalo.github.io/cn/blog/rust-standard-library/</link><pubDate>Sat, 19 Feb 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-standard-library/</guid><description/></item><item><title>Rust 安装部署以及版本管理</title><link>https://gohalo.github.io/cn/blog/rust-basic-introduce/</link><pubDate>Wed, 26 Jan 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-basic-introduce/</guid><description/></item><item><title>字符编码详解</title><link>https://gohalo.github.io/cn/blog/charsets-encoding/</link><pubDate>Wed, 26 Jan 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/charsets-encoding/</guid><description>&lt;p>是不是还分不清什么是字符集，什么是编码，两者到底有什么区别？ 什么是 GB2312、GB18030、BIG5？ Unicode 和 UTF-8、UTF-16、UTF-32 到底什么关系？ BMP、UCS、emoji 又是什么？ 为什么会出现乱码？&lt;/p>
&lt;p>OK，接下来我们介绍一下他们之间剪不断理还乱的关系 &amp;hellip; &amp;hellip;&lt;/p></description></item><item><title>git 换行符配置</title><link>https://gohalo.github.io/cn/blog/git-tips-crlr/</link><pubDate>Wed, 12 Jan 2022 23:05:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-tips-crlr/</guid><description>&lt;p>Windows 和 Linux/Mac 平台上的换行符不同，通过 git 可以自动进行设置。&lt;/p></description></item><item><title>Bash 使用常见错误以及规避措施</title><link>https://gohalo.github.io/cn/blog/bash-pitfalls/</link><pubDate>Tue, 04 Jan 2022 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-pitfalls/</guid><description>&lt;p>简单介绍下 Linux 中 Bash 编程所需要注意的内容，以及常见的规避措施。&lt;/p></description></item><item><title>K8S 配置上下文介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-config-context/</link><pubDate>Wed, 22 Dec 2021 19:40:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-config-context/</guid><description>&lt;p>通常在开发过程中需要维护多个集群，例如研发、测试、生产等，为了方便管理可以通过 kubeconfig 维护集群、用户、命名空间、身份认证相关的信息，用来快速切换访问的集群。&lt;/p></description></item><item><title>BCC eBPF 使用</title><link>https://gohalo.github.io/cn/blog/linux-ebpf-bcc-tools/</link><pubDate>Wed, 01 Dec 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ebpf-bcc-tools/</guid><description>&lt;p>正常来说，如果要使用 eBPF 提供的能力，需要完成 &amp;ldquo;编写BPF代码-编译成字节码-注入内核-获取结果-展示&amp;rdquo; 这一整套流程，而且会非常复杂。&lt;/p>
&lt;p>而 bcc 是通过 Python 编写的一个 eBPF 工具集，使得上述的 整个过程更加便捷。&lt;/p></description></item><item><title>eBPF 基本功能介绍</title><link>https://gohalo.github.io/cn/blog/linux-ebpf-basic-introduce/</link><pubDate>Wed, 01 Dec 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ebpf-basic-introduce/</guid><description>&lt;p>Berkeley Packet Filter, BPF 提供了强大的网络包过滤规则，可以确定应该检查哪些流量、忽略哪些流量等，而内核近几年发展的 Extended BPF, eBPF 实际上将应用范围，处理效率进行了更新。&lt;/p>
&lt;p>eBPF 是 Linux 内核近几年最为引人注目的特性之一，通过一个内核内置的字节码虚拟机，完成数据包过滤、调用栈跟踪、耗时统计、热点分析等等高级功能。&lt;/p></description></item><item><title>Parquet 文件格式详解</title><link>https://gohalo.github.io/cn/blog/warehouse-format-parquet/</link><pubDate>Wed, 01 Dec 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/warehouse-format-parquet/</guid><description/></item><item><title>SVG 使用详解</title><link>https://gohalo.github.io/cn/blog/web-scalable-vector-graphics-svg/</link><pubDate>Wed, 01 Dec 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-scalable-vector-graphics-svg/</guid><description/></item><item><title>火焰图使用详解</title><link>https://gohalo.github.io/cn/blog/performance-flamegraph-introduce/</link><pubDate>Wed, 01 Dec 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/performance-flamegraph-introduce/</guid><description>&lt;p>通过火焰图可以有效观察资源消耗在那，不重要的会自然淡化甚至消失，而真正重要的代码路径则会突显，从而提供恰到好处的信息，不多也不少。&lt;/p></description></item><item><title>NeoVim LSP 使用介绍</title><link>https://gohalo.github.io/cn/blog/neovim-lsp-usage/</link><pubDate>Tue, 30 Nov 2021 18:39:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-lsp-usage/</guid><description>&lt;p>在 NeoVim 内部已经提供了 Language Server Protocol, LSP 客户端，服务端就需要按照自己的需求进行安装了，目前已经有一些高效的配置插件，可以很简单完成基本环境的配置。&lt;/p></description></item><item><title>GoLang SSH 源码解析</title><link>https://gohalo.github.io/cn/blog/ssh-golang-details/</link><pubDate>Sat, 27 Nov 2021 20:18:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-golang-details/</guid><description>&lt;p>之前的文章已经介绍了简单的示例，这里对部分常用的源码进行解析。&lt;/p></description></item><item><title>NeoVIM 常用命令整理</title><link>https://gohalo.github.io/cn/blog/neovim-cheatsheet/</link><pubDate>Sun, 31 Oct 2021 18:39:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-cheatsheet/</guid><description>&lt;p>整理使用 NeoVIM 时常用的技巧。&lt;/p></description></item><item><title>K8S 存储</title><link>https://gohalo.github.io/cn/blog/kubernets-storage/</link><pubDate>Fri, 22 Oct 2021 19:43:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-storage/</guid><description/></item><item><title>通过 go-client 访问 K8S 集群</title><link>https://gohalo.github.io/cn/blog/kubernets-source-code-go-client/</link><pubDate>Tue, 12 Oct 2021 23:11:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-source-code-go-client/</guid><description>&lt;p>&lt;code>client-go&lt;/code> 是用 GoLang 编写的官方编程式交互客户端库，提供对 Kubernetes API Server 服务的交互访问，也是 Kubernetes 的核心处理框架，其源码中已经集成了 &lt;code>client-go&lt;/code> 的源码，无需单独下载。&lt;/p></description></item><item><title>ORC 文件格式详解</title><link>https://gohalo.github.io/cn/blog/warehouse-format-orc/</link><pubDate>Tue, 05 Oct 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/warehouse-format-orc/</guid><description/></item><item><title>Docker 主机映射</title><link>https://gohalo.github.io/cn/blog/docker-hosts-mapping/</link><pubDate>Wed, 22 Sep 2021 21:30:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-hosts-mapping/</guid><description>&lt;p>配置服务器时，经常会修改域名映射，Linux 中就是 /etc/hosts 文件，不过容器每次启动都会覆盖。&lt;/p></description></item><item><title>Docker 使用简介</title><link>https://gohalo.github.io/cn/blog/docker-basic-introduce/</link><pubDate>Mon, 20 Sep 2021 23:10:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-basic-introduce/</guid><description>&lt;p>从 Docker 1.11 开始，Docker 容器运行已经不是简单的通过 Docker Daemon 启动，而是集成了 containerd、runC 等多个组件，在 Docker 服务启动之后，可以看到系统上启动了 dockerd、containerd 等进程。&lt;/p>
&lt;p>这里简单介绍一些与 Docker 相关的基本概念。&lt;/p></description></item><item><title>Rust 与不同语言调用</title><link>https://gohalo.github.io/cn/blog/rust-external-ffi/</link><pubDate>Sat, 18 Sep 2021 20:02:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-external-ffi/</guid><description>&lt;p>简单介绍 Rust 和 C 之间的相互代码调用。&lt;/p></description></item><item><title>Rust 内存管理</title><link>https://gohalo.github.io/cn/blog/rust-memory-manage/</link><pubDate>Sat, 18 Sep 2021 20:02:47 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-memory-manage/</guid><description>&lt;p>Rust 中的内存管理跟其它语言基本类似，提供了浅复制和深复制两种方式，使用时略有区别，这里简单介绍。&lt;/p></description></item><item><title>Debian 系统配置</title><link>https://gohalo.github.io/cn/blog/linux-debian-distribution/</link><pubDate>Sun, 12 Sep 2021 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-debian-distribution/</guid><description>&lt;p>Debian 是最早最老牌的 Linux 发行版之一，最大优点是极其稳定快速，是 Ubuntu、Linux Mint 和 elementary OS 等 Linux 操作系统的母板，同时拥有强大的 APT 包管理机制和丰富的软件源，可以方便地安装和平滑升级软件和系统，省去很多编译安装和版本升级的麻烦.&lt;/p>
&lt;p>其具有完善的包管理系统，它的每个组件和应用程序都内置在系统中安装的软件包中。&lt;/p></description></item><item><title>K8S ConfigMap 使用介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-components-configmap/</link><pubDate>Fri, 10 Sep 2021 20:18:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-components-configmap/</guid><description>&lt;p>在 K8S 中可以通过 configmap 保存应用的配置，这样就将配置和运行代码分开了。&lt;/p></description></item><item><title>Hugo 常用命令</title><link>https://gohalo.github.io/cn/blog/hugo-cheatsheet/</link><pubDate>Wed, 01 Sep 2021 23:10:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hugo-cheatsheet/</guid><description>整理 Hugo 常用的命令或者使用方式。
常用命令 # ----- 在开发模式下启动服务 hugo server --buildDrafts --bind=0.0.0.0 --port=38785 ----- 正式发布之前检查网站是否正常 hugo server -e production --bind=0.0.0.0 --port=38785 ----- 根据模板新建文章 hugo new blog/my-first-post/index.md ----- 启动页面压缩，或者配置文件中指定minify=true hugo --minify -d public 最佳实践 # 目录 # 支持选中某个 section 之后显示部分标签，默认不会显示，例如如下示例中默认不会显示 归档 标签 目录，当选中了包括 博客 之后才会显示这三个。
[[main]] name = &amp;#34;博客&amp;#34; url = &amp;#34;/blog/&amp;#34; weight = 20 [[main]] name = &amp;#34;归档&amp;#34; url = &amp;#34;/blog/archives/&amp;#34; weight = 20 [main.params] section = &amp;#34;blog&amp;#34; [[main]] name = &amp;#34;标签&amp;#34; url = &amp;#34;/blog/tags/&amp;#34; weight = 20 [main.</description></item><item><title>Java 常用工具详解</title><link>https://gohalo.github.io/cn/blog/java-tools-introduce/</link><pubDate>Sun, 29 Aug 2021 20:38:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/java-tools-introduce/</guid><description>&lt;p>Java 安装包中除了 JVM 虚拟机之外，还提供了一些常用的命令行，这里简单介绍常用的命令。&lt;/p></description></item><item><title>gogs 使用简介</title><link>https://gohalo.github.io/cn/blog/git-gogs-introduce/</link><pubDate>Thu, 26 Aug 2021 21:19:45 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-gogs-introduce/</guid><description>&lt;p>Gogs 的功能类似于 GitHub 或者 GitLab ，不过相比来说是一款极易搭建的 Git 服务，其目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务，通过 Go 语言开发，使得 Gogs 能够通过独立二进制分发，支持平台包括了 Linux、Mac OS、Windows 以及 ARM 。&lt;/p></description></item><item><title>Containerd 介绍</title><link>https://gohalo.github.io/cn/blog/docker-containerd-introduce/</link><pubDate>Sun, 22 Aug 2021 21:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-containerd-introduce/</guid><description>&lt;p>早在 K8S 1.7 时，Containerd 已经作为运行时替换 Docker 了，只是大部分时候因为熟悉 Docker 会默认使用 docker-shim ，而在 1.24 版本起就彻底替换为了 Containerd 运行时。&lt;/p>
&lt;p>这里简单介绍使用方式。&lt;/p></description></item><item><title>Python 通过 Paramiko 访问 SSH 服务</title><link>https://gohalo.github.io/cn/blog/ssh-python-paramiko-examples/</link><pubDate>Thu, 12 Aug 2021 20:28:54 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-python-paramiko-examples/</guid><description>&lt;p>Paramiko 实现了 SSH2 协议，用于与远程机器建立经过认证和加密后的安全连接，与 SSL 不同的是，SSH 不需要权威机构签署的分层证书，采用分布式的方式管理。&lt;/p></description></item><item><title>CSS 概念介绍</title><link>https://gohalo.github.io/cn/blog/web-css-introduce/</link><pubDate>Sun, 01 Aug 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-css-introduce/</guid><description>&lt;p>Cascading Style Sheets, CSS 层叠样式表，定义了如何显示 HTML 中的元素，为了方便管理，通常会将样式表单独保存在 CSS 文件中，利用 CSS 可以很方便控制网页的样式和布局，会大大提升网页开发效率。&lt;/p>
&lt;p>这里简单整理相关的概念。&lt;/p></description></item><item><title>Webs 安全配置</title><link>https://gohalo.github.io/cn/blog/web-security-introduce/</link><pubDate>Sun, 01 Aug 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-security-introduce/</guid><description/></item><item><title>自动控制 PID 算法详细使用</title><link>https://gohalo.github.io/cn/blog/automatic-control-pid-details/</link><pubDate>Sun, 01 Aug 2021 10:29:33 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/automatic-control-pid-details/</guid><description>&lt;p>Proportional Integral Derivative, PID 控制是最早发展起来的控制策略之一，由于其算法简单、鲁棒性好和可靠性高，被广泛应用于工业过程控制。&lt;/p>
&lt;p>这里详细介绍实际使用时使用问题。&lt;/p></description></item><item><title>SASS 基本用法介绍</title><link>https://gohalo.github.io/cn/blog/web-sass-introduce/</link><pubDate>Mon, 26 Jul 2021 21:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-sass-introduce/</guid><description>&lt;p>通过 CSS 可以用来开发网页样式，不过它没有变量、条件语句，只是单纯的描述，写起来很费事，所以，就有人开始为 CSS 加入编程的元素，也就是预处理器。&lt;/p>
&lt;p>使用时通过专门的编程语言进行网页设计，然后再编译成正常的 CSS 文件，最常见的包括了 SASS、LESS 等。&lt;/p></description></item><item><title>Docker 镜像分析工具 Dive 简介</title><link>https://gohalo.github.io/cn/blog/docker-image-layers-analyze/</link><pubDate>Wed, 21 Jul 2021 22:18:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-image-layers-analyze/</guid><description>&lt;p>Docker 的容器镜像是一层层叠加的，可以通过 &lt;code>docker inspect&lt;/code> 命令查看镜像中的 meta 信息，或者通过 &lt;code>docker history&lt;/code> 了解镜像的构建历史，不过相对来说不够清晰。&lt;/p>
&lt;p>这里介绍一个很好用的工具 Dive 。&lt;/p></description></item><item><title>RFB 通讯协议详解</title><link>https://gohalo.github.io/cn/blog/vnc-rbf-protocol/</link><pubDate>Fri, 16 Jul 2021 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vnc-rbf-protocol/</guid><description>&lt;p>VNC 是一套实现远程网络操控的软件，通常用于界面操作。&lt;/p></description></item><item><title>Neovim 常用插件介绍</title><link>https://gohalo.github.io/cn/blog/neovim-basic-plugins-introduce/</link><pubDate>Sat, 26 Jun 2021 21:34:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-basic-plugins-introduce/</guid><description>&lt;p>这里会列举常用的一些 NeoVIM 插件。&lt;/p></description></item><item><title>SQL 与关系代数</title><link>https://gohalo.github.io/cn/blog/database-sql-relational-algebra/</link><pubDate>Sat, 12 Jun 2021 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-sql-relational-algebra/</guid><description/></item><item><title>数据库质量体系构建</title><link>https://gohalo.github.io/cn/blog/database-testing-chaos/</link><pubDate>Sat, 12 Jun 2021 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/database-testing-chaos/</guid><description>&lt;p>这里介绍数据库相关的测试，包括了基准、分布式、混沌工程等。&lt;/p></description></item><item><title>树状数组详解</title><link>https://gohalo.github.io/cn/blog/binary-indexed-tree/</link><pubDate>Sun, 23 May 2021 17:30:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/binary-indexed-tree/</guid><description>&lt;p>树状数组 Binary Indexed Tree 或以作者名字命名为 Fenwick Tree，最早由 Peter M. Fenwick 在 1994 年发表的 &lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8917">A New Data Structure for Cumulative Frequency Tables&lt;/a>，起初是为了解决 Cumulative Frequency 的计算，现在也用于高效计算数列的前缀和、区间和。&lt;/p>
&lt;p>这里详细介绍其原理以及实现方式。&lt;/p></description></item><item><title>MySQL 日志相关</title><link>https://gohalo.github.io/cn/blog/mysql-log/</link><pubDate>Wed, 19 May 2021 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-log/</guid><description>&lt;p>MySQL 中的日志主要包括了：错误日志、查询日志、慢查询日志、事务日志、二进制日志，在此，介绍下一些常见的配置，以及 BinLog 相关内容。&lt;/p></description></item><item><title>K8S 简单安装部署服务</title><link>https://gohalo.github.io/cn/blog/kubernets-simple-install/</link><pubDate>Tue, 04 May 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-simple-install/</guid><description>&lt;p>现在很多的 K8S 部署是通过容器安装的，这里介绍如何在物理机上独立部署，这也是最简单的方式。&lt;/p></description></item><item><title>MySQL 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/mysql-basic-introduce/</link><pubDate>Fri, 30 Apr 2021 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-basic-introduce/</guid><description>&lt;p>在此主要介绍下与数据库相关的一些操作，其中有一部分是与 MySQL 相关的功能。&lt;/p></description></item><item><title>Curl 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-curl/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-curl/</guid><description>&lt;p>常用的 curl 相关命令整理。&lt;/p></description></item><item><title>Netcat 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-netcat/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-netcat/</guid><description>&lt;p>常用的 netcat 相关命令整理。&lt;/p></description></item><item><title>Web 权限管理介绍</title><link>https://gohalo.github.io/cn/blog/web-access-control-introduce/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-access-control-introduce/</guid><description/></item><item><title>Wget 命令使用简介</title><link>https://gohalo.github.io/cn/blog/linux-network-command-wget/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-wget/</guid><description>&lt;p>常用的 wget 相关命令整理。&lt;/p></description></item><item><title>使用 Hugo 制作静态博客</title><link>https://gohalo.github.io/cn/blog/hugo-static-site/</link><pubDate>Thu, 29 Apr 2021 21:15:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hugo-static-site/</guid><description>&lt;p>Hugo 采用开源的 goldmark 作为 markdown 的解析器，兼容 GitHub-Flavored Markdown 标准规范，很多的静态网站都是使用的Hugo，例如 K8S 的主页，这里介绍常见的使用技巧。&lt;/p></description></item><item><title>HTML 介绍</title><link>https://gohalo.github.io/cn/blog/web-html-introduce/</link><pubDate>Mon, 12 Apr 2021 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-html-introduce/</guid><description>&lt;p>简单介绍常用的语法。&lt;/p></description></item><item><title>Python 打包详解</title><link>https://gohalo.github.io/cn/blog/python-package-distribute/</link><pubDate>Sat, 03 Apr 2021 20:49:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-package-distribute/</guid><description>&lt;p>之前介绍了如何通过 &lt;code>pip&lt;/code> 安装包，主要是以用户的角度介绍，这里则从开发角度介绍如何打包、分发。&lt;/p></description></item><item><title>Kubernets 网络示例</title><link>https://gohalo.github.io/cn/blog/kubernets-examples-nginx/</link><pubDate>Fri, 19 Mar 2021 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-examples-nginx/</guid><description>&lt;p>这里以 Nginx 为例，介绍几种常见的网络模型。&lt;/p></description></item><item><title>K8S Ingress 详细介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-components-ingress/</link><pubDate>Wed, 10 Mar 2021 23:19:41 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-components-ingress/</guid><description/></item><item><title>K8S 权限管理介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-access-control-introduce/</link><pubDate>Tue, 02 Mar 2021 23:19:41 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-access-control-introduce/</guid><description/></item><item><title>K8S Kustomize 命令介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-commands-kustomize-usage/</link><pubDate>Tue, 23 Feb 2021 23:19:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-commands-kustomize-usage/</guid><description>&lt;p>这是 K8S 的原生配置管理，以无模板方式来定制应用的配置，以 Base+Overlay 的方式生成应用最终部署时所需的描述文件。&lt;/p></description></item><item><title>Casbin 使用详细介绍</title><link>https://gohalo.github.io/cn/blog/casbin-access-control/</link><pubDate>Sun, 14 Feb 2021 22:39:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/casbin-access-control/</guid><description>&lt;p>Casbin 是一个强大的、高效的开源访问控制框架，其权限管理机制支持多种访问控制模型，注意，其只负责权限控制，没有用户管理的实现。&lt;/p></description></item><item><title>K8S Patch 命令介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-commands-patch-usage/</link><pubDate>Fri, 05 Feb 2021 23:19:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-commands-patch-usage/</guid><description>&lt;p>通过 patch 命令可以对集群中的资源进行部分更新，也就是以补丁 (Patch) 方式修改、更新某资源的字段，相对于 apply 命令来说，无需提供完整的资源文件，只需要提供更新的内容即可。&lt;/p></description></item><item><title>Java 常用技巧</title><link>https://gohalo.github.io/cn/blog/java-some-tips/</link><pubDate>Tue, 26 Jan 2021 20:39:48 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/java-some-tips/</guid><description>&lt;p>这里总结一些常用的技巧。&lt;/p></description></item><item><title>Rust PyO3 使用</title><link>https://gohalo.github.io/cn/blog/rust-python-binding-pyo3/</link><pubDate>Tue, 26 Jan 2021 20:39:48 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-python-binding-pyo3/</guid><description>&lt;p>Python 有强于 Bash 的语法检查，但是，不适合一些高性能的场景，所以，很多时候会作为胶水语言使用。而且，由于 CPython 作为事实标准，使得其兼容 C/C++ 要容易的多，所以，通常高性能场景下会通过 C/C++ 进行重构。&lt;/p>
&lt;p>这里介绍 Python 如何调用 Rust 的实现。&lt;/p></description></item><item><title>TypeScript 语法简介</title><link>https://gohalo.github.io/cn/blog/web-typescript-basic-syntax/</link><pubDate>Fri, 15 Jan 2021 19:20:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-typescript-basic-syntax/</guid><description/></item><item><title>YAML 配置格式</title><link>https://gohalo.github.io/cn/blog/yaml-format-standard/</link><pubDate>Sun, 10 Jan 2021 23:15:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/yaml-format-standard/</guid><description>&lt;p>YAML 是一种可读性高的数据标记语言，通常用于配置文件，可存放一些复杂的数据类型，例如列表、字典等。&lt;/p></description></item><item><title>K8S 常用命令</title><link>https://gohalo.github.io/cn/blog/kubernets-commands-usage/</link><pubDate>Fri, 08 Jan 2021 19:43:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-commands-usage/</guid><description>&lt;p>整理下 K8S 的常用命令，以供参考。&lt;/p></description></item><item><title>K8S 网络简介</title><link>https://gohalo.github.io/cn/blog/kubernets-network-introduce/</link><pubDate>Mon, 21 Dec 2020 20:30:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-network-introduce/</guid><description>简介 # K8S 中的网络以及 IP 地址都分了三层，分别为：
Node Network 各个 Node 之间的通讯方式，可以是物理网络或者虚拟网络； Pod Network 各个 Pod 之间通讯，Pod 可以在 Node 内部，也可以是跨 Node ； Service Network 也就是 Pod 对外部暴露的接口，创建 Service 时会新建一个 IP 。 与之对应的 IP 地址包括了：
Node IP 每个 Node 之间通讯时，分配的 IP 地址； Pod IP 每个 Pod 会分配一个 IP 地址，一般由 Pause 容器创建，一个 Node 中可以包含多个 Pod ； Cluster IP 对应了 Service 内部 IP ，作为服务的入口。 K8S 支持 Flannel、Calico、Weave Network 等多种 CNI 网络驱动。
Docker 网络 # 在 Docker 的后台服务启动之后，会创建一个 docker0 的网关，容器默认会分配在一个以 docker0 为默认网关的虚拟子网中。</description></item><item><title>Python 包管理机制详解介绍</title><link>https://gohalo.github.io/cn/blog/python-package-management/</link><pubDate>Sun, 20 Dec 2020 19:59:28 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-package-management/</guid><description>&lt;p>Python 中可以通过 PIP 来自动管理依赖包，当然，也可以下载源码或者二进制包，有些源码包需要编译环境，最好直接下载安装二进制包。&lt;/p></description></item><item><title>Kubernetes 基本介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-basic-introduce/</link><pubDate>Thu, 10 Dec 2020 21:50:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-basic-introduce/</guid><description/></item><item><title>VIM 代码折叠</title><link>https://gohalo.github.io/cn/blog/vim-tips-folding/</link><pubDate>Mon, 30 Nov 2020 18:39:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-tips-folding/</guid><description>&lt;p>VIM 支持多种模式的折叠，可以方便查看代码结构。&lt;/p></description></item><item><title>Rust 结构体详解</title><link>https://gohalo.github.io/cn/blog/rust-syntax-structure-details/</link><pubDate>Thu, 26 Nov 2020 20:49:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-syntax-structure-details/</guid><description>&lt;p>结构体是 Rust 中最常用的，同样使用起来也相对更加复杂。&lt;/p></description></item><item><title>在 Python 中如何连接 MySQL 数据库</title><link>https://gohalo.github.io/cn/blog/python-third-package-mysql/</link><pubDate>Mon, 23 Nov 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-third-package-mysql/</guid><description>&lt;p>在 Python 中多种方式可以访问 MySQL 服务端，这里介绍几种常用的库。&lt;/p></description></item><item><title>C++ 命令行解析包 gflags 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-gflags-usage/</link><pubDate>Sun, 22 Nov 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-gflags-usage/</guid><description>&lt;p>gflags 是 Google 提供的一个命令行参数处理的开源库，目前已经独立开源，比传统的 &lt;code>getopt()&lt;/code> 功能更加强大，可以将不同的参数定义分布到各个源码文件中，不需要集中管理。&lt;/p>
&lt;p>提供了 C++ 和 Python 两个版本，这里仅详细介绍 C++ 版本的使用方式。&lt;/p></description></item><item><title>MySQL 语法解析</title><link>https://gohalo.github.io/cn/blog/mysql-parser/</link><pubDate>Sat, 21 Nov 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-parser/</guid><description>当服务器接收到一条 SQL 语句时，会经过词法分析、语法分析、语义分析、构造执行树、生成执行计划、计划的执行几个过程。其中，词法语法解析的处理过程根编译原理上的东西基本类似，MySQL 并没有使用 lex 来实现词法分析，但是语法分析用了 yacc。
与之对比的 SQLite 数据库，其词法分析器是手工写的，语法分析器由 Lemon 生成。在此介绍其在 MySQL 中的使用。
源码解析 # Linux 一般来说，词法和语法解析都是通过 Flex 与 Bison 完成的；而在 MySQL 中，词法分析使用自己的程序，而语法分析使用的是 Bison；Bison 会根据 MySQL 定义的语法规则，进行语法解析。
完成语法解析后，会将解析结果生成的数据结构保存在 struct LEX 中，该结构体在 sql/sql_lex.h 文件中定义。
struct LEX: public Query_tables_list { friend bool lex_start(THD *thd); SELECT_LEX_UNIT *unit; ///&amp;lt; Outer-most query expression /// @todo: select_lex can be replaced with unit-&amp;gt;first-select() SELECT_LEX *select_lex; ///&amp;lt; First query block SELECT_LEX *all_selects_list; ///&amp;lt; List of all query blocks private: /* current SELECT_LEX in parsing */ SELECT_LEX *m_current_select; .</description></item><item><title>详细介绍 C++ 的强制转换方法</title><link>https://gohalo.github.io/cn/blog/cpp-cast-methods-introduce/</link><pubDate>Fri, 20 Nov 2020 23:18:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-cast-methods-introduce/</guid><description>&lt;p>在 C 中提供了强制类型转换，不过其实现很简单，而且没有区分具体的使用场景，所以，在编译或者运行阶段可能会出现一些异常，尤其是一旦不注意极易发生异常。&lt;/p>
&lt;p>为此，C++ 对于不同的场景进行了划分，由于 C++ 支持面向对象编程，也因此对这一场景进行了优化。&lt;/p>
&lt;p>本文详细介绍其使用场景。&lt;/p></description></item><item><title>DBDeployer 常用命令</title><link>https://gohalo.github.io/cn/blog/mysql-tools-dbdeployer-cheatsheet/</link><pubDate>Wed, 18 Nov 2020 20:01:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-tools-dbdeployer-cheatsheet/</guid><description>&lt;p>DBDeployer 是一款十分强大的数据库测试环境部署工具，可实现一键部署不同架构、不同版本的数据库环境，之前已经详细介绍过其使用方法。&lt;/p>
&lt;p>这里将一些常用的命令整理下，已方便查询。&lt;/p></description></item><item><title>详细介绍 DBDeployer 部署工具使用</title><link>https://gohalo.github.io/cn/blog/mysql-tools-dbdeployer-usage/</link><pubDate>Wed, 18 Nov 2020 20:01:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-tools-dbdeployer-usage/</guid><description>&lt;p>通过 DBDeployer 可以在本地快速搭建一个强大的测试环境，包括了不同版本、不同架构的数据库环境，例如 MySQL 主从复制、GTID 模式复制、MySQL 组复制等等。&lt;/p>
&lt;p>支持几乎当前所有版本的 MySQL 发行版本，除了官方的，还有 Percona MySQL、MariaDB、MySQL NDB Cluster、Percona XtraDB Cluster 等等，还有 MySQL-Shell 的安装，甚至还有 TiDB ，估计是 TiDB 团队贡献的代码吧。&lt;/p>
&lt;p>这里会详细介绍其使用方法。&lt;/p></description></item><item><title>关于 Python 函数声明以及调用方式</title><link>https://gohalo.github.io/cn/blog/python-parameter-methods/</link><pubDate>Fri, 13 Nov 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-parameter-methods/</guid><description>&lt;p>Python 提供了非常灵活的参数声明以及调用方式，除了最常用的位置参数，还包括了默认值以及关键词匹配方式，而且对于列表、字典很方便展开。&lt;/p>
&lt;p>这里详细介绍 Python 的参数声明、调用方式。&lt;/p></description></item><item><title>排序算法简介</title><link>https://gohalo.github.io/cn/blog/algorithm-sort-introduce/</link><pubDate>Sun, 08 Nov 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-sort-introduce/</guid><description/></item><item><title>终端音乐播放器 CMUS 详细介绍</title><link>https://gohalo.github.io/cn/blog/cmus-music-player/</link><pubDate>Tue, 03 Nov 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmus-music-player/</guid><description>&lt;p>CMUS 是一个可以在终端上使用的音乐播放器，可以运行在多数类 Unix 的系统上，例如 Linux、Unix、Mac 等，而且支持绝大多数格式的音乐文件。&lt;/p>
&lt;p>不过目前已经不再维护了，这里详细介绍其使用方法。&lt;/p></description></item><item><title>Python With 语句详细介绍</title><link>https://gohalo.github.io/cn/blog/python-basic-syntax-with/</link><pubDate>Fri, 30 Oct 2020 22:48:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-basic-syntax-with/</guid><description>&lt;p>通常会有一些任务，开始需要进行设置，处理任务，事后做清理工作，对于这种场景，Python 的 with 语句提供了一种非常方便的处理方式。一个很好的例子是文件处理，你需要获取一个文件句柄，从文件中读取数据，然后关闭文件句柄。&lt;/p>
&lt;p>这里详细介绍其实现的内部原理。&lt;/p></description></item><item><title>JavaScript 语法介绍</title><link>https://gohalo.github.io/cn/blog/javascript-basic-usage/</link><pubDate>Sun, 25 Oct 2020 20:18:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/javascript-basic-usage/</guid><description>&lt;p>简单介绍 JavaScript 的核心语法，作为后续的参考手册。&lt;/p></description></item><item><title>详细介绍 glibc 特性宏的使用</title><link>https://gohalo.github.io/cn/blog/glibc-feature-macros-usage/</link><pubDate>Fri, 23 Oct 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/glibc-feature-macros-usage/</guid><description>&lt;p>GNU C Library 也就是 glibc 库，是目前 Linux 上最为基本的 C 语言库，不过其实现的不只是标准的 C 定义，还包括了其它的一些标准协议，不同场景下用户可以使用不同的接口。&lt;/p>
&lt;p>这些特性的开启都是通过宏来实现的，这里详细介绍其使用方式。&lt;/p></description></item><item><title>Linux PAM 认证机制使用详解</title><link>https://gohalo.github.io/cn/blog/linux-security-pam-introduce/</link><pubDate>Tue, 13 Oct 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-security-pam-introduce/</guid><description>Linux 通常会通过 login 进程完成登陆，最开始时只是简单的提示用户输入用户名和密码，然后校验用户是否存在、密码是否正确，如果都正常，那么就会直接完成登陆，进入到 Shell 程序运行。
PAM 提供了独立于具体程序配置机制，可以更加灵活的鉴权方案，这里详细介绍其使用方式。
简介 # 通常在用户登陆时，需要有一套的验证授权机制，最开始的时候，这一整套的验证机制是硬编码到程序中的，这样当程序有 bug 或者需要修改验证策略时，只能修改源程序。
为了改善这些问题，人们开始思考其他的方法，也就是所谓的 Pluggable Authentication Modules, PAM 应运而生了。
PAM 提供了一整套的鉴权、授权、密码管理、会话管理机制等，只需要程序支持 PAM 框架，用户就可以在完全不修改程序的条件下，动态修改鉴权机制，例如除了常规的用户名密码登陆，还可以使用指纹、One-Time-Password 等机制。
运行机制 # 如下是一个最常见的 login 示例程序，其中包括了二进制 login 可执行程序，该程序会动态链接 libpam.so 库，该库会读取 /etc/pam.d/login 配置文件，并根据配置文件中的内容，按照顺序生成不同栈。
然后，会根据不同的栈以及配置执行相关的动作。
相关文件 # 在 64 位系统中，与 PAM 相关的文件包含了如下几类：
/usr/lib64/libpam.so* 核心库，使用 PAM 机制的应用会链接到该库上。 /etc/pam.conf /etc/pam.d/* 配置文件，配置内容基本类似，前者为全局配置，通过第一列标识应用程序，而后者则以文件名标识应用程序，结构层次更加明确，也更常见。 /usr/lib64/security/pam_*.so 可以动态加载的模块，在配置文件中可以直接通过文件名引用。 如果一个应用程序 (例如 login) 想使用 PAM 提供的机制，那么需要链接到 libpam.so 库，否则就不支持 PAM 机制，可以通过如下命令查看。
$ ldd /usr/bin/login | grep pam libpam.so.0 =&amp;gt; /lib64/libpam.</description></item><item><title>InnoDB 简单介绍</title><link>https://gohalo.github.io/cn/blog/mysql-innodb-introduce/</link><pubDate>Thu, 08 Oct 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-innodb-introduce/</guid><description>&lt;p>我们知道，在 MySQL 中，存储引擎是通过插件实现的，从而使得添加存储引擎时相对来说比较简单，而且目前支持多种类型的存储引擎。&lt;/p>
&lt;p>InnoDB 目前基本上已经是实时上的没人存储引擎了，现在可以支持外键、行锁、MVCC、支持标准的 4 种隔离级别等等。实际上，这也就意味着 InnoDB 是相当复杂的一个存储引擎。&lt;/p>
&lt;p>在此，仅简单介绍下。&lt;/p></description></item><item><title>C++ Mock 工具 gmock 使用</title><link>https://gohalo.github.io/cn/blog/cpp-gmock-usage/</link><pubDate>Fri, 25 Sep 2020 19:30:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-gmock-usage/</guid><description>&lt;p>所谓的 mock 方法，是单元测试中常见的一种测试方式，用来模拟对象、隔离边界等，例如单元测试时模拟三方接口，这样服务可以独立测试；开发阶段不需要依赖其它类的开发进度等等。&lt;/p>
&lt;p>在 C++ 中，比较常用的是 Google 的 GMock 工具，可以用来模拟构造接口，并返回 mock 数据。&lt;/p>
&lt;p>这里我们从一个简单的示例开始，一步步详细介绍其使用方法，以及一些常用的技巧。&lt;/p></description></item><item><title>C++ 单测工具 gtest 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-google-test-introduce/</link><pubDate>Wed, 16 Sep 2020 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-google-test-introduce/</guid><description>&lt;p>这是 Google 提供的一个跨平台的测试、Mock 框架，很简单几乎没有依赖，但是提供了丰富的断言机制，尤其是提供了大部分其它语言测试框架没有的死亡测试。&lt;/p>
&lt;p>这里就详细介绍如何使用这一单元测试工具。&lt;/p></description></item><item><title>通过 OpenSSL 制作自签名证书</title><link>https://gohalo.github.io/cn/blog/openssl-self-signed-certificate/</link><pubDate>Sat, 12 Sep 2020 22:20:03 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/openssl-self-signed-certificate/</guid><description>&lt;p>一般来说，在互联网上使用 HTTPS 时，需要向一些官方的 CA 中心申请证书，不过一般来说比较贵。如果只是公司内部使用，那么就可以自己制作证书，当然也可以模拟 CA 的方式管理证书。&lt;/p>
&lt;p>这里详细介绍如何使用 OpenSSL 制作自签名证书，包括了自建 CA 的方式。&lt;/p></description></item><item><title>Docker 示例 Alpine + OpenSSH</title><link>https://gohalo.github.io/cn/blog/docker-example-sshd/</link><pubDate>Mon, 07 Sep 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-example-sshd/</guid><description>&lt;p>SSH 是最常见的远程连接协议，这里通过 Alpine 和 OpenSSH 搭建一个示例。&lt;/p></description></item><item><title>决策树</title><link>https://gohalo.github.io/cn/blog/artificial-intelligence-decision-tree/</link><pubDate>Sat, 05 Sep 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/artificial-intelligence-decision-tree/</guid><description>&lt;p>决策树算法是从数据的特征出发，并以此作为基础划分不同的类。&lt;/p></description></item><item><title>InnoDB 崩溃恢复</title><link>https://gohalo.github.io/cn/blog/mysql-innodb-crash-recovery/</link><pubDate>Thu, 03 Sep 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-innodb-crash-recovery/</guid><description>&lt;p>如果 InnoDB 没有正常关闭，会在服务器启动的时候执行崩溃恢复 (Crash Recovery)，这一流程比较复杂，涉及到了 redo log、undo log 甚至包括了 binlog 。&lt;/p>
&lt;p>在此简单介绍下 InnoDB 崩溃恢复的流程。&lt;/p></description></item><item><title>优先队列详细介绍</title><link>https://gohalo.github.io/cn/blog/structure-heap/</link><pubDate>Mon, 17 Aug 2020 18:19:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-heap/</guid><description>&lt;p>堆 (Heap) 又被为优先队列 (Priority Queue)，通过堆可以按照元素的优先级取出元素，而不是按照元素进入队列的先后顺序取出元素。&lt;/p>
&lt;p>这里详细介绍其实现。&lt;/p></description></item><item><title>详细介绍 PKI 以及 CA 基本概念</title><link>https://gohalo.github.io/cn/blog/ssl-public-key-infrastructure/</link><pubDate>Thu, 13 Aug 2020 19:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssl-public-key-infrastructure/</guid><description>&lt;p>公钥基础设施 (Public Key Infrastructure, PKI) 是目前网络安全建设的基础与核心，而证书认证机构 (Certificate Authority, CA) 更是核心中的核心，其中 CA 最重要的用途就是提供根证书，用来加强服务器和客户端之间信息交互的安全性。&lt;/p>
&lt;p>这里简单介绍一些基本概念。&lt;/p></description></item><item><title>离散化数组介绍</title><link>https://gohalo.github.io/cn/blog/discretization-array/</link><pubDate>Mon, 10 Aug 2020 21:38:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/discretization-array/</guid><description>&lt;p>有时候需要用数组的值作为下标，有可能会是一个很大的值，那么就导致内存中保存不了，但实际上数组大小是有限的，那么此时就可以通过数组离散化进行处理。&lt;/p>
&lt;p>简单来说，离散化关心的是相对大小，而不是某个数具体多大。&lt;/p></description></item><item><title>GoLang INI 配置文件解析</title><link>https://gohalo.github.io/cn/blog/golang-ini-config-parse/</link><pubDate>Sun, 09 Aug 2020 21:59:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-ini-config-parse/</guid><description>&lt;p>INI 是 Initialization File 的缩写，也就是初始化文件，原来是 Windows 系统配置文件所采用的存储格式，不过因为其使用简单，所以后来被广泛应用。&lt;/p>
&lt;p>这里介绍如何通过 GoLang 解析。&lt;/p></description></item><item><title>Python 内置模块和内置命名空间介绍</title><link>https://gohalo.github.io/cn/blog/python-builtins-module-and-builtin-namespace/</link><pubDate>Sat, 01 Aug 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-builtins-module-and-builtin-namespace/</guid><description>&lt;p>在 CPython 的实现中有一个内置的 &lt;code>builtins&lt;/code> 模块，同时还包含了一个内置的命名空间，其 Key 被称为 &lt;code>__builtins__&lt;/code>，两者在查找时会相互关联，不过在不同模块中实现又不相同。&lt;/p>
&lt;p>这里详细介绍其区别。&lt;/p></description></item><item><title>GoLang WebSocket 编程</title><link>https://gohalo.github.io/cn/blog/golang-websocket-program/</link><pubDate>Tue, 28 Jul 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-websocket-program/</guid><description/></item><item><title>Websocket 协议详解</title><link>https://gohalo.github.io/cn/blog/network-websocket-introduce/</link><pubDate>Sat, 25 Jul 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-websocket-introduce/</guid><description>&lt;p>对于 HTTP 协议，通信只能由客户端发起，服务端无法主动向客户端推送信息，通过轮询方式就很消耗资源。&lt;/p>
&lt;p>为了达到实时响应以及良好的用户体验，通常通过 AJAX 实现异步无刷新请求功能，不过只能在浏览器异步请求服务器，也就是拉取；而推送一般通过类似 Comet 的技术，略显复杂。&lt;/p>
&lt;p>而 WebSocket 是一种全新的协议，将 TCP 的 Socket 应用在了 web page 上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工工作模式。&lt;/p>
&lt;p>这里详细介绍其实现。&lt;/p></description></item><item><title>K8S Secret 介绍</title><link>https://gohalo.github.io/cn/blog/kubernets-components-secret/</link><pubDate>Tue, 21 Jul 2020 22:09:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-components-secret/</guid><description>&lt;p>在 K8S 中通过 configmap 保存了常用配置，但是因为是明文保存会导致安全问题，对于敏感信息可以通过 Secret 保存。&lt;/p></description></item><item><title>CentOS 安装与配置</title><link>https://gohalo.github.io/cn/blog/centos-config-from-scratch/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/centos-config-from-scratch/</guid><description>&lt;p>CentOS (Community Enterprise Operating System) 也即社区版的企业操作系统，是 Linux 发行版本之一，来自于 Red Hat Enterprise Linux 所开放的源码编译而成。因此，对稳定性较高的服务器通常以 CentOS 替代商业版的 Red Hat 。&lt;/p>
&lt;p>两者的不同在于 CentOS 并不包含封闭源代码软件。下面会介绍桌面版的 CentOS 在安装时需要作的一些常用配置。&lt;/p></description></item><item><title>git 免登陆设置</title><link>https://gohalo.github.io/cn/blog/git-tips-skip-password-typing/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-tips-skip-password-typing/</guid><description>&lt;p>使用 git 时，可以通过 http 或者 ssh 访问远端仓库，但是每次访问如果都要填写用户名密码就会很麻烦，这里主要针对这两种场景，介绍如何配置免密码直接登陆。&lt;/p></description></item><item><title>git 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/git-basic-introduce/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-basic-introduce/</guid><description>&lt;p>起初 git 是 Linus Torvalds 为了便于管理 Linux 内核开发而开发的一个开放源码的版本控制软件，这是一个开源的分布式版本控制系统，可以高效地处理从很小到非常大的项目版本管理。&lt;/p>
&lt;p>简单来说，如果你严肃对待编程，就必定会使用&amp;quot;版本管理系统&amp;quot; (Version Control System)。&lt;/p></description></item><item><title>KVM 虚拟平台</title><link>https://gohalo.github.io/cn/blog/linux-kernel-based-virtual-machine-kvm/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-based-virtual-machine-kvm/</guid><description>&lt;p>全虚拟化最简单通俗的理解是，在一台机器上可以运行不同的平台 (例如Linux、Windows等)，不过其对应的仍然是 x86_64 架构。另外，如果允许在机器上可以运行不同的架构(例如x86_64、PowerPC、ARM等)，那么这种的虚拟化方式称为硬件仿真。&lt;/p>
&lt;p>这里简单介绍下 Linux 中 KVM 的使用方式。&lt;/p></description></item><item><title>MinIO 使用详解</title><link>https://gohalo.github.io/cn/blog/minio-object-storage/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/minio-object-storage/</guid><description>安装 # 可以从 Download 查看不同平台的安装方法，如下以 RPM 为例，同时会包含 systemd 的配置文件。
在 /lib/systemd/system/minio.service 可以看到具体的启动命令行为 minio server $MINIO_OPTS $MINIO_VOLUMES，同时需要修改启动的用户名和用户组，修改如下配置文件后启动。
# cat /etc/default/minio MINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password MINIO_DOMAIN=&amp;#34;minio.com&amp;#34; MINIO_VOLUMES=&amp;#34;/opt/minio/data&amp;#34; MINIO_OPTS=&amp;#34;--address :9000 --console-address :9001&amp;#34; # systemctl start minio 然后访问 http://localhost:9001 即可，注意，从 2021 版本开始，需要通过 MINIO_ROOT_USER/MINIO_ROOT_PASSWORD 替换之前的 MINIO_ACCESS_KEY/MINIO_SECRET_KEY 配置参数，其它常用配置参数可以参考：
MINIO_REGION 部署所在区域，一般通过 国家-区域-编号 表示，例如 us-west-1 。 MINIO_DOMAIN 配置后支持 Virtual Host 方式访问。 默认会使用 Path Style 也就是类似 http://xxx.com:9000/bucket/1.txt 方式访问对象，设置 MINIO_DOMAIN 参数后将会同时支持 Virtual Host Style 方式，此时桶名会作为域名，例如 http://bucket.xxx.com:9000/1.txt 这种路径。
注意，此时要同时设置域名解析，如果是本地，可以参考 DNSmasq 中的介绍，同时增加。
配置 # 同样按照上述的介绍下载客户端，最新一般是 mc 命令。</description></item><item><title>XWindow 简介</title><link>https://gohalo.github.io/cn/blog/linux-xwindow-introduce/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-xwindow-introduce/</guid><description>&lt;p>XWindow 是一种以位图方式显示的软件窗口系统，最初是 1984 年麻省理工学院的研究成果，之后变成类 UNIX 操作系统的标准化软件工具包及显示架构协议。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>二叉搜索树</title><link>https://gohalo.github.io/cn/blog/structure-binary-search-tree/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-binary-search-tree/</guid><description/></item><item><title>并查集详细介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-union-find/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-union-find/</guid><description>&lt;p>并查集 Union-Find 算法，顾名思义，用作合并集合、查找集合元素，通常用来解决图论中动态连通性问题，当然也包括了分类。&lt;/p>
&lt;p>这里详细介绍基本概念。&lt;/p></description></item><item><title>自平衡二叉搜索树</title><link>https://gohalo.github.io/cn/blog/structure-avl-tree/</link><pubDate>Thu, 16 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-avl-tree/</guid><description>&lt;p>为了保证树的高度，也就出现了如下的平衡二叉树，例如 AVL Tree、Red-Black Tree 等，两者都是针对可能出现的不同场景进行调整，从而达到了平衡状态，但是两者处理不平衡状态都不太好记忆，而且死板。&lt;/p>
&lt;p>这里先介绍下自平衡二叉树的实现。&lt;/p></description></item><item><title>Bash 命令注入以及预防策略</title><link>https://gohalo.github.io/cn/blog/bash-security-commands-injection/</link><pubDate>Wed, 08 Jul 2020 19:18:35 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-security-commands-injection/</guid><description>&lt;p>所谓的命令注入，简单来说，就是利用任何会调用系统命令的应用，通过构造特殊命令字符串的方式，执行恶意代码。常见的例如 SQL 命令注入、页面命令注入等。&lt;/p>
&lt;p>这里介绍一下 Bash 的命令注入以及预防策略。&lt;/p></description></item><item><title>K8S 制作离线镜像</title><link>https://gohalo.github.io/cn/blog/kubernets-create-offline-images/</link><pubDate>Mon, 06 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-create-offline-images/</guid><description>&lt;p>大部分的镜像制作都是通过 Dockerfile 来实现的，基本都是基于基础镜像制作，这里介绍使用 &lt;code>buildah&lt;/code> 来构建基础镜像，可以以此理解其基本原理。&lt;/p></description></item><item><title>yum 配置以及常用 rpm 命令</title><link>https://gohalo.github.io/cn/blog/yum-rpm-config-and-command-usage/</link><pubDate>Wed, 01 Jul 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/yum-rpm-config-and-command-usage/</guid><description>&lt;p>在 CentOS 中，会通过 YUM 或者 RPM 进行软件包的管理，不过 RPM 不能很好的解决软件之间的依赖关系，所以目前使用较多的是 YUM 源。&lt;/p>
&lt;p>介绍常用的管理命令，基本的 RPM 规范，常见的错误处理，例如镜像地址配置、本地源设置、强制安装包等等。&lt;/p></description></item><item><title>树基本介绍</title><link>https://gohalo.github.io/cn/blog/structure-tree/</link><pubDate>Tue, 16 Jun 2020 18:43:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-tree/</guid><description>&lt;p>通过树可以用来描述层级结构数据，基本上有序列的地方就可以应用树，因为树结构即是一种序列索引结构。&lt;/p>
&lt;p>这里简单介绍常见的树结构。&lt;/p></description></item><item><title>Neovim 插件管理工具之 Packer(历史)</title><link>https://gohalo.github.io/cn/blog/neovim-plugins-management-legacy-packer/</link><pubDate>Fri, 12 Jun 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/neovim-plugins-management-legacy-packer/</guid><description>&lt;p>从 Neovim 0.5 版本开始，一般推荐使用 Lua 原生的 &lt;code>packer.nvim&lt;/code> 做插件管理，现在大多数插件都支持该管理工具。&lt;/p>
&lt;p>这里详细介绍其使用。&lt;/p></description></item><item><title>浮点数的前世今生</title><link>https://gohalo.github.io/cn/blog/computer-floating-point-introduce/</link><pubDate>Mon, 08 Jun 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/computer-floating-point-introduce/</guid><description>&lt;p>在计算机中，所有的信息都是通过二进制进行保存的，对于浮点数也不例外，但是，因为字节长度有限，这样就很难保证能表示所有的实数。&lt;/p>
&lt;p>这也就是造成了 &lt;code>0.1 + 0.2&lt;/code> 的结果不太符合预期，这里一步步介绍这一问题产生的原因。&lt;/p></description></item><item><title>如何在 Linux 中查看 CPU 信息</title><link>https://gohalo.github.io/cn/blog/check-cpu-info-on-linux/</link><pubDate>Fri, 29 May 2020 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/check-cpu-info-on-linux/</guid><description>&lt;p>现在 CPU 一般是多核，甚至包括了现在的手机，而每个核又包含了缓存，那么，在 Linux 上如何通过命令查看当前 CPU 的信息呢？例如，常见的型号、时钟频率、核数等等，在这篇文章里会详细介绍。&lt;/p></description></item><item><title>Linux 网络配置</title><link>https://gohalo.github.io/cn/blog/linux-network-settings/</link><pubDate>Wed, 20 May 2020 21:29:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-settings/</guid><description>&lt;p>现在很多系统管理员仍在使用 ifconfig、route、arp 和 netstat 等命令行工具，来管理和排查各种网络配置。这套工具也就是 net-tools 包，源于 BSD TCP/IP 工具箱，但是自 2001 年以后基本就停滞不前。&lt;/p>
&lt;p>iproute 作为一套新的网络配置工具，旨在替换原有的 net-tools 工具包，这里大概介绍下两者的区别。&lt;/p></description></item><item><title>Lua 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/lua-basic-introduce/</link><pubDate>Thu, 30 Apr 2020 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-basic-introduce/</guid><description>&lt;p>Lua 历史可以从 1993 年开始，到现在为止，在很多场景都可以看到 Lua 的影子，如游戏开发、Web 应用脚本、安全系统插件等，像常见的 nmap、sysbench 等程序。&lt;/p>
&lt;p>这里简单介绍 Lua 的安装使用。&lt;/p></description></item><item><title>Linux 密码管理</title><link>https://gohalo.github.io/cn/blog/how-to-save-password-security/</link><pubDate>Thu, 23 Apr 2020 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/how-to-save-password-security/</guid><description>&lt;p>简单介绍下 Linux 中的密码管理。&lt;/p></description></item><item><title>GoLang Trace 详解</title><link>https://gohalo.github.io/cn/blog/golang-trace-basic/</link><pubDate>Wed, 15 Apr 2020 21:18:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-trace-basic/</guid><description>&lt;p>GoLang 有很多的 Profile 工具，包括了 CPU、Memory、Blocking 各种 Profiler 实现，也包括了 GC/Scheduler Tracer、Heap Dumper，这些工具大部分提供的是聚合信息，即使 Dump 这种可以查看内存对象的，也很难确定其执行过程。&lt;/p>
&lt;p>于是乎，就有了 Trace 实现。&lt;/p></description></item><item><title>GoLang 单元测试</title><link>https://gohalo.github.io/cn/blog/golang-testing-method/</link><pubDate>Wed, 15 Apr 2020 21:18:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-testing-method/</guid><description>&lt;p>程序开发中比较重要的一点是如何可以高效的进行单元测试，可以保证快速发现定位问题，在 GoLang 中自带了一个轻量级的测试框架 &lt;code>testing&lt;/code> 以及 &lt;code>go test&lt;/code> 命令来实现单元测试和性能测试。&lt;/p></description></item><item><title>Rest API 介绍以及最佳实践</title><link>https://gohalo.github.io/cn/blog/rest-api-best-practice/</link><pubDate>Sun, 12 Apr 2020 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rest-api-best-practice/</guid><description>&lt;p>当前网络应用一般分成了独立的前后端，而且前端设备层出不穷，所以需要有统一的标准，便于不同的前后端进行通讯，而 RESTful API 是目前比较成熟的 API 设计理论。&lt;/p>
&lt;p>它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。&lt;/p></description></item><item><title>VIM 界面显示介绍</title><link>https://gohalo.github.io/cn/blog/vim-tips-tab-buffer/</link><pubDate>Sun, 12 Apr 2020 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-tips-tab-buffer/</guid><description>&lt;p>在 VIM 中，与显示相关的内容包括了 Tab、Window、Buffer 三种，很多的功能可以用不同的机制实现，不过很容易引起混淆，这里简单介绍 VIM 设计的基本概念，并简单介绍最佳实践。&lt;/p></description></item><item><title>VIM 颜色配置</title><link>https://gohalo.github.io/cn/blog/vim-tips-true-colors/</link><pubDate>Sun, 12 Apr 2020 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-tips-true-colors/</guid><description>&lt;p>不同的终端对于颜色的支持能力略有区别。&lt;/p></description></item><item><title>VIM 自动对齐配置</title><link>https://gohalo.github.io/cn/blog/vim-tips-indent/</link><pubDate>Fri, 03 Apr 2020 18:19:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-tips-indent/</guid><description>&lt;p>通过 VIM 可以自动设置对齐方式，例如使用 Tab 还是空格，使用四个字节还是八个字节等等，而且，可以根据不同的语言设置不同的格式。&lt;/p></description></item><item><title>Bitmap 详细介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-bitmap-introduce/</link><pubDate>Sat, 28 Mar 2020 22:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-bitmap-introduce/</guid><description/></item><item><title>整数溢出</title><link>https://gohalo.github.io/cn/blog/integer-overflow/</link><pubDate>Sat, 28 Mar 2020 22:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/integer-overflow/</guid><description>&lt;p>这实际上是一个很严重的问题，包括 PostgreSQL、ZooKeeper 都可能会出现。&lt;/p></description></item><item><title>TLS/SSL 通讯协议详解</title><link>https://gohalo.github.io/cn/blog/security-ssl-tls-overview/</link><pubDate>Fri, 27 Mar 2020 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-ssl-tls-overview/</guid><description>&lt;p>SSL/TLS 处于传输层 (一般为 TCP) 以及应用层 (常用的 HTTP) 之间，提供了加密 (Encryption)、认证 (Verification)、鉴定 (Identification) 三种功能。&lt;/p>
&lt;p>如下简单介绍其基本概念。&lt;/p></description></item><item><title>React Router Dom V6 使用详解</title><link>https://gohalo.github.io/cn/blog/react-router-dom-introduce/</link><pubDate>Sun, 15 Mar 2020 22:10:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/react-router-dom-introduce/</guid><description>&lt;p>现在的网页，不同于之前的全页面刷新，一般会采用局部刷新，用户不会感知，看起来实际上只有一个页面，所以也被称为 &amp;ldquo;单页应用&amp;rdquo; (Single Page Appliaction) 。&lt;/p></description></item><item><title>React 项目实战</title><link>https://gohalo.github.io/cn/blog/react-practice-examples/</link><pubDate>Fri, 06 Mar 2020 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/react-practice-examples/</guid><description/></item><item><title>PyCharm 常用设置</title><link>https://gohalo.github.io/cn/blog/pycharm-settings/</link><pubDate>Fri, 06 Mar 2020 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/pycharm-settings/</guid><description>&lt;p>PyCharm 是 JetBrains 打造的一款 Python IDE 跨平台的 IDE ，当然，还有其它语言的 IDE ，快捷键十分相似。&lt;/p>
&lt;p>这里简单介绍下 PyCharm 相关的一些常用配置。&lt;/p></description></item><item><title>GoLang Echo 简介</title><link>https://gohalo.github.io/cn/blog/golang-echo-http-framework/</link><pubDate>Thu, 05 Mar 2020 22:28:15 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-echo-http-framework/</guid><description>&lt;p>echo web 框架是通过 GoLang 开发的一种高性能、可扩展、轻量级的 web 框架，只包含了 MVC 框架的 C 部分，也就是负责 URL 路由和控制器部分，对于 V 视图和 M 数据操作可以使用自己喜欢的工具库来实现。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Linux 用户管理的最佳实践</title><link>https://gohalo.github.io/cn/blog/linux-user-best-practise/</link><pubDate>Tue, 25 Feb 2020 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-user-best-practise/</guid><description>&lt;p>在 Linux 中，权限管理包括了用户、主用户组、从用户组，通过这三者的组织可以方便对权限的管理，尤其是对于文件的权限管理。这里假设一个运维中的使用场景，通过创建一系列的用户以及用户组，然后查看其权限管理的方案。&lt;/p></description></item><item><title>Breakpad 崩溃状态信息收集</title><link>https://gohalo.github.io/cn/blog/cpp-google-breakpad-introduce/</link><pubDate>Tue, 25 Feb 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-google-breakpad-introduce/</guid><description>&lt;p>一个跨平台的 Crash 状态采集工具，相对 Linux 中的 CoreDump 文件来说，采集的内容更小。&lt;/p></description></item><item><title>Python 命名空间和作用域介绍</title><link>https://gohalo.github.io/cn/blog/python-namespace-scope/</link><pubDate>Mon, 24 Feb 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-namespace-scope/</guid><description>&lt;p>在 Python 中，一切皆对象，命名空间实际是一个名称到对象的映射，另外，虽然 Python 是一种动态类型的语言，但是静态作用域语言，变量使用与作用域相关。&lt;/p>
&lt;p>这里详细介绍命名空间和作用域的关系。&lt;/p></description></item><item><title>详细介绍 Python 闭包以及装饰器</title><link>https://gohalo.github.io/cn/blog/python-decorator-closure/</link><pubDate>Thu, 20 Feb 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-decorator-closure/</guid><description>&lt;p>装饰器可以为 Python 提供一些修饰工作，所谓修饰工作就是想给现有的模块加上一些小功能，但又不让这个小功能侵入到原有的模块中的代码里去，最常见的三种函数修饰器 &lt;code>@staticmethod&lt;/code>、&lt;code>@classmethod&lt;/code> 和 &lt;code>@property&lt;/code> ，都是 Python 的内置函数。&lt;/p>
&lt;p>这里详细介绍其使用方式。&lt;/p></description></item><item><title>git 子模块使用</title><link>https://gohalo.github.io/cn/blog/git-tips-submodule/</link><pubDate>Sun, 16 Feb 2020 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-tips-submodule/</guid><description>&lt;p>开发过程中经常会遇到依赖另外的项目，多数情况可能就是三方库，但是几个独立的项目，通过子模块可以将多个项目关联。&lt;/p></description></item><item><title>Python 变量基本概念详解</title><link>https://gohalo.github.io/cn/blog/python-variables-bind/</link><pubDate>Wed, 05 Feb 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-variables-bind/</guid><description>&lt;p>在 Python 中，所有的都是对象，变量与大部分常用语言有所区别，赋值的时候，严格来说不是赋值，而是变量的绑定，变量名称中并没有保存对象，而更像是在对象上添加了一个标签而已。&lt;/p>
&lt;p>这里简单介绍下 Python 中与变量相关的基本概念。&lt;/p></description></item><item><title>Python 日志使用详解</title><link>https://gohalo.github.io/cn/blog/python-third-package-logging/</link><pubDate>Thu, 30 Jan 2020 23:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-third-package-logging/</guid><description>&lt;p>用 Python 写代码时，经常需要打印日志，其实内部提供了一个灵活的 logging 模块，基本可以满足绝大部分的需求，如下简单介绍其使用方式。&lt;/p></description></item><item><title>Bloom Filter 详细介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-bloomfilter-introduce/</link><pubDate>Mon, 27 Jan 2020 22:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-bloomfilter-introduce/</guid><description>&lt;p>BloomFilter 是一个哈希索引结构，采用类似 BitMap 的方式存储数据，所以空间利用率很高，其独特的地方在于使用多个哈希函数来避免哈希冲突。&lt;/p></description></item><item><title>Linux Capabilites 机制详细介绍</title><link>https://gohalo.github.io/cn/blog/linux-security-capabilities/</link><pubDate>Sat, 18 Jan 2020 21:39:50 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-security-capabilities/</guid><description>&lt;p>在 Linux 系统中，有些操作是需要 root 用户权限才能操作的，常见的包括 chown、使用 Raw Sokcet (ping) 等，如果使用 sudo 就会导致配置管理和权限控制比较麻烦。&lt;/p>
&lt;p>为了只给这个程序开所需要的权限，Linux 提供了一套 capabilities 机制，这里详细介绍。&lt;/p></description></item><item><title>C++ 智能指针</title><link>https://gohalo.github.io/cn/blog/cpp-smart-pointer-introduce/</link><pubDate>Wed, 15 Jan 2020 22:26:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-smart-pointer-introduce/</guid><description>类似于 C 语言，C++ 中申请的对象也需要手动释放，不像 Java GoLang 这类的语言，有自己的垃圾回收机制 (C++中有相关的实现，但非标准) ，这样 C++ 程序员需要重点关注内存的申请和释放，否则可能会导致内存泄漏。
为了解决 C++ 内存泄漏问题，在 C++11 中引入了智能指针 (Smart Pointer)，在一定程度上减轻了对内存的管理。
简介 # 例如对于如下的函数，如果没有显示的调用 delete(p) 函数，那么就会造成内存泄漏。
#include &amp;lt;unistd.h&amp;gt; #include &amp;lt;iostream&amp;gt; class Rectangle { private: double width, height; }; void foobar(void) { Rectangle *p = new Rectangle(); //delete(p); } int main(void) { while (1) { foobar(); sleep(1); } } 而智能指针实际上就是为了解决上述的问题。
基本使用 # 一个栈上创建的对象，在退出栈的作用域之后，该对象会自动销毁，而智能指针就是使用的这一原理。创建一个智能指针保存申请好的内存地址，当程序退出作用域的时候，对应的智能指针被自动销毁，同时会释放其指向的内存。
在 C++11 中提供了三种智能指针 std::shared_ptr std::unique_ptr std::weak_ptr ，定义在头文件 &amp;lt;memory&amp;gt; 中，分别用于不同的场景中。
unique_ptr # 指向一个唯一的对象，该对象可以 move 但是不能进行赋值。</description></item><item><title>HTML 语法速查表</title><link>https://gohalo.github.io/cn/blog/html-cheatsheet/</link><pubDate>Sun, 12 Jan 2020 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/html-cheatsheet/</guid><description/></item><item><title>Python 常用模块</title><link>https://gohalo.github.io/cn/blog/python-third-package-others/</link><pubDate>Fri, 03 Jan 2020 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-third-package-others/</guid><description/></item><item><title>一致性模型详解</title><link>https://gohalo.github.io/cn/blog/concurrency-consistent-models-introduce/</link><pubDate>Mon, 30 Dec 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/concurrency-consistent-models-introduce/</guid><description>&lt;p>现实生活中，对于一个系统的组成会经常发生网络分区、消息丢失、发送延迟、消息重复、消息乱序等等，造成这一问题的原因有很多，包括光纤、交换机、网卡、主机硬件、操作系统、磁盘、虚拟化层、程序等等，都可能会出现各种各样的问题。&lt;/p>
&lt;p>此时就需要有一个比较直观的正确性模型，包括如何定义、描述。&lt;/p></description></item><item><title>Docker Compose 简介</title><link>https://gohalo.github.io/cn/blog/docker-compose-introduce/</link><pubDate>Sun, 22 Dec 2019 21:34:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-compose-introduce/</guid><description>&lt;p>Docker Compose 是 Docker 官方编排项目，用于快速的部署应用。通过 DockerFile 可以快速生成一个容器，如果要多个容器配合使用，那么就可以通过该编排工具完成。&lt;/p></description></item><item><title>C++ 右值引用</title><link>https://gohalo.github.io/cn/blog/cpp-right-value-reference/</link><pubDate>Fri, 20 Dec 2019 21:18:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-right-value-reference/</guid><description>&lt;p>在 C++11 的新特性中增加了所谓的右值引用的支持，其主要目的是为了解决两个问题：A) 临时对象非必要的拷贝操作；B) 在模板函数中如何按照参数的实际类型进行转发。&lt;/p>
&lt;p>同时，和右值引用相关的概念比较多，包括了纯右值、将亡值、Universal References、引用折叠、移动语义、Move语义和完美转发等等，这里简单介绍。&lt;/p></description></item><item><title>MySQL 通讯协议详解</title><link>https://gohalo.github.io/cn/blog/mysql-protocol-details/</link><pubDate>Sun, 08 Dec 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-protocol-details/</guid><description>&lt;p>Client/Server 通讯协议用于客户端链接、代理、主备复制等，支持 SSL、压缩，在链接阶段进行认证，在执行命令时可以支持 Prepared Statements 以及 Stored Procedures 。&lt;/p>
&lt;p>当打算编写数据库代理、中间件、对 MySQL 数据包进行审核时，都需要了解底层的通信协议。在本文中，主要介绍 MySQL 通讯协议相关的内容。&lt;/p></description></item><item><title>TLSv1.3 简介</title><link>https://gohalo.github.io/cn/blog/security-ssl-tlsv13-introduce/</link><pubDate>Sun, 08 Dec 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-ssl-tlsv13-introduce/</guid><description>&lt;p>TLS 1.3 是时隔九年对 TLS 1.2 之前版本的新升级，也是迄今为止改动最大的一次。&lt;/p></description></item><item><title>npm 使用详解</title><link>https://gohalo.github.io/cn/blog/web-npm-introduce/</link><pubDate>Thu, 05 Dec 2019 22:10:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-npm-introduce/</guid><description>&lt;p>简单介绍前端开发过程中最常用的包管理工具。&lt;/p></description></item><item><title>Podman 使用简介</title><link>https://gohalo.github.io/cn/blog/podman-container-basic-introduce/</link><pubDate>Sun, 01 Dec 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/podman-container-basic-introduce/</guid><description>&lt;p>Docker 是一个以 root 身份在系统上运行的守护程序，然后利用 Linux 内核的功能来管理正在运行的容器，包括了容器镜像。&lt;/p>
&lt;p>而 Podman 提供与 Docker 类似的功能，但是不再以 root 用户运行，而且非常驻进程。&lt;/p></description></item><item><title>React 基本介绍</title><link>https://gohalo.github.io/cn/blog/react-basic-introduce/</link><pubDate>Wed, 20 Nov 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/react-basic-introduce/</guid><description>&lt;p>React 是一个用于构建用户界面的 JavaScript 库，起源于 Facebook 内部项目，最初用来架设 Instagram 的网站，并于 2013 年 5 月开源，以声明式、组件化的特性让编写代码变得简单，而且性能很高。&lt;/p>
&lt;p>另外，React 不仅可以用来开发 Web 应用，还能开发移动应用。&lt;/p></description></item><item><title>二分查找详解 (闭区间)</title><link>https://gohalo.github.io/cn/blog/algorithm-binary-search-other/</link><pubDate>Wed, 20 Nov 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-binary-search-other/</guid><description>&lt;p>之前的文章已经详细介绍了二分查找，不过使用的是闭区间，这里再介绍一下开区间的实现细节，两种方法基本没有区别，可以选择其中一个。&lt;/p></description></item><item><title>Webpack 基本介绍</title><link>https://gohalo.github.io/cn/blog/webpack-basic-usage/</link><pubDate>Wed, 20 Nov 2019 22:10:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/webpack-basic-usage/</guid><description>&lt;p>Webpack 是前端使用最为广泛的打包工具，可以大大提高工作效率。&lt;/p></description></item><item><title>二分查找详解</title><link>https://gohalo.github.io/cn/blog/algorithm-binary-search/</link><pubDate>Wed, 20 Nov 2019 19:58:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-binary-search/</guid><description>&lt;p>二分查找 (Binary Search) 是一种效率较高的查找方法，不过其对保存的数据有所要求，数据需要线性顺序存储，同时需要保证数据是有序排列的。&lt;/p>
&lt;p>虽然二分查找的思路很简单，却有很多的细节问题，如整型溢出、边界的递进等等，这里详细介绍其使用方法。&lt;/p></description></item><item><title>UML 设计简介</title><link>https://gohalo.github.io/cn/blog/uml-introduce/</link><pubDate>Tue, 19 Nov 2019 20:45:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/uml-introduce/</guid><description/></item><item><title>C++ 可调用对象</title><link>https://gohalo.github.io/cn/blog/cpp-basic-callable-introduce/</link><pubDate>Tue, 12 Nov 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-basic-callable-introduce/</guid><description>&lt;p>在 C++11 之前，可调用对象包括了函数、函数指针以及重载 &lt;code>operator()&lt;/code> 运算符的对象；而在 C++11 之后，新增了 &lt;code>lambda&lt;/code> 表达式以及 &lt;code>bind()&lt;/code> 返回值，同时，引入了新的 &lt;code>function&lt;/code> 类型，用来统一可调用对象。&lt;/p></description></item><item><title>MySQL 存储引擎</title><link>https://gohalo.github.io/cn/blog/mysql-storage-engine-plugin/</link><pubDate>Tue, 12 Nov 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-storage-engine-plugin/</guid><description>&lt;p>众所周知，在 MySQL 中很多功能是通过插件实现的，包括了其中的存储引擎。在此简单介绍一下与 MySQL 存储引擎相关的内容，包括了提供的接口，实现方法等。&lt;/p>
&lt;p>在 &lt;a href="https://gohalo.github.io/cn/blog/mysql-plugin/">MySQL 插件&lt;/a> 这篇文章中，已经讨论了与插件相关的内容，包括了编译、加载、使用方法等，同时也包括了存储引擎，详细使用方法可以参考这篇文章。&lt;/p>
&lt;p>在此，仅介绍下 MySQL 中，存储引擎的实现。&lt;/p></description></item><item><title>MySQL 常用工具</title><link>https://gohalo.github.io/cn/blog/mysql-tools/</link><pubDate>Tue, 12 Nov 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-tools/</guid><description>&lt;p>在此介绍一些 MySQL 中常用的工具，包括了 percona-tools、sysbench 等工具。&lt;/p>
&lt;p>接下来我们看看。&lt;/p></description></item><item><title>gRPC 源码解析</title><link>https://gohalo.github.io/cn/blog/golang-grpc-source-code-details/</link><pubDate>Tue, 29 Oct 2019 23:19:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-grpc-source-code-details/</guid><description>gRPC 是一个通用的 RPC 框架，这里简单看下 GoLang 中 gRPC 的实现。
简介 # 整个 RPC 服务的调用流程如下：
client 调用 client stub，这是一次本地过程调用； client stub 将参数打包成消息，然后发送这个消息，打包过程(序列化)也叫做 marshalling； client 所在的系统将消息发送给 server； server 的将收到的包传给 server stub； server stub 解包得到参数，解包(反序列化) 也被称作 unmarshalling； 最后 server stub 调用服务过程，返回结果按照相反的步骤传给 client 。
目录结构 # 在 gRPC 目录下有许多常用的包，例如：
metadata # 定义了 gRPC 所支持的元数据结构，包中方法可以对 MD 进行获取和处理。
Client # 对于代码中，实际调用流程为。
c := pb.NewGreeterClient(conn) r, err := c.SayHello(ctx, &amp;amp;pb.HelloRequest{Name: name}) Dial() clientconn.go |-DialContext() 除了个函数的入参，同时会新建一个CTX |-context.WithCancel() 创建所使用的上下文 Server # 一般来说分为了如下几步操作：</description></item><item><title>C 程序加载过程</title><link>https://gohalo.github.io/cn/blog/c-linux-load-process-plt-got/</link><pubDate>Sun, 20 Oct 2019 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-load-process-plt-got/</guid><description>&lt;p>利用动态库，可以节省磁盘、内存空间，而且可以提高程序运行效率；不过同时也导致调试比较困难，而且可能存在潜在的安全威胁。&lt;/p>
&lt;p>这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。&lt;/p></description></item><item><title>gRPC 基本介绍</title><link>https://gohalo.github.io/cn/blog/golang-grpc-introduce/</link><pubDate>Sat, 19 Oct 2019 23:19:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-grpc-introduce/</guid><description>&lt;p>gRPC 一开始由 google 开发，是一款开源的远程过程调用 (RPC) 系统。&lt;/p>
&lt;p>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，能够更容易地创建分布式应用和服务。&lt;/p></description></item><item><title>Linux 内存检查工具 Valgrind 介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-memory-valgrind/</link><pubDate>Sat, 12 Oct 2019 21:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-memory-valgrind/</guid><description>&lt;p>Valgrind 可以用于构建动态分析工具，包括一个工具集，每个工具可以进行一类的调试、分析、测试，以帮助完善程序。&lt;/p>
&lt;p>该工具采用的是模块化方式，可以很容易创建新的工具而又不会扰乱现有工具。&lt;/p></description></item><item><title>MySQL 复制源码解析</title><link>https://gohalo.github.io/cn/blog/mysql-replication-sourcecode/</link><pubDate>Fri, 04 Oct 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-replication-sourcecode/</guid><description>&lt;p>MySQL 主从复制通过 binlog 实现，从库通过 dump 协议来交互数据的，binlog 复制的基本逻辑处理单元为 event 。&lt;/p>
&lt;p>在本文中，我们看看源码是如何执行的。&lt;/p></description></item><item><title>【拍案惊奇】之网络端口</title><link>https://gohalo.github.io/cn/blog/network-same-source-destination-port/</link><pubDate>Wed, 02 Oct 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-same-source-destination-port/</guid><description>&lt;p>如果在本地访问时，使用了一个源和目的端口都相同的 TCP 链接，会出现什么情况？&lt;/p></description></item><item><title>常用 Bash 脚本</title><link>https://gohalo.github.io/cn/blog/bash-some-useful-scripts/</link><pubDate>Tue, 01 Oct 2019 19:14:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-some-useful-scripts/</guid><description>&lt;p>这里总结一些常见的脚本，例如备份、日志清理等等。&lt;/p></description></item><item><title>Python 绘图方法</title><link>https://gohalo.github.io/cn/blog/python-matplotlib-ploting-method-intorduce/</link><pubDate>Sat, 28 Sep 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-matplotlib-ploting-method-intorduce/</guid><description>&lt;p>介绍一些 Python 中常见的图片绘制方法。&lt;/p></description></item><item><title>Linux 系统配置</title><link>https://gohalo.github.io/cn/blog/linux-system-config/</link><pubDate>Fri, 27 Sep 2019 19:49:36 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-system-config/</guid><description>&lt;p>一些与 Linux 系统配置相关的介绍。&lt;/p></description></item><item><title>Lua 和 C 语言相互调用</title><link>https://gohalo.github.io/cn/blog/lua-c-api/</link><pubDate>Sun, 22 Sep 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-c-api/</guid><description>&lt;p>Lua 是扩展性非常良好的语言，虽然核心非常精简，但是用户可以依靠 Lua 库来实现大部分工作，还可以通过与 C 函数相互调用来扩展程序功能。&lt;/p>
&lt;p>在 C 中嵌入 Lua 脚本既可以让用户在不重新编译代码的情况下修改 Lua 代码更新程序，也可以给用户提供一个自由定制的接口，这种方法遵循了机制与策略分离的原则；在 Lua 中调用 C 函数可以提高程序的运行效率。&lt;/p>
&lt;p>Lua 与 C 的相互调用在工程中相当实用，这里就简单讲解 Lua 与 C 相互调用的方法。&lt;/p></description></item><item><title>InnoDB Double Write Buffer</title><link>https://gohalo.github.io/cn/blog/mysql-innodb-double-write-buffer/</link><pubDate>Fri, 13 Sep 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-innodb-double-write-buffer/</guid><description>&lt;p>从 Double Write Buffer 来看，貌似是内存中的一块缓存区域，实际上，这里的 buffer 并不只是一块内存区域，而是还包括了存放在表空间中或是单独指定的某个文件中的一个 buffer 。&lt;/p>
&lt;p>在此，介绍下为什么会有 Double Write Buffer，以及其是如何实现的。&lt;/p></description></item><item><title>开源协议简介</title><link>https://gohalo.github.io/cn/blog/opensource-license/</link><pubDate>Tue, 10 Sep 2019 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/opensource-license/</guid><description/></item><item><title>Drone 使用</title><link>https://gohalo.github.io/cn/blog/cicd-drone-introduce/</link><pubDate>Mon, 26 Aug 2019 21:38:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cicd-drone-introduce/</guid><description>&lt;p>相对于常见的 Jenkins 来说，其非常简洁，同时拥有可以满足基本需求的能力，并且提供了许多实用的插件，如 GitHub、Gogs、Email 等等，再结合 Gogs 可以实现持续集成和持续部署的方案。&lt;/p></description></item><item><title>MySQL 自带工具</title><link>https://gohalo.github.io/cn/blog/mysql-tools-internal/</link><pubDate>Mon, 19 Aug 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-tools-internal/</guid><description>&lt;p>简单介绍下 MySQL 中自带的工具集。&lt;/p></description></item><item><title>关于 OSCP 的基本概念以及使用介绍</title><link>https://gohalo.github.io/cn/blog/ssl-oscp-introduce/</link><pubDate>Thu, 15 Aug 2019 20:19:43 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssl-oscp-introduce/</guid><description>&lt;p>对于颁发的证书，如果因为一些特殊原因，例如私钥泄漏、证书信息有误、颁发了其它域名证书等等，这样，就需要吊销某些证书，这里关键就是浏览器或客户端如何知道当前使用的证书已经被吊销了。&lt;/p>
&lt;p>为了解决这一问题，引入了 Certificate Revocation List, CRL 和 Online Certificate Status Protocol, OCSP 技术，前者需要用户定期下载用于脱机使用，后者则可实时在线查询。&lt;/p></description></item><item><title>通过 CMake 进行测试</title><link>https://gohalo.github.io/cn/blog/cmake-unit-test-introduce/</link><pubDate>Sat, 10 Aug 2019 19:29:21 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-unit-test-introduce/</guid><description>&lt;p>CMake 除了提供自动编译的工具之外，还可以用来进行测试，提供了一整套基于 ctest 的工具。&lt;/p></description></item><item><title>GoLang pprof 模块介绍</title><link>https://gohalo.github.io/cn/blog/golang-common-module-pprof-performace-introduce/</link><pubDate>Mon, 05 Aug 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-pprof-performace-introduce/</guid><description>&lt;p>GoLang 提供了非常强大的代码性能分析工具 pprof，可以非常方便的分析代码运行性能，同时非常直观。&lt;/p></description></item><item><title>LSM 详解</title><link>https://gohalo.github.io/cn/blog/lsm-tree-introduce/</link><pubDate>Thu, 01 Aug 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lsm-tree-introduce/</guid><description>&lt;!-- The Log-Structured Merge-Tree (LSM-Tree) --></description></item><item><title>洗牌算法</title><link>https://gohalo.github.io/cn/blog/algorithm-shuffling-method-introduce/</link><pubDate>Thu, 01 Aug 2019 22:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-shuffling-method-introduce/</guid><description>&lt;p>需要保证是一个公平的随机算法，首先介绍如何打乱，然后是如何判断已经打乱，也就是符合均匀分布，满足公平。&lt;/p></description></item><item><title>GoLang Delve 调试工具</title><link>https://gohalo.github.io/cn/blog/golang-debug-delve/</link><pubDate>Tue, 23 Jul 2019 22:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-debug-delve/</guid><description>&lt;p>Delve 是 GoLang 的三方调试器，相比 GDB 来说能更好的理解 GoLang 的运行时，包括数据结构、表达式等，目前支持 Linux、Windows 以及 Mac 等平台。&lt;/p></description></item><item><title>InnoDB 存储空间</title><link>https://gohalo.github.io/cn/blog/mysql-innodb-storage/</link><pubDate>Tue, 23 Jul 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-innodb-storage/</guid><description>&lt;p>InnoDB 表空间 (table space) 用来组织存储保存的数据，本文中对表空间管理进行分析。&lt;/p></description></item><item><title>Python StatsModels 简介</title><link>https://gohalo.github.io/cn/blog/python-statsmodels-package-introduce/</link><pubDate>Thu, 18 Jul 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-statsmodels-package-introduce/</guid><description>&lt;p>一个 Python 库，提供了经典频率学派统计方法，包括了多种统计模型。&lt;/p></description></item><item><title>Dockerfile 简介</title><link>https://gohalo.github.io/cn/blog/docker-dockerfile/</link><pubDate>Thu, 11 Jul 2019 21:48:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-dockerfile/</guid><description>&lt;p>Dockerfile 可以用来创建一个镜像，允许在该文件中调用一些命令行中的命令，这样可以利用一个基础镜像，然后附加一些基础操作，最后直接自动生成新镜像。&lt;/p></description></item><item><title>MCMC 采样 - Metropolis</title><link>https://gohalo.github.io/cn/blog/math-monte-carlo-mcmc-metropolis/</link><pubDate>Tue, 02 Jul 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-monte-carlo-mcmc-metropolis/</guid><description>&lt;p>在介绍贝叶斯算法时，有讨论如何计算后验概率，适用于一些简单的分布，例如可以通过共轭先验进行简化。&lt;/p>
&lt;p>但是对于一些复杂的场景，很难进行简化，那么就需要借助 MCMC 工具了。&lt;/p></description></item><item><title>Linux Alternatives 命令使用</title><link>https://gohalo.github.io/cn/blog/linux-command-alternatives-introduce/</link><pubDate>Thu, 13 Jun 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-alternatives-introduce/</guid><description>&lt;p>在 Linux 中，对于相同的功能可能会存在多种的实现，例如查看文件可以使用 head、tail、cat 等；而且，即使相同软件可能会有多个版本，例如 Python 有 2.X、3.X 版本，等等。&lt;/p>
&lt;p>为了统一命令、方便管理，就可以使用 Linux 中的 alternatives 命令，这里简单介绍。&lt;/p></description></item><item><title>VIM技巧 -- 自动换行</title><link>https://gohalo.github.io/cn/blog/vim-auto-return/</link><pubDate>Wed, 12 Jun 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-auto-return/</guid><description> 自动换行 # 输入时，默认 Vim 是不会自动换行的，可以通过设定 :set textwidth=29 选项，让 Vim 自动在第 30 列换行，注意，对于已经存在的文本是不会换行的，也超过制定长度后也不会换行。
这里的换行不会添加 EOL 符号，而只是影响显示。希望允许设置显示的最大宽度，超过之后可以不显示或者换行，如果换行，那么上下切换行的时候就不要再以原有的行进行切换。
通过设置 linebreak=true 可以只在分词的时候进行换行，而设置为 false 时会在对应的字符位置直接换行。
换行切换 # 一行因为过长自动换行之后，可以通过 gj 切换，为了保持与之前的快捷键统一，那么就可以使用如下的映射。
noremap j gj noremap k gk</description></item><item><title>Linux 可执行文件解析工具</title><link>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</link><pubDate>Sat, 08 Jun 2019 21:19:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-tools-executable-binary-parse/</guid><description>&lt;p>主要是在如何解析 ELF 格式的文件。&lt;/p></description></item><item><title>GoLang 逃逸分析</title><link>https://gohalo.github.io/cn/blog/golang-escape-analysis-introduce/</link><pubDate>Mon, 03 Jun 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-escape-analysis-introduce/</guid><description/></item><item><title>Prometheus 监控系统</title><link>https://gohalo.github.io/cn/blog/monitor-system-prometheus-introduce/</link><pubDate>Sat, 01 Jun 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/monitor-system-prometheus-introduce/</guid><description>&lt;p>一套开源的时序数据存储方案，同时包含了前端的页面展示。&lt;/p></description></item><item><title>数据预处理</title><link>https://gohalo.github.io/cn/blog/machine-learning-pre-processing-methods-introduce/</link><pubDate>Wed, 22 May 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/machine-learning-pre-processing-methods-introduce/</guid><description/></item><item><title>Linux 常用配置</title><link>https://gohalo.github.io/cn/blog/linux-basic-common-setup/</link><pubDate>Tue, 21 May 2019 20:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-basic-common-setup/</guid><description>&lt;p>这里简单整理在 Linux 安装过程中常见的配置。&lt;/p></description></item><item><title>采样算法</title><link>https://gohalo.github.io/cn/blog/math-monte-carlo-sample/</link><pubDate>Sun, 12 May 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-monte-carlo-sample/</guid><description>&lt;p>经常会在各类的算法中看到 &amp;ldquo;蒙特卡罗&amp;rdquo; (Monte Carlo) 的字样，例如 Markov Chain Monte Carlo, MCMC、以及 AlphaGo 使用的蒙特卡洛搜索树。&lt;/p>
&lt;p>在使用 Monte-Carlo 时，除了所谓的采样之外，在解决贝叶斯问题的时候，很多地方还使用了积分，这时就是通过 Monte-Carlo 的样本和去近似积分。&lt;/p>
&lt;p>而所谓的采样，实际上就是根据某种分布去生成一些数据点，最简单的例如抛硬币、掷骰子等，服从均匀分布。&lt;/p></description></item><item><title>OpenSSL 常用命令</title><link>https://gohalo.github.io/cn/blog/linux-network-command-openssl/</link><pubDate>Fri, 10 May 2019 22:08:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-openssl/</guid><description>&lt;p>OpenSSL 除了提供一个开发库之外，还包括了一些常用的命令，这里简单介绍其使用方式。&lt;/p></description></item><item><title>MySQL 复制方式</title><link>https://gohalo.github.io/cn/blog/mysql-replication/</link><pubDate>Wed, 08 May 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-replication/</guid><description>MySQL 的复制包括了多种方式，一种是基于 Binlog 的原生复制方式，除此之外，还包括了通过插件实现的 semi-sync 复制。另外，针对 InnoDB 实现的 xtrabackup 也可以作为一种复制方式。
在本文中，简单介绍下 MySQL 中的复制方式。
简介 # MySQL 在复制时，可以指定要忽略的数据库、需要复制的数据库甚至具体那些表；支持异步复制、半同步复制、同步复制 (NDB Cluster, Group Replication)、延迟复制等模式。
在进行复制的时候，有两种格式： Statement Based、Row Based，也可以是两者的组合，在配置文件中通过 binlog_format 参数进行设置；后面再介绍与格式相关的内容。
其中，MySQL 的复制原理如下图所示。
在主服务器上，会将数据的更新写入到 binary log 中，而备服务器会从该文件中读取对数据的更改；每次备服务器链接到主时，都会分配一个单独的线程进行处理；该线程会将 binlog 产生的事件发送到备服务器。
通常来说，主服务器会直接从缓存中读取 binlog ，所以不会对磁盘造成压力；但是，如果读取的数据是半小时，甚至更长事件之前的数据，那么就会不可避免的发生磁盘 IO 。
备服务器 # 在备服务器上有两个线程，分别是 IO Thread 以及 SQL Thread 。
IO Thread 线程会从主服务器读取数据，然后保存到本地的日志文件 relay log，该线程当前的状态可以通过 show slave status 查看。
SQL thread 会读取本地的 relay log，然后将相应的语句写入到数据库。
延迟复制 # 当发生延迟复制 (Replication Lag) 时，通常是由于 SQL 线程延迟导致的，当然，最好是通过 show slave status 查看两个线程的状态。如果是 IO 线程导致，最好是打开压缩协议，减小网络 IO 的消耗量。</description></item><item><title>X509 证书内容详细介绍</title><link>https://gohalo.github.io/cn/blog/ssl-x509-certification-details/</link><pubDate>Tue, 07 May 2019 20:08:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssl-x509-certification-details/</guid><description>&lt;p>在 X509 标准中，规定了证书包含的信息，同时说明了记录信息的方法，也就是详细的证书格式。&lt;/p>
&lt;p>这里详细介绍其基本概念。&lt;/p></description></item><item><title>TLS/SSL CipherSuite 简介</title><link>https://gohalo.github.io/cn/blog/security-ssl-tls-ciphersuites/</link><pubDate>Mon, 06 May 2019 21:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-ssl-tls-ciphersuites/</guid><description>&lt;p>直接翻译为加密套件，在 TLS/SSL 中实际上包含了四类，用来完成握手阶段的信息交互，决定了后续信息交互的过程，包括了认证、加解密、密钥交换等所使用的算法。&lt;/p>
&lt;p>这里会简单介绍所支持的算法，以及如何在 OpenSSL 中使用。&lt;/p></description></item><item><title>GoLang 陷阱</title><link>https://gohalo.github.io/cn/blog/golang-some-pitfalls-introduce/</link><pubDate>Fri, 03 May 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-some-pitfalls-introduce/</guid><description>&lt;p>简单列举一些 GoLang 中容易犯的错误。&lt;/p></description></item><item><title>Bash 常用技巧整理</title><link>https://gohalo.github.io/cn/blog/bash-some-tips/</link><pubDate>Wed, 01 May 2019 23:19:07 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-some-tips/</guid><description>&lt;p>整理一些常见 Bash 的使用技巧，例如 Here Document、特殊字符文件处理、字符集设置等。&lt;/p></description></item><item><title>GoLang 内存模型</title><link>https://gohalo.github.io/cn/blog/golang-concept-memory-module-introduce/</link><pubDate>Wed, 01 May 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-memory-module-introduce/</guid><description>&lt;p>在 Golang 中所谓的内存模型，定义的是，对多个协程中共享的变量，一个协程中怎样可以看到其它协程的写入。&lt;/p>
&lt;p>当多个协程同时操作一个数据时，可以通过管道、同步原语 (sync 包中的 Mutex 以及 RWMutex)、原子操作 (sync/atomic 包中)。&lt;/p>
&lt;p>除此之外，为了保证语义的正确性，Golang 还对一些常见的场景做了语义上的约束。&lt;/p></description></item><item><title>GoLang 基本语法介绍</title><link>https://gohalo.github.io/cn/blog/golang-basic-syntax/</link><pubDate>Thu, 25 Apr 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-syntax/</guid><description>&lt;p>简单介绍常见的语法，例如 import、异常处理、反射等。&lt;/p></description></item><item><title>Stan 简介</title><link>https://gohalo.github.io/cn/blog/statistic-tools-stan-introduce/</link><pubDate>Thu, 25 Apr 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/statistic-tools-stan-introduce/</guid><description>&lt;p>概率建模分析使用较多的三个软件有 Stan PyMc3 Edward ，其中后者是 Google 出品的，据说在某些场景下要比 Stan 快很多。&lt;/p>
&lt;p>Stan 是一种语言，可以在生物、物理、工程等领域进行统计建模、数据分析、预测等。&lt;/p></description></item><item><title>背包问题</title><link>https://gohalo.github.io/cn/blog/algorithm-knapsack-problem-introduce/</link><pubDate>Tue, 23 Apr 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-knapsack-problem-introduce/</guid><description>&lt;p>分治算法和动态规划都是将大问题拆解为小问题，前者针对同一个子问题可能会计算多次，而后者则会将中间结果记录下来，通过空间节约时间，而 &lt;code>0-1&lt;/code> 背包问题是最基本的动态规划问题。&lt;/p></description></item><item><title>Prophet 使用简介</title><link>https://gohalo.github.io/cn/blog/prophet-usage-introduce/</link><pubDate>Sat, 20 Apr 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/prophet-usage-introduce/</guid><description>&lt;p>Facebook 提供的 Prophet 算法主要是用来处理单变量的时间序列，对于一些异常数据以及确实的情况可以很好的处理，对于周期性的数据几乎可以全自动地预测未来的走势。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>GoLang Gopher</title><link>https://gohalo.github.io/cn/blog/golang-concept-much-more-gopher-introduce/</link><pubDate>Tue, 16 Apr 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-much-more-gopher-introduce/</guid><description>&lt;p>在人类自然语言学界有一个很著名的 &amp;ldquo;萨丕尔-沃夫&amp;rdquo; 假说，语言影响或决定人类的思维方式。&lt;/p>
&lt;p>Language inuences/determines thought. - Sapir-Whorf hypothesis&lt;/p>
&lt;p>那么 Gopher 的价值观是什么。&lt;/p></description></item><item><title>GoLang 调度机制</title><link>https://gohalo.github.io/cn/blog/golang-concept-scheduler-introduce/</link><pubDate>Mon, 15 Apr 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-scheduler-introduce/</guid><description>&lt;p>在 Go 语言中的核心是协程，其实现在用户态，那么就需要在用户态实现其调度器，在 1.1 版本对调度器进行了重构，也就是现在的 GMP 模型。&lt;/p>
&lt;p>另外，为了防止协程不让出 CPU 导致其它协程饿死，在 1.2 版本加入了强占式调度器。&lt;/p></description></item><item><title>ABI 二进制接口介绍</title><link>https://gohalo.github.io/cn/blog/c-application-binary-interface/</link><pubDate>Wed, 10 Apr 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-application-binary-interface/</guid><description>&lt;p>如果将编译后的代码反汇编，会发现传参过程中有很多寄存器相关的操作，包括了传参、数据的清理等等。&lt;/p>
&lt;p>那么具体是怎么工作的？为什么要按照这一规则？&lt;/p></description></item><item><title>网络 Namespace</title><link>https://gohalo.github.io/cn/blog/linux-namespace-network-introduce/</link><pubDate>Wed, 10 Apr 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-namespace-network-introduce/</guid><description>Namespace # ---- 查看帮助信息 # ip netns help ----- 当前NS的列表 # ip netns list ----- 添加NS，会在/var/run/netns目录下创建 # ip netns add foobar ----- 删除全部或者指定的NS # ip -all netns delete # ip netns delete foobar 对于每个 Network Namespace 来说，它会有自己独立的网卡、路由表、ARP 表、iptables 等和网络相关的资源，通过 ip netns exec 命令可以在 NS 中执行命令。
----- 查看网卡信息 # ip netns exec foobar ip addr ----- lo网卡默认关闭，可以通过如下命令打开 # ip netns exec foobar ip link set lo up ----- ping回环地址 # ip netns exec foobar ping -c 3 127.</description></item><item><title>Docker RunC 简介</title><link>https://gohalo.github.io/cn/blog/docker-component-runc-introduce/</link><pubDate>Mon, 08 Apr 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-component-runc-introduce/</guid><description>&lt;p>OCI 定义了容器运行时标准，runC 是 Docker 按照开放容器格式标准 Open Container Format, OCF 制定的一种具体实现。&lt;/p>
&lt;p>该项目从 Docker 的 libcontainer 中迁移来，实现了容器启停、资源隔离等功能，所以，可以直接通过该工具运行容器。&lt;/p></description></item><item><title>GoLang 反射简介</title><link>https://gohalo.github.io/cn/blog/golang-reflect-introduce/</link><pubDate>Sat, 06 Apr 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-reflect-introduce/</guid><description>&lt;p>与 C/C++ 不同，GoLang 的指针是不支持指针运算和转换，GoLang 是静态语言，所有变量必须标明其类型，不同类型变量不能执行赋值、比较、计算等操作；指针也有其对应的类型，在编译阶段同样会进行检查。&lt;/p>
&lt;p>同时，GoLang 在运行阶段提供了一定的灵活性。&lt;/p></description></item><item><title>Beringei 内存时序数据库</title><link>https://gohalo.github.io/cn/blog/beringei-memory-database-introduce/</link><pubDate>Tue, 02 Apr 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/beringei-memory-database-introduce/</guid><description>&lt;p>Facebook 在 2017.02.03 开源了一个高性能内存时序数据存储引擎 Beringei ，用来解决监控数据的存储和查询需求，具有快速读写、高压缩比等特性。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>git 常见问题整理</title><link>https://gohalo.github.io/cn/blog/git-faqs/</link><pubDate>Mon, 01 Apr 2019 18:38:55 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-faqs/</guid><description>&lt;p>整理下常见的 git 问题。&lt;/p></description></item><item><title>基本优化算法</title><link>https://gohalo.github.io/cn/blog/math-basic-concept-optimize-method/</link><pubDate>Sat, 30 Mar 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-basic-concept-optimize-method/</guid><description/></item><item><title>GoLang 接口源码解析</title><link>https://gohalo.github.io/cn/blog/golang-interface-source-code-introduce/</link><pubDate>Thu, 28 Mar 2019 20:23:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-interface-source-code-introduce/</guid><description/></item><item><title>Linux 子进程创建</title><link>https://gohalo.github.io/cn/blog/c-linux-fork-process-execute/</link><pubDate>Fri, 22 Mar 2019 22:11:22 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-fork-process-execute/</guid><description/></item><item><title>常用 DNS 工具介绍</title><link>https://gohalo.github.io/cn/blog/dns-tools-usage/</link><pubDate>Fri, 22 Mar 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/dns-tools-usage/</guid><description>&lt;p>之前已经介绍了关于 DNS 常见的基本概念，这里会通过一些常见的命令行工具进行验证，例如 getent、nslookup、dig 等等。&lt;/p></description></item><item><title>R 语言绘图</title><link>https://gohalo.github.io/cn/blog/r-language-graph-function-introduce/</link><pubDate>Tue, 19 Mar 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/r-language-graph-function-introduce/</guid><description>&lt;p>原生的 R 语言提供了非常强大的绘图功能，基本不需要其它辅助，就可以绘制非常炫目的图片，再加上各种各样的神级 R 包 (例如 &lt;code>ggplot2&lt;/code>、&lt;code>plotly&lt;/code> 等)，更是如虎添翼。&lt;/p>
&lt;p>另外，Python 语言中的 Matplotlib 库，同样提供了非常强大的绘图功能。&lt;/p></description></item><item><title>K8S Pod 简介</title><link>https://gohalo.github.io/cn/blog/kubernets-components-pod-deployment/</link><pubDate>Tue, 12 Mar 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-components-pod-deployment/</guid><description>&lt;p>K8S 中有各种各样的组件，对于容器来说 K8S 的最小单元由 Pod 进行组成，它封装了一个或多个应用程序的容器、存储资源、网络 IP 以及管理容器的选项。&lt;/p></description></item><item><title>KVM 网路配置介绍</title><link>https://gohalo.github.io/cn/blog/linux-kvm-network-setting/</link><pubDate>Tue, 12 Mar 2019 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kvm-network-setting/</guid><description/></item><item><title>MySQL 插件详解</title><link>https://gohalo.github.io/cn/blog/mysql-plugin/</link><pubDate>Tue, 12 Mar 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-plugin/</guid><description>&lt;p>在 MySQL 中，为了提高其灵活性，很多的功能都是通过插件来实现的，常见的比如 semi-sync、存储引擎、登陆认证等等。因为 MySQL 是 C/C++ 实现的，对于插件来说实际为动态链接库，保存在 plugin_dir 变量对应的目录下。&lt;/p>
&lt;p>在此介绍一下 MySQL 的插件实现。&lt;/p></description></item><item><title>R 语言简介</title><link>https://gohalo.github.io/cn/blog/r-language-basic-introduce/</link><pubDate>Tue, 12 Mar 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/r-language-basic-introduce/</guid><description>&lt;p>R 语言作为统计学一门语言，一直属于一个小众的工具集，直到大数据爆发后，越来越多的人开始使用 R 语言进行数据分析。&lt;/p>
&lt;p>是一套开源的数据分析解决方案，为统计计算和绘图而生的语言和环境，几行简答的代码就可以实现很复杂的功能。&lt;/p></description></item><item><title>Linux C 陷阱</title><link>https://gohalo.github.io/cn/blog/linux-c-some-pitfalls-introduce/</link><pubDate>Sun, 10 Mar 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-some-pitfalls-introduce/</guid><description>&lt;p>一些 C 语言中比较容易犯错的知识点。&lt;/p></description></item><item><title>Golang 竞态检查</title><link>https://gohalo.github.io/cn/blog/golang-race-condition-introduce/</link><pubDate>Fri, 08 Mar 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-race-condition-introduce/</guid><description>&lt;p>Race Conditions 是最隐晦而且难以捉摸的编程错误之一，一般会在代码部署到生产之后很长时间才会发作，但是如果要通过 Golang 进行并发编程，那么就会很容易遇到。&lt;/p>
&lt;p>Go 的并发机制使得编写干净并发代码变得容易，但它们并不能防止竞态条件。&lt;/p></description></item><item><title>GoLang 管道详解</title><link>https://gohalo.github.io/cn/blog/golang-basic-syntax-channel-introduce/</link><pubDate>Fri, 01 Mar 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-syntax-channel-introduce/</guid><description>&lt;p>在 Go 语言中，通过协程和管道实现了 Communicating Sequential Processes, CSP 模型，两者承担了通信和同步中的重要角色。&lt;/p></description></item><item><title>UDP 通讯优化</title><link>https://gohalo.github.io/cn/blog/linux-c-udp-optimize-introduce/</link><pubDate>Wed, 27 Feb 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-udp-optimize-introduce/</guid><description>&lt;p>有部分应用场景采用的仍然是无连接协议，例如 DNS、StatsD 等，都是采用的 UDP 。&lt;/p>
&lt;p>UDP 不是面向连接的，所以不能像 TCP 通过建立多个连接来提高对服务器的并发访问，如果通过多线程共享一个 UDP Socket 可能会无法充分利用所有的 CPU 资源。&lt;/p>
&lt;p>这里简单介绍其优化方法，当然，这里的策略也适用与像 ICMP 这样的协议。&lt;/p></description></item><item><title>内存检查工具</title><link>https://gohalo.github.io/cn/blog/linux-c-some-memory-debugger-tools-introduce/</link><pubDate>Mon, 25 Feb 2019 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-some-memory-debugger-tools-introduce/</guid><description/></item><item><title>GoLang 汇编语言</title><link>https://gohalo.github.io/cn/blog/golang-assembly-language-introduce/</link><pubDate>Sat, 23 Feb 2019 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-assembly-language-introduce/</guid><description>&lt;p>现在的汇编通常作为从高阶语言到机器码的中间产品，表示方式常见的有 Intel 以及 AT&amp;amp;T 两种，不知道为啥 GoLang 选择的是参考 Plan 9 这种汇编语言，其使用的方式与前两者有很大的区别。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>InnoDB Checkpoint</title><link>https://gohalo.github.io/cn/blog/mysql-innodb-checkpoint/</link><pubDate>Fri, 22 Feb 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-innodb-checkpoint/</guid><description>&lt;p>如果 redo log 可以无限地增大，同时缓冲池也足够大，是不是就意味着可以不将缓冲池中的脏页刷新回磁盘上？宕机时，完全可以通过 redo log 来恢复整个数据库系统中的数据。&lt;/p>
&lt;p>显然，上述的前提条件是不满足的，这也就引入了 checkpoint 技术。&lt;/p>
&lt;p>在这篇文章里，就简单介绍下 MySQL 中的实现。&lt;/p></description></item><item><title>Windows WSL 环境使用</title><link>https://gohalo.github.io/cn/blog/windows-wsl-introduce/</link><pubDate>Thu, 21 Feb 2019 20:40:59 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/windows-wsl-introduce/</guid><description>&lt;p>所谓的 WSL 就是 Windows Subsystem for Linux 的缩写，意思是 Linux 版的 Window 子系统，可以在 Windows 上运行 Linux 系统。&lt;/p></description></item><item><title>GoLang 内存管理</title><link>https://gohalo.github.io/cn/blog/golang-concept-memory-management-module-introduce/</link><pubDate>Wed, 20 Feb 2019 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concept-memory-management-module-introduce/</guid><description>&lt;p>在 C 语言中，通过 &lt;code>malloc()&lt;/code> 函数可以动态分配内存，常用的有 ptmalloc2(glib)、tcmalloc(Google)、jemaloc(FaceBook)，后两者在避免内存碎片以及性能上都有较大的优势。&lt;/p>
&lt;p>而 Go 中的内存分配器，其原理与 tcmalloc 类似，简单的说就是维护一块大的全局内存，每个线程 (P) 维护一块小的私有内存，私有内存不足再从全局申请。&lt;/p></description></item><item><title>基本算法介绍</title><link>https://gohalo.github.io/cn/blog/algorithm-basic-concept/</link><pubDate>Wed, 20 Feb 2019 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/algorithm-basic-concept/</guid><description>&lt;p>这里简单介绍一下递归、分治算法、动态规划、贪心算法、回溯算法的区别和联系。&lt;/p></description></item><item><title>机器学习基本概念介绍</title><link>https://gohalo.github.io/cn/blog/machine-learning-basic-introduce/</link><pubDate>Fri, 15 Feb 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/machine-learning-basic-introduce/</guid><description/></item><item><title>CMake 使用简介</title><link>https://gohalo.github.io/cn/blog/cmake-basic-introduce/</link><pubDate>Mon, 11 Feb 2019 17:49:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-basic-introduce/</guid><description>&lt;p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，对于简单的程序来说是可以的，当项目变得复杂之后会很难进行维护。&lt;/p>
&lt;p>而目前在维护 C/C++ 项目时，使用比较多的是 CMake ，这里就详细介绍下 CMake 的使用。&lt;/p></description></item><item><title>Memory Reordering 简析</title><link>https://gohalo.github.io/cn/blog/linux-c-memory-reordering-introduce/</link><pubDate>Fri, 01 Feb 2019 19:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-memory-reordering-introduce/</guid><description>&lt;p>以 C 语言为例，在编写完源代码之后，需要经过编译，然后在 CPU 上运行，为了提高代码的执行效率，在编译阶段和运行阶段会执行乱序优化，但同时也带来了一些副作用。&lt;/p>
&lt;p>这里简单介绍内存乱序的基本概念。&lt;/p></description></item><item><title>C/CPP 静态链接顺序</title><link>https://gohalo.github.io/cn/blog/c-cpp-static-linkage/</link><pubDate>Mon, 28 Jan 2019 22:10:33 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-cpp-static-linkage/</guid><description>&lt;p>静态链接和动态链接最大的区别就在于链接的时机不一样，静态链接是在生车可执行程序前，而动态链接的进行则是在程序执行时，而且静态链接库的位置不同将会影响二进制文件生成。&lt;/p></description></item><item><title>git 对象简介</title><link>https://gohalo.github.io/cn/blog/git-internal-object-introduce/</link><pubDate>Mon, 21 Jan 2019 19:38:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-internal-object-introduce/</guid><description>&lt;p>git 作为当前最流行的版本管理工具，简单、易用，而且功能强大，不过其依托的是一组极为简洁的数据结构。&lt;/p>
&lt;p>这里简单介绍其核心概念。&lt;/p></description></item><item><title>Linux PID 分配方法</title><link>https://gohalo.github.io/cn/blog/linux-pid-allocate-method-introduce/</link><pubDate>Sat, 19 Jan 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-pid-allocate-method-introduce/</guid><description>&lt;p>在 Linux 系统中，每个进程都有一个非负整型表示的唯一进程 ID，虽然在主机级别是唯一的，但是进程的 ID 可以重用，一个进程停止后，其它的进程可以复用该 ID 。&lt;/p>
&lt;p>Linux 采用延迟重用的算法，在大部分场景下会使得新进程 ID 不同于最近终止进程所使用的 ID，以防止将新进程误认为是使用同一 ID 的某个已终止的先前进程。&lt;/p>
&lt;p>这里主要讨论了 Linux 中分配进程 ID 的方法以及源码实现。&lt;/p></description></item><item><title>K8S Pause</title><link>https://gohalo.github.io/cn/blog/kubernets-basic-components-pause/</link><pubDate>Sat, 12 Jan 2019 21:50:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kubernets-basic-components-pause/</guid><description>&lt;p>在 K8S 的 Slave 节点上，除了本身启动的容器外，还会看到很多的 Pause 容器，一般是一个 Pod 会对应一个 Pause 。&lt;/p>
&lt;p>那么这个 Pause 的用途是什么？&lt;/p></description></item><item><title>ProxySQL 简单介绍</title><link>https://gohalo.github.io/cn/blog/proxysql-basic-introduce/</link><pubDate>Fri, 11 Jan 2019 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/proxysql-basic-introduce/</guid><description>&lt;p>一个强大灵活的 MySQL 代理层，支持读写分离、Query 路由、配置动态加载、故障切换等等。&lt;/p></description></item><item><title>LVM 简介</title><link>https://gohalo.github.io/cn/blog/linux-logical-volume-manager-lvm-introduce/</link><pubDate>Thu, 10 Jan 2019 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-logical-volume-manager-lvm-introduce/</guid><description>&lt;p>在最初对磁盘分区的大小进行规划时，很难确定其真正使用的磁盘空间，那在后续的管理时就非常麻烦，实际上类似的问题可以通过 LVM 进行管理。&lt;/p>
&lt;p>Logical Volume Manager, LVM 一般翻译为 &amp;ldquo;逻辑卷管理&amp;rdquo;，它是 Linux 下对磁盘分区进行管理的一种机制，在磁盘分区和文件系统之间的一个逻辑层，可以灵活的调整分区大小。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>Linux Write API 简介</title><link>https://gohalo.github.io/cn/blog/linux-kernel-vfs-multi-write-methods-introduce/</link><pubDate>Tue, 08 Jan 2019 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-vfs-multi-write-methods-introduce/</guid><description>&lt;p>之前其实已经介绍过，Linux 中有条设计原则，&amp;ldquo;一切都是文件&amp;rdquo; 。&lt;/p>
&lt;p>对于文件的操作除了 &lt;code>open()&lt;/code> &lt;code>close()&lt;/code> 之外，使用比较多的就是 &lt;code>read()&lt;/code> 和 &lt;code>write()&lt;/code> 函数了，为了适配不同的应用场景，实际上，Linux 还提供了 &lt;code>writev()&lt;/code> &lt;code>pwrite()&lt;/code> 之类的函数。&lt;/p>
&lt;p>那么，这些函数的区别、使用场景是什么。&lt;/p></description></item><item><title>Python 语法简介</title><link>https://gohalo.github.io/cn/blog/python-basic-syntax-introduce/</link><pubDate>Sun, 30 Dec 2018 20:58:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-basic-syntax-introduce/</guid><description>&lt;p>这里介绍 Python 的基本的语法。&lt;/p></description></item><item><title>Golang 语法之结构体</title><link>https://gohalo.github.io/cn/blog/golang-syntax-structure-introduce/</link><pubDate>Sun, 30 Dec 2018 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-syntax-structure-introduce/</guid><description>&lt;p>类似于 C 中的结构体，也就是用户自定义的类型，它代表若干字段的集合。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>git 多个远端仓库</title><link>https://gohalo.github.io/cn/blog/git-tips-multi-remote-repos/</link><pubDate>Wed, 26 Dec 2018 19:38:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-tips-multi-remote-repos/</guid><description>&lt;p>Git 作为一个分布式的仓库，可以配置多个远端，这里介绍如何将一个本地仓库同步到不同的远端仓库中，最常见的是开源代码时对应了不同仓库地址。&lt;/p></description></item><item><title>DNS 协议详解</title><link>https://gohalo.github.io/cn/blog/network-dns-protocol-details-introduce/</link><pubDate>Fri, 21 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-protocol-details-introduce/</guid><description>&lt;p>也就是做 DNS 解析时，客户端和服务端的通讯协议，详见 &lt;a href="https://www.ietf.org/rfc/rfc1035.txt">RFC1035 4.MESSAGES&lt;/a> 部分。&lt;/p>
&lt;p>这里简单介绍其基本概念。&lt;/p></description></item><item><title>替换 glibc malloc</title><link>https://gohalo.github.io/cn/blog/linux-c-program-replace-glibc-memory-function/</link><pubDate>Wed, 19 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-program-replace-glibc-memory-function/</guid><description>&lt;p>在进行系统优化、内存泄漏测试时，经常需要对 glibc 的一些 API 进行替换，例如比较常见的是内存管理接口。&lt;/p>
&lt;p>如果代码量很大，或者使用了三方的静态库时，此时就无法直接替换相关的函数，例如 &lt;code>malloc()&lt;/code> &lt;code>realloc()&lt;/code> &lt;code>calloc()&lt;/code> 等，需要直接替换掉系统的相关函数。&lt;/p>
&lt;p>这里简单介绍几种方法。&lt;/p></description></item><item><title>Python Scipy 简介</title><link>https://gohalo.github.io/cn/blog/python-scipy-package-introduce/</link><pubDate>Sat, 15 Dec 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-scipy-package-introduce/</guid><description>&lt;p>Scipy 是一个用于数学、科学、工程领域的常用软件包，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。&lt;/p>
&lt;p>可以有效计算 Numpy 中的矩阵，从而使 Numpy 和 Scipy 可以协同工作，高效解决问题。&lt;/p></description></item><item><title>PyMC 使用简介</title><link>https://gohalo.github.io/cn/blog/python-pymc-package-introduce/</link><pubDate>Thu, 13 Dec 2018 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-pymc-package-introduce/</guid><description>&lt;p>PyMC3 是一个用 Python 编写的开源的概率编程框架，完全通过 Python 代码来定义模型，并使用 Theano 通过变分推理进行梯度计算，并使用 C 实现加速运算。&lt;/p>
&lt;p>目前的 Theano 库已经不再维护，而 PyMC3 团队会单独维护与 PyMC3 相关的一些特性。&lt;/p></description></item><item><title>lock-free 编程</title><link>https://gohalo.github.io/cn/blog/linux-c-program-lock-free-queue-introduce/</link><pubDate>Sun, 09 Dec 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-program-lock-free-queue-introduce/</guid><description>&lt;p>简单介绍下无锁编程 (Lock Free) 的概念，并实现一个基本的 Queue 。&lt;/p></description></item><item><title>C 动态参数使用详解</title><link>https://gohalo.github.io/cn/blog/c-dynamic-arguments/</link><pubDate>Sun, 09 Dec 2018 21:40:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-dynamic-arguments/</guid><description>&lt;p>在使用过程中，通常会有参数个数不确定，最常见的是 &lt;code>printf&lt;/code> 这类的函数，只有在使用时才能确定参数的个数以及其类型。&lt;/p>
&lt;p>这里详细介绍其使用以及基本原理。&lt;/p></description></item><item><title>Bash 自动补全机制详解</title><link>https://gohalo.github.io/cn/blog/bash-auto-completion-introduce/</link><pubDate>Sat, 08 Dec 2018 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-auto-completion-introduce/</guid><description>&lt;p>在 Linux 命令行中，当输入字符后，按两次 &lt;code>Tab&lt;/code> 键，Shell 就会列出以这些字符打头的所有可用命令，如果只有一个命令匹配到，按一次 &lt;code>Tab&lt;/code> 键就自动将这个命令补全。&lt;/p>
&lt;p>比如，如果想更改密码，但只记得这个命令前几个字母是 pa，此时按 &lt;code>Tab&lt;/code> 键 Shell 就会自动补全 passwd 命令，非常方便。除了命令补全，还有路径、文件名补全，这个在通过 cd 命令切换到指定目录时特别好用。&lt;/p>
&lt;p>这里详细介绍其使用方法。&lt;/p></description></item><item><title>LLVM 使用简介</title><link>https://gohalo.github.io/cn/blog/llvm-compiler-infrastructure-introduce/</link><pubDate>Sat, 08 Dec 2018 19:17:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/llvm-compiler-infrastructure-introduce/</guid><description>&lt;p>LLVM 计划启动于 2000 年，由 UIUC 大学的 Chris Lattner 博士主持，后入职 Apple 继续推广，所以 Apple 就成了主要的赞助商。&lt;/p>
&lt;p>最初是 Low Level Virtual Machine 的缩写，不过随着发展，逐渐整合成了一整套的编译工具，所以官方也就放弃了原有的缩写，而修改成 The LLVM Compiler Infrastructure 。&lt;/p>
&lt;p>其强大之处在于模块化，可以很方便适配不同的语言以及硬件平台。&lt;/p></description></item><item><title>逻辑回归</title><link>https://gohalo.github.io/cn/blog/machine-learning-logistic-regression-introduce/</link><pubDate>Thu, 06 Dec 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/machine-learning-logistic-regression-introduce/</guid><description>&lt;p>在机器学习里，有一类比较特殊的算法，就是逻辑回归 (Logistic Regression)，虽然被称为 &amp;ldquo;回归&amp;rdquo; 算法，实际上却是标准的解决分类问题的模型，也就是采用与回归类似的思路解决了分类问题，严格来说是二分类。&lt;/p>
&lt;p>简单来说，就是建立代价函数，然后通过优化方法迭代求解出最优的模型参数。&lt;/p></description></item><item><title>git lfs 简介</title><link>https://gohalo.github.io/cn/blog/git-large-file-storage-introduce/</link><pubDate>Sat, 01 Dec 2018 19:38:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-large-file-storage-introduce/</guid><description>&lt;p>GIT 代码管理是基于文本文件行的，那么，对于二进制文件来说，当保存每次提交的改动时，会保存整个文件，会导致仓库快速增大，包括了网络带宽。&lt;/p>
&lt;p>在 2015.04 GitHub 推出了 Large File Storage, LFS 将标记的大文件保存在另外的仓库，而主仓库仅保留其轻量级指针。&lt;/p></description></item><item><title>Bash 生成随机内容</title><link>https://gohalo.github.io/cn/blog/bash-tips-random-content/</link><pubDate>Fri, 30 Nov 2018 23:30:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-tips-random-content/</guid><description>&lt;p>在编写代码时，一般会使用伪随机函数，不过对于安全通讯往往存在风险，Linux 提供了随机生成设备，可以提供基本满足真随机内容。&lt;/p>
&lt;p>这里介绍常见的使用技巧。&lt;/p></description></item><item><title>Protobuf 序列化详解</title><link>https://gohalo.github.io/cn/blog/protobuf-protocol-serialize-details/</link><pubDate>Sat, 24 Nov 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-protocol-serialize-details/</guid><description>&lt;p>类似于 JSON、XML 格式，Protocol Buffer 是 Google 出品的一种轻量而且高效的结构化数据存储格式，性能比 JSON、XML 要强很多，包括其序列化、反序列化速度，数据压缩效果。&lt;/p>
&lt;p>当然，带来的问题是可读性不高。&lt;/p></description></item><item><title>线性回归 贝叶斯介绍</title><link>https://gohalo.github.io/cn/blog/machine-learning-linear-regression-bayes-introduce/</link><pubDate>Thu, 22 Nov 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/machine-learning-linear-regression-bayes-introduce/</guid><description/></item><item><title>Linux 常用命令 inotify 介绍</title><link>https://gohalo.github.io/cn/blog/linux-command-inotify-introduce/</link><pubDate>Wed, 21 Nov 2018 23:10:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-inotify-introduce/</guid><description>&lt;p>在 Linux 系统下 inotify 是一种强大的、细粒度的、异步的文件系统事件监控机制，通过该机制可以快速感知文件的变化，这样可以用于一些文件的实时同步。&lt;/p></description></item><item><title>Huffman 编码简介</title><link>https://gohalo.github.io/cn/blog/huffman-introduce/</link><pubDate>Tue, 20 Nov 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/huffman-introduce/</guid><description>&lt;p>哈夫曼编码 Huffman Coding 是一种变长的前缀码，使用的算法是 David A. Huffman 还在 MIT 的学生时提出的，并且在 1952 年发表了名为 &lt;code>A Method for the Construction of Minimum-Redundancy Codes&lt;/code> 的文章。&lt;/p>
&lt;p>编码过程叫做哈夫曼编码，是一种普遍的熵编码技术，包括用于无损数据压缩领域。&lt;/p></description></item><item><title>HTTP2 HPACK 介绍</title><link>https://gohalo.github.io/cn/blog/network-http2-hpack-introduce/</link><pubDate>Fri, 16 Nov 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http2-hpack-introduce/</guid><description>&lt;p>Google 直接在 HTTP1.X 的基础上设计了 SPDY 协议，对头部使用 deflate 算法进行压缩，一并解决了多路复用和优先级等问题。而 HTTP2 的实现就是参考了 SPDY 协议，但是专门为头部压缩设计了一套压缩算法，就是这里的 HPACK 。&lt;/p></description></item><item><title>Linux Socket 端口使用</title><link>https://gohalo.github.io/cn/blog/linux-socket-port-range-introduce/</link><pubDate>Tue, 13 Nov 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-socket-port-range-introduce/</guid><description>&lt;p>Linux 使用的 TCP/IP 协议栈会使用四元组，在客户端与服务端建立链接的时候一般无需指定端口，可以直接使用系统默认指定的端口。&lt;/p>
&lt;p>当然，也可以指定固定的端口，不过此时可能会导致端口冲突。&lt;/p></description></item><item><title>Linux 进程退出码</title><link>https://gohalo.github.io/cn/blog/linux-process-exit-code-introduce/</link><pubDate>Sun, 04 Nov 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-exit-code-introduce/</guid><description>&lt;p>Linux 下进程的退出包括了正常退出和异常退出，正常退出包括了 A) &lt;code>main()&lt;/code> 函数中通过 &lt;code>return&lt;/code> 返回；B) 调用 &lt;code>exit()&lt;/code> 或者 &lt;code>_exit()&lt;/code> 退出。异常退出包括了 A) &lt;code>abort()&lt;/code> 函数；B) 收到了信号退出。&lt;/p>
&lt;p>不管是哪种退出方式，系统最终都会执行内核中的同一代码，并将进程的退出方式以返回码的方式保存下来。&lt;/p></description></item><item><title>数据集简介</title><link>https://gohalo.github.io/cn/blog/machine-learning-some-datasets-introduce/</link><pubDate>Tue, 30 Oct 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/machine-learning-some-datasets-introduce/</guid><description>&lt;p>简单来说，就是准备所需的数据，包括一些从官方下载的数据，动态生成的测试数据，以及部分经典的函数等。&lt;/p></description></item><item><title>APM 分布式跟踪系统</title><link>https://gohalo.github.io/cn/blog/monitor-apm-introduce/</link><pubDate>Tue, 23 Oct 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/monitor-apm-introduce/</guid><description>&lt;p>目前的产品架构，分布式系统得到了大范围的应用，使得系统更加灵活，不过同时也给开发、运维人员也带来了很大的难题，如何监控和优化分布式系统的行为。&lt;/p>
&lt;p>这里简单介绍下一个小众、简单的 APM 监控工具。&lt;/p></description></item><item><title>Google Benchmark 使用详解</title><link>https://gohalo.github.io/cn/blog/cpp-google-benchmark/</link><pubDate>Mon, 22 Oct 2018 23:12:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-google-benchmark/</guid><description>&lt;p>Google 提供的 Benchmark 工具是一款强大的性能压测工具，易于安装和使用，并提供了全面的性能测试接口。&lt;/p></description></item><item><title>HTTP2 协议简介</title><link>https://gohalo.github.io/cn/blog/network-http2-protocol-introduce/</link><pubDate>Tue, 16 Oct 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http2-protocol-introduce/</guid><description>&lt;p>HTTP2 也就是超文本传输协议第 2 版，基于 TCP 连接的一个上层协议，允许在一个 TCP 连接上多路复用，支持优先级、流量控制、服务器推送、首部HPACK压缩、&lt;/p>
&lt;p>保持了与 HTTP1 相同的基本语义，例如 方法语义 (GET PUST PUT DELETE 等)、状态码 (200 404 500 等)、URL 等等，相比来说做了如下的优化。&lt;/p>
&lt;p>通过单个 TCP 连接支持多个通道；头部压缩，解析会更快、更小等等。&lt;/p></description></item><item><title>Bash 模拟终端介绍</title><link>https://gohalo.github.io/cn/blog/bash-terminal-emulator/</link><pubDate>Tue, 16 Oct 2018 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-terminal-emulator/</guid><description>&lt;p>Bash 是一个交互程序，不过现在都是基于虚拟终端来实现，不同虚拟终端支持能力各有区别，这里简单介绍。&lt;/p></description></item><item><title>GCC 强弱符号、引用基本介绍</title><link>https://gohalo.github.io/cn/blog/c-strong-weak-symbol-reference/</link><pubDate>Sat, 13 Oct 2018 18:19:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-strong-weak-symbol-reference/</guid><description>&lt;p>在编程时经常会碰到一种情况叫符号重复定义，一般意味着多个目标文件中含有相同名字全局符号的定义，而有时又不会报错，为什么？&lt;/p>
&lt;p>在 glibc 中定义了很多类似 &lt;code>read()&lt;/code> &lt;code>open()&lt;/code> 的函数，但是又可以自己定义相同的函数？&lt;/p>
&lt;p>这就涉及到了强弱符号以及强弱引用的概念了，这里详细介绍。&lt;/p></description></item><item><title>SQLite 优化实践</title><link>https://gohalo.github.io/cn/blog/sqlite-optimize-introduce/</link><pubDate>Tue, 09 Oct 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/sqlite-optimize-introduce/</guid><description>&lt;p>SQLite 的写入性能与磁盘的性能有很大的关系，例如在 SATA 上可能只有 100 左右，在 SSD 上大概有 1K 左右，如果直接使用 RAMDisk 测试能达到 1W 以上。除此之外，还可以通过一些方法进行相关的优化。&lt;/p></description></item><item><title>Python Numpy 简介</title><link>https://gohalo.github.io/cn/blog/python-numpy-package-introduce/</link><pubDate>Tue, 09 Oct 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-numpy-package-introduce/</guid><description>&lt;p>NumPy 是 Python 的一个扩充程序库，支持高级大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库。内部解除了 Python 的 PIL (全局解释器锁)，同时使用 C/C++ 做扩展，运算效率极好，是大量机器学习框架的基础库。&lt;/p></description></item><item><title>MySQL GTID 简介</title><link>https://gohalo.github.io/cn/blog/mysql-gtid/</link><pubDate>Mon, 08 Oct 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-gtid/</guid><description>&lt;p>全局事务 ID (Global Transaction ID, GTID) 是用来强化数据库在主备复制场景下，可以有效保证主备一致性、提高故障恢复、容错能力。&lt;/p>
&lt;p>接下来，看看 GTID 是如何实现的，以及如何使用。&lt;/p></description></item><item><title>C 语言 inline 简介</title><link>https://gohalo.github.io/cn/blog/language-c-inline-concept-introduce/</link><pubDate>Fri, 05 Oct 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-inline-concept-introduce/</guid><description>&lt;p>在 C 语言中，调用函数时会在栈空间生成一个函数调用栈，如果函数嵌套过深则会导致大量的栈空间消耗，甚至是溢出。内联函数的引入就是解决一些频繁调用小函数时的大量栈空间消耗问题，这是 C99 的新增特性。&lt;/p></description></item><item><title>微积分基本概念</title><link>https://gohalo.github.io/cn/blog/math-calculus-basic-concept/</link><pubDate>Thu, 04 Oct 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-calculus-basic-concept/</guid><description/></item><item><title>Linux 常用命令 rsync 介绍</title><link>https://gohalo.github.io/cn/blog/linux-command-rsync-introduce/</link><pubDate>Mon, 01 Oct 2018 21:10:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-rsync-introduce/</guid><description>&lt;p>rsync 是一个远程数据同步工具，使用 &amp;ldquo;rsync算法&amp;rdquo; 来使本地和远程两个主机之间的文件达到同步，该算法只传送两个文件的不同部分，从而可以有效提高传输效率，而且本地复制文件也可以提高效率。&lt;/p></description></item><item><title>概率论基本概念</title><link>https://gohalo.github.io/cn/blog/math-probability-basic-concept/</link><pubDate>Mon, 01 Oct 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-probability-basic-concept/</guid><description/></item><item><title>C 宏使用技巧</title><link>https://gohalo.github.io/cn/blog/c-macros-basic-concepts-introduce/</link><pubDate>Sun, 30 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-macros-basic-concepts-introduce/</guid><description>拼接宏 # 其中 # 把宏的参数直接替换为字符串，不进行替换；而 ## 会把两个宏参数贴在一起。注意，当宏参数是另一个宏时，只要宏定义用到了 # 或 ## 的地方，其宏参数都不会再展开。
#include &amp;lt;stdio.h&amp;gt; #define INT_MAX 0x7FFFFFFF #define STRING(s) #s #define A 2 #define CONCAT(a, b) (int)(a##e##b) int main(void) { int AeA = 55; puts(STRING(INT_MAX)); // INT_MAX printf(&amp;#34;%d\n&amp;#34;, CONCAT(A, A)); // 55 return 0; } 如果将 CONCAT 宏定义修改为 (int)((a##e##b) + a) ，那么结果为 57 。
其中 A 和 INT_MAX 都是宏，而且做为了 STRING 和 CONCAT 的参数，但是因为存在 # 或者 ## 符号，所以其中的 A 和 INT_MAX 都没有展开。</description></item><item><title>SQLite 源码解析</title><link>https://gohalo.github.io/cn/blog/sqlite-sourcecode-analyze/</link><pubDate>Sat, 29 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/sqlite-sourcecode-analyze/</guid><description>&lt;p>SQLite 嵌入到使用它的应用程序中，它们共用相同的进程空间，而不是单独的一个进程，从外部看，它并不像一个 RDBMS，但在进程内部，它却是完整的，自包含的数据库引擎。&lt;/p>
&lt;p>核心大约有 3W 行标准 C 代码，这些代码都是模块化的，很容易阅读，如下简单介绍。&lt;/p></description></item><item><title>Linux GCC 常用技巧</title><link>https://gohalo.github.io/cn/blog/language-c-gcc-some-basic-tips/</link><pubDate>Thu, 27 Sep 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-gcc-some-basic-tips/</guid><description/></item><item><title>GoLang 闭包简介</title><link>https://gohalo.github.io/cn/blog/golang-basic-closure-introduce/</link><pubDate>Tue, 25 Sep 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-closure-introduce/</guid><description>&lt;p>在很多语言里实际上都支持闭包，例如 Python、Lua 等，GoLang 实际上也支持，功能基本类似，如果对闭包的概念比较熟悉，实际上也很好理解。&lt;/p>
&lt;p>这里简单介绍其概念以及常见的错误使用场景。&lt;/p></description></item><item><title>容器之 CGroup</title><link>https://gohalo.github.io/cn/blog/linux-container-cgroup-introduce/</link><pubDate>Fri, 21 Sep 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-container-cgroup-introduce/</guid><description>&lt;p>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制进程组使用资源的机制，该项目最早是由 Google 的工程师 (主要时 Paul Menage 和 Rohit Seth) 在 2006 年发起，开始被称为进程容器 (Process Containers)。&lt;/p>
&lt;p>在 2007 年，因为 Linux 内核中容器这一名词太过广泛，为避免混乱，重命名为 cgroup ，并且合并到 2.6.24 版本的内核中。&lt;/p>
&lt;p>随着其功能逐渐完善，开始作为 LXC、容器等资源隔离机制的基础，这里详细介绍其使用机制。&lt;/p></description></item><item><title>Linux C 数据对齐</title><link>https://gohalo.github.io/cn/blog/c-structure-align-basic-introduce/</link><pubDate>Thu, 20 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-structure-align-basic-introduce/</guid><description>&lt;p>C 语言中的结构体包含了各种成员，编译器会将结构体中的每个成员按其自然边界分配空间，合理的设置对齐规则，可以提高 CPU 的访问速度 (有些 CPU 会禁止非对齐，会抛出硬件异常)，降低结构体的占用空间。&lt;/p></description></item><item><title>Linux C 位域和大小端</title><link>https://gohalo.github.io/cn/blog/c-bit-field-and-endian-introduce/</link><pubDate>Tue, 18 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-bit-field-and-endian-introduce/</guid><description>在处理通讯协议时，经常需要按照字节甚至是位进行处理，例如 MySQL 协议，那么对于 C 而言如何方便的进行处理呢？ 另外，网络通讯时采用的是大端，到底是啥意思？
简介 # 在编写代码的时候，很大一部分工作是在不同的格式之间进行转换，从外部的数据结构转换成内部使用的结构，例如网络包 (TCP/IP、MySQL协议等)、磁盘文件 (GIF、JPEG等图片格式) 等等。
其中很重要的一部分就是整数的字节顺序问题，也就是当整数的大小超过了一个字节之后，如何进行表示，这就是所谓的字节序的问题。
CPU # 不同的 CPU 对应的字节序略有区别：
大端，PowerPC、IBM、Sun、51 小端，x86、DEC 其中 ARM 两种模式都可以支持，另外，网络协议中大部分使用的是大端字节序，所以就有一系列的 API 对整数进行转换。
# if __BYTE_ORDER == __BIG_ENDIAN # define ntohl(x) (x) # define ntohs(x) (x) # define htonl(x) (x) # define htons(x) (x) # else # define ntohl(x) __bswap_32(x) # define ntohs(x) __bswap_16(x) # define htonl(x) __bswap_32(x) # define htons(x) __bswap_16(x) # endif 其中 ntohs 为 network to host short 的简写，这些函数一般在头文件 &amp;lt;arpa/inet.</description></item><item><title>GoLang 异常处理</title><link>https://gohalo.github.io/cn/blog/golang-basic-error-panic/</link><pubDate>Sat, 15 Sep 2018 21:39:58 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-error-panic/</guid><description>&lt;p>Golang 中的错误处理是一个被大家经常拿出来讨论的话题(另外一个是泛型)，这里简单介绍其使用方法。&lt;/p></description></item><item><title>MySQL 时间相关介绍</title><link>https://gohalo.github.io/cn/blog/mysql-basic-time/</link><pubDate>Sat, 15 Sep 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-basic-time/</guid><description>&lt;p>简单介绍 MySQL 中与时间相关的概念。&lt;/p></description></item><item><title>git 统计工具</title><link>https://gohalo.github.io/cn/blog/git-some-statistic-commands-and-tools-introduce/</link><pubDate>Thu, 13 Sep 2018 19:38:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-some-statistic-commands-and-tools-introduce/</guid><description>&lt;p>git 应该是目前使用最为广泛的代码管理仓库了，提供了非常简单的命令行工具，通过这些命令行可以进行一些常见的代码统计。&lt;/p>
&lt;p>这里简单介绍一些常用的命令。&lt;/p></description></item><item><title>GoLang 并发控制</title><link>https://gohalo.github.io/cn/blog/golang-concurrent-control/</link><pubDate>Mon, 10 Sep 2018 18:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-concurrent-control/</guid><description>&lt;p>协程不像进程或者线程可以被抢占，也就是可以强制退出，但是协程需要通过协作方式完成调度，也就是只能主动退出，如下是几种常见的退出方式。&lt;/p></description></item><item><title>C 整数介绍</title><link>https://gohalo.github.io/cn/blog/c-integer-basic-concepts-introduce/</link><pubDate>Fri, 07 Sep 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-integer-basic-concepts-introduce/</guid><description>&lt;p>在 C 中与整数类型相关的内容。&lt;/p></description></item><item><title>C11 标准解读</title><link>https://gohalo.github.io/cn/blog/program-c-c11-standard-introduce/</link><pubDate>Sat, 01 Sep 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-c11-standard-introduce/</guid><description/></item><item><title>Systemd 服务管理</title><link>https://gohalo.github.io/cn/blog/linux-systemd-notify-watchdog-introduce/</link><pubDate>Mon, 27 Aug 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-systemd-notify-watchdog-introduce/</guid><description>&lt;p>Systemd 提供了很多系统服务的基本功能，包括了系统的系统进程、启动级别、cgroup 管理、进程管理等等。&lt;/p>
&lt;p>这里简单介绍进程管理功能。&lt;/p></description></item><item><title>Linux 内存磁盘</title><link>https://gohalo.github.io/cn/blog/linux-ramdisk-introduce/</link><pubDate>Thu, 23 Aug 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ramdisk-introduce/</guid><description>&lt;p>简单来说，我们在做一些压测时，可能会由于磁盘性能的限制无法得到极限的压测结果，此时可以使用 RAM DISK 进行测试。&lt;/p>
&lt;p>内存磁盘是把一部分内存模拟成磁盘，可以把它当成一块高速的硬盘使用。&lt;/p></description></item><item><title>GoLang 基本介绍</title><link>https://gohalo.github.io/cn/blog/golang-basic-introduce/</link><pubDate>Tue, 21 Aug 2018 21:09:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-introduce/</guid><description>&lt;p>GoLang 目前越来越火，包括了 Docker、InfluxDB、etcd 等等，越来越多的工程都在使用 GoLang 。虽然它的语法都比较 &amp;ldquo;奇葩&amp;rdquo;，一些高级语言支持的特性却都不支持，但其高并发、高效率等等，也使其热度不减。&lt;/p>
&lt;p>这篇文章主要简单介绍下 GoLang 环境的搭建。&lt;/p></description></item><item><title>GORM 关联操作基本概念</title><link>https://gohalo.github.io/cn/blog/golang-db-gorm-preload/</link><pubDate>Sun, 19 Aug 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-db-gorm-preload/</guid><description>&lt;p>关于 GORM 有些与常规 ORM 不同的基本概念，理解这些概念对于使用 GROM 函数会有很大帮助，而不是简单使用 RAW SQL 实现。&lt;/p></description></item><item><title>GORM 源码解析</title><link>https://gohalo.github.io/cn/blog/golang-db-gorm-source/</link><pubDate>Sun, 19 Aug 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-db-gorm-source/</guid><description/></item><item><title>gdbinit 功能介绍</title><link>https://gohalo.github.io/cn/blog/gdb-gdbinit-script/</link><pubDate>Mon, 13 Aug 2018 20:10:51 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-gdbinit-script/</guid><description>&lt;p>在启动时，会在当前用户目录下寻找文件名为 &lt;code>.gdbinit&lt;/code> 的文件，如果存在，会执行该文件中的所有命令，通常用于简单的配置命令，如设置所需的默认汇编程序格式、输出数据默认基数，还可以读取宏编码语言，从而实现更强大的自定义函数。&lt;/p></description></item><item><title>MySQL 组复制</title><link>https://gohalo.github.io/cn/blog/mysql-group-replication/</link><pubDate>Thu, 09 Aug 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-group-replication/</guid><description>&lt;p>MySQL 当前存在异步复制、半同步复制，在 5.7.17 引入了组复制模式，这是基于分布式一致性算法 (Paxos 协议的变体) 实现。&lt;/p>
&lt;p>一个组允许部分节点挂掉，只要保证多数节点仍然存活并且相互之间可以正常通讯，那么这个组仍然可以对外提供服务，是目前一种被分布式系统广泛使用的技术。&lt;/p>
&lt;p>如下，仅简单介绍如何使用。&lt;/p></description></item><item><title>Linux C Flock 使用</title><link>https://gohalo.github.io/cn/blog/c-linux-flock-introduce/</link><pubDate>Fri, 03 Aug 2018 20:11:22 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-flock-introduce/</guid><description>&lt;p>在某些场景下，例如需要保证单个进程运行，通常的做法是生成一个 PID 文件，并将当前的进程 PID 写入，每次进程启动时检查文件以及进程是否存在。&lt;/p>
&lt;p>如果进程异常崩溃没有删除文件，而 Linux 中 PID 可以复用，那么就可能会导致误认为进程存在，虽然概率很低。&lt;/p>
&lt;p>其实在 Linux 中可以通过 flock 实现。&lt;/p></description></item><item><title>基本初等函数</title><link>https://gohalo.github.io/cn/blog/math-basic-elementary-function/</link><pubDate>Fri, 03 Aug 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-basic-elementary-function/</guid><description>&lt;p>基本初等函数包括了：幂函数、指数函数、对数函数、三角函数、反三角函数五类。&lt;/p></description></item><item><title>Linux OOM 简介</title><link>https://gohalo.github.io/cn/blog/kernel-memory-oom-killer-introduce/</link><pubDate>Wed, 01 Aug 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-oom-killer-introduce/</guid><description/></item><item><title>Linux Cache VS. Buffer</title><link>https://gohalo.github.io/cn/blog/linux-memory-buffer-vs-cache-details/</link><pubDate>Sat, 28 Jul 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-memory-buffer-vs-cache-details/</guid><description>&lt;p>实际上 Buffer 和 Cache 是两个用烂的词，在不同的场景下其语义会有所区别。在 Linux 的内存管理中，Buffer 是指 Buffer Cache(缓冲区缓存)，Cache 是指 Page Cache(页面缓存)。&lt;/p>
&lt;p>这里简单介绍其概念。&lt;/p></description></item><item><title>Python 新类和旧类区别</title><link>https://gohalo.github.io/cn/blog/python-old-new-style-class/</link><pubDate>Fri, 27 Jul 2018 19:49:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-old-new-style-class/</guid><description>&lt;p>在 Python 2.2 版本中引入了新式类 (New Style Class)，所以，通常将在此之前的类称为经典类或者旧类，而在此之后的称为新式类，两者在使用时略有区别。&lt;/p>
&lt;p>这里会简单介绍两者的区别。&lt;/p></description></item><item><title>MySQL 链接方式</title><link>https://gohalo.github.io/cn/blog/mysql-connection/</link><pubDate>Sun, 22 Jul 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-connection/</guid><description>&lt;p>与 Oracle 或者 Postgre 不同，MySQL 采用的是线程模型，在这里介绍通过 socket 链接到服务器之后，线程与链接直接是怎么处理的。&lt;/p></description></item><item><title>Python 常用代码</title><link>https://gohalo.github.io/cn/blog/python-some-codes/</link><pubDate>Sun, 22 Jul 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-some-codes/</guid><description/></item><item><title>Linux PIPE 相关介绍</title><link>https://gohalo.github.io/cn/blog/linux-pipe-stuff-introduce/</link><pubDate>Fri, 20 Jul 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-pipe-stuff-introduce/</guid><description>&lt;p>在命令行以及代码中经常使用管道，不过其使用是有些限制的，这里简单介绍。&lt;/p></description></item><item><title>Python Matplotlib 简介</title><link>https://gohalo.github.io/cn/blog/python-matplotlib-package-introduce/</link><pubDate>Tue, 10 Jul 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-matplotlib-package-introduce/</guid><description>&lt;p>简单来说，Matplotlib 是 Python 中的一个绘图库，包含了大量的工具，几乎可以通过该工具完成你所需要的任何图形，包括散点图、正弦曲线，甚至是三维图形。&lt;/p>
&lt;p>这一工具经常用在数据可视化中，这里简单介绍其使用方法。&lt;/p></description></item><item><title>C 语言使用 SSL</title><link>https://gohalo.github.io/cn/blog/program-c-ssl-tls-basic-introduce/</link><pubDate>Sun, 08 Jul 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-ssl-tls-basic-introduce/</guid><description/></item><item><title>Linux Hang Task 简介</title><link>https://gohalo.github.io/cn/blog/linux-kernel-hang-task-panic-introduce/</link><pubDate>Sat, 30 Jun 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-hang-task-panic-introduce/</guid><description>&lt;p>长期以来，处于 D 状态的进程都是让人比较烦恼的问题，此时不能接收信号，不能 &lt;code>kill&lt;/code> 掉，用户对此基本是无能为力，而且也很难知道发生的原因，一般来说只能重启服务器恢复。&lt;/p>
&lt;p>正常来说 D 状态的任务只有在 IO 操作时会有，而且会很快完成，只有在极端的异常场景下才会出现问题，例如磁盘损坏、NFS 的 bug 等等，不过如果驱动写的完善的话，一般会增加超时机制，原则上不会出现永久的 D 状态进程。&lt;/p>
&lt;p>也就是说，只有在内核驱动不合理的时候可能会导致进程长期处于 D 状态，无法唤醒，类似于死锁状态。&lt;/p></description></item><item><title>Kafka 基本介绍</title><link>https://gohalo.github.io/cn/blog/kafka-basic-introduce/</link><pubDate>Fri, 22 Jun 2018 21:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kafka-basic-introduce/</guid><description>&lt;p>Apache Kafka 最初由 LinkedIn 开发，通过 Scala 和 Java 编写的一个分布式消息系统，在 2011 年成为 Apache 的孵化项目，随后于 2012 年成为 Apache 的主要项目之一。&lt;/p>
&lt;p>因为其可扩展、高吞吐、高可用等特性被广泛应用在大规模的消息处理场景中，一些常见的流处理工具都支持与 Kafka 的集成。&lt;/p></description></item><item><title>ZooKeeper 基本介绍</title><link>https://gohalo.github.io/cn/blog/zookeeper-basic-introduce/</link><pubDate>Fri, 22 Jun 2018 21:23:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zookeeper-basic-introduce/</guid><description/></item><item><title>Socket 关闭方式</title><link>https://gohalo.github.io/cn/blog/language-c-socket-close-method/</link><pubDate>Wed, 20 Jun 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-socket-close-method/</guid><description>&lt;p>在 Linux 中，对于 Socket 来说，可以通过系统调用 &lt;code>close()&lt;/code> 关闭，通过还提供了一个 &lt;code>shutdown()&lt;/code> 接口，可以直接将 socket 关闭。&lt;/p>
&lt;p>那么两种方式有什么区别？&lt;/p></description></item><item><title>C 语言发布流程</title><link>https://gohalo.github.io/cn/blog/program-c-debug-release-etc/</link><pubDate>Sat, 16 Jun 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-debug-release-etc/</guid><description>&lt;p>整理下 C 语言中调试、发布的流程。&lt;/p></description></item><item><title>GCC 常用技巧</title><link>https://gohalo.github.io/cn/blog/program-c-language-gcc-some-stuff/</link><pubDate>Wed, 13 Jun 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-language-gcc-some-stuff/</guid><description>&lt;p>Clang 是一个 C++ 编写，基于 LLVM 的 C/C++、Objective-C 语言的轻量级编译器，在 2013.04 开始，已经全面支持 C++11 标准。&lt;/p></description></item><item><title>Linux 信号 VS. 线程</title><link>https://gohalo.github.io/cn/blog/linux-signal-vs-thread/</link><pubDate>Thu, 07 Jun 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-signal-vs-thread/</guid><description>&lt;p>在开发多线程应用时，考虑到线程安全，一般会通过 &lt;code>pthread_mutex()&lt;/code> 去保护全局变量。如果应用中使用了信号，信号在被处理后应用程序还将正常运行，那么此时就需要正确的处理。&lt;/p>
&lt;p>一般来说，需要在指定的线程中以同步的方式处理，以避免由于处理异步信号而给程序运行带来的不确定性风险。&lt;/p></description></item><item><title>VIM 常用配置</title><link>https://gohalo.github.io/cn/blog/vim-some-tips/</link><pubDate>Fri, 01 Jun 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-some-tips/</guid><description/></item><item><title>Linux GNU 内联汇编</title><link>https://gohalo.github.io/cn/blog/c-gnu-inline-assembly/</link><pubDate>Wed, 30 May 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-gnu-inline-assembly/</guid><description>&lt;p>在通过 C 做上层的开发时，实际上很少会用到汇编语言，不过对于 Linux 内核开发来说，经常会遇到与体系架构相关的功能或优化代码，此时可能需要通过将汇编语言指令插入到 C 语句的中间来执行这些任务。&lt;/p>
&lt;p>这里简单介绍下 GNU 中与 Linux 内联汇编相关的用法。&lt;/p></description></item><item><title>Protobuf 协议简介</title><link>https://gohalo.github.io/cn/blog/protobuf-protocol-introduce/</link><pubDate>Thu, 24 May 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/protobuf-protocol-introduce/</guid><description>&lt;p>Protobuf (Google Protocol Buffers) 是 google 开发的的一套用于数据存储，网络通信时用于协议编解码的工具库，与 XML 和 JSON 数据格式类似，但采用的是二进制的数据格式，具有更高的传输，打包和解包效率。&lt;/p>
&lt;p>相比 JSON 来说，Protobuf 的效率、编解码速度更快、数据体积更小，带来的问题是数据可读性变差，协议升级比较麻烦。&lt;/p></description></item><item><title>MySQL 杂项</title><link>https://gohalo.github.io/cn/blog/mysql-tips/</link><pubDate>Wed, 23 May 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-tips/</guid><description>&lt;p>简单记录下 MySQL 常见的一些操作。&lt;/p></description></item><item><title>MySQL 执行简介</title><link>https://gohalo.github.io/cn/blog/mysql-executor/</link><pubDate>Mon, 21 May 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-executor/</guid><description>&lt;p>最后是 MySQL 的执行。&lt;/p></description></item><item><title>C 语言 Volatile 使用简介</title><link>https://gohalo.github.io/cn/blog/linux-c-volatile-statement-introduce/</link><pubDate>Sun, 20 May 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-volatile-statement-introduce/</guid><description>&lt;p>C 语言中的 volatile 关键字大部分都见过，但是很少有人能明确其具体使用的场景。实际上，上层编程很少会用到，一般只有涉及到 IO、中断等与硬件交互的底层编程才会经常使用。&lt;/p>
&lt;p>这里简单介绍其使用场景，使用方法。&lt;/p></description></item><item><title>GoLang DB 操作简介</title><link>https://gohalo.github.io/cn/blog/golang-db-introduce/</link><pubDate>Sat, 19 May 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-db-introduce/</guid><description>&lt;p>GoLang 提供了标准包用于对 SQL 数据库进行访问，作为操作数据库的入口对象 sql.DB, 主要为提供了两个重要的功能：A) 提供管理底层数据库连接的打开和关闭操作；B) 管理数据库连接池。&lt;/p>
&lt;p>需要注意的是，sql.DB 表示操作数据库的抽象访问接口，而非一个数据库连接对象，会根据实际的驱动打开关闭数据库连接，管理连接池。&lt;/p>
&lt;p>这里简单介绍 MySQL 的使用方式。&lt;/p></description></item><item><title>Linux Random</title><link>https://gohalo.github.io/cn/blog/linux-random-introduce/</link><pubDate>Sat, 12 May 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-random-introduce/</guid><description>&lt;p>在 Linux 中，有两类用于生成随机数的设备，分别是 &lt;code>/dev/random&lt;/code> 以及 &lt;code>/dev/urandom&lt;/code> ，其中前者可能会导致阻塞，后者的安全性则较低。&lt;/p>
&lt;p>后者是 unblocked random 的简称，会重用内部池中的数据以产生伪随机数据，可用于安全性较低的应用。&lt;/p></description></item><item><title>Linux 进程监控</title><link>https://gohalo.github.io/cn/blog/linux-monitor-process-introduce/</link><pubDate>Wed, 09 May 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-process-introduce/</guid><description/></item><item><title>Python AI 环境准备</title><link>https://gohalo.github.io/cn/blog/python-ai-environment-prepare/</link><pubDate>Wed, 09 May 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-ai-environment-prepare/</guid><description>&lt;p>目前大部分的 AI 相关工具包、框架等都是通过 Python 实现的，包括了常用的 Numpy、Scikit-Learn、TensorFlow、PyTorch 等等。&lt;/p>
&lt;p>所以，这里搭建的环境主要也就是 Python 相关的，另外还有基本的 MNIST 数据集。&lt;/p></description></item><item><title>Python Seaborn 简介</title><link>https://gohalo.github.io/cn/blog/python-seaborn-package-introduce/</link><pubDate>Wed, 09 May 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-seaborn-package-introduce/</guid><description>&lt;p>Seaborn 是一个基于 matplotlib 的可视化库，提供了一个更上层的 API 封装，从而可以更容易的绘制图形。&lt;/p></description></item><item><title>GoLang HTTP 使用简介</title><link>https://gohalo.github.io/cn/blog/golang-http-webserver-introduce/</link><pubDate>Fri, 27 Apr 2018 18:13:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-http-webserver-introduce/</guid><description>&lt;p>除去细节，理解 HTTP 构建的网络应用只要关注客户端和服务端的处理，服务器主要用来接收客户端的请求，然后返回响应，在接收请求并处理的过程中，最重要的莫过于路由 (Router)。&lt;/p>
&lt;p>这里简单介绍如何使用 &lt;code>net/http&lt;/code> 构建 HTTP 请求。&lt;/p></description></item><item><title>Linux 网络状态查看</title><link>https://gohalo.github.io/cn/blog/linux-network-status/</link><pubDate>Thu, 26 Apr 2018 21:19:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-status/</guid><description>&lt;p>直接通过 &lt;code>man 8 netstat&lt;/code> 查看帮助时就可以发现这样的一句话 &lt;code>This program is obsolete. Replacement for netstat is ss.&lt;/code>，而且后面还有几个相关的等价示例介绍。&lt;/p>
&lt;p>所以这里简单介绍与 ss 相关的指令。&lt;/p></description></item><item><title>C 常用函数</title><link>https://gohalo.github.io/cn/blog/language-c-some-basic-functions-usage-introduce/</link><pubDate>Fri, 20 Apr 2018 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-some-basic-functions-usage-introduce/</guid><description>&lt;p>C 语言中一些常用的基础函数，包括了 &lt;code>qsort()&lt;/code> &lt;code>bsearch()&lt;/code> &lt;code>atexit()&lt;/code> &lt;code>backtrace()&lt;/code> 等。&lt;/p></description></item><item><title>NMAP 使用</title><link>https://gohalo.github.io/cn/blog/linux-network-command-nmap/</link><pubDate>Tue, 17 Apr 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-nmap/</guid><description>&lt;p>Nmap 是一款网络扫描和主机检测的非常有用的工具，不仅可以收集信息，同时可用来作为一个漏洞探测器或安全扫描器。&lt;/p></description></item><item><title>RAFT 协议简介</title><link>https://gohalo.github.io/cn/blog/raft-consensus-algorithms-introduce/</link><pubDate>Fri, 13 Apr 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/raft-consensus-algorithms-introduce/</guid><description>&lt;p>Paxos 一直是分布式协议的标准，但是 Paxos 难于理解，更难以实现，例如 Google 的分布式锁系统 Chubby 在实现 Paxos 协议时就遇到很多坑。&lt;/p>
&lt;p>来自 Stanford 的新的分布式协议研究称为 RAFT，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性。&lt;/p></description></item><item><title>GCC 安全编译选项</title><link>https://gohalo.github.io/cn/blog/program-gcc-security-options/</link><pubDate>Mon, 09 Apr 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-gcc-security-options/</guid><description>&lt;p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，例如 ASLR、NX 等等，这里简单介绍一些常见的使用项。&lt;/p></description></item><item><title>C 指针简介</title><link>https://gohalo.github.io/cn/blog/language-c-pointer-basic-usage-introduce/</link><pubDate>Sun, 01 Apr 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-pointer-basic-usage-introduce/</guid><description>&lt;p>在 C 语言中，指针是一个特殊的变量，存储值指向内存中的一个地址，一个指针包含了四方面的内容：指针类型、指向类型，指针所指向的内存区以及指针本身所占据的内存区。&lt;/p>
&lt;p>指针或许是 C 语言中最复杂的东西了。&lt;/p></description></item><item><title>Golang 语法之接口</title><link>https://gohalo.github.io/cn/blog/golang-syntax-interface-introduce/</link><pubDate>Fri, 30 Mar 2018 20:23:40 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-syntax-interface-introduce/</guid><description>&lt;p>在 Go 语言的实际编程中，几乎所有的数据结构都围绕 Interface 展开，这是 GoLang 中所有数据结构的核心。&lt;/p>
&lt;p>首先，Go 不是一种典型的 OO 语言，它在语法上不支持类和继承的概念，而通过 Interface 可以看到多态的影子。&lt;/p></description></item><item><title>GoLang time 模块</title><link>https://gohalo.github.io/cn/blog/golang-common-module-time-introduce/</link><pubDate>Mon, 26 Mar 2018 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-time-introduce/</guid><description>&lt;p>GoLang 中的 time 模块包含了一些与时间相关的函数，例如格式转换、定时器等。&lt;/p></description></item><item><title>Docker Network 简介</title><link>https://gohalo.github.io/cn/blog/docker-basic-concept-network-introduce/</link><pubDate>Mon, 12 Mar 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-basic-concept-network-introduce/</guid><description/></item><item><title>MySQL 启动脚本</title><link>https://gohalo.github.io/cn/blog/mysql-mysqld-safe/</link><pubDate>Thu, 08 Mar 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-mysqld-safe/</guid><description>&lt;p>mysqld_safe 是一个 shell 脚本，通常用来启动 MySQL 服务进程，在这篇文章中，我们看下该脚本具体做了什么。&lt;/p></description></item><item><title>Bash 基本语法</title><link>https://gohalo.github.io/cn/blog/bash-basic-syntax/</link><pubDate>Thu, 01 Mar 2018 22:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-basic-syntax/</guid><description>&lt;p>在 Linux 中通过 Bash 与系统进行简单的交互，但是，通常可能会有一些负责的逻辑进行处理，这就涉及到了 Bash 的编程，实际上就是通过命令行以及一些常见的处理逻辑。&lt;/p>
&lt;p>这里简单介绍常见的语法。&lt;/p></description></item><item><title>git 分支管理</title><link>https://gohalo.github.io/cn/blog/git-branch-model/</link><pubDate>Tue, 27 Feb 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-branch-model/</guid><description>&lt;p>相比其它的版本管理软件，git 有很多优点，其中很重要的一个特性就是版本的分支 (branch) 和合并 (merge) 十分方便。&lt;/p>
&lt;p>git 分支并非生成一个物理代码拷贝，而是只生成一个指向当前版本的指针，又被称为 &amp;ldquo;快照&amp;rdquo; (snapshot) ，因此，处理起来是分快速，而且节省空间。&lt;/p>
&lt;p>接下来，就看看 git 的版本分支管理策略。&lt;/p></description></item><item><title>SSO 简介</title><link>https://gohalo.github.io/cn/blog/single-sign-on-sso/</link><pubDate>Tue, 20 Feb 2018 20:52:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/single-sign-on-sso/</guid><description>&lt;p>Single Sign-On, SSO 单点登录，允许在单次登陆之后可以访问其它相关网站，也就是说，其中的一部分核心功能就是验证用户身份，除了上述的认证，同时也会作为用户的跟踪。&lt;/p></description></item><item><title>JWT 简介</title><link>https://gohalo.github.io/cn/blog/golang-json-web-token-jwt/</link><pubDate>Tue, 13 Feb 2018 21:27:20 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-json-web-token-jwt/</guid><description>&lt;p>在程序开发中，用户认证授权是一个绕不过的重难点，以前的开发模式下，cookie 和 session 认证是主流，随着前后端分离的趋势，基于 Token 的认证方式成为主流。&lt;/p>
&lt;p>而 JWT(RFC 7519) 是基于 Token 认证方式的一种机制，是实现单点登录认证的一种有效方法。&lt;/p>
&lt;p>这里详细介绍其设计和使用方式。&lt;/p></description></item><item><title>线性回归 基本介绍</title><link>https://gohalo.github.io/cn/blog/machine-learning-linear-regression-basic-introduce/</link><pubDate>Thu, 01 Feb 2018 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/machine-learning-linear-regression-basic-introduce/</guid><description>&lt;p>回归分析 (Regression Analysis) 是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法，线性回归 (Linear Regression) 也是最基本的。&lt;/p>
&lt;p>这里介绍其概念、公式推导以及基本的实现。&lt;/p></description></item><item><title>Python C</title><link>https://gohalo.github.io/cn/blog/python-c-bind-introduce/</link><pubDate>Tue, 30 Jan 2018 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-c-bind-introduce/</guid><description/></item><item><title>Beanstalk 使用简介</title><link>https://gohalo.github.io/cn/blog/message-queue-beanstalk-introduce/</link><pubDate>Sun, 21 Jan 2018 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/message-queue-beanstalk-introduce/</guid><description>&lt;p>这是 FaceBook 实现的一个消息队列，其协议是基于 ASCII 的，上报的数据可以通过 binlog 进行持久化，其高可用类似于 Memcached 的方式，也就是各个进程之间不知道相互的存在。&lt;/p>
&lt;p>支持优先级、延时、超时重发、预留等机制，支持分布式的后台任务和定时任务处理。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>MySQL 高可用 MHA</title><link>https://gohalo.github.io/cn/blog/mysql-replication-mha/</link><pubDate>Sat, 20 Jan 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-replication-mha/</guid><description>&lt;p>Master High Availability, MHA 在 MySQL 高可用方面是一个相对成熟的解决方案，能做到在 0~30 秒之内自动完成数据库的故障切换操作，而且能最大程度上保证数据的一致性。&lt;/p>
&lt;p>这里介绍使用配置方法，以及其原理。&lt;/p></description></item><item><title>GORM 操作简介</title><link>https://gohalo.github.io/cn/blog/golang-db-gorm-basic/</link><pubDate>Fri, 19 Jan 2018 21:09:38 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-db-gorm-basic/</guid><description>&lt;p>Object Relational Mapping, ORM 对象关系映射，用于将数据库中的数据与代码中的结构体进行映射，不同语言的实现方式略有区别，但是目的基本相同。&lt;/p>
&lt;p>GoLang 中有多种映射库，这里简单介绍常见的 GORM 使用方式。&lt;/p></description></item><item><title>GoLang 模板使用简介</title><link>https://gohalo.github.io/cn/blog/golang-template-introduce/</link><pubDate>Tue, 09 Jan 2018 20:19:08 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-template-introduce/</guid><description>&lt;p>在前后端分离的时代，模板语言使用的已经很少了，不过很多特定的场景还是很有用的，这里介绍其基本使用方法。&lt;/p></description></item><item><title>ELF 符号表</title><link>https://gohalo.github.io/cn/blog/program-c-elf-symbol-section/</link><pubDate>Sat, 06 Jan 2018 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-elf-symbol-section/</guid><description/></item><item><title>Python Pandas 简介</title><link>https://gohalo.github.io/cn/blog/python-pandas-package-introduce/</link><pubDate>Thu, 04 Jan 2018 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-pandas-package-introduce/</guid><description>&lt;p>Pandas 是一个基于 NumPy 的工具，主要是为了解决数据分析任务，包括了一些标准的数据模型，提供了高效地操作大型数据集所需的工具。&lt;/p></description></item><item><title>Linux C 动态库加载</title><link>https://gohalo.github.io/cn/blog/c-reload-dynamic-library/</link><pubDate>Wed, 03 Jan 2018 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-reload-dynamic-library/</guid><description>&lt;p>简单来说，对于正在运行的程序，当尝试重新加载动态库时，可能会导致程序 CoreDump 。&lt;/p>
&lt;p>这里简单解释下其原因，以及规避方案。&lt;/p></description></item><item><title>ETCD 源码解析</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-details/</link><pubDate>Fri, 15 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-details/</guid><description>&lt;p>在上篇 &lt;a href="https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/">ETCD 示例源码&lt;/a> 中介绍了 ETCD 代码中 RAFT 相关的示例代码，接着介绍与 ETCD 相关的代码。&lt;/p></description></item><item><title>FastDFS 使用简介</title><link>https://gohalo.github.io/cn/blog/fastdfs-introduce/</link><pubDate>Tue, 12 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/fastdfs-introduce/</guid><description>这是一个开源的轻量级分布式文件系统，主要功能有文件存储、文件同步、文件访问等，解决了大容量存储和负载均衡的问题，适合以文件为载体的在线服务，如相册网站、视频网站等等，一般文件大小为 4KB &amp;lt; file_size &amp;lt; 500MB 。
简介 # 服务端包括了 Tracker Server 和 Storage Server 两个部分，前者用于负载均衡和调度，后者用于文件存储。两种类型服务可以多节点部署，单个节点宕机不会影响整体提供服务。
Tracker Server # 负责管理所有的 Storage Server 和 Group ，每个 Storage Server 启动后会主动连接到 Tracker ，告知自己所属的 Group 同时保持心跳信息，Tracker 会根据上报的元数据在内存中维护映射信息。
Storage Server # 真正存储数据的地方，以分组 Group 为单位，每个分组包含了多个 Storage Server ，数据互为备份，存储空间以最小的为准。
实际上 Group 是一个逻辑概念，主要是为了能够方便的进行应用隔离、负责均衡和副本数定制，如果 Group 内机器出现故障需要该 Group 内的其它机器重新同步数据。
使用简介 # 首先是通过源码编译打包，V5.0 之前的版本依赖 libevent 而 V5.0 以后不再依赖 libevent ，V5.04 开始依赖 libfastcommon 。
----- 安装libfastcommon，这个是提取出来的单独公共代码库 ./make.sh ./make.sh install rpmbuild --bb libfastcommon.spec ----- 编译安装fastdfs .</description></item><item><title>DWARF 格式简介</title><link>https://gohalo.github.io/cn/blog/gdb-dwarf-format-introduce/</link><pubDate>Sun, 10 Dec 2017 23:49:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-dwarf-format-introduce/</guid><description>&lt;p>也就是 Debugging With Attributed RecordFormats, DWARF ，到目前为止，应该包括了 &lt;code>V1~5&lt;/code> 共五个版本，其中 dwarf2 对 dwarf1 的改变很大，而后续的版本基本上是对前者的扩展。&lt;/p>
&lt;p>这一格式独立于语言，不过使用比较多的是 C/C++ ，这里简单介绍在 GDB 中，如何对这些调试信息进行组织、实现，并且如何利用调试信息进行 C 语言级别的调试。&lt;/p></description></item><item><title>CMocka 使用简介</title><link>https://gohalo.github.io/cn/blog/c-cmocka-introduce/</link><pubDate>Wed, 06 Dec 2017 18:19:58 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-cmocka-introduce/</guid><description>&lt;p>CMocka 是一针对 C 语言的单元测试框架，而且支持 mock 测试，其前身是由 Google 开发的 Cmockery，而后者由于不再维护，后来就通过 CMocka 继续开发维护。&lt;/p>
&lt;p>也就因此，可以看到有些细节与同样由 Google 开发的 gmock 和 gtest 有些相似，这里详细介绍其使用方式。&lt;/p></description></item><item><title>ETCD 网络模块</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-network/</link><pubDate>Tue, 05 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-network/</guid><description>&lt;p>在使用 RAFT 协议内核时，需要单独实现网络的通讯协议，也就是集群中各个结点之间的通讯，除此之外还有客户端与服务器之间的通讯。&lt;/p>
&lt;p>这里简单介绍其实现方式。&lt;/p></description></item><item><title>TC 使用简介</title><link>https://gohalo.github.io/cn/blog/network-traffic-control-introduce/</link><pubDate>Fri, 01 Dec 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-traffic-control-introduce/</guid><description>&lt;p>网络的 IP 服务模型是尽力而为的，这样的模型不能体现某些流量的重要性，所以诞生了 QoS 技术，Linux 很早就提供了流量控制接口，命令行工具是 tc (Traffic Control)。&lt;/p></description></item><item><title>ETCD 一致性读</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-consistent-reading/</link><pubDate>Thu, 30 Nov 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-consistent-reading/</guid><description>&lt;p>在分布式系统中，存在多种一致性模型，不同模型给应用提供的数据保证也不同，其代价也略有区别。一般来说，一致性越强，代价越高，同时应用也越友好。&lt;/p></description></item><item><title>NeoVim/Vim 按键映射</title><link>https://gohalo.github.io/cn/blog/vim-tips-keymap/</link><pubDate>Thu, 30 Nov 2017 18:39:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/vim-tips-keymap/</guid><description>&lt;p>使用 NeoVim/Vim 的主要就是为了可以减少鼠标的使用，而且提供了极高的配置，按键映射主要还是为了适合自己的操作习惯。&lt;/p></description></item><item><title>Python 三方库 requests</title><link>https://gohalo.github.io/cn/blog/python-third-package-requests/</link><pubDate>Thu, 30 Nov 2017 18:39:17 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-third-package-requests/</guid><description>&lt;p>这是一个简单但是非常优雅的 HTTP 库，对于一些常见的 API 调用非常简单实用。&lt;/p></description></item><item><title>数字挂钟</title><link>https://gohalo.github.io/cn/blog/linux-command-cron-clock/</link><pubDate>Sun, 26 Nov 2017 22:45:35 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-cron-clock/</guid><description>&lt;p>一个很有意思的数学挂钟，这个时钟通过各种符号计算公式表示 1~12 个数字。&lt;/p></description></item><item><title>你所不知道的 Linux 定时任务</title><link>https://gohalo.github.io/cn/blog/linux-command-cron-introduce/</link><pubDate>Sat, 25 Nov 2017 20:45:35 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-command-cron-introduce/</guid><description>&lt;p>在 Linux 中，我们经常使用 cron 执行一些定时任务，只需要配置一下时间，它就可以周期的执行一些任务。&lt;/p>
&lt;p>不知道你是否清楚它的详细用法？是否发现，脚本单独运行时是好好的，放到 cron 任务里却挂了！！！一个部署了 crond 的服务器，系统资源却被莫名其妙的被占满了，Why？？？&lt;/p></description></item><item><title>Linux 信号机制</title><link>https://gohalo.github.io/cn/blog/kernel-signal-introduce/</link><pubDate>Sat, 25 Nov 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-signal-introduce/</guid><description>&lt;p>软中断信号 (简称为信号) 是用来通知进程发生了异步事件，是在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。&lt;/p>
&lt;p>信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。&lt;/p>
&lt;p>进程之间可以互相通过系统调用 kill 发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。&lt;/p>
&lt;p>信号机制除了基本通知功能外，还可以传递附加信息。&lt;/p></description></item><item><title>GDB 死锁分析</title><link>https://gohalo.github.io/cn/blog/gdb-deadlock-analyze-introduce/</link><pubDate>Mon, 20 Nov 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-deadlock-analyze-introduce/</guid><description>&lt;p>pthread 是 POSIX 标准的多线程库，其源码位于 glibc 中的 Native POSIX Thread Library, NPTL 目录下，大部分的应用都是基于 pthread 来实现多线程的并行与同步管理。&lt;/p></description></item><item><title>AirFlow 工作流简介</title><link>https://gohalo.github.io/cn/blog/airflow-dac-introduce/</link><pubDate>Sun, 19 Nov 2017 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/airflow-dac-introduce/</guid><description>&lt;p>AirFlow 一个用于编排复杂计算工作流和数据处理流水线的开源工具，通常可以解决一些复杂超长 Cron 脚本任务或者大数据的批量处理任务。&lt;/p>
&lt;p>其工作流的设计是基于有向非循环图 (Directed Acyclical Graphs, DAG) ，用于设置任务依赖关系和时间调度。&lt;/p>
&lt;p>简单来说，在编写工作流时，尽量考虑如何将一个大型的任务拆分为多个可独立执行的原子任务，再将这些任务合并为一个逻辑整体。&lt;/p>
&lt;p>这里简单介绍一些常见的基本概念及其使用方法。&lt;/p></description></item><item><title>ETCD 存储模块</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-storage/</link><pubDate>Wed, 15 Nov 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-sourcode-storage/</guid><description>&lt;p>如前所述，ETCD 中 RAFT 协议的只是实现了其核心的部分，而其中的存储模块需要单独实现。&lt;/p></description></item><item><title>ETCD 示例源码</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/</link><pubDate>Wed, 15 Nov 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-example-sourcode-details/</guid><description>&lt;p>现在已知的 Golang 版本的 RAFT 的开源实现主要有两个：一个是 CoreOS 的 etcd 中的实现，使用的项目有比如 tidb、cockroachdb 等；另外一个是 hashcorp 的 RAFT 实现，使用的项目有比如 consul、InfluxDB 等。&lt;/p>
&lt;p>相比而言，前者只实现了一个整体框架，很多的功能需要用户实现，难度增加但是更加灵活；而后者则是完整的实现，WAL、SnapShot、存储、序列化等。&lt;/p></description></item><item><title>Linux umask 使用</title><link>https://gohalo.github.io/cn/blog/linux-umask-and-open-introduce/</link><pubDate>Sun, 12 Nov 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-umask-and-open-introduce/</guid><description>&lt;p>在使用 umask 设置问价的掩码时遇到了一个坑，本来以为设置会很简单，但是开始设置时一直不是预期的结果。&lt;/p>
&lt;p>简单整理下踩坑的过程。&lt;/p></description></item><item><title>MySQL RedoLog 简介</title><link>https://gohalo.github.io/cn/blog/mysql-innodb-redo-log/</link><pubDate>Wed, 08 Nov 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-innodb-redo-log/</guid><description>&lt;p>当事务需要修改某条记录时，会先记录到 redo log，在此介绍下其实现。&lt;/p></description></item><item><title>Fuzzing 测试</title><link>https://gohalo.github.io/cn/blog/program-c-fuzzing-test-introduce/</link><pubDate>Tue, 31 Oct 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-fuzzing-test-introduce/</guid><description>Fuzzing 一般指模糊测试，是一种基于黑盒的测试技术，通过自动化生成并执行大量的随机测试用例来发现产品或协议的未知漏洞。
同时，也作为了当前最为强大而有效的漏洞挖掘技术。
AFL # American Fuzzy Lop, AFL 是一种开源的模糊测试器，由谷歌的 Michal Zalewski 开发。
可以在源码编译时添加，或者使用 QEMU 模式，也就是 QEMU-(User Mode) ，在执行时注入部分代码进行测试。
目前使用 AFL 有两种方式：
开源软件，在编译的时候同时进行插桩； 闭源软件，配合QEMU直接对闭源的二进制代码进行fuzz测试。 安装 # 直接从 ALF Release 下载相关的版本，然后执行 make 即可。
默认安装在 /usr/local 相对目录下，可以通过 PREFIX=/usr &amp;amp;&amp;amp; make 修改。
使用 # 如果程序使用 autoconf 工具链构建，在执行 configure 脚本时，添加如下参数即可。
$ ./configure --disable-shared CC=&amp;#34;afl-gcc&amp;#34; CXX=&amp;#34;afl-g++&amp;#34; 其中 --disable-shared 选项可以允许通过 LD_LIBRARY_PATH 变量，让程序加载经过 AFL 插桩的 .so 文件，进行静态构建而不是动态链接。
如果是其它的 Makefile 文件，可以直接修改引用的编译器。
另外，为了后期更好的分析 crash 可以开启 Address Sanitizer, ASAN 检测工具，此工具可以更好的检测出缓存区溢出、UAF 等内存漏洞。</description></item><item><title>Linux Direct IO</title><link>https://gohalo.github.io/cn/blog/linux-direct-io-introduce/</link><pubDate>Fri, 27 Oct 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-direct-io-introduce/</guid><description>&lt;p>可以直接在应用层和磁盘之间建立通道，减少上下文切换次数。&lt;/p></description></item><item><title>Linux C 错误信息</title><link>https://gohalo.github.io/cn/blog/language-c-error-message-usage-introduce/</link><pubDate>Fri, 20 Oct 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-error-message-usage-introduce/</guid><description>&lt;p>在 C 代码中，当发生错误时，一般会在库函数中设置 errno ，然后应用可以通过 strerror 打印详细的错误信息，以方便定位问题。&lt;/p>
&lt;p>但是有些错误打印函数标示为安全的？这是什么意思？使用时应该注意什么？&lt;/p></description></item><item><title>MySQL 半同步复制</title><link>https://gohalo.github.io/cn/blog/mysql-semisync/</link><pubDate>Fri, 20 Oct 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-semisync/</guid><description>&lt;p>MySQL 提供了原生的异步复制，也就是主库的数据落地之后，并不关心备库的日志是否落库，从而可能导致较多的数据丢失。&lt;/p>
&lt;p>从 MySQL5.5 开始引入了一种半同步复制功能，该功能可以确保主服务器和访问链中至少一台从服务器之间的数据一致性和冗余，从而可以减少数据的丢失。&lt;/p>
&lt;p>接下来，我们就简单介绍下 MySQL 中的半同步复制。&lt;/p></description></item><item><title>GoLang Array VS. Slice</title><link>https://gohalo.github.io/cn/blog/golang-array-slice-concept-introduce/</link><pubDate>Wed, 18 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-array-slice-concept-introduce/</guid><description>&lt;p>两者十分类似，很容易造成混淆。&lt;/p></description></item><item><title>GoLang 日志模块使用介绍</title><link>https://gohalo.github.io/cn/blog/golang-log-module-introduce/</link><pubDate>Mon, 16 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-log-module-introduce/</guid><description>&lt;p>打印日志是最常规的需求，GoLang 的基础库只提供了简单的格式化功能，但是很多基础功能不存在，例如日志级别、文件切割等等。&lt;/p>
&lt;p>这里介绍 Uber 开发的一个日志库 ZAP 。&lt;/p></description></item><item><title>GoLang 网络编程</title><link>https://gohalo.github.io/cn/blog/golang-example-socket-introduce/</link><pubDate>Sat, 14 Oct 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-example-socket-introduce/</guid><description>&lt;p>Golang 对 TCP 做了很好的抽象，而且提供了很高的性能，其底层的 netpoller 通过非阻塞的 IO 多路复用实现，然后再结合协程的调度，使得用户在编程时实际是阻塞接口。&lt;/p></description></item><item><title>Inotify 机制详解</title><link>https://gohalo.github.io/cn/blog/kernel-inotify-introduce/</link><pubDate>Wed, 11 Oct 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-inotify-introduce/</guid><description>日常工作中，经常会需要知道某些文件上的变化，一般是通过轮询机制检查文件的变化，不过这样非常低效。
Inotify 是一种文件变化通知机制，Linux 内核从 2.6.13 开始引入，而 BSD 和 Mac OS 系统中比较有名的是 kqueue，可以高效地实时跟踪文件系统的变化。
这里简单介绍其使用方法。
简介 # 可以通过如下方式查看是否支持 Inotify 机制。
$ grep INOTIFY_USER /boot/config-$(uname -r) CONFIG_INOTIFY_USER=y 如果输出 CONFIG_INOTIFY_USER=y 那么就表示系统支持 inotify 机制。
源码实现 # 在用户态主要通过三个系统调用，首先是要创建 inotify 实例。
#include &amp;lt;sys/inotify.h&amp;gt; int inotify_init(void); int inotify_init1(int flags); 每个 inotify 实例对应一个独立的排序的队列，文件系统的变化事件被称做 watches 的一个对象管理，每一个 watch 是一个二元组：
目标，可以是文件或目录； 事件掩码，应用希望关注的 inotify 事件，每位对应一个 inotify 事件。 Watch 对象通过 watch 描述符引用，其中，目录 watches 将返回在该目录下的所有文件上面发生的事件。
下面函数用于添加一个 watch 。
#include &amp;lt;sys/inotify.h&amp;gt; int inotify_add_watch(int fd, const char *pathname, uint32_t mask); 参数： fd 如上的 inotify_init() 返回的文件描述符； path 被监视的目标的路径名，可以是文件名或目录名； mask 事件掩码，在头文件 `linux/inotify.</description></item><item><title>git 补丁相关操作</title><link>https://gohalo.github.io/cn/blog/git-tips-patch-command-usage/</link><pubDate>Sun, 08 Oct 2017 19:30:02 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-tips-patch-command-usage/</guid><description>&lt;p>在 Linux 中可以通过 diff patch 命令生成补丁以及打补丁，而且 git 实际上也提供了很简单的命令直接生成 Patch 文件，然后，可以再结合 patch 命令使用即可。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>GDB 常用命令</title><link>https://gohalo.github.io/cn/blog/gdb-commands-usage-cheatsheet/</link><pubDate>Thu, 05 Oct 2017 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-commands-usage-cheatsheet/</guid><description>&lt;p>这里一些常用的 gdb 命令。&lt;/p></description></item><item><title>GDB 栈帧简介</title><link>https://gohalo.github.io/cn/blog/gdb-stack-frame-introduce/</link><pubDate>Thu, 05 Oct 2017 21:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-stack-frame-introduce/</guid><description>&lt;p>栈是一块内存空间，会从高地址向低地址增长，同时在函数调用过程中，会通过栈寄存器来维护栈帧相关的内容。函数运行时，栈帧 (Stack Frame) 非常重要，包含了函数的局部变量以及函数调用之间的传参。&lt;/p></description></item><item><title>MySQL 组提交</title><link>https://gohalo.github.io/cn/blog/mysql-group-commit/</link><pubDate>Sun, 01 Oct 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-group-commit/</guid><description>&lt;p>组提交 (group commit) 是为了优化写日志时的刷磁盘问题，从最初只支持 InnoDB redo log 组提交，到 5.6 官方版本同时支持 redo log 和 binlog 组提交，大大提高了 MySQL 的事务处理性能。&lt;/p>
&lt;p>下面将以 InnoDB 存储引擎为例，详细介绍组提交在各个阶段的实现原理。&lt;/p></description></item><item><title>Flex 简介</title><link>https://gohalo.github.io/cn/blog/program-concept-lexical-flex-introduce/</link><pubDate>Fri, 29 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-concept-lexical-flex-introduce/</guid><description>一种词法分析器，可以通过正则表达式识别文本中的词汇，然后自动生成对应的 C 代码，最后编译链接 C 代码就可以了。
Flex 采用的是状态机，通过分析输入流 (字符流)，只要发现一段字符能够匹配一个关键字 (正则表达式)，就会采取对应的动作。
简介 # Flex 文件被 %% 分成了上中下三个部分：
第一部分中要写入 C/C++ 代码必须用 %{ 和 %} 括起来，将原封不动放到生成源码中。 第二部分是规则段，包括了模式 (正则表达式) 和动作，由空白分开，当匹配到模式时，就会执行后面的动作。 第三部分可以直接写入 C/C++ 代码。 yylex() 是扫描程序的入口，调用该函数启动或重新开始，该函数会初始化一些全局变量，然后开始扫描。如果定义的 flex 动作是将数值传递给调用程序，那么对 yylex() 的下次调用就从它停止的地方继续扫描。
%{ #include &amp;lt;stdio.h&amp;gt; %} %% is | are { printf(&amp;#34;%s: VERB &amp;#34;, yytext); } island printf(&amp;#34;LAND &amp;#34;); [0-9]+ printf(&amp;#34;NUMBER &amp;#34;); [ \t]+ /* ignore whitespace */; [a-zA-Z][a-zA-Z0-9]* printf(&amp;#34;COMMON WORD &amp;#34;); .|\n { ECHO; } %% int main(void) { yylex(); } 特殊字符 '.</description></item><item><title>词法语法解析</title><link>https://gohalo.github.io/cn/blog/program-lexical-basic-introduce/</link><pubDate>Fri, 29 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-lexical-basic-introduce/</guid><description>&lt;p>介绍与词法语法分析相关的概念。&lt;/p></description></item><item><title>Bison 简介</title><link>https://gohalo.github.io/cn/blog/program-concept-syntax-bison-introduce/</link><pubDate>Wed, 20 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-concept-syntax-bison-introduce/</guid><description>&lt;p>bison 读入一个 CFG 文法的文件，在程序内经过计算，输出一个 parser generator 的 c 文件；也就是说 Bison 适合上下文无关文法，采用 LALR Parser (LALR语法分析器)。&lt;/p></description></item><item><title>MySQL Crash-Safe 复制</title><link>https://gohalo.github.io/cn/blog/mysql-crash-safe-replication/</link><pubDate>Mon, 18 Sep 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-crash-safe-replication/</guid><description>&lt;p>简单来说，crash-safe replication 是指当主备库任何一个节点发生宕机等意外情况下，服务器重启后主备的数据依然能够保证一致性。&lt;/p>
&lt;p>接下来看看 MySQL 中是如何实现的。&lt;/p></description></item><item><title>UUID 详细介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-uuid-introduce/</link><pubDate>Fri, 15 Sep 2017 21:18:05 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-uuid-introduce/</guid><description>&lt;p>UUID 的目的是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中心节点指定，无需考虑数据库创建时的名称重复问题，目前最广泛应用的 UUID 是 RFC4122 协议规范的。&lt;/p>
&lt;p>有时 GUID 也特指是微软对标准 UUID 的实现，其实 RFC4122 的作者之一也是微软员工，这里介绍其使用方法。&lt;/p></description></item><item><title>Zabbix 监控系统</title><link>https://gohalo.github.io/cn/blog/zabbix-monitor-introduce/</link><pubDate>Sun, 10 Sep 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zabbix-monitor-introduce/</guid><description>&lt;p>Zabbix 能监视各种网络、系统参数，保证服务器系统的安全运行，同时提供了灵活的 API 接口，例如通知机制，可以让系统管理员及时通过或者当前的异常状态，支持 Agentd、SNMP、JMX 等多种监控方式。&lt;/p>
&lt;p>同时，提供了一个 WEB 界面，可以作为分布式系统监控以及网络监控的企业级开源解决方案。&lt;/p></description></item><item><title>正则表达式</title><link>https://gohalo.github.io/cn/blog/program-c-string-regular-expression/</link><pubDate>Tue, 05 Sep 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-regular-expression/</guid><description/></item><item><title>CentOS 内核、软件升级</title><link>https://gohalo.github.io/cn/blog/centos-update-version/</link><pubDate>Fri, 01 Sep 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/centos-update-version/</guid><description>&lt;p>CentOS 使用 yum 管理包以及升级内核，不过为了保持稳定，一般官方仓库提供的内核版本往往小于 Linux 的正式版本。&lt;/p>
&lt;p>这里简单介绍如何使用三方仓库进行升级。&lt;/p></description></item><item><title>P2P 协议简介</title><link>https://gohalo.github.io/cn/blog/network-p2p-introduce/</link><pubDate>Mon, 28 Aug 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-p2p-introduce/</guid><description>不同于传统的 C/S 服务模型，取消了中心服务器，每个节点都可以作为客户端和服务端。
简介 # BitTorrent 实际上是一个协议族，其基本协议是 BEP-3 ，其它的大部分协议都是围绕这个来进行扩展或补充。
如果要通过 P2P 协议进行下载，必须要包含如下的几个文件：
种子文件，一般后缀为 .torrent ，本质上是一个由 bencode 编码的文本文件，把资源分成很多虚拟块，并记录每个块的 hash 值，还包括了文件大小、名字、Tracker服务器等信息。 BT 客户端，也就是专门解析 BT 协议的程序，例如迅雷、电驴等。 Tracker 服务器，记录着 Peer 和种子相关信息，起着中心调控的作用。 在下载资源的时候，大致的流程如下：
客户端解码种子文件，得到 Tracker 服务器的地址和资源信息； 通过和 Tracker 服务器沟通得到其它已经下载该资源的 Peers 信息； 再和这些 Peers 沟通得到自己想要的部分。 可以看到，在上述的流程中，Tracker 是整个流程的关键部分，如果不能通过 Tracker 读取到 Peers 的相关信息，那么也就无法下载资源。
DHT 协议 # 为了弥补 Tracker 的单点问题，于是出现了 Distributed Hash Table, DHT 协议，该协议基于 Kademlia 建立。
参考 # 一个资源嗅探器的网站 bthub.io 。 官方网站 bittorrent.org 包括了很多相关协议的开发文档。 一个传输可视化的示例网站 mq8.org 。</description></item><item><title>Linux C 网络编程</title><link>https://gohalo.github.io/cn/blog/program-c-network/</link><pubDate>Mon, 21 Aug 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-network/</guid><description/></item><item><title>MySQL 线上部署</title><link>https://gohalo.github.io/cn/blog/mysql-deploy-online/</link><pubDate>Mon, 21 Aug 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-deploy-online/</guid><description>&lt;p>主要介绍下 MySQL 如何在线上进行部署。&lt;/p></description></item><item><title>Linux C 网络编程</title><link>https://gohalo.github.io/cn/blog/c-linux-network-socket-program/</link><pubDate>Mon, 21 Aug 2017 17:49:01 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-network-socket-program/</guid><description>&lt;p>在 linux 中的网络编程会涉及到很多的细节，这里简单整理常见的问题，例如套接子信息、域名解析等等，有些也可能不怎么常见，以备不时之需。&lt;/p></description></item><item><title>50 行 Python 实现 Bitcoin</title><link>https://gohalo.github.io/cn/blog/bitcoin-50-python-lines/</link><pubDate>Mon, 07 Aug 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bitcoin-50-python-lines/</guid><description>&lt;p>区块链近年来被越炒越热，是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一次比特币网络交易的信息，用于验证其信息的有效性和生成下一个区块。&lt;/p>
&lt;p>而比特币的交易过程中，就使用了区块链技术。&lt;/p></description></item><item><title>Docker Volume 简介</title><link>https://gohalo.github.io/cn/blog/docker-concept-volume-introduce/</link><pubDate>Wed, 02 Aug 2017 21:16:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/docker-concept-volume-introduce/</guid><description>&lt;p>所谓的 Docker 数据持久化，也就是数据不会随着容器的结束而删除，对于像数据库这类的应用，为了能够使数据持久化，提供了 Volume 的概念，简单来说，就是可以绕过默认的联合文件系统，将文件或者目录保存在宿主机上。&lt;/p>
&lt;p>通常有两种：A) Bind Mount 保存在主机上的某个目录；B) Volume 通过 Docker 自己管理的 Volume 。&lt;/p></description></item><item><title>似然函数</title><link>https://gohalo.github.io/cn/blog/math-statistics-likelihood-function/</link><pubDate>Tue, 01 Aug 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-statistics-likelihood-function/</guid><description>&lt;p>在统计学中，通常所要观测的样本集很大 (全国身高)，很难完成这么多的样本数据采集，这时就需要用到估计了。&lt;/p>
&lt;p>一般会抽取样本，然后通过统计样本 (Sample) 去估计总体 (Population)，也就是参数估计。&lt;/p>
&lt;p>参数估计中的最大似然估计，有点难理解，这里简单介绍。&lt;/p></description></item><item><title>C/C++ Sanitizer 简介</title><link>https://gohalo.github.io/cn/blog/language-c-some-sanitizers-introduce/</link><pubDate>Tue, 25 Jul 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-c-some-sanitizers-introduce/</guid><description>&lt;p>Sanitizer 英文翻译过来是杀菌剂的意思，Google 提供了很多相关的一些 Sanitizers ，用来检测程序的异常。&lt;/p>
&lt;p>可以做内存、地址访问、竞态条件的检测，这里简单介绍。&lt;/p></description></item><item><title>Linux CGroup 监控</title><link>https://gohalo.github.io/cn/blog/linux-monitor-cgroup-introduce/</link><pubDate>Sun, 23 Jul 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-cgroup-introduce/</guid><description/></item><item><title>详细介绍 MySQL Sandbox 使用</title><link>https://gohalo.github.io/cn/blog/mysql-sandbox/</link><pubDate>Sat, 22 Jul 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-sandbox/</guid><description>&lt;p>MySQL Sandbox 是个用于在本地快速部署 MySQL 服务的工具，包括了不同版本，不同模式的部署，例如单节点、主备部署、一主多备等等；如果配合 &lt;a href="http://gearman.org/">Gearman&lt;/a>，甚至可以完成分布式的部署。&lt;/p>
&lt;p>该程序通常用于测试，是用 Perl 语言编写的，在此，仅简单介绍下如何使用。&lt;/p></description></item><item><title>MySQL CAPI 接口</title><link>https://gohalo.github.io/cn/blog/mysql-capi/</link><pubDate>Fri, 21 Jul 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-capi/</guid><description>&lt;p>在编写 MySQL 客户端程序时，最常见的就是如何连接以及关闭 MySQL，这里需要注意，如果使用不当将会造成内存泄漏。&lt;/p>
&lt;p>这里，简单介绍 MySQL 中如何通过 C 进行编程。&lt;/p></description></item><item><title>MySQL 使用简介</title><link>https://gohalo.github.io/cn/blog/mysql-install-debug/</link><pubDate>Sun, 16 Jul 2017 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-install-debug/</guid><description>&lt;p>MySQL 是一款最流行的开源关系型数据库，最初由瑞典的 MySQL AB 公司开发，目前已被 Oracle 收购，现在比较流行的分支包括了 MariaDB 和 Percona。&lt;/p>
&lt;p>现在来看，MySQL 被收购之后，实际上添加了很多不错的特性，解掉了很多之前未解的问题，而现在 MariaDB 离主干的特性越来越远；而 Percona 据说为了保证质量是不接受社区提供的代码的，不过其提供的工具却是极好的^_^&lt;/p>
&lt;p>在此，简单介绍，二进制安装、源码编译安装、单实例以及多实例的启动、常见的调试方法。&lt;/p></description></item><item><title>tcpdump 常用网络命令</title><link>https://gohalo.github.io/cn/blog/linux-network-command-tcpdump/</link><pubDate>Sun, 16 Jul 2017 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-command-tcpdump/</guid><description>&lt;p>tcpdump 会根据表达式 (expression) 来决定是否过滤报文，如果满足条件则会捕获报文，如果没有给出任何条件则会将所有的报文捕获。&lt;/p></description></item><item><title>R 概率函数</title><link>https://gohalo.github.io/cn/blog/r-language-some-statistic-function-introduce/</link><pubDate>Sat, 15 Jul 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/r-language-some-statistic-function-introduce/</guid><description/></item><item><title>Linux ptrace 简介</title><link>https://gohalo.github.io/cn/blog/linux-ptrace-api-introduce/</link><pubDate>Thu, 15 Jun 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ptrace-api-introduce/</guid><description>&lt;p>&lt;code>ptrace()&lt;/code> 是一个由 Linux 内核提供的系统调用，允许一个用户态进程检查、修改另一个进程的内存和寄存器，通常用在类似 gdb、strace 的调试器中，用来实现断点调试、系统调用的跟踪。&lt;/p>
&lt;p>你想过怎么实现对系统调用的拦截吗？你尝试过通过改变系统调用的参数来愚弄你的系统 kernel 吗？你想过调试器是如何使运行中的进程暂停并且控制它吗？&lt;/p>
&lt;p>这里简单介绍如何使用该接口。&lt;/p></description></item><item><title>GoLang sync 模块介绍</title><link>https://gohalo.github.io/cn/blog/golang-common-module-sync-introduce/</link><pubDate>Sun, 11 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-sync-introduce/</guid><description/></item><item><title>Golang nil 解析</title><link>https://gohalo.github.io/cn/blog/golang-basic-concept-nil-introduce/</link><pubDate>Sat, 10 Jun 2017 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-basic-concept-nil-introduce/</guid><description/></item><item><title>Golang bytes 模块</title><link>https://gohalo.github.io/cn/blog/golang-common-module-bytes-introduce/</link><pubDate>Thu, 08 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-common-module-bytes-introduce/</guid><description>&lt;p>Golang 中的 bytes 包使用频率较高，主要提供了字节相关的操作，通常作为缓冲区使用。&lt;/p></description></item><item><title>Golang 调试方法</title><link>https://gohalo.github.io/cn/blog/golang-call-frame-debug-method-introduce/</link><pubDate>Thu, 08 Jun 2017 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-call-frame-debug-method-introduce/</guid><description/></item><item><title>Python DocString 简介</title><link>https://gohalo.github.io/cn/blog/python-basic-syntax-docstring-introduce/</link><pubDate>Mon, 05 Jun 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-basic-syntax-docstring-introduce/</guid><description>&lt;p>也就是 Python 的文档字符串，提供了一种很方便的方式将文档与 modules、functions、classes 以及 methods ；该字符串是在对象的第一个语句中定义，然后通过 &lt;code>__doc__&lt;/code> 引用。&lt;/p></description></item><item><title>Python 杂项</title><link>https://gohalo.github.io/cn/blog/python-tips/</link><pubDate>Mon, 05 Jun 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-tips/</guid><description>&lt;p>在此记录与 Python 相关的乱七八糟的东西。&lt;/p></description></item><item><title>C++ 构造析构函数详细分析</title><link>https://gohalo.github.io/cn/blog/cpp-constructor-destructor/</link><pubDate>Wed, 31 May 2017 20:19:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-constructor-destructor/</guid><description>&lt;p>在 C++ 中，当类的内存申请完之后，会通过构造函数进行初始化，而构造函数在不同的使用场景下又分成了不同的类型，例如默认构造函数、简单构造函数、复制构造函数、转换构造函数等等。&lt;/p>
&lt;p>同时，在涉及到赋值操作时，最好将赋值操作运算符也重载掉，尤其是会动态申请内存的类；另外，随着 C++11 标准的发布，有引入了移动构造函数以及移动赋值运算符。&lt;/p>
&lt;p>这就导致构造函数与赋值重载不断重叠，很容易引起混淆，所以，这里就详细介绍其使用方式。&lt;/p></description></item><item><title>Python ORM 简介</title><link>https://gohalo.github.io/cn/blog/python-orm-introduce/</link><pubDate>Tue, 23 May 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-orm-introduce/</guid><description>&lt;p>很多数据库都可以通过相应的库，直接编写原生的 SQL 语句进行操作，实现增删改查，但是如果功能比较复杂，就会导致重用性不强。&lt;/p>
&lt;p>Object Relational Mapping, ORM 建立在数据库 API 之上，使用关系对象映射进行数据库操作；简言之，将对象转换成 SQL，然后使用数据 API 执行 SQL 并获取执行结果。&lt;/p></description></item><item><title>连续概率 -- 正态分布</title><link>https://gohalo.github.io/cn/blog/math-probability-continuous-normal-distribution/</link><pubDate>Sun, 21 May 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-probability-continuous-normal-distribution/</guid><description>&lt;p>&lt;code>Normal distribution 正态分布&lt;/code> 也称为 &lt;code>Gaussian Distribution 高斯分布&lt;/code>，这是一个在数学、物理、工程等领域都非常重要的概率分布，在统计学的很多方面都有着重大影响力。&lt;/p></description></item><item><title>连续概率分布</title><link>https://gohalo.github.io/cn/blog/math-probability-basic-concept-continuous-distribution/</link><pubDate>Sat, 20 May 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-probability-basic-concept-continuous-distribution/</guid><description>&lt;p>介绍一些常见的概率分布。&lt;/p></description></item><item><title>离散概率分布</title><link>https://gohalo.github.io/cn/blog/math-probability-basic-concept-discrete-distribution/</link><pubDate>Sun, 14 May 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-probability-basic-concept-discrete-distribution/</guid><description>&lt;p>一些常见的离散概率分布，包括了伯努利分布、二项分布、泊松分布等，包括了如何通过 Python 进行测试。&lt;/p></description></item><item><title>Linux 资源限制</title><link>https://gohalo.github.io/cn/blog/linux-resource-limit-introduce/</link><pubDate>Tue, 09 May 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-resource-limit-introduce/</guid><description>&lt;p>如何通过最简单的设置来实现最有效的性能调优，在有限资源的条件下保证程序的运作，ulimit 是在处理这些问题时，经常使用的一种简单手段。&lt;/p>
&lt;p>ulimit 是一种 Linux 系统的内键功能，它具有一套参数集，用于为由它生成的 shell 进程及其子进程的资源使用设置限制。&lt;/p></description></item><item><title>压缩库使用</title><link>https://gohalo.github.io/cn/blog/program-c-compress-library-introduce/</link><pubDate>Mon, 01 May 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-compress-library-introduce/</guid><description/></item><item><title>GDB Python 脚本</title><link>https://gohalo.github.io/cn/blog/gdb-python-script/</link><pubDate>Sat, 15 Apr 2017 20:39:11 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-python-script/</guid><description>&lt;p>GDB 很早就支持自定义脚本辅助调试，不过语法比较老，不如 Python 使用方便广泛，从 GDB 7.X(2009) 版本开始支持 Python Scripting ，不过建议使用 9.X 以上的版本，关于 Python 的详细特性可以参考 &lt;a href="https://www.sourceware.org/gdb/news/">GDB News&lt;/a> 的内容。&lt;/p></description></item><item><title>libev 信号处理</title><link>https://gohalo.github.io/cn/blog/libev-source-code-signal-process-details/</link><pubDate>Sat, 15 Apr 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-source-code-signal-process-details/</guid><description>&lt;p>信号的处理非常敏感，如果处理不当很容易出现问题，如果在信号处理函数中使用了非信号安全函数，那么很容易发生死锁。&lt;/p>
&lt;p>这里简单介绍 libev 中是如何处理信号的。&lt;/p></description></item><item><title>MySQL Handler 监控</title><link>https://gohalo.github.io/cn/blog/mysql-monitor-handler/</link><pubDate>Fri, 14 Apr 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-monitor-handler/</guid><description>&lt;p>在 MySQL 中有很多的 &lt;code>handler_*&lt;/code> 类型的监控，接下来我们就看看这些监控项。&lt;/p></description></item><item><title>Linux Fail Points</title><link>https://gohalo.github.io/cn/blog/linux-c-fail-point-introduce/</link><pubDate>Mon, 10 Apr 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-c-fail-point-introduce/</guid><description>&lt;p>对于一些异常一般很难构建，尤其是像系统 API 调用、硬件故障等等，通过 FailPoints 可以在指定的代码段注入一些异常处理。&lt;/p>
&lt;p>实际上，BSD 已经提供了一套相关的 FailPoints 机制。&lt;/p></description></item><item><title>Linux 信号安全</title><link>https://gohalo.github.io/cn/blog/linux-signal-safe-introduce/</link><pubDate>Wed, 05 Apr 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-signal-safe-introduce/</guid><description>&lt;p>最近遇到比较奇葩的问题，在信号处理函数中，为了方便查看收到的是何信号，会打印相关的日志，不过也因此在连续收到信号时导致死锁。&lt;/p>
&lt;p>这里简单排查下原因，以及如何进行规避。&lt;/p></description></item><item><title>SSH 常用技巧</title><link>https://gohalo.github.io/cn/blog/ssh-some-tips/</link><pubDate>Mon, 27 Mar 2017 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-some-tips/</guid><description>&lt;p>简单记录一些常见的 SSH 使用技巧。&lt;/p></description></item><item><title>C++ STL 使用</title><link>https://gohalo.github.io/cn/blog/language-cpp-stl-basic-usage-introduce/</link><pubDate>Thu, 23 Mar 2017 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/language-cpp-stl-basic-usage-introduce/</guid><description/></item><item><title>关于 C++ 基本概念介绍</title><link>https://gohalo.github.io/cn/blog/cpp-basic-syntax-introduce/</link><pubDate>Mon, 20 Mar 2017 21:15:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-basic-syntax-introduce/</guid><description>&lt;p>一般会将 C++ 划分为所谓的中级语言，从底层的 C 语言发展而来，提供了比 C 更丰富的特性，而又没有提供类似 Java、Python 等语言的高级特性，所以，介于中间，称之为中级语言。&lt;/p>
&lt;p>随着 C++11 标准的发布，以及更新的 C++0x 标准，C++ 提供的功能越来越完善。&lt;/p>
&lt;p>这里仅简单介绍下基本的概念。&lt;/p></description></item><item><title>libev 时间处理</title><link>https://gohalo.github.io/cn/blog/libev-timers/</link><pubDate>Mon, 20 Mar 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-timers/</guid><description>&lt;p>在之前的文章中介绍了 libev 库的基本概念以及常见的使用方法，其中与时间相关的内容只是简单介绍，不过这一部分涉及到的内容会比较多，而且杂，所以单独摘出来介绍下。&lt;/p></description></item><item><title>GDB 基本功能介绍</title><link>https://gohalo.github.io/cn/blog/gdb-basic-usage-introduce/</link><pubDate>Fri, 10 Mar 2017 22:30:31 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/gdb-basic-usage-introduce/</guid><description>&lt;p>GNU Project Debugger, GDB 一个代码调试工具，通过系统提供的 ptrace 接口实现的控制进程，然后可以在进程内部查看信息，甚至调用函数。&lt;/p></description></item><item><title>CPU 物理架构</title><link>https://gohalo.github.io/cn/blog/linux-cpu-physical-arch-introduce/</link><pubDate>Wed, 01 Mar 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-cpu-physical-arch-introduce/</guid><description/></item><item><title>MySQL 关闭过程</title><link>https://gohalo.github.io/cn/blog/mysql-shutdown/</link><pubDate>Wed, 01 Mar 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-shutdown/</guid><description>&lt;p>简单分析下 mysqld 进程关闭的过程，并讨论如何安全地关闭 MySQL 实例。&lt;/p></description></item><item><title>Linux NTP 介绍</title><link>https://gohalo.github.io/cn/blog/linux-ntp-related-stuff-introduce/</link><pubDate>Tue, 28 Feb 2017 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-ntp-related-stuff-introduce/</guid><description>&lt;p>网络时间协议 (Network Time Protocol, NTP) 是通过 &lt;a href="https://tools.ietf.org/html/rfc1305">RFC-1305&lt;/a> 定义的时间同步协议，该协议基于 UDP 协议，使用端口号为 123；该协议用于在时间服务器和客户端之间同步时间，从而使网络内所有设备的时钟保持一致。&lt;/p>
&lt;p>这里简单介绍 NTP 的使用方法。&lt;/p></description></item><item><title>Python2 VS. Python3</title><link>https://gohalo.github.io/cn/blog/python-version2-vs-version3-introduce/</link><pubDate>Thu, 23 Feb 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-version2-vs-version3-introduce/</guid><description/></item><item><title>报文超过 MTU</title><link>https://gohalo.github.io/cn/blog/linux-network-mtu-oversize/</link><pubDate>Mon, 20 Feb 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-mtu-oversize/</guid><description>&lt;p>正常来说，通过 TCP 传输的报文应该不会超过 MTU 大小，一般是 1500 大小。&lt;/p>
&lt;p>但是，如果通过 tcpdump 获取报文，那么可能会出现报文大小超过 MTU 的报文，甚至超过 20K 。&lt;/p></description></item><item><title>Linux 进程状态</title><link>https://gohalo.github.io/cn/blog/linux-process-state-introduce/</link><pubDate>Thu, 16 Feb 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-state-introduce/</guid><description>&lt;p>Linux 中的进程在不同的阶段会通过其状态显示，一般来说会有 7 种，相当于一个状态机运行。&lt;/p>
&lt;p>这里简单介绍，以及一些常见的特殊状态。&lt;/p></description></item><item><title>Linux 惊群详解</title><link>https://gohalo.github.io/cn/blog/linux-details-of-thundering-herd/</link><pubDate>Mon, 06 Feb 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-details-of-thundering-herd/</guid><description>简言之，惊群现象就是当多个进程或线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。
这里对 Linux 中的惊群现象进行简单介绍。
惊群 # 关于惊群的解释可以查看 Wiki 的解释 Thundering herd problem 。
accept() # 常见的场景如下。
主进程执行 socket()+bind()+listen() 后，fork() 多个子进程，每个子进程都通过 accept() 循环处理这个 socket；此时，每个进程都阻塞在 accpet() 调用上，当一个新连接到来时，所有的进程都会被唤醒，但其中只有一个进程会 accept() 成功，其余皆失败，重新休眠。这就是 accept 惊群。
如果只用一个进程去 accept 新连接，并通过消息队列等同步方式使其他子进程处理这些新建的连接，那么将会造成效率低下；因为这个进程只能用来 accept 连接，该进程可能会造成瓶颈。
而实际上，对于 Linux 来说，这只是历史上的问题，现在的内核都解决该问题，也即只会唤醒一个进程。可以通过如下程序进行测试，只会激活一个进程。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;sys/wait.h&amp;gt; #include &amp;lt;netinet/in.h&amp;gt; #define PROCESS_NUM 10 int main() { int fd = socket(PF_INET, SOCK_STREAM, 0); int connfd; int pid, i, status; char sendbuff[1024]; struct sockaddr_in serveraddr; printf(&amp;#34;Listening 0.</description></item><item><title>StatsD 监控简介</title><link>https://gohalo.github.io/cn/blog/statsd-monitor-introduce/</link><pubDate>Fri, 03 Feb 2017 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/statsd-monitor-introduce/</guid><description>&lt;p>StatsD 的使用非常简单，其中 Etsy 改写后使用的是 Node.js 编写的，所以需要先安装好 node 环境，然后修改配置文件，直接启动即可。&lt;/p>
&lt;p>当然，也可以将其理解为一个协议，也就对应了多种语言的实现。&lt;/p>
&lt;p>这里简单介绍与之相关的概念。&lt;/p></description></item><item><title>Sysbench 压测工具</title><link>https://gohalo.github.io/cn/blog/linux-benchmark-tools-sysbench/</link><pubDate>Fri, 20 Jan 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-benchmark-tools-sysbench/</guid><description>&lt;p>Linux 中有很多压测工具，不同的场景会各有优劣，例如磁盘压测工具 fio 。&lt;/p>
&lt;p>Sysbench 算是一个比较通用的压测或者基准测试工具，这是一个开源、模块化、跨平台的多线程性能测试工具，可以用来进行 CPU、内存、IO、线程、数据库的性能测试，其中数据库支持 MySQL、Oracle 和 PostgreSQL 。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>贝叶斯简介</title><link>https://gohalo.github.io/cn/blog/math-statistics-basic-concept-bayes-theorem/</link><pubDate>Fri, 20 Jan 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-statistics-basic-concept-bayes-theorem/</guid><description>&lt;p>贝叶斯定理 (Bayes&amp;rsquo; Theorem) 是英国数学家 托马斯·贝叶斯 (Thomas Bayes) 在 1763 年发表的一篇论文中首次提出；而贝叶斯推断 (Bayesian Inference) 是贝叶斯定理的一种应用，是一种统计学方法，用来估计统计量的某些性质。&lt;/p>
&lt;p>这里简单介绍其基本概念。&lt;/p></description></item><item><title>马尔科夫简介</title><link>https://gohalo.github.io/cn/blog/math-statistics-markov-process/</link><pubDate>Fri, 20 Jan 2017 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/math-statistics-markov-process/</guid><description/></item><item><title>Linux 时间相关概念介绍</title><link>https://gohalo.github.io/cn/blog/linux-time-basic/</link><pubDate>Sun, 15 Jan 2017 21:16:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-time-basic/</guid><description>&lt;p>简单介绍在 Linux 中部分与时间相关的概念，例如时区、闰秒、夏令时、ntp 等。&lt;/p>
&lt;p>&amp;ldquo;现在几点了？&amp;rdquo; 或者 &amp;ldquo;离过年还有多久？&amp;rdquo; 这恐怕连小学生也觉得是再简单不过的问题了；但是如果问及 &amp;ldquo;时间是什么？&amp;rdquo; 恐怕绝大多数人都会顿觉茫然。&lt;/p></description></item><item><title>Linux 进程优先级</title><link>https://gohalo.github.io/cn/blog/linux-process-exec-priority-nice-introduce/</link><pubDate>Thu, 12 Jan 2017 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-process-exec-priority-nice-introduce/</guid><description/></item><item><title>Python 字典对象实现</title><link>https://gohalo.github.io/cn/blog/python-dictioniary-string-hash-table/</link><pubDate>Sun, 08 Jan 2017 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-dictioniary-string-hash-table/</guid><description>&lt;p>在 Python 中有一个字典，可以看作是一个 Key Value 对，其代码是通过哈希表实现，也就是说，字典是一个数组，而数组的索引是键经过哈希函数处理后得到的。&lt;/p>
&lt;p>Python 字典是用哈希表 (hash table) 实现，哈希表是一个数组，它的索引是对键运用哈希函数计算求得的。&lt;/p>
&lt;p>这里简单结合 Python 中 Hash 函数的实现。&lt;/p></description></item><item><title>事件驱动库 libev 使用详解</title><link>https://gohalo.github.io/cn/blog/libev-basic-introduce/</link><pubDate>Fri, 30 Dec 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-basic-introduce/</guid><description>&lt;p>libev 是一个通过 C 语言编写的，高性能的事件循环库，支持多种事件类型，与此类似的事件循环库还有 libevent、libubox 等，相比来说这个库要简单很多，在此详细介绍下 libev 相关的内容。&lt;/p></description></item><item><title>Linux 后台服务管理</title><link>https://gohalo.github.io/cn/blog/linux-daemon-tools/</link><pubDate>Fri, 23 Dec 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-daemon-tools/</guid><description>&lt;p>在 Linux 中，对于一个后台服务，如果要可靠地在后台运行，最好能监控进程状态，在意外结束时能自动重启。&lt;/p>
&lt;p>常见的功能全面的主流工具主要有 monit(C)、supervisor(Python)、goreman(Go)，其中 goreman 是对 Ruby 下广泛使用的 foreman 工具，使用 golang 的重写。&lt;/p>
&lt;p>在此，仅介绍下在 Linux 中如何使用。&lt;/p></description></item><item><title>libev 源码详解</title><link>https://gohalo.github.io/cn/blog/libev-source-code-introduce/</link><pubDate>Thu, 15 Dec 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/libev-source-code-introduce/</guid><description>&lt;p>libev 内部结构比较简单，只提供了基本的处理逻辑，其中核心主要分成了几部分：文件描述符处理。&lt;/p></description></item><item><title>RPM DB 修复</title><link>https://gohalo.github.io/cn/blog/linux-rpm-fixdb-introduce/</link><pubDate>Thu, 01 Dec 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-rpm-fixdb-introduce/</guid><description>&lt;p>在一些 Linux 的发行版本中，例如 CentOS、SUSE 中，会采用 RPM 来管理软件包，不过在使用过程中，经常会出现由于各种各样的原因导致 RPM DB 被损坏。&lt;/p>
&lt;p>这里简单介绍一下其修复方法。&lt;/p></description></item><item><title>Conky 配置简介</title><link>https://gohalo.github.io/cn/blog/linux-conky-introduce/</link><pubDate>Thu, 17 Nov 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-conky-introduce/</guid><description>&lt;p>Conky 是一个轻量级的桌面系统监控工具，支持多种监控项，而且支持 Python、Lua 脚本。&lt;/p></description></item><item><title>C 代码覆盖率</title><link>https://gohalo.github.io/cn/blog/c-coverage-introduce/</link><pubDate>Sun, 13 Nov 2016 17:12:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-coverage-introduce/</guid><description>&lt;p>我们已经提供了一些测试用例，但是这些测试用例的好坏如何评估？是否已经覆盖了所有的函数？函数中的分支以及边界条件是否都已经覆盖？&lt;/p>
&lt;p>这就需要通过代码覆盖率进行查看，这里简单介绍其使用方法。&lt;/p></description></item><item><title>Linux Gunplot 使用简介</title><link>https://gohalo.github.io/cn/blog/linux-gnuplot/</link><pubDate>Thu, 03 Nov 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-gnuplot/</guid><description>&lt;p>主要介绍一下 Linux 中的 Gnuplot Graphviz 套件，主要用于画图。&lt;/p>
&lt;p>Ggnuplot 是一个命令行驱动的绘图工具，可将数学函数或数值资料以平面图或立体图的形式画在不同种类终端机或绘图输出装置上，是由 Colin Kelley 和 Thomas Williams 于 1986 年开发的绘图程序发展而来的，可以在多个平台下使用。&lt;/p>
&lt;p>graphviz 是贝尔实验室开发的一个开源的工具包，它使用一个特定的 DSL(领域特定语言) dot 作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。该软件包提供丰富的导出格式，如常用的图片格式，SVG、PDF 格式等。&lt;/p>
&lt;p>在此介绍一下常见的使用方法。&lt;/p></description></item><item><title>C 编译链接</title><link>https://gohalo.github.io/cn/blog/c-compile-linkage-introduce/</link><pubDate>Sun, 23 Oct 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-compile-linkage-introduce/</guid><description>&lt;p>详细介绍下与 C 语言相关的概念。&lt;/p></description></item><item><title>PGP 简介</title><link>https://gohalo.github.io/cn/blog/security-pgp-introduce/</link><pubDate>Fri, 21 Oct 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-pgp-introduce/</guid><description>&lt;p>GnuPGP 是一个基于公钥加密体系的加密软件，功能强大，有很快的速度，而且源码是免费的。&lt;/p>
&lt;p>这里简单介绍下 PGP 相关内容。&lt;/p></description></item><item><title>C Mock 使用以及机制介绍</title><link>https://gohalo.github.io/cn/blog/c-linux-mock-wrap-unit-test/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-mock-wrap-unit-test/</guid><description>&lt;p>编写高效松耦合的模块，体现的是功力，而完善的测试用例则是习惯。包括了一些异常场景的积累，代码重构时的验证等等，编写有效的测试用例就尤为重要。&lt;/p>
&lt;p>而 C 语言，由于其偏向于底层，导致不能像 Java、Python、GO 那样提供了成熟的测试框架。&lt;/p>
&lt;p>这里简单介绍一下基于 cmocka 修改的测试框架，会通过一些宏定义处理部分问题，当然，真正使用时还需要一些其它的技巧。&lt;/p></description></item><item><title>CMake 常用示例</title><link>https://gohalo.github.io/cn/blog/cmake-some-tips/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cmake-some-tips/</guid><description>&lt;p>整理常用的示例。&lt;/p></description></item><item><title>Ping 协议详细介绍</title><link>https://gohalo.github.io/cn/blog/network-icmp-ping-introduce/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-icmp-ping-introduce/</guid><description>&lt;p>Internet Control Message Protocol, ICMP(RFC-792) 基于 IP 协议，工作在七层协议的第三层，主要用来解析网络路由情况，通过返回错误信息进行分析定位。&lt;/p>
&lt;p>这里详细介绍其使用方式。&lt;/p></description></item><item><title>详细介绍 GoLang 的包管理机制</title><link>https://gohalo.github.io/cn/blog/golang-package-management/</link><pubDate>Sun, 16 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-package-management/</guid><description>&lt;p>当拿到代码后，用户首先看到和接触的就是源码文件的布局、命名还有包的结构，代码漂亮、布局清晰、通俗易懂，就像是设计严谨的 API 一样。GoLang 的包管理经历了好几个阶段，从简单的通过环境变量管理，到现在完善的机制。&lt;/p>
&lt;p>相比其它语言，GoLang 的包管理机制对包、变量、代码格式，甚至代码组织结构等，都有详细的约束，这里详细介绍其包管理的规则。&lt;/p></description></item><item><title>MySQL 监控指标</title><link>https://gohalo.github.io/cn/blog/mysql-monitor/</link><pubDate>Tue, 11 Oct 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-monitor/</guid><description>&lt;p>为了排查问题，对数据库的监控是必不可少的，在此介绍下 MySQL 中的常用监控指标。&lt;/p></description></item><item><title>GoLang JSON 编码解码</title><link>https://gohalo.github.io/cn/blog/golang-json-encode-decode-introduce/</link><pubDate>Fri, 07 Oct 2016 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-json-encode-decode-introduce/</guid><description>&lt;p>随着 REST API 的兴起，基本上已经前后端分离，更多的返回格式是 json 字符串，这里简单讨论下在 GoLang 中如何编码和解码 JSON 结构。&lt;/p>
&lt;p>GoLang 提供了 &lt;code>encoding/json&lt;/code> 的标准库用于 JSON 的处理，简单记录 GoLang 中使用 JSON 的常用技巧。&lt;/p></description></item><item><title>InfluxDB</title><link>https://gohalo.github.io/cn/blog/influxdata-influxdb-introduce/</link><pubDate>Sun, 25 Sep 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/influxdata-influxdb-introduce/</guid><description>&lt;p>InfluxDB 是一个开源分布式时序、事件和指标数据库，使用 Go 语言编写，无需外部依赖，其设计目标是实现分布式和水平伸缩扩展。&lt;/p>
&lt;p>InfluxData 提供了 TICK 一套解决方案，不过使用比较多的是 InfluxDB，在此就介绍下 InfluxDB 以及 Telegraf 。&lt;/p></description></item><item><title>Bash 重定向</title><link>https://gohalo.github.io/cn/blog/linux-bash-redirect-details/</link><pubDate>Fri, 23 Sep 2016 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-bash-redirect-details/</guid><description>&lt;p>所谓 IO 重定向简单来说就是一个过程，这个过程捕捉一个文件、命令、程序、脚本、甚至脚本中的代码块的输出，然后把捕捉到的输出，作为输入发送给另外一个文件、命令、程序、或者脚本。&lt;/p>
&lt;p>这里简单介绍常用命令及其实现。&lt;/p></description></item><item><title>Systemtap</title><link>https://gohalo.github.io/cn/blog/linux-systemtap/</link><pubDate>Thu, 15 Sep 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-systemtap/</guid><description>&lt;p>Systemtap 几乎是目前所知的最强大的内核调试工具，甚至有人说它无所不能，接下来，我们就看看 SystemTAP 。&lt;/p></description></item><item><title>时序数据库简介</title><link>https://gohalo.github.io/cn/blog/time-series-database-introduce/</link><pubDate>Mon, 12 Sep 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/time-series-database-introduce/</guid><description>&lt;p>时序数据以时间作为主要的查询纬度，通常会将连续的多个时间序列数据绘制成线，可制作基于时间的多纬度报表，用揭示其趋势、规律、异常，除了实时在线预测和预警，还可以做离线的数据分析甚至是机器学习。&lt;/p></description></item><item><title>HTTP 协议简介</title><link>https://gohalo.github.io/cn/blog/network-http-introduce/</link><pubDate>Fri, 09 Sep 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-http-introduce/</guid><description>&lt;p>HTTP 协议在 TCP/IP 协议之上，目前已经成为了互联网的基础协议，也是网页开发的必备知识，这里简单介绍下 HTTP 协议的历史演变、设计思路，以及相关的解析实现。&lt;/p></description></item><item><title>Collectd 源码解析</title><link>https://gohalo.github.io/cn/blog/collectd-sourcecode/</link><pubDate>Fri, 26 Aug 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/collectd-sourcecode/</guid><description>&lt;p>接下来介绍下 Collectd 中源码的实现。&lt;/p></description></item><item><title>PostgreSQL C 语言编程</title><link>https://gohalo.github.io/cn/blog/postgresql-c-language-pgcenter/</link><pubDate>Sat, 20 Aug 2016 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/postgresql-c-language-pgcenter/</guid><description>&lt;p>对于 PostgreSQL 的 C 语言编程，可以直接使用 libpq 库，这里简单介绍其使用方法。&lt;/p></description></item><item><title>Collectd 简介</title><link>https://gohalo.github.io/cn/blog/collectd-introduce/</link><pubDate>Tue, 16 Aug 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/collectd-introduce/</guid><description>&lt;p>collectd 是一个后台监控程序，用来采集其所运行系统上的系统信息，并提供各种存储方式来存储为不同值的格式，例如 RRD 文件形式、文本格式、MongoDB 等等。&lt;/p>
&lt;p>在此，简单介绍下 collectd 。&lt;/p></description></item><item><title>ETCD 简介</title><link>https://gohalo.github.io/cn/blog/golang-raft-etcd-introduce/</link><pubDate>Sun, 14 Aug 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-raft-etcd-introduce/</guid><description>&lt;p>Etcd 是一个分布式可靠的键值存储系统，提供了与 ZooKeeper 相似的功能，通过 GoLang 开发而非 Java ，采用 RAFT 算法而非 PAXOS 算法。&lt;/p>
&lt;p>相比来所，etcd 的安装使用更加简单有效。&lt;/p></description></item><item><title>GoLang 常用工具</title><link>https://gohalo.github.io/cn/blog/golang-some-third-tools/</link><pubDate>Mon, 08 Aug 2016 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-some-third-tools/</guid><description>&lt;p>这里简单介绍下 GoLang 中常用的工具，包括了 GVM、GDM、Goreman 等。&lt;/p></description></item><item><title>cgroup 之 cpuset 简介</title><link>https://gohalo.github.io/cn/blog/linux-cgroup-cpuset-subsys-introduce/</link><pubDate>Fri, 05 Aug 2016 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-cgroup-cpuset-subsys-introduce/</guid><description>&lt;p>在内核中可以通过 CPUSET 限制进程只使用某几个 CPU，更准确的说是某个几个逻辑核。&lt;/p></description></item><item><title>PostgreSQL 结构及权限</title><link>https://gohalo.github.io/cn/blog/postgresql-structure-privileges/</link><pubDate>Fri, 05 Aug 2016 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/postgresql-structure-privileges/</guid><description>&lt;p>在 PostgreSQL 中，有各种各样的概念，例如，一个实例中允许创建多个数据库，每个数据库中可以创建多个 schema，每个 schema 下面可以创建多个对象，包括了表、物化视图、操作符、索引、视图、序列、函数 &amp;hellip; &amp;hellip; 等等。&lt;/p>
&lt;p>另外，PG 中还有表空间的概念，这就导致上面的概念越来越混乱。&lt;/p>
&lt;p>本文主要是理解 PostgreSQL 的逻辑结构和权限体系，快速理解和管理数据库的权限。&lt;/p></description></item><item><title>PostgreSQL 简单介绍</title><link>https://gohalo.github.io/cn/blog/postgresql-introduce/</link><pubDate>Tue, 02 Aug 2016 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/postgresql-introduce/</guid><description>&lt;p>PostgreSQL 可以说是目前功能最强大、特性最丰富和结构最复杂的开源数据库管理系统，其中有些特性甚至连商业数据库都不具备。&lt;/p>
&lt;p>这里简单介绍 PG 的常见操作。&lt;/p></description></item><item><title>GoLang 实现 SSH 相关示例</title><link>https://gohalo.github.io/cn/blog/ssh-golang-examples/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-golang-examples/</guid><description>&lt;p>GoLang 提供了基础的 SSH 库，可以用来作为服务端或者客户端使用，这里整理了常见的用法。&lt;/p></description></item><item><title>SSH 代理设置</title><link>https://gohalo.github.io/cn/blog/ssh-port-forwarding/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-port-forwarding/</guid><description>&lt;p>通过 ssh 的端口转发或者隧道 (tunneling) 功能，可以实现: A) 加密 SSH Client 端至 SSH Server 端之间的通讯数据；B) 突破防火墙的限制完成一些之前无法建立的 TCP 连接。&lt;/p></description></item><item><title>SSH 基本介绍</title><link>https://gohalo.github.io/cn/blog/ssh-basic-introduce/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-basic-introduce/</guid><description>&lt;p>传统的 telnet、rcp ftp、rlogin、rsh 都是极不安全的，并且会使用明文传送密码，OpenSSH 提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。&lt;/p>
&lt;p>OpenSSH 是 SSH (Secure SHell) 协议的免费开源实现，SSH 协议族可以用来进行远程控制，或在计算机之间传送文件。这里简单介绍下 SSH 和 OpenSSH 的使用。&lt;/p></description></item><item><title>SSH 密钥管理</title><link>https://gohalo.github.io/cn/blog/ssh-keys-manage/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-keys-manage/</guid><description>&lt;p>服务端会保存自己的公私钥，客户端每次链接时会确认是否为上次记录主机。&lt;/p></description></item><item><title>SSH 证书登录介绍</title><link>https://gohalo.github.io/cn/blog/ssh-cert-manage/</link><pubDate>Tue, 26 Jul 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-cert-manage/</guid><description>&lt;p>从 OpenSSH 5.4 版本 (2010年) 开始支持 SSH 证书，相比 SSL 中使用的证书来说，SSH 的更为简单，没有证书链只有一个 CA 证书，这样就免去了商业签名授权。&lt;/p></description></item><item><title>MySQL 中 localhost 127.0.0.1 区别</title><link>https://gohalo.github.io/cn/blog/mysql-localhost-vs-loopback/</link><pubDate>Fri, 22 Jul 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-localhost-vs-loopback/</guid><description>&lt;p>最近在 MySQL 中新建了一个数据库帐号，然后配置成允许所有 IP 都可以登陆，但是当尝试从本地登陆时竟然报错 &amp;hellip; &amp;hellip; 用户名和密码都是正确的 WTF&lt;/p>
&lt;p>然后仔细研究了下，发现别有天地。&lt;/p></description></item><item><title>通过 tcprstat 工具统计应答时间</title><link>https://gohalo.github.io/cn/blog/linux-tcprstat/</link><pubDate>Wed, 20 Jul 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-tcprstat/</guid><description>&lt;p>一个不错的工具，可以用来统计服务端的数据处理时间，包括了最大最小值等统计信息。&lt;/p>
&lt;p>本文简单介绍该工具的使用方法及其实现原理。&lt;/p></description></item><item><title>Redis 简介</title><link>https://gohalo.github.io/cn/blog/redis-introduce/</link><pubDate>Mon, 18 Jul 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/redis-introduce/</guid><description>&lt;p>REmote DIctionary Server (Redis) 是一个由 Salvatore Sanfilippo 写的 KV 存储系统，采用 C 语言实现，同时提供了多种语言的 API 。&lt;/p>
&lt;p>Redis 是完全开源免费的高性能 KV 数据库，相比其它的 KV 数据库来说，Redis 还支持持久化，可以将内存中的数据保存到磁盘中，重启时再次加载；除了 KV 接口，还支持 list、set、hash 等多种数据库结构；同时支持备份以及集群模式。&lt;/p></description></item><item><title>Rust 迭代器详解</title><link>https://gohalo.github.io/cn/blog/rust-advanced-iterator/</link><pubDate>Mon, 18 Jul 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/rust-advanced-iterator/</guid><description>&lt;p>Rust 中的迭代器 (Iterator) 是一个强大灵活的工具，将数据和处理过程分离，可以简化对数组、Map、链表等的访问操作。实现时，采用惰性求值，有效降低非必要的性能开销。&lt;/p></description></item><item><title>Nginx 源码解析</title><link>https://gohalo.github.io/cn/blog/nginx-sourcecode-analyze/</link><pubDate>Tue, 28 Jun 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-sourcecode-analyze/</guid><description>&lt;p>Nginx 是业界之名的高性能服务器，采用模块化实现，这里简单看下其实现方式。&lt;/p></description></item><item><title>uWSGI 简介</title><link>https://gohalo.github.io/cn/blog/uwsgi-introduce/</link><pubDate>Thu, 23 Jun 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/uwsgi-introduce/</guid><description>&lt;p>这是一个 C 语言编写的 web 容器，实现了 wsgi 和 uwsig 协议，速度很快。&lt;/p></description></item><item><title>ELF 详解</title><link>https://gohalo.github.io/cn/blog/program-elf-details/</link><pubDate>Tue, 21 Jun 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-elf-details/</guid><description>&lt;p>ELF 的全称为 Executable and Linkable Format 用于存储 Linux 程序，可以从运行以及链接的两个视角查看，分别通过 Program Header Table 以及 Section Header Table 查看。&lt;/p></description></item><item><title>ZeroMQ 架构</title><link>https://gohalo.github.io/cn/blog/zeromq-architecture/</link><pubDate>Mon, 20 Jun 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zeromq-architecture/</guid><description>&lt;p>之前介绍了 ZeroMQ 的基本使用方法，接下来介绍一下其架构。&lt;/p></description></item><item><title>ZeroMQ 简介</title><link>https://gohalo.github.io/cn/blog/zeromq-introduce/</link><pubDate>Fri, 10 Jun 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/zeromq-introduce/</guid><description>&lt;p>ZMQ (Zero Message Queue) 是一个 C++ 编写的高性能分布式消息队列，是一个非常简单好用的传输层，使得 Socket 编程更加简单、简洁和性能更高效。&lt;/p>
&lt;p>目前比较常用的消息中间件产品包括了 RabbitMQ、ZeroMQ、ActiveMQ，三者分别通过　Erlang、C++、Java 实现，相比而言，ZMQ 是一个简单的库，而非单独的中间件产品。&lt;/p>
&lt;p>接下来简单介绍一下 ZMQ 的相关内容。&lt;/p></description></item><item><title>Linux IO 调度器</title><link>https://gohalo.github.io/cn/blog/linux-kernel-io-scheduler/</link><pubDate>Sun, 05 Jun 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-io-scheduler/</guid><description>&lt;p>用来决定块设备上 IO 操作提交顺序的方法，主要是用于提高吞吐量、降低响应时间。然而两者是相互矛盾的，为了尽量平衡这两者，Linux 内核提供了多种调度算法来适应不同的 IO 请求场景。&lt;/p>
&lt;p>这里简单介绍下 Linux 中的 IO 调度器。&lt;/p></description></item><item><title>Nginx + uWSGI + Flask</title><link>https://gohalo.github.io/cn/blog/nginx-uwsgi-flask/</link><pubDate>Mon, 23 May 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-uwsgi-flask/</guid><description>&lt;p>如前所述，Flask 是一个轻量级的 Web 应用框架，这里简单介绍如何通过 nginx、uwsgi 搭建 flask 环境。&lt;/p></description></item><item><title>CSS 选择器介绍</title><link>https://gohalo.github.io/cn/blog/web-css-selector/</link><pubDate>Fri, 20 May 2016 20:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-css-selector/</guid><description>&lt;p>简单介绍在 CSS 中如何选择对应的元素。&lt;/p></description></item><item><title>Nginx 监控</title><link>https://gohalo.github.io/cn/blog/nginx-monitor/</link><pubDate>Sat, 30 Apr 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-monitor/</guid><description>&lt;p>Nginx 服务器在生产环境中运行时，可以通过类似 Nagios、Zabbix、Munin 之类的网络监控软件。然而，很多时候处理问题时，只需要快速简单的查看当前 Nginx 服务器的状态请求。&lt;/p>
&lt;p>可以使用一个 Python 编写的工具 ngxtop，可以直接从 &lt;a href="https://github.com/lebinh/ngxtop">www.github.com&lt;/a> 上下载相应的源码。&lt;/p>
&lt;p>接下来介绍一下该工具的使用方法。&lt;/p></description></item><item><title>Nginx 日志解析</title><link>https://gohalo.github.io/cn/blog/nginx-logs/</link><pubDate>Wed, 27 Apr 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-logs/</guid><description>&lt;p>在 Nginx 的统计排错过程中，通常要依赖日志，Nginx 有非常灵活的日志记录模式，每个级别的配置可以有各自独立的访问日志。&lt;/p></description></item><item><title>Nginx 通用网关</title><link>https://gohalo.github.io/cn/blog/nginx-cgi-introduce/</link><pubDate>Mon, 18 Apr 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-cgi-introduce/</guid><description>&lt;p>CGI (Common Gateway Interface，通用网关接口) 描述了客户端和服务器程序之间传输数据的一种标准，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。&lt;/p>
&lt;p>在此我们看下具体的实现以及应用。&lt;/p></description></item><item><title>Nginx 入门</title><link>https://gohalo.github.io/cn/blog/nginx-introduce/</link><pubDate>Sat, 02 Apr 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/nginx-introduce/</guid><description>&lt;p>Nginx (发音 &amp;ldquo;Engine X&amp;rdquo;) 是一款轻量级且高性能的 Web 服务器、反向代理服务器，同时也是一个 IMAP POP3 SMTP 服务器，完全通过 C 语言编写，支持多平台，并且在 BSD-like 协议下发行。&lt;/p>
&lt;p>是由俄罗斯的 Igor Sysoev 开发，其特点是占有内存少、并发能力强、丰富的功能集和示例配置文件。在此仅简单介绍其安装使用方法。&lt;/p></description></item><item><title>MySQL 用户管理</title><link>https://gohalo.github.io/cn/blog/mysql-users/</link><pubDate>Thu, 24 Mar 2016 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-users/</guid><description>&lt;p>MySQL 权限管理系统的主要功能是证实连接到一台给定主机的用户，并且赋予该用户在数据库上的相关权限，在认证的时候是通过用户名+主机名定义。&lt;/p>
&lt;p>在此，简单介绍下 MySQL 的权限管理，以及设置相应的用户管理。&lt;/p></description></item><item><title>Webserver 简介</title><link>https://gohalo.github.io/cn/blog/webserver-introduce/</link><pubDate>Wed, 23 Mar 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/webserver-introduce/</guid><description>&lt;p>简单介绍一下 webserver，其中很大一部分是关于一些小型软件的介绍。&lt;/p></description></item><item><title>GoLang 参数校验</title><link>https://gohalo.github.io/cn/blog/golang-validator-introduce/</link><pubDate>Sat, 12 Mar 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-validator-introduce/</guid><description>&lt;p>接口开发经常会遇到一个问题是后端需要大量代码进行参数校验，防止用户的恶意请求。最常见的如日期格式、用户年龄、性别等必须是正常的值，不能随意设置。&lt;/p>
&lt;p>这里介绍 GoLang 中的一个参数校验库。&lt;/p></description></item><item><title>C Preload 简介</title><link>https://gohalo.github.io/cn/blog/c-preload-introduce/</link><pubDate>Thu, 25 Feb 2016 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-preload-introduce/</guid><description>&lt;p>Linux C 中有一个很不错的特性，可以在不改变程序的前提下，修改动态库所调用的函数，也就是 Preload 功能。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Linux 内核模块</title><link>https://gohalo.github.io/cn/blog/kernel-modules/</link><pubDate>Tue, 23 Feb 2016 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-modules/</guid><description>&lt;p>简单介绍下 Linux 中的内核模块编写，包括了内核签名机制的配置。&lt;/p></description></item><item><title>Ansible 简介</title><link>https://gohalo.github.io/cn/blog/python-ansible/</link><pubDate>Sat, 13 Feb 2016 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-ansible/</guid><description>&lt;p>Ansible 是一个配置管理工具，当然同类的产品还有 Puppet、Chef、SaltStack 等，不过上述的三者都是基于服务端+客户端的模式，而 Ansible 相对来说要简单的多，无需安装服务端和客户端，只需要有 ssh 即可，而且使用简单。&lt;/p></description></item><item><title>libevent</title><link>https://gohalo.github.io/cn/blog/linux-libevent/</link><pubDate>Fri, 12 Feb 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-libevent/</guid><description>&lt;p>libevent 是一个轻量级的开源的高性能的事件库，适用于 windows、linux、bsd 等多种平台，根据不同的平台，会选择使用 select、epoll、kqueue 等系统调用管理事件机制。&lt;/p>
&lt;p>下面简单介绍下。&lt;/p></description></item><item><title>Python 异步任务队列</title><link>https://gohalo.github.io/cn/blog/python-async-queue/</link><pubDate>Wed, 10 Feb 2016 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-async-queue/</guid><description>&lt;p>Python 中有很多的调度系统，这里简单介绍一下常用的，例如 APScheduler、Redis Queue、Celery 等。&lt;/p></description></item><item><title>DVWA 简介</title><link>https://gohalo.github.io/cn/blog/security-dvwa-introduce/</link><pubDate>Wed, 03 Feb 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-dvwa-introduce/</guid><description>&lt;p>DVWA (Damn Vulnerable Web Application) 是用 PHP+MySQL 编写的一套用于漏洞检测和教学的程序，支持多种数据库，包括了 SQL 注入、XSS 等一些常见的安全漏洞。&lt;/p>
&lt;p>详细的内容可以参考官方网站 &lt;a href="http://www.dvwa.co.uk/">www.dvwa.co.uk&lt;/a>，在此暂时仅介绍其环境的安装方法。&lt;/p></description></item><item><title>日志切割 logrotate 使用方法</title><link>https://gohalo.github.io/cn/blog/logrotate-usage/</link><pubDate>Sun, 31 Jan 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/logrotate-usage/</guid><description>&lt;p>通常我们会通过日志记录程序运行时各种信息，如有异常，则通过日志分析用户行为、记录运行轨迹、查找程序问题。但是，磁盘空间有限，为了节省空间和方便整理，可以将日志文件按时间或大小分成多份，删除时间久远的日志文件。&lt;/p>
&lt;p>这就是通常说的日志滚动 (log rotation)，在本文中，就简单介绍下 Linux 中的 logrotate 程序。&lt;/p></description></item><item><title>SSH 便捷登录配置</title><link>https://gohalo.github.io/cn/blog/ssh-simplify-your-life/</link><pubDate>Fri, 22 Jan 2016 20:28:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-simplify-your-life/</guid><description>&lt;p>通常在一个 ssh 链接中，需要指定用户名、主机名、主机端口号、配置参数等信息，如果每次登陆一台主机都要输入，那么就会变的非常麻烦，而且一些 IP 地址通常又非常难记。&lt;/p>
&lt;p>为此，我们可以通过 OpenSSH 的客户端配置文件简化我们的登陆方式，下面简单介绍下。&lt;/p></description></item><item><title>SQLite 使用简介</title><link>https://gohalo.github.io/cn/blog/sqlite-introduce/</link><pubDate>Tue, 19 Jan 2016 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/sqlite-introduce/</guid><description>&lt;p>SQLite 是一个开源的嵌入式关系数据库，一个简单无需配置的小型数据库，支持事物，在嵌入式设备或者小型应用中使用较多，例如 Android、Chrome、WeChat 等系统。&lt;/p>
&lt;p>它在 2000 年由 D. Richard Hipp 发布，用来减少应用程序管理数据的开销，可移植性好、很容易使用、高效而且可靠。&lt;/p></description></item><item><title>SaltStack 使用简介</title><link>https://gohalo.github.io/cn/blog/saltstack-introduce/</link><pubDate>Sat, 02 Jan 2016 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/saltstack-introduce/</guid><description>&lt;hr>
&lt;p>SaltStack 是一个轻量级的运维工具，具备配置管理、远程执行、监控等功能，类似于 Puppet 和 Chef，不过这两者是用 Ruby 写的，而 Salt Stack 用的是 Python。&lt;/p>
&lt;p>结下来看看具体的使用。&lt;/p></description></item><item><title>Java C 程序调用</title><link>https://gohalo.github.io/cn/blog/program-c-java/</link><pubDate>Wed, 23 Dec 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-java/</guid><description>&lt;p>简单介绍下 Java 和 C 程序的相互调用。&lt;/p></description></item><item><title>C/C++ 常见错误整理</title><link>https://gohalo.github.io/cn/blog/cpp-some-pitfalls/</link><pubDate>Tue, 22 Dec 2015 21:00:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cpp-some-pitfalls/</guid><description/></item><item><title>软件 DNSmasq 使用介绍</title><link>https://gohalo.github.io/cn/blog/linux-dnsmasq-introduce/</link><pubDate>Sun, 20 Dec 2015 21:50:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-dnsmasq-introduce/</guid><description>&lt;p>通常上网使用的 DNS 服务器都是由电信、联通等运营商提供的，或者是公用的 DNS 解析服务器，例如 Google 提供的解析器，这通常会带来些问题，如有时解析不正常、经常弹出广告等。&lt;/p>
&lt;p>有时我们需要管理 DNS 解析，如加速 DNS 的解析过程、纠正错误的 DNS 解析记录、配置局域网的 DNS 解析等等。&lt;/p>
&lt;p>DNSmasq 就是其中的一个主机上最常用的解决方案，相比 BIND 来说，其更加小巧，配置更加方便，其源码仅有 2 万多行，但足以满足常见的需求。&lt;/p></description></item><item><title>CSS 示例代码</title><link>https://gohalo.github.io/cn/blog/web-css-basic-examples/</link><pubDate>Tue, 15 Dec 2015 22:10:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/web-css-basic-examples/</guid><description>&lt;p>介绍一些常见的 CSS 简单相关示例。&lt;/p></description></item><item><title>ARP 协议详解</title><link>https://gohalo.github.io/cn/blog/network-arp-introduce/</link><pubDate>Tue, 15 Dec 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-arp-introduce/</guid><description>&lt;p>地址解析协议 Address Resolution Protocol, ARP 是一个通过解析网络层地址来找寻数据链路层地址的网络传输协议，在 IPv4 中极其重要。&lt;/p></description></item><item><title>VirtualBox 的一些高级特性</title><link>https://gohalo.github.io/cn/blog/wonderful-things-about-virtualbox/</link><pubDate>Sat, 05 Dec 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/wonderful-things-about-virtualbox/</guid><description>&lt;p>本文不会介绍如何安装 VirtualBox，也不会讲解如何安装操作系统，只是介绍一些比较好玩的特性，一些很有意思，但是经常会被忽略的特性。&lt;/p>
&lt;p>怎么样，一块看看吧。&lt;/p></description></item><item><title>Linux 自动编译 AutoTools</title><link>https://gohalo.github.io/cn/blog/linux-autotools-auto-compile-introduce/</link><pubDate>Mon, 30 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-autotools-auto-compile-introduce/</guid><description>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。
这里简单介绍下 AutoTools 一系列工具的使用。
Autotools # 在 Linux 平台上，经常使用 configure-&amp;gt;make-&amp;gt;make install 从源码开始编译安装，也就是 GNU 构建系统，利用脚本和 make 程序在特定平台上编译软件，也就是利用 autotools 创建构建系统的项目。
注意，有些程序虽然也是采用上述的三步，但并未采用 autotools 实现，如 nginx 是作者编写的构建程序。
在 CentOS 中可以直接通过 yum install automake autoconf 安装相关的文件；利用 autotools 生成 Makefile 的过程如下图所示。
其中用到的核心工具包括了 Autoconf 和 Automake ，首先从用户和开发者角度看看两者的区别。关于 autotools 的简单处理流程可以参考 automake 中的 Setup Explained 内容。
用户视角 # configure 脚本是由软件开发者维护并发布给用户使用的 shell 脚本，该脚本作用是检测系统环境，最终目的是生成 Makefile 和 config.h 两个文件。
开发者在分发源码包时，除了源代码 (.c .h)，还有许多支撑软件构建的文件和工具，其中最重要的文件就是 Makefile.in 和 config.h.in 两个，在 configure 脚本执行成功后，将为每个 *.</description></item><item><title>Python 虚拟环境详解</title><link>https://gohalo.github.io/cn/blog/python-virtual-environments/</link><pubDate>Mon, 30 Nov 2015 20:19:36 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-virtual-environments/</guid><description>&lt;p>Python 的虚拟环境用来创建一个相对独立的执行环境，尤其是一些依赖的三方包，最常见的如不同项目依赖同一个但是不同版本的三方包，而且，在虚拟环境中的安装包不会影响到系统的安装包。&lt;/p>
&lt;p>不过，其具体的工作原理是怎样的，这里详细介绍。&lt;/p></description></item><item><title>Linux Package 管理</title><link>https://gohalo.github.io/cn/blog/linux-package-config-introduce/</link><pubDate>Fri, 27 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-package-config-introduce/</guid><description>&lt;p>可以通过 &lt;code>pkg-config&lt;/code> 命令来检索系统中安装库文件的信息，通常用于库的编译和连接。&lt;/p></description></item><item><title>数据结构 -- SkipList</title><link>https://gohalo.github.io/cn/blog/structure-skiplist-introduce/</link><pubDate>Fri, 20 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/structure-skiplist-introduce/</guid><description>&lt;p>William Pugh 于 1990 年发表了 &lt;code>Skip lists: a probabilistic alternative to balanced trees&lt;/code> 论文，也就是设计初衷是作为替换平衡树的一种选择，这是一种随机化数据结构，基于并联的链表，其效率可比拟二叉查找树。&lt;/p>
&lt;p>同时，可以支持排序。&lt;/p></description></item><item><title>C 参数解析</title><link>https://gohalo.github.io/cn/blog/program-c-linux-getopt-usage-introduce/</link><pubDate>Tue, 10 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-linux-getopt-usage-introduce/</guid><description>&lt;p>在 glibc 中提供了一个通用的参数解析库，包括了短参以及长参的使用。&lt;/p></description></item><item><title>MySQL 变量相关</title><link>https://gohalo.github.io/cn/blog/mysql-variables/</link><pubDate>Mon, 09 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-variables/</guid><description>&lt;p>MySQL 通过变量设置来控制不同的行为，以及进行调优，从不同的角度看，定义方式各不相同，例如，如根据能否修改，可以分为动态和静态参数两种，动态参数可以修改，而静态参数是只读。&lt;/p>
&lt;p>在本文中简单介绍下 MySQL 中相关变量的设置，以及源码的实现。&lt;/p></description></item><item><title>Linux 进程执行简介</title><link>https://gohalo.github.io/cn/blog/kernel-process-introduce/</link><pubDate>Thu, 05 Nov 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-process-introduce/</guid><description>&lt;p>简单介绍一下 Linux 中的常见的一些与进程相关的操作，主要是执行命令、守护进程等。&lt;/p></description></item><item><title>Linux 自动编译 Makefile</title><link>https://gohalo.github.io/cn/blog/linux-makefile-auto-compile-introduce/</link><pubDate>Tue, 03 Nov 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-makefile-auto-compile-introduce/</guid><description>&lt;p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。&lt;/p>
&lt;p>这里简单介绍下最基本的 Makefile 。&lt;/p></description></item><item><title>InnoDB 隔离级别使用实例</title><link>https://gohalo.github.io/cn/blog/mysql-innodb-isolation-level/</link><pubDate>Sun, 01 Nov 2015 19:58:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-innodb-isolation-level/</guid><description>&lt;p>数据库的事务存在着 ACID 四个属性，而在实际应用场景中，当面临着性能需求时，隔离性往往成为最容易妥协的一个，其实际上就是指数据库在并发事务下的表现。&lt;/p>
&lt;p>在本文章中，详细介绍下 InnoDB 中关于隔离级别的实现。&lt;/p></description></item><item><title>Lua 源码解析</title><link>https://gohalo.github.io/cn/blog/lua-sourcecode/</link><pubDate>Wed, 28 Oct 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-sourcecode/</guid><description>&lt;p>Lua 类似于 Java、Python，实际执行的都不是机器码，而是运行在虚拟机上的，而虚拟机则屏蔽了底层不同的硬件，从而使得这些程序可以跨平台执行，包括不同的操作系统以及不同的硬件平台。&lt;/p>
&lt;p>相比而言，Lua 的代码十分简单，源码总共才 2W 行左右，但是却实现了很多不错的特性。&lt;/p>
&lt;p>接下来，我们看看 Lua 具体是如何工作的。&lt;/p></description></item><item><title>如何制作一个标准的 RPM 包</title><link>https://gohalo.github.io/cn/blog/linux-create-rpm-package/</link><pubDate>Wed, 21 Oct 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-create-rpm-package/</guid><description>&lt;p>Red-Hat Package Manager 简称 RPM，这一文件格式在历史名称上虽然打着 RedHat 标志，但其原始设计理念是开放式的，现在包括 OpenLinux、SuSE、Turbo Linux 等多个 Linux 分发版本都有采用，可以算是公认的行业标准了。&lt;/p>
&lt;p>在此介绍下如何制作 RPM 包，尤其是如何写 .spec 配置文件，以及常见的技巧。&lt;/p></description></item><item><title>Java JDBC 驱动介绍</title><link>https://gohalo.github.io/cn/blog/java-jdbc-introduce/</link><pubDate>Mon, 19 Oct 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/java-jdbc-introduce/</guid><description>&lt;p>JDBC (Java Datebase Connectivity) 实际是一个独立于特定数据库管理系统、通用的 SQL 数据库存取和操作的公共接口，它是 JAVA 访问数据库的一种标准。也就是说它只是接口规范，具体实现是各数据库厂商提供的驱动程序。&lt;/p>
&lt;p>接下来，先看看 JDBC 的使用方法，然后看看其具体的实现原理。&lt;/p></description></item><item><title>SNMP 协议详解</title><link>https://gohalo.github.io/cn/blog/network-snmp-introduce/</link><pubDate>Sat, 17 Oct 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-snmp-introduce/</guid><description>&lt;p>简单记录下 Linux 常见的通讯协议，如 SNMP 协议。&lt;/p></description></item><item><title>Kernel 映射文件</title><link>https://gohalo.github.io/cn/blog/kernel-memory-mmap-introduce/</link><pubDate>Fri, 16 Oct 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-mmap-introduce/</guid><description>&lt;p>mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。&lt;/p>
&lt;p>这里简单介绍下如何使用。&lt;/p></description></item><item><title>Linux 内存监控</title><link>https://gohalo.github.io/cn/blog/linux-monitor-memory-introduce/</link><pubDate>Mon, 12 Oct 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-memory-introduce/</guid><description/></item><item><title>GoLang Echo 中间件</title><link>https://gohalo.github.io/cn/blog/golang-echo-middleware/</link><pubDate>Tue, 06 Oct 2015 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/golang-echo-middleware/</guid><description>&lt;p>Echo 中间件指的是可以拦截 http 请求的特殊函数，在请求和响应中间可以注册多个中间件，每个中间件执行不同的功能，一个中间执行完再轮到下一个中间件执行。&lt;/p></description></item><item><title>Lua 协程</title><link>https://gohalo.github.io/cn/blog/lua-coroutine/</link><pubDate>Tue, 06 Oct 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/lua-coroutine/</guid><description>协程是另外一种并发方式，相比多进程或者多线程来说，其上下文的切换成本开销更小，这也意味这协程的执行更加高效。
Lua 作为一种简单的语言，仍然可以支持闭包、协程等较新的特性，在此介绍一下协程相关的内容。
简介 # 对于并发任务，通常有两种解决方法：A) 抢占式 (preemptive) 多任务，常见的是通过操作系统决定何时执行哪个任务；B) 协作式 (cooperative) 多任务，有任务自身决定何时放弃任务的执行。
协程 (coroutine) 是一种程序控制机制，实际上在上世纪 60 年代就已经被提出，用来方便地实现协作式的多任务。在很多主流的程序语言中，如 C/C++、Java 等，很少能看到协程，但现在不少脚本语言，如 Python、Lua 等，都提供了协程或与之相似的机制。
Lua 实现的是一种非对称式 (asymmetric) 或者称为半对称式 (semi-symmetric) 协程，之所以被称为非对称的，是因为它提供了两种传递程序控制权的操作：A) 利用 resume() (重)调用协程；B) 通过 yield 挂起协程并将程序控制权返回给协程的调用者。这看起来有点像函数的调用过程。
而 libtask 的实现就更像对称式的协程。
协程类似于线程，包含了自己的栈、本地变量、指针，但是包括了其它的全局变量是共享的。与线程不同的是，线程可以真正的在多个核上并发执行，而协程在具体的时间只能运行其中的一个。
常用接口 # 与协程相关的函数包含在 coroutine table 中，其中的 create() 函数用来创建一个协程，该函数会返回一个 thread 类型的变量，用来表示协程。
co = coroutine.create(function () print(&amp;#34;Hello World&amp;#34;) end) print(co) --&amp;gt; thread: 0x24a0b20 Lua 中的协程包含了四种状态：suspended、running、dead 以及 normal，可以通过 satatus() 查看。
print(coroutine.status(co)) --&amp;gt; suspended 刚创建的协程处于 suspended 状态，也就是说创建时不会自动运行；可以通过 resume() 函数运行或者重新运行该协程，将状态从 suspended 转换为 running 。如上的函数中，仅仅打印字符串，那么执行完成之后，状态会变为 dead 。</description></item><item><title>SELinux 简介</title><link>https://gohalo.github.io/cn/blog/linux-selinux-introduce/</link><pubDate>Sat, 03 Oct 2015 19:38:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-selinux-introduce/</guid><description>&lt;p>Security-Enhanced Linux, SELinux 给 Linux 带来的最重要价值是：提供了一个灵活的，可配置的 MAC 机制。包括了内核中的模块，以及用户态的工具，对于用户来说是透明的，只有同时满足了 &amp;ldquo;标准 Linux 访问控制&amp;rdquo; 和 &amp;ldquo;SELinux 访问控制&amp;rdquo; 时，主体才能访问客体。&lt;/p></description></item><item><title>Bash 基本介绍</title><link>https://gohalo.github.io/cn/blog/bash-basic-introduce/</link><pubDate>Wed, 23 Sep 2015 22:55:32 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-basic-introduce/</guid><description>&lt;p>一些与 Bash 相关的内容，如命令执行顺序、配置文件、通配符、元字符及转义字符等。&lt;/p></description></item><item><title>Bash 命令注释</title><link>https://gohalo.github.io/cn/blog/bash-tips-command-comment/</link><pubDate>Sat, 19 Sep 2015 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-tips-command-comment/</guid><description>&lt;p>在通过 &lt;code>man&lt;/code> 查看命令时，可以看到对参数解释时是有大概的固定格式的，这里基本介绍如下。&lt;/p></description></item><item><title>SSH 通讯协议介绍</title><link>https://gohalo.github.io/cn/blog/ssh-protocol-details/</link><pubDate>Thu, 17 Sep 2015 22:58:24 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-protocol-details/</guid><description>&lt;p>SSH 通讯是基于几个基本协议完成，这里简单介绍。&lt;/p></description></item><item><title>Systemd 使用简介</title><link>https://gohalo.github.io/cn/blog/linux-systemd/</link><pubDate>Thu, 17 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-systemd/</guid><description>&lt;p>现在一般新发行的版本会采用新的 init 进程，也就是 systemd ，其中启动过程可以通过 man bootup 查看。&lt;/p>
&lt;p>在此，简单介绍一下 systemd 。&lt;/p></description></item><item><title>C 语言的字符串</title><link>https://gohalo.github.io/cn/blog/program-c-string-stuff/</link><pubDate>Wed, 16 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-stuff/</guid><description>&lt;p>简单介绍下 C 语言中与字符串操作相关的函数。&lt;/p></description></item><item><title>C 加载过程</title><link>https://gohalo.github.io/cn/blog/c-load-process/</link><pubDate>Tue, 15 Sep 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-load-process/</guid><description>&lt;p>这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。&lt;/p></description></item><item><title>Linux IP 隧道技术</title><link>https://gohalo.github.io/cn/blog/network-ip-tunneling/</link><pubDate>Sun, 13 Sep 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-ip-tunneling/</guid><description>&lt;p>隧道是一种封装技术，它利用一种网络协议来传输另一种网络协议，即利用一种网络传输协议，将其它协议产生的数据报文封装在它自己的报文中，然后在网络中传输。&lt;/p>
&lt;p>隧道可以看做是一条虚拟的点对点连接，隧道的两端需要对数据报文进行封装及解封装，常用的是基于 IP 的隧道。&lt;/p>
&lt;p>在此简单介绍下隧道技术。&lt;/p></description></item><item><title>Linux IO 多路复用</title><link>https://gohalo.github.io/cn/blog/linux-program-io-multiplexing/</link><pubDate>Sat, 12 Sep 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-io-multiplexing/</guid><description>&lt;p>通过 IO 多路复用技术，系统内核缓冲 IO 数据，当某个 IO 准备好后，系统通知应用程序该 IO 可读或可写，这样应用程序可以马上完成相应的 IO 操作，而不需要等待系统完成相应 IO 操作，从而应用程序不必因等待 IO 操作而阻塞。&lt;/p>
&lt;p>这里简单介绍下 Linux 中 IO 多路复用的使用。&lt;/p></description></item><item><title>git 使用杂项</title><link>https://gohalo.github.io/cn/blog/git-cheatsheet/</link><pubDate>Thu, 10 Sep 2015 19:28:10 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/git-cheatsheet/</guid><description>&lt;p>记录 git 常见的示例，可以用来作为参考使用。&lt;/p></description></item><item><title>C 语言通配符</title><link>https://gohalo.github.io/cn/blog/program-c-string-linux-wildcard/</link><pubDate>Tue, 08 Sep 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-string-linux-wildcard/</guid><description>&lt;p>简单介绍下 C 语言中与字符串操作相关的函数。&lt;/p></description></item><item><title>最小的ELF文件</title><link>https://gohalo.github.io/cn/blog/linux-the-really-teensy-elf-file/</link><pubDate>Wed, 26 Aug 2015 21:16:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-the-really-teensy-elf-file/</guid><description>&lt;p>从最经典 &amp;ldquo;Hello World&amp;rdquo; C 程序实例，逐步演示如何通过各种常用工具来分析 ELF 文件，并逐步精简代码，尽量减少可执行文件的大小。&lt;/p>
&lt;p>接下来，看看一个可打印 &amp;ldquo;Hello World&amp;rdquo; 的可执行文件能够小到什么样的地步。&lt;/p></description></item><item><title>MySQL 备份工具</title><link>https://gohalo.github.io/cn/blog/mysql-backup-tools/</link><pubDate>Tue, 25 Aug 2015 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-backup-tools/</guid><description>&lt;p>为了保证数据安全，都会对硬件做高可用，防止出现单点故障，但是无论如何都无法取代备份，尤其对于数据库中所保存的数据而言。&lt;/p>
&lt;p>在此，介绍一下 MySQL 中常用的备份方法。&lt;/p></description></item><item><title>Linux 网络超时与重传</title><link>https://gohalo.github.io/cn/blog/network-timeout-retries/</link><pubDate>Mon, 17 Aug 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-timeout-retries/</guid><description>&lt;p>在此介绍重传，为了保证可靠性，在 TCP 的三次握手、数据传输、链接关闭阶段都有响应的重传机制。那么，重传的次数都是有那些参数指定？tcp_retries1 和 tcp_retries2 到底有什么区别？什么是 orphan socket ？&lt;/p></description></item><item><title>C 语言的奇技淫巧</title><link>https://gohalo.github.io/cn/blog/program-c-tips/</link><pubDate>Sun, 16 Aug 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-tips/</guid><description>&lt;p>整理下 C 语言中常用的技巧。&lt;/p></description></item><item><title>Linux 网络半链接、链接队列</title><link>https://gohalo.github.io/cn/blog/network-synack-queue/</link><pubDate>Wed, 05 Aug 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-synack-queue/</guid><description>&lt;p>我们知道在建立链接阶段，需要完成三次握手，而这一阶段是在内核中完成，为此保存了两个队列：半链接队列 (SYN队列)、链接队列 (Accepted队列)。&lt;/p>
&lt;p>那么，这两个队列分别对应到内核中的那些成员？队列的大小由那些参数决定？当队列满了之后，对应用的影响是什么？其报错的内容是什么？&lt;/p>
&lt;p>在这篇文章里大致介绍下。&lt;/p></description></item><item><title>MySQL 常用资源</title><link>https://gohalo.github.io/cn/blog/mysql-some-reference/</link><pubDate>Thu, 30 Jul 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-some-reference/</guid><description>&lt;p>保存一下经常使用的经典 MySQL 资源。&lt;/p></description></item><item><title>Python 时间操作</title><link>https://gohalo.github.io/cn/blog/python-time-handle/</link><pubDate>Fri, 26 Jun 2015 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-time-handle/</guid><description>&lt;p>Python 与时间处理相关的提供了 datetime、time、calendar 三个模块，而且还有三方模块 pytz 可以使用；另外，datetime 模块中又存在 datetime、time 类，不要与相应的模块混淆。&lt;/p></description></item><item><title>Linux 的防火墙</title><link>https://gohalo.github.io/cn/blog/network-netfilter-iptables/</link><pubDate>Tue, 23 Jun 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-netfilter-iptables/</guid><description>&lt;p>Linux 防火墙是由 Netfilter 和 iptables 两个组件组成，其中前者在内核空间中；后者是一个用户程序，用于插入、修改和删除相应的防火墙规则。&lt;/p>
&lt;p>通过 Netfilter+iptables 可以实现数据包过滤、网络地址转换和数据报文处理等功能。&lt;/p></description></item><item><title>Java 环境搭建</title><link>https://gohalo.github.io/cn/blog/java-environment/</link><pubDate>Fri, 19 Jun 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/java-environment/</guid><description>&lt;p>简单记录一下 Linux 下的 Java 环境搭建，以及使用方法。&lt;/p></description></item><item><title>Python 动态执行</title><link>https://gohalo.github.io/cn/blog/python-eval/</link><pubDate>Tue, 16 Jun 2015 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-eval/</guid><description>&lt;p>在 Python 中，允许通过 exec 和 eval 执行以字符串形式表示的代码片段，这体现了动态语言的特性，可以让代码变得更灵活。实际上，在使用 exec 和 eval 时，也是需要进行编译的，没错是 &amp;ldquo;编译&amp;rdquo;。&lt;/p>
&lt;p>只是与 C 需要编译成机器码不同，CPython 需要编译成字节码 (ByteCode) 。&lt;/p>
&lt;p>接下来，我们看看 Python 的动态执行相关内容。&lt;/p></description></item><item><title>Python 模块简介</title><link>https://gohalo.github.io/cn/blog/python-modules-introduce/</link><pubDate>Sun, 07 Jun 2015 21:39:22 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-modules-introduce/</guid><description>在 Python 解析器中，每次重新进入，之前定义的函数、变量等都会丢失，所以，通常是将代码保存在文件中运行，而随着功能增加，文件会变得越来越大，为了方便维护，会将其拆分成多个文件。
其它语言也有类似的问题，Python 将其称为模块 (Module) ，通过模块可以定义函数、类、变量等，从而更有逻辑地组织 Python 代码。
这里介绍模块的引入、搜索、制作等一些常见的问题。
简介 # 每个文件都是一个模块 (module)，其模块名就是对应的文件名，在模块内运行时，可以通过全局变量 __name__ 获取，最常见的就是 __main__ 的判断，也就是是否为主 Pyhton 脚本。
if __name__ == &amp;#34;__main__&amp;#34;: print(&amp;#34;Hello World&amp;#34;) 也就是该文件可以作为模块引入其它代码中，也可以作为一个独立的执行文件运行，而判断的逻辑就是这里的 if __name__ == &amp;quot;__main__&amp;quot; 语句，直接调用脚本时，对应 __name__ 变量保存的是 __main__ ，如果是引入的模块，则是模块名称。
模块导入 # 可以通过 import 关键字导入模块，也就是添加到当前的命名空间中，根据不同的使用场景，有如下的几种方式。
# 直接导入模块，可以通过math.cos()调用 import math # 导入模块中的函数，这样可以直接调用cos sin，不过很容易被覆盖 from math import cos, sin # 导入模块的所有符号 from math import * # 导入模块的符号，为了防止名字覆盖，将其重命名 from math import pi as PI 导入的模块会保存在 sys.modules 中，这是一个字典，如果多次导入第二次实际不会有加载的动作。</description></item><item><title>Python 的垃圾回收</title><link>https://gohalo.github.io/cn/blog/python-garbage-collection/</link><pubDate>Sun, 07 Jun 2015 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-garbage-collection/</guid><description>&lt;p>Python 带有自动垃圾回收机制，但是它真的能处理所有的垃圾回收问题吗？ 是不是有了自动垃圾回收，就不用再担心内存泄露了呢？ 为什么经常会看到文章说，在实现自己的类时，不要使用 &lt;code>__del__()&lt;/code> ？&lt;/p>
&lt;p>很多当代的语言都实现了垃圾回收机制，包括 Java、Ruby、Lua、Go等，从而将众码农从内存管理中释放出来，那么 Python 的垃圾回收是怎么实现的呢？&lt;/p>
&lt;p>这篇文章将详细介绍 Python 垃圾回收的使用方法，包括示例以及相关的源码分析。&lt;/p></description></item><item><title>Kernel 进程相关</title><link>https://gohalo.github.io/cn/blog/kernel-process-details/</link><pubDate>Tue, 02 Jun 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-process-details/</guid><description>&lt;p>实际上一个进程，包括了代码、数据和分配给进程的资源，这是一个动态资源。&lt;/p>
&lt;p>这里简单介绍与进程相关的东西，例如进程创建、优先级、进程之间的关系、进程组和会话、进程状态等。&lt;/p></description></item><item><title>Linux AIO</title><link>https://gohalo.github.io/cn/blog/linux-program-aio/</link><pubDate>Sat, 09 May 2015 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-aio/</guid><description>&lt;p>AIO 是 Linux 下的异步读写模型，它是 2.6 内核提供的一个标准增强特性。对于文件的读写，即使以 O_NONBLOCK 方式来打开一个文件，也会处于 &amp;ldquo;阻塞&amp;rdquo; 状态，因为文件时时刻刻处于可读状态，而从磁盘到内存所等待的时间是惊人的。&lt;/p>
&lt;p>为了充份发挥把数据从磁盘复制到内存的时间，引入了 AIO 模型，其基本原理是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成。稍后或在接收到 I/O 操作完成的通知时，进程就可以检索 I/O 操作的结果。&lt;/p></description></item><item><title>C 多语言支持</title><link>https://gohalo.github.io/cn/blog/c-linux-i18n-multi-language-gettext-usage/</link><pubDate>Wed, 06 May 2015 18:20:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/c-linux-i18n-multi-language-gettext-usage/</guid><description>&lt;p>可以通过 gettext 进行处理，一个在 Linux 上的 i18n 国际化常用的解决方案。&lt;/p></description></item><item><title>MySQL 代码导读</title><link>https://gohalo.github.io/cn/blog/mysql-skeleton/</link><pubDate>Sat, 02 May 2015 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-skeleton/</guid><description>&lt;p>在 MySQL 的官网上，MySQL 号称是 The World&amp;rsquo;s Most Popular Open Source Database ，既然是开源的，据说又这么牛掰，那不看看源码真有点对不起 MySQL 了。&lt;/p>
&lt;p>不禁想起了 PostgreSQL 号称是 The World&amp;rsquo;s Most Advanced Open Source Database ^_^''&lt;/p>
&lt;p>废话少说，本文简单介绍一下 MySQL 的执行流程。&lt;/p></description></item><item><title>MySQL 安全设置</title><link>https://gohalo.github.io/cn/blog/mysql-security/</link><pubDate>Thu, 30 Apr 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-security/</guid><description>&lt;p>很多时候在部署一种产品时，安全性往往是最后考虑的，不过这也带来了很大的风险。&lt;/p></description></item><item><title>FTP 服务简介</title><link>https://gohalo.github.io/cn/blog/network-service-ftp/</link><pubDate>Wed, 29 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-service-ftp/</guid><description>&lt;p>File Transfer Protocol, FTP(RFC 959) 是 TCP/IP 协议组中的协议之一，其传输效率非常高，在网络上传输大的文件时，一般也采用该协议。&lt;/p></description></item><item><title>Linux C++ 线程同步</title><link>https://gohalo.github.io/cn/blog/program-cpp-linux-synchronize/</link><pubDate>Thu, 23 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-cpp-linux-synchronize/</guid><description/></item><item><title>Linux 线程同步</title><link>https://gohalo.github.io/cn/blog/program-c-linux-pthreads-synchronize/</link><pubDate>Thu, 23 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-c-linux-pthreads-synchronize/</guid><description>&lt;p>线程的三个主要同步原语：互斥锁 (mutex)、信号量 (semaphore) 和条件变量 (cond)。其中 mutex 和 sem 都是对应 futex 进行了简单的封装，在不存在冲突的情况下就不用陷入到内核中进行仲裁；而且 pthread_join 也是借助 futex 来实现的。&lt;/p>
&lt;p>简单介绍下 Linux 中与线程相关的编程。&lt;/p></description></item><item><title>cares 异步 DNS 简介</title><link>https://gohalo.github.io/cn/blog/network-dns-async-resolve-introduce/</link><pubDate>Sat, 18 Apr 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-async-resolve-introduce/</guid><description>&lt;p>c-ares 是一个 C89 实现的异步请求 DNS 的实现，一些常见的软件 (如 curl、NodeJS、WireShark 等等) 都使用了这一软件库。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>MySQL 示例数据库</title><link>https://gohalo.github.io/cn/blog/mysql-sample-database/</link><pubDate>Sun, 12 Apr 2015 18:28:19 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-sample-database/</guid><description>&lt;p>一些简单的数据库示例，可以用于简单演示、测试使用。&lt;/p></description></item><item><title>HTTP/HTTPS 代理协议</title><link>https://gohalo.github.io/cn/blog/network-proxy-http-https/</link><pubDate>Fri, 10 Apr 2015 22:09:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-proxy-http-https/</guid><description>&lt;p>代理服务器的功能是代理网络用户去取得网络信息，是网络信息的中转站，通常用于隐藏身份、充当防火墙、防止攻击、权限控制等用途。&lt;/p></description></item><item><title>SSH 安全审计</title><link>https://gohalo.github.io/cn/blog/ssh-security-audit/</link><pubDate>Fri, 10 Apr 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/ssh-security-audit/</guid><description/></item><item><title>DNS 配置文件 resolv.conf 简介</title><link>https://gohalo.github.io/cn/blog/network-dns-resolv-conf-usage-introduce/</link><pubDate>Mon, 30 Mar 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-resolv-conf-usage-introduce/</guid><description>&lt;p>Linux 中可以通过 &lt;code>/etc/resolv.conf&lt;/code> 文件配置 DNS 服务器的地址，不过目前该文件大部分是通过一些工具自动配置的，例如 NetworkManager ，那么这就可能会导致在重启网络服务后该配置文件被刷新。&lt;/p>
&lt;p>这里简单介绍其使用方式。&lt;/p></description></item><item><title>DNS 的基本概念详解</title><link>https://gohalo.github.io/cn/blog/network-dns-basic-introduce/</link><pubDate>Thu, 19 Mar 2015 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-dns-basic-introduce/</guid><description>&lt;p>在通过浏览器访问某个网站时，或者说访问网络上的服务器时，可以直接使用 IP 地址，但是对于人类来说很难记忆，为此引入了域名，而为了可以做到自动解析，于时就有了 DNS 。&lt;/p>
&lt;p>这里详细介绍 DNS 的基本概念。&lt;/p></description></item><item><title>LXC sshd 单进程启动</title><link>https://gohalo.github.io/cn/blog/linux-container-lxc-sshd/</link><pubDate>Wed, 11 Mar 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-container-lxc-sshd/</guid><description>&lt;p>在之前的 &lt;a href="https://gohalo.github.io/cn/blog/linux-container-lxc-introduce/">LXC 简介&lt;/a> 中介绍了如何搭建 CentOS 7 容器，在此介绍如何单独启动 sshd 这一个进程。这样，实际上我们可以通过这种方式启动类似 MySQL 之类的服务，从而减小成本。&lt;/p>
&lt;p>接下来，我们看看是如何启动的。&lt;/p></description></item><item><title>LXC 网络设置相关</title><link>https://gohalo.github.io/cn/blog/linux-container-lxc-network/</link><pubDate>Sun, 08 Mar 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-container-lxc-network/</guid><description>&lt;p>LXC 本身就是基于内核的 Namespace、Cgroup 的隔离技术，对于网络同样使用了网络上常用的虚拟技术，包括 veth、vlan、macvlan 等等。&lt;/p>
&lt;p>在此仅介绍一下 LXC 中与网络相关的使用方法。&lt;/p></description></item><item><title>LXC 简介</title><link>https://gohalo.github.io/cn/blog/linux-container-lxc-introduce/</link><pubDate>Mon, 02 Mar 2015 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-container-lxc-introduce/</guid><description>&lt;p>LXC (Linux Containters) 是一种基于内核容器的用户空间接口，提供了一系列创建、配置、管理的接口。&lt;/p>
&lt;p>其提供了比 chroot 更强的资源隔离，但是与硬件提供的完全虚拟化又不同，其目标为创建一个不需要独立内核，但近可能接近标准 Linux 安装的环境。&lt;/p>
&lt;p>在此简单介绍其使用方法，以及常用的命令。&lt;/p></description></item><item><title>Kernel 内存杂项</title><link>https://gohalo.github.io/cn/blog/kernel-memory-tips/</link><pubDate>Sat, 21 Feb 2015 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-tips/</guid><description>&lt;p>简单介绍下内核中与内存相关的内容。&lt;/p></description></item><item><title>glob 命令格式使用详解</title><link>https://gohalo.github.io/cn/blog/bash-tips-glob-introduce/</link><pubDate>Tue, 10 Feb 2015 20:30:45 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/bash-tips-glob-introduce/</guid><description>&lt;p>除了常见的正则表达式之外，还有一种 glob 模式经常用于匹配文件路径，相比正则来说更加简单，匹配效率也要更高一些，所以，在某些方面可以替换掉正则。&lt;/p></description></item><item><title>MySQL 主备数据校验</title><link>https://gohalo.github.io/cn/blog/mysql-replication-pt-table-checksum/</link><pubDate>Tue, 20 Jan 2015 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/mysql-replication-pt-table-checksum/</guid><description>&lt;p>由于各种原因，MySQL 主从架构可能会出现数据不一致的情况出现，为此需要对主备复制的数据进行校验。&lt;/p>
&lt;p>在此，简单介绍 Percona-Toolkits 提供的数据校验方式。&lt;/p></description></item><item><title>Nginx HTTPS 配置</title><link>https://gohalo.github.io/cn/blog/security-ssl-tls-nginx-https-setting/</link><pubDate>Sat, 27 Dec 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-ssl-tls-nginx-https-setting/</guid><description>&lt;p>简单介绍如何使用 Nginx 搭建 https 服务。&lt;/p></description></item><item><title>HAProxy 简介</title><link>https://gohalo.github.io/cn/blog/haproxy-introduce/</link><pubDate>Fri, 28 Nov 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/haproxy-introduce/</guid><description>&lt;p>HAProxy 是一个免费的负载均衡软件，可以运行于大部分主流的 Linux 操作系统上，提供了 L4 和 L7 两种负载均衡能力，可媲美商用负载均衡器的性能和稳定性，使其不仅仅是免费负载均衡软件的首选，更几乎成为了唯一选择。&lt;/p>
&lt;p>这里简单介绍下 HAProxy 的使用方式。&lt;/p></description></item><item><title>Linux 网络负载均衡</title><link>https://gohalo.github.io/cn/blog/network-load-balancing/</link><pubDate>Mon, 24 Nov 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-load-balancing/</guid><description>&lt;p>对于一个每秒处理百万请求的网站来说，通常是有整个集群提供服务的，而如何做到负载均衡呢？&lt;/p></description></item><item><title>Linux 进程切换</title><link>https://gohalo.github.io/cn/blog/linux-context-schedule/</link><pubDate>Mon, 17 Nov 2014 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-context-schedule/</guid><description>&lt;p>在本文中介绍了 Linux 的进程切换以及协程的相关文档，包括了上下文相关信息、Linux 进程切换的过程以及协程相关的信息。&lt;/p></description></item><item><title>Linux 网络加速</title><link>https://gohalo.github.io/cn/blog/network-speedup-introduce/</link><pubDate>Mon, 27 Oct 2014 18:49:39 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-speedup-introduce/</guid><description>&lt;p>硬件与 CPU 进行信息沟通有两种方式，一种是中断，另一种是轮询。中断是硬件主动产生中断信号，中断控制器将信号传递给 CPU，此时 CPU 会停下手中的工作，执行中断任务；轮询则是 CPU 主动，定时查询硬件设备的状态，是否处理硬件请求。&lt;/p>
&lt;p>随着网络带宽越来越大，实际由中断带来的 CPU 负载越来越大，这也就导致了 NAPI 的出现。&lt;/p>
&lt;p>不过这不是本文要讲的重点，本文着重看下网络针对 SMP 所做的优化。&lt;/p></description></item><item><title>Linux 内存-内核空间</title><link>https://gohalo.github.io/cn/blog/kernel-memory-management-from-kernel-view/</link><pubDate>Tue, 21 Oct 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-management-from-kernel-view/</guid><description>&lt;p>线性地址到物理地址的映射是通过 page table 完成的，内核会在启动分页机制前完成初始化；而且内核会将 A) 不可用物理地址空间，B) 内核代码以及内核初始数据结构对应的地址空间保留。&lt;/p>
&lt;p>接下来，看看内核中是如何管理内存的。&lt;/p></description></item><item><title>分布式缓存 memcached</title><link>https://gohalo.github.io/cn/blog/memcached-introduce/</link><pubDate>Sun, 19 Oct 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/memcached-introduce/</guid><description>&lt;p>通常 Web 应用的数据都会持久化到数据库中，随着应用数据量以及访问量的增加，就会导致数据库负担加重，从而导致网站的延迟。&lt;/p>
&lt;p>Memcached 是一个高性能的分布式内存缓存服务器，用于缓存数据库的查询结果，从而减少数据库的访问次数，提高动态 Web 应用的速度、提高扩展性。&lt;/p></description></item><item><title>Linux 中的 loopback 设备</title><link>https://gohalo.github.io/cn/blog/linux-network-loopback/</link><pubDate>Thu, 02 Oct 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-network-loopback/</guid><description>&lt;p>我们知道，在 Linux 设备中有一个 lo 设备，在此稍微介绍下。&lt;/p></description></item><item><title>Linux 内存-用户空间</title><link>https://gohalo.github.io/cn/blog/kernel-memory-management-from-userspace-view/</link><pubDate>Sat, 27 Sep 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-management-from-userspace-view/</guid><description>&lt;p>简单介绍下 Linux 中用户空间的内存管理，包括了内存的布局、内存申请等操作。&lt;/p></description></item><item><title>Linux 共享内存</title><link>https://gohalo.github.io/cn/blog/linux-program-shared-memory/</link><pubDate>Wed, 10 Sep 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-program-shared-memory/</guid><description>&lt;p>共享内存应该是进程间通信最有效的方式，同一块物理内存被映射到两个不同进程 A、B 各自的地址空间；进程 A 可以立即看到进程 B 对共享内存中数据的更新，反之亦然。&lt;/p>
&lt;p>接下来简单介绍下与共享内存相关的内容。&lt;/p></description></item><item><title>Greenlet Gevent</title><link>https://gohalo.github.io/cn/blog/python-gevent-greenlet/</link><pubDate>Thu, 04 Sep 2014 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-gevent-greenlet/</guid><description>&lt;p>对于服务器端的编程，从多进程，到多线程，再到异步回调，再到现在比较流行的协程的方式。对于 Python 来说，支持多进程；由于存在 GIL，实际对于线程会有性能影响。&lt;/p>
&lt;p>对于 Python 协程在此介绍一下 greenlet 的实现。&lt;/p></description></item><item><title>闰秒简介</title><link>https://gohalo.github.io/cn/blog/linux-leap-seconds-basic-introduce/</link><pubDate>Sat, 30 Aug 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-leap-seconds-basic-introduce/</guid><description>&lt;p>闰秒，是为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中对协调世界时增加或减少 1 秒的调整。&lt;/p>
&lt;p>由于地球自转的不均匀性和长期变慢性，当世界时和原子时之间相差超过到 ±0.9 秒时，就把协调世界时向前拨 1 秒或向后拨 1 秒。&lt;/p>
&lt;p>闰秒的调整也就是意味着 UTC 与 TAI(国际原子时) 之间的差异，截止到 2016 年，两者已经相差 37 秒。&lt;/p></description></item><item><title>程序简介</title><link>https://gohalo.github.io/cn/blog/program-exec-basic-concept-introduce/</link><pubDate>Fri, 01 Aug 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/program-exec-basic-concept-introduce/</guid><description>&lt;p>可执行二进制文件在编译以及加载过程中都有统一的格式，不同的平台其格式略有不同，这还只是在磁盘上的保存方式，而加载到内存中又不相同。&lt;/p>
&lt;p>这里简单介绍。&lt;/p></description></item><item><title>libgcrypt 使用</title><link>https://gohalo.github.io/cn/blog/security-libgcrypt-practice/</link><pubDate>Wed, 16 Jul 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-libgcrypt-practice/</guid><description>&lt;p>libgcrypt 是一个非常成熟的加密算法库，也是著名的开源加密软件 GnuPG 的底层库，支持多种对称、非对称加密算法，以及多种 Hash 算法。&lt;/p>
&lt;p>接下来，看看该库的使用方式。&lt;/p></description></item><item><title>HTTPS 协议详解</title><link>https://gohalo.github.io/cn/blog/https-introduce/</link><pubDate>Sat, 07 Jun 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/https-introduce/</guid><description>&lt;p>我们知道 HTTP 采用的是明文传输，而在互联网中，比如要在淘宝买个东西，使用支付宝转个帐，必须要保证这些信息只有客户端和服务器才知道的，也就是通过 HTTPS 协议。&lt;/p>
&lt;p>接下来，我们就看看 HTTPS 协议是如何实现的。&lt;/p></description></item><item><title>文件完整性检查</title><link>https://gohalo.github.io/cn/blog/file-integrity-check/</link><pubDate>Tue, 03 Jun 2014 19:38:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/file-integrity-check/</guid><description>&lt;p>通常为了防止文件的内容被修改，如一个文件号称是包含了补丁的文件，却被人加入了木马；同时也可以用来保证文件的完整性，防止文件被损坏。&lt;/p>
&lt;p>当然，一些 hash 算法可能会被破解，所以一些网站则提供了多种完整性校验方法。&lt;/p></description></item><item><title>Linux 时间函数</title><link>https://gohalo.github.io/cn/blog/linux-timer-functions/</link><pubDate>Mon, 02 Jun 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-timer-functions/</guid><description>&lt;p>简单介绍下 Linux 中与时间相关的函数。&lt;/p></description></item><item><title>加密算法简介</title><link>https://gohalo.github.io/cn/blog/security-encryption-introduce/</link><pubDate>Sun, 01 Jun 2014 19:38:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/security-encryption-introduce/</guid><description>&lt;p>开放网络中数据传输的安全性一直是一个热门的话题，特别是电子商务兴起的今天，各种攻击欺骗手段更是层出不穷，安全的网络传输需求愈显重要，而这就是所谓的密码学涉及的内容。&lt;/p>
&lt;p>通过一些加密算法，保证网络上数据传输的安全性，在此介绍一些常见的加密算法及其使用场景等。&lt;/p></description></item><item><title>dstat 使用及其原理</title><link>https://gohalo.github.io/cn/blog/dstat-introduce/</link><pubDate>Tue, 27 May 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/dstat-introduce/</guid><description>&lt;p>dstat 是一个不错的系统监控程序，类似于 vmstat、iostat、mpstat，所不同的是，可以监控多个系统指标，如 CPU、网络、内存、中断等，可以将结果显示到终端，也可保存到文件。&lt;/p>
&lt;p>另外，该程序是通过 Python 实现的，可以动态指定插件，甚至编写自己的插件。&lt;/p>
&lt;p>在本文中，大致介绍其使用方法，以及实现的原理。&lt;/p></description></item><item><title>Awesome Projects</title><link>https://gohalo.github.io/cn/blog/awesome-projects/</link><pubDate>Sun, 25 May 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/awesome-projects/</guid><description/></item><item><title>TMUX 简介</title><link>https://gohalo.github.io/cn/blog/tmux-terminal-introduce/</link><pubDate>Wed, 21 May 2014 19:49:37 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/tmux-terminal-introduce/</guid><description>&lt;p>TMUX 类似于 screen，是一个窗口管理器，而且功能更加强大，提供了强劲的、易于使用的命令行界面，可横向和纵向分割窗口，支持 UTF-8 编码及 256 色终端等特性。&lt;/p>
&lt;p>接下来简单介绍下 TMUX 的使用。&lt;/p></description></item><item><title>Linux 监控之 IO</title><link>https://gohalo.github.io/cn/blog/linux-monitor-io-introduce/</link><pubDate>Sat, 03 May 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-io-introduce/</guid><description>&lt;p>简单介绍下 Linux 中与 IO 相关的内容。&lt;/p></description></item><item><title>TCP/IP 协议之 TIME_WAIT</title><link>https://gohalo.github.io/cn/blog/network-tcpip-timewait/</link><pubDate>Tue, 29 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-tcpip-timewait/</guid><description>&lt;p>&lt;code>TIME_WAIT&lt;/code> 是 TCP 协议栈中比较特殊的状态，其主要目的是保证不同的链接不会相互干扰，但是对于一些高性能的场景，就可能由于较多的 &lt;code>TIME_WAIT&lt;/code> 状态最终导致链接不可用。&lt;/p>
&lt;p>如下简单介绍如何充分利用该状态。&lt;/p></description></item><item><title>TCP/IP 协议简介</title><link>https://gohalo.github.io/cn/blog/network-tcpip-introduce/</link><pubDate>Mon, 07 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-tcpip-introduce/</guid><description>&lt;p>TCP 协议是 &amp;ldquo;面向连接&amp;rdquo; 的，整个过程被分为几个阶段：准备、协商、建立连接、管理以及最后的连接终止，同时可以管理多个链接。&lt;/p>
&lt;p>接下来，我们看看 TCP 协议是如何实现的。&lt;/p></description></item><item><title>Linux 网卡驱动的工作原理</title><link>https://gohalo.github.io/cn/blog/network-driver-works/</link><pubDate>Thu, 03 Apr 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-driver-works/</guid><description>&lt;p>如题所示，介绍网卡是如何接收数据，然后又是如何交给上层处理。因为鄙人的网卡驱动用的是 e1000e，所以就以此为例了。&lt;/p>
&lt;p>Just enjoy it.&lt;/p></description></item><item><title>Linux 内核 系统调用详解</title><link>https://gohalo.github.io/cn/blog/kernel-syscall/</link><pubDate>Sun, 23 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-syscall/</guid><description>&lt;p>Intel 的 x86 架构的 CPU 提供了 0 到 3 四个特权级，而在 Linux 操作系统中主要采用了 0 和 3 两个特权级，也就是我们通常所说的内核态和用户态。&lt;/p>
&lt;p>从用户态向内核态切换通常有 3 种情况： A) 系统调用(主动)，用户态的进程申请操作系统的服务，通常用软中断实现；B) 产生异常，如缺页异常、除0异常；C) 外设产生中断，如键盘、磁盘等。&lt;/p>
&lt;p>下面以系统调用来讲解。&lt;/p></description></item><item><title>Linux 常用命令 SED</title><link>https://gohalo.github.io/cn/blog/linux-commands-text-sed-introduce/</link><pubDate>Fri, 21 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-commands-text-sed-introduce/</guid><description>&lt;p>sed 是一个精简的、非交互式的编辑器，可以提供与编辑器 VIM 或者 EMACS 相同的编辑任务，但 sed 不提供交互使用方式，只能在命令行下输入编辑命令。&lt;/p>
&lt;p>这里简单介绍其使用方法。&lt;/p></description></item><item><title>Linux 常用命令 AWK</title><link>https://gohalo.github.io/cn/blog/linux-commands-text-awk-introduce/</link><pubDate>Wed, 19 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-commands-text-awk-introduce/</guid><description>&lt;p>AWK 是一种程序语言，对文档资料的处理具有很强的功能，擅长从格式化报文或一个大的文本文件中抽取数据，会将一行文字按分隔符分为多个域，然后进行处理。&lt;/p>
&lt;p>这里简单介绍其常用的方法。&lt;/p></description></item><item><title>Linux VFS 文件系统</title><link>https://gohalo.github.io/cn/blog/linux-kernel-virtual-file-system-introduce/</link><pubDate>Sat, 15 Mar 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-kernel-virtual-file-system-introduce/</guid><description>&lt;p>在次重申下，Linux 的设计理念是：一切都是文件！&lt;/p>
&lt;p>也就是在 Linux 中，一切设备皆是以文件的形式进行操作，如网络套接字、硬件设备等。这一切都是通过一个中间层实现的，被称为 VFS (Virtual File System) 。&lt;/p></description></item><item><title>Linux 文件操作</title><link>https://gohalo.github.io/cn/blog/linux-file-operations/</link><pubDate>Mon, 10 Mar 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-file-operations/</guid><description>&lt;p>Linux 的设计理念是：一切都是文件！在此简单介绍下 Linux 中常见的文件操作。&lt;/p></description></item><item><title>Linux 启动过程</title><link>https://gohalo.github.io/cn/blog/kernel-bootstrap/</link><pubDate>Fri, 28 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-bootstrap/</guid><description>&lt;p>现在的 Linux 启动过程一般分成了两步，也就是首先调用 GRUB 作为通用的启动服务，然后可以选择 Windows 或者 Linux 加载。&lt;/p>
&lt;p>接下来，看看 Linux 的加载过程。&lt;/p></description></item><item><title>Linux 硬件启动</title><link>https://gohalo.github.io/cn/blog/kernel-hardware-startup/</link><pubDate>Tue, 25 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-hardware-startup/</guid><description>&lt;p>从内核加电之后，简单介绍如何从硬件加载启动。&lt;/p></description></item><item><title>Linux 内核编译</title><link>https://gohalo.github.io/cn/blog/kernel-compile/</link><pubDate>Sun, 23 Feb 2014 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-compile/</guid><description>现在安装时，一般是发行版本已经编译创建好的通用内核，对于一些特定的需求，如嵌入式设置，那么可能就需要手动编译内核镜像。
这里简单介绍如何手动编译内核。
内核镜像介绍 # 通常 Unix 平台下的内核镜像称为 unix，Linux 也与之相似，不过随着虚拟内存 (Virtual Memory) 的发展，于是支持虚拟内存的内核在前面添加了 vm，其中 vmlinux 源自 vmunix 。现在 Linux 支持虚拟内存，不再像老的操作系统比如 DOS 会有 640KB 内存的限制。
在 DOS 的时代，采用的是 16 位段寻址方式，因此只能访问 1M 的空间。在这 1M 的 RAM 空间里，段址从 A000 起，被分配给了显示缓存、外部设备 ROM、BIOS ROM 等等。因此，一般情况下， dos 可供自己分配的也就是段 A000 之前的那部分了，这部分的大小为 640K 。
一般来说，一个可启动的内核镜像 (bootable kernel image) 是经过 zlib 算法压缩的，2.6.30 之后采用 LZMA 或者 BZIP2，vmlinuz 最后的 z 表示内核是压缩的，这也意味着内核中会有一段解压程序。
内核中包含了各种内核镜像的格式，如 vmlinux、zImage、bzImage、uImage 等，首先介绍一下内核中的常见内核文件。
vmlinux 是静态编译出来的最原始的 ELF 文件，包括了内核镜像、调试信息、符号表等内容；其中 &amp;ldquo;vm&amp;rdquo; 代表 &amp;ldquo;Virtual Memory&amp;rdquo;，现在一般都是虚拟内存模式，这个是相对于 8086 的实地址而言。 bzImage 是 vmlinux 经过 gzip 压缩后的文件，适用于大内核，&amp;ldquo;bz&amp;rdquo; 表示 &amp;ldquo;big zImage&amp;rdquo;。 uImage 是 uboot 专用的镜像文件，它是在 zImage 之前加上一个长度为 0x40 的头信息，包括了该镜像文件的类型、加载位置、生成时间、大小等信息。 在发行版本中，通常使用 vmlinuz 标示，而实际上是 bzImage 格式，可以通过 file 命令查看。</description></item><item><title>Linux Netlink 简介</title><link>https://gohalo.github.io/cn/blog/linux-communication-netlink/</link><pubDate>Wed, 19 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-communication-netlink/</guid><description>&lt;p>Netlink 机制是在 Linux 中作为内核态与用户态的一种通讯机制，它是基于 socket 的！！！怎么样，没有想到，除了 TCP/IP 协议外，这样也可以 ^_^&lt;/p>
&lt;p>另外的一个特性是，面向数据报文的无连接消息子系统，有点类似于 UDP 协议。&lt;/p></description></item><item><title>Linux 中断</title><link>https://gohalo.github.io/cn/blog/kernel-interrupts/</link><pubDate>Wed, 19 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-interrupts/</guid><description>&lt;p>中断在很大程度上解放了 CPU，提高了 CPU 的执行效率，弥补了 CPU 与外设运行速度之间的差距。&lt;/p></description></item><item><title>Linux 中的 socketfs</title><link>https://gohalo.github.io/cn/blog/network-socketfs/</link><pubDate>Mon, 10 Feb 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-socketfs/</guid><description>&lt;p>BSD socket 是用户程序与网络协议栈之间的接口层，用户通过调用 socket API 将报文传给协议栈，以及从协议栈读取报文。实际上，Linux 对于网络提供了一个与虚拟文件系统相似的接口，也就是可以通过 socket 接口打开一个类似的文件，而内核中实际是通过 sockfs 文件系统实现的。&lt;/p>
&lt;p>接下来我们就在这篇文章中查看下与 socketfs 相关的内容。&lt;/p></description></item><item><title>Linux 网络常见监控项以及报错</title><link>https://gohalo.github.io/cn/blog/linux-monitor-network/</link><pubDate>Mon, 03 Feb 2014 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-network/</guid><description>&lt;p>本来是想将报错和监控拆开的，但是发现两者几乎是耦合的，通过监控项才能发现错误，定为错误的原因时也要依赖监控项，索性就将两者合并到了一起。&lt;/p>
&lt;p>对于很多的报错，实际上你即使看到报错的信息也不清楚到底是那里报错了，或者模棱两可，甚至是误导。最好的方式是 &amp;ldquo;Show me the code&amp;rdquo; 。&lt;/p>
&lt;p>在此，简单介绍一下与网络相关的调试、查看方法，当然也包括了报错相关的内容。&lt;/p></description></item><item><title>Linux 网络协议栈简介</title><link>https://gohalo.github.io/cn/blog/network-introduce/</link><pubDate>Thu, 23 Jan 2014 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/network-introduce/</guid><description>&lt;p>Linux 的 TCP/IP 协议栈估计是目前最灵活、应用最广的网络协议栈了，具有清晰的层次结构以及清晰定义的原语和接口，不仅使得上层应用开发者可以无需关心下层架构或者内部机制，从而提供相对透明的操作网络。&lt;/p>
&lt;p>在本文中简单介绍一下与协议栈相关的内容。&lt;/p></description></item><item><title>Linux Chroot</title><link>https://gohalo.github.io/cn/blog/linux-chroot/</link><pubDate>Mon, 13 Jan 2014 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-chroot/</guid><description>&lt;p>chroot 也就是 change root directory，也就是改变程序执行时所参考的根目录位置。在 Linux 系统中，系统默认的目录结构都是以 &amp;ldquo;/&amp;quot;，即是以根 (root) 开始的，而在使用 chroot 之后，系统的目录结构将以指定的位置作为 &amp;ldquo;/&amp;rdquo; 位置。&lt;/p>
&lt;p>应用场景比较多，如安全中的蜜罐、系统启动时用的 initrd、嵌入式系统挂载的 NFS、Linux From Scratch 的编译过程等等。&lt;/p>
&lt;p>在此，简单介绍下 chroot 。&lt;/p></description></item><item><title>SEO 优化技巧</title><link>https://gohalo.github.io/cn/blog/seo-tips-for-webs/</link><pubDate>Mon, 28 Oct 2013 19:20:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/seo-tips-for-webs/</guid><description>&lt;p>所谓的 SEO 也就是搜索引擎优化，指遵循搜索引擎的搜索原理，对网站结构、网页文字语言和站点间互动外交略等进行合理规划部署，以改善网站在搜索引擎的搜索表现，进而增加客户发现并访问网站的可能性。&lt;/p>
&lt;p>这里主要介绍一些常见的优化技巧。&lt;/p></description></item><item><title>Python 基本环境准备</title><link>https://gohalo.github.io/cn/blog/python-environment-prepare/</link><pubDate>Thu, 17 Oct 2013 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/python-environment-prepare/</guid><description>&lt;p>与 Java 类似，Python 底层通过一个虚拟机运行，而且已经移植到了多个平台上，也就是，需要根据不同的平台安装虚拟机，实际上最主要的就是 python 可执行文件。&lt;/p>
&lt;p>现在大多数安装的都是 CPython ，也就是 C 语言实现的 Python ，通常，直接使用安装包安装即可。&lt;/p>
&lt;p>这里详细介绍如何安装环境，使用虚拟环境等等。&lt;/p></description></item><item><title>Markdown 使用介绍</title><link>https://gohalo.github.io/cn/blog/cheatsheet-markdown/</link><pubDate>Thu, 18 Jul 2013 22:14:27 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/cheatsheet-markdown/</guid><description>&lt;p>Markdown 是一种很简单的标记语法，可以直接使用普通的文本编辑器编写，在渲染之后具有一定的格式，主要特点就是简单、方便书写。&lt;/p>
&lt;p>同时，还有一些衍生版本，用于扩展一些常见的功能，常见的有 Markdown Extra、MultiMarkdown、Maruku 等。&lt;/p>
&lt;p>这里简单整理基础语法的速查表，详细语法可以参考 &lt;a href="https://daringfireball.net/projects/markdown/syntax">Markdown Syntax&lt;/a> 中的介绍。&lt;/p></description></item><item><title>Kernel 系统时钟</title><link>https://gohalo.github.io/cn/blog/kernel-timer-introduce/</link><pubDate>Tue, 02 Jul 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-timer-introduce/</guid><description/></item><item><title>Kernel 调度系统</title><link>https://gohalo.github.io/cn/blog/kernel-scheduler/</link><pubDate>Fri, 21 Jun 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-scheduler/</guid><description>&lt;p>操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级和高优先级进程的需要尽可能调和等等。&lt;/p>
&lt;p>什么时候以怎样的方式选择一个进程运行，就是所谓的调度策略 (Scheduling Policy)。&lt;/p>
&lt;p>本文中，介绍下 Linux Kernel 中时如何实现的。&lt;/p></description></item><item><title>关于时间的杂七杂八</title><link>https://gohalo.github.io/cn/blog/time-mess/</link><pubDate>Sat, 01 Jun 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/time-mess/</guid><description>&lt;p>一篇引用的文章，忘了从哪里引用的了。&lt;/p></description></item><item><title>Linux 常用监控工具</title><link>https://gohalo.github.io/cn/blog/linux-monitor-misc/</link><pubDate>Sun, 12 May 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-misc/</guid><description>在此简单列举一些常见的监控工具，以及配置方式等。
SAR # sar (select activity information) 用于采集系统的信息，默认会保存一个月的信息，在 CentOS 中包含在 sysstat软件包中。与此相关的还有：
sac, system ativity data collector。也就是 sar 的后端，用于收集信息； sa1，用于将信息保存为二进制信息，默认位置为 /var/log/sa/saXX (其中XX表示当月的日期)； sar2，显示每天的统计信息，是 一个 shell 脚本； sadf，用于转换为其它的格式 (如csv，xml) 的程序。 sar1 和 sar2 会在 cron 任务中调用，配置在 /etc/cron.d/sysstat 文件中，默认每 10 分钟调用 sa1 采集一次数据；在 23:53 时通过 sa2 转换一次数据，默认保存 28 天，可以在 /usr/lib64/sa/sa2 中设置。
其中 /etc/cron.d/sysstat 文件内容如下。
# Run system activity accounting tool every 10 minutes */10 * * * * root /usr/lib64/sa/sa1 1 1 # Generate a daily summary of process accounting at 23:53 53 23 * * * root /usr/lib64/sa/sa2 -A 因为使用的是 crontab ，所以最小的粒度是 1min；当然，也可以使用 sa1 1 60 每秒执行依次，并执行 60 次，进一步减小监控的粒度。</description></item><item><title>Cache 能否回收</title><link>https://gohalo.github.io/cn/blog/linux-monitor-memory-cache-buffer-introduce/</link><pubDate>Sat, 20 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-memory-cache-buffer-introduce/</guid><description/></item><item><title>Linux 常用命令</title><link>https://gohalo.github.io/cn/blog/linux-commands-tips/</link><pubDate>Fri, 12 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-commands-tips/</guid><description>&lt;p>主要介绍下在 Linux 中，日常用到的一些常用指令，如 find、cmp 等。&lt;/p></description></item><item><title>Linux 监控之 Memory</title><link>https://gohalo.github.io/cn/blog/linux-monitor-memory/</link><pubDate>Sat, 06 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-monitor-memory/</guid><description>&lt;p>在 Linux 的内存分配机制中，优先使用物理内存，当物理内存还有空闲时，不会释放其占用内存，就算占用内存的程序已经被关闭了，该程序所占用的内存用来做缓存使用，这样对于开启过的程序、或是读取刚存取过得数据会比较快，可以提高整体 IO 效率。&lt;/p></description></item><item><title>Kernel 内存映射</title><link>https://gohalo.github.io/cn/blog/kernel-memory-virtual-physical-map/</link><pubDate>Fri, 05 Apr 2013 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/kernel-memory-virtual-physical-map/</guid><description>&lt;p>现在的操作系统在内存使用时，一般为逻辑地址，那么逻辑地址和物理地址之间是怎样映射的，或者说，通过逻辑地址如何找到物理内存中的内容。&lt;/p>
&lt;p>其实，包括动态共享库，mmap 映射等，都使用到了虚拟内存，也就是逻辑地址的映射。&lt;/p>
&lt;p>这里，简单介绍下逻辑地址到物理地址的映射关系。&lt;/p></description></item><item><title>Linux LVS</title><link>https://gohalo.github.io/cn/blog/linux-lvs-introduce/</link><pubDate>Fri, 15 Mar 2013 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-lvs-introduce/</guid><description>&lt;p>LVS 通常用于四层的网络服务器做负载均衡，其工作在内核层，而且效率非常高；部署时还会使用 heartbeat 以及 keepalived 做高可用。&lt;/p>
&lt;p>在本文中，我们对其做些介绍。&lt;/p></description></item><item><title>Linux 常用技巧</title><link>https://gohalo.github.io/cn/blog/linux-tips/</link><pubDate>Sat, 09 Mar 2013 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/linux-tips/</guid><description/></item><item><title>【专题】数据仓库</title><link>https://gohalo.github.io/cn/blog/topic-warehouse-introduce/</link><pubDate>Tue, 21 Dec 2010 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-warehouse-introduce/</guid><description/></item><item><title>【专题】数据库之 RocksDB</title><link>https://gohalo.github.io/cn/blog/topic-database-rocksdb/</link><pubDate>Tue, 21 Dec 2010 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-database-rocksdb/</guid><description/></item><item><title>【专题】Web 前端编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-webs/</link><pubDate>Wed, 15 Dec 2010 22:10:52 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-webs/</guid><description>前端 # 在前端的页面中，核心包括了三部分：
HTML 主要包括了文字、图片、链接，其它还有音乐、程序等非文字元素的标记语言； CSS 可以定制化 HTML 中元素显示的样式，从而更加美观； JavaScript 一种解释性脚本语言，可以用来给 HTML 页面增加动态、交互功能。 HTML 用于创建网页的标记语言。 CSS # 基本概念 包括基本语法、样式、盒子模型等概念，还可以参考 示例 代码，另外还有 选择器 。 SCSS 语法 在 SASS3 引入的新语法，完全监控 CSS3 并继承了 SASS 强大能力。 JavaScript # 基本语法 简单介绍纯原生的核心语法，以及常用示例。 TypeScript 详细介绍 TS 的基础语法。 React # React 是一个用于构建用户界面的 JavaScript 库，起源于 FaceBook 的内部项目。
基本介绍 介绍基础的 React 使用。 简明教程 一步步简单介绍 React 中的基本概念以及使用方法。 Router 详细介绍 React Router Dom V6 的使用方式。 常用工具 # npm 介绍 npm 以及常用的配置方式。 webpack 这是前端使用最为广泛的打包工具，可以大大提高工作效率。 参考 # 关于当前浏览器如何工作的，可以参考 how browsers work 以及 mozilla.</description></item><item><title>【专题】C/C++ 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-c-cpp/</link><pubDate>Fri, 12 Nov 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-c-cpp/</guid><description>C 语言 # 在 1989 年，美国国家标准协会 (ANSI) 对 C 语言进行了标准化，此时 C 语言又被称为 ANSI C。在一年后被国际标准化组织 ISO 采纳，所以 C 语言在 ISO 中有了一个官方名称 ISO/IEC 9899:1990 ，其中 9899 是 C 语言在 ISO 标准中代号 (C++ 是 14882)，冒号后面的 1990 表示当前修订好的版本是在 1990 年发布。
所以，最开始的 C 语言标准也被称为 C89、C90 或者 C89/C90，后续又在 1999、2007、2011 进行了改进。另外，C++ 在从 C++11 之后，基本固定每三年发布一个新版本。
整数介绍 包括了类型提升、整型溢出等。 宏使用 一些基本使用规则，以及常见注意事项。 数据对齐 结构体以及内存的对齐方式。 指针简介 包括了基本概念、函数指针等概念的介绍。 位域和字节序 位域或位段相关概念，以及大小端字节序相关的内容。 inline 简介 有点类似于 C 中的宏，但是又有所区别。 Volatile 简介 C 语言中与 volatile 相关的介绍。 基本概念 # 不只是 C 相关代码，实际上更多的是 Linux 中的基本介绍。</description></item><item><title>【专题】PostgreSQL 关系型数据库</title><link>https://gohalo.github.io/cn/blog/topic-database-postgresql/</link><pubDate>Fri, 12 Nov 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-database-postgresql/</guid><description/></item><item><title>【专题】Python 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-python/</link><pubDate>Sun, 17 Oct 2010 18:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-python/</guid><description>&lt;p>Python 是一种解释型语言，提供了跨平台的支持，可以快速开发一些脚本，随着 AI 的兴起，提供了一些常见的开发框架，这里详解介绍 Python 的使用。&lt;/p></description></item><item><title>【专题】Rust 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-rust/</link><pubDate>Sat, 16 Oct 2010 19:39:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-rust/</guid><description>&lt;p>可以将 Rust 理解为 C 的直接替代品，提供了系统级的性能，而且在很多方面更好，最常提到的就是内存安全，并且可以与遗留 C 代码原生互操作以进行增量替换。&lt;/p></description></item><item><title>【专题】GoLang 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-golang/</link><pubDate>Wed, 06 Oct 2010 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-golang/</guid><description>&lt;p>GoLang 是谷歌 2009 年发布的开源编程语言，其开发人员都是计算机界大神一般的存在，提供了便捷的协程使用，具有很高的并发性。目前很多 Cloud Native 软件都是通过 GoLang 编写，例如 Docker、K8S、LXD 等等。&lt;/p></description></item><item><title>【专题】Bash 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-bash/</link><pubDate>Sun, 19 Sep 2010 21:15:12 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-bash/</guid><description>&lt;p>Shell 是一个程序，用于用户和操作系统进行交互，相当于是一个命令解析器，Shell 有很多种，其实现有很多细节差异，不过大部分的语法基本相同。&lt;/p>
&lt;p>在 Linux 中默认的就是 Bash 实现，这里介绍其常用语法以及使用技巧。&lt;/p></description></item><item><title>【专题】数据库之 SQLite</title><link>https://gohalo.github.io/cn/blog/topic-database-sqlite/</link><pubDate>Wed, 25 Aug 2010 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-database-sqlite/</guid><description/></item><item><title>【专题】数据库之时序数据库</title><link>https://gohalo.github.io/cn/blog/topic-database-time-series/</link><pubDate>Wed, 25 Aug 2010 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-database-time-series/</guid><description/></item><item><title>【专题】数据库之 ETCD</title><link>https://gohalo.github.io/cn/blog/topic-database-etcd/</link><pubDate>Sat, 21 Aug 2010 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-database-etcd/</guid><description> PAXOS 算法从 90 年提出到现在已经有二十几年了，不过其流程过于复杂，目前较多的有 Chubby、libpaxos ，以及 Zookeeper 修改后的 Zookeeper Atomic Broadcase, ZAB 。
RAFT 是斯坦福的 Diego Ongaro、John Ousterhout 两人设计的一致性算法，在 2013 年发布了论文 《In Search of an Understandable Consensus Algorithm》，目前已经有近十多种语言的实现，其中使用较多的是 ETCD 。
RAFT 一个为真实世界应用建立的协议，注重落地性和可理解性。 基本介绍 主要介绍 ETCD 如何使用，包括安装、部署、使用以及常见的介绍。 示例源码 源码中关于如何 RAFT 协议的示例代码，直接使用的是内存数据库。 源码解析 除了上述的示例代码，这里简单介绍其代码的实现。 网络模块 包括了集群节点内部网络通讯，除此之外还有客户端与服务器之间的通讯。 存储模块 核心的 RAFT 协议已经实现，不过存储模块需要单独实现，提供了 BoltDB 作为存储。 一致性读 一致性越强，代价越高，同时应用也越友好。</description></item><item><title>【主题】人工智能</title><link>https://gohalo.github.io/cn/blog/topic-artificial-intelligence/</link><pubDate>Mon, 16 Aug 2010 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-artificial-intelligence/</guid><description/></item><item><title>【专题】Lua 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-lua/</link><pubDate>Thu, 12 Aug 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-lua/</guid><description>&lt;p>Lua 在葡萄牙语中是 &amp;ldquo;月亮&amp;rdquo; 的意思，是一个小巧的脚本语言，官方版本只包括一个精简的核心和最基本的库，使得其体积小、启动速度快，从而特别适合嵌入到其它程序里。&lt;/p></description></item><item><title>【专题】MySQL 数据库</title><link>https://gohalo.github.io/cn/blog/topic-database-mysql/</link><pubDate>Thu, 22 Jul 2010 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-database-mysql/</guid><description>&lt;p>MySQL 是一款最流行的开源关系型数据库，最初由瑞典的 MySQL AB 公司开发，目前已被 Oracle 收购，虽然如此，但是仍然在不断的向前发展。&lt;/p>
&lt;p>这里详细介绍概念。&lt;/p></description></item><item><title>【专题】算法详解</title><link>https://gohalo.github.io/cn/blog/topic-algorithm/</link><pubDate>Fri, 16 Jul 2010 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-algorithm/</guid><description>&lt;p>包括常见的基础数据结构、算法，也包含了类似 LeetCode 的刷题技巧。&lt;/p></description></item><item><title>【专题】开发环境</title><link>https://gohalo.github.io/cn/blog/topic-develop-workspace/</link><pubDate>Sat, 12 Jun 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-develop-workspace/</guid><description>Git # Git 是一免费、开源的分布式版本控制系统，可有效、高速的处理从很小到非常大的项目版本管理，该工具是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发，其本意是为了替换 BitKeeper 。
除了 GitHub 外，开源的工具还有 GitLab、Gogs，以及 C 的相关库 libgit2 。
这里简单介绍一下常见概念及其操作。
简明教程 介绍常见的基础操作，以及相关的配置。 分支模型 git 提供了很方便的分支管理，通过规范化的管理策略可以简化版本维护成本。 对象简介 内部使用一组极为简洁的数据结构来维护，也就是对象。 常用技巧 # 免密登录 这里介绍对于 http 和 ssh 访问时如何免除密码输入。 子模块使用 可以将其它的库作为模块添加，这样就可以方便管理。 补丁管理 可以通过 git 生成补丁文件，然后可以在 Linux 中通过命令打补丁。 换行符切换 在 Window 和 Linux 上的换行符是不同的，可以自动进行切换。 多源管理 介绍如何将一个本地仓库同步到不同的远端仓库中。 统计工具 对于一些常见指标的统计。 LFS 使用 由 GitHub 实现的一种处理大文件的解决方案。 开源流程 这里以 GitHub 为例简单介绍一个常用的提交流程。 常见问题 整理下 git 中常见的问题、解决方案以及相关原因，同时包含 github 代理。 使用杂项 记录 git 常见的示例，可以用来作为参考使用，也就是 Cheatsheet 参考。 参考 # 下载加速 长期维护的代理、Hosts 等信息，海外下载可以使用 果冻网络加速 进行代理。 CICD # 用于搭建开发、自动部署等平台。</description></item><item><title>【专题】Linux 内核详解</title><link>https://gohalo.github.io/cn/blog/topic-linux-kernel/</link><pubDate>Fri, 21 May 2010 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-kernel/</guid><description/></item><item><title>【专题】Java 编程语言</title><link>https://gohalo.github.io/cn/blog/topic-language-java/</link><pubDate>Thu, 06 May 2010 19:29:18 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-language-java/</guid><description>&lt;p>Java 是由 Sun Microsystems 公司于 1995 年 5 月推出的高级程序设计语言，可运行于多个平台，如 Windows、Mac OS 及其它多种类 UNIX 版本的系统，包括 Linux 系统。&lt;/p></description></item><item><title>【专题】Linux 监控调优</title><link>https://gohalo.github.io/cn/blog/topic-linux-monitor/</link><pubDate>Wed, 21 Apr 2010 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-monitor/</guid><description>系统监控 # 记录与监控相关的内容。
网络监控 包含一些异常的处理，例如丢包、内存不足等。 进程监控 与进程相关的一些监控指标。 内存监控 主要介绍 proc 文件系统的统计。 IO 监控 包括常见的 IO 监控工具，同时也包含测试相关的内容。 CGroup 监控 通过 proc 文件系统可以查看某个 cgroup 组的性能指标。 监控工具 简单列举一些常见的监控工具 (sar top ps)、配置方式以及多线程相关等。 CPU 物理结构 简单介绍 CPU 物理结构，以及 如何在 Linux 中查看 CPU 信息 。 Network # 网络配置 常见的如主机名、网卡、路由等的配置。 状态查看 主要是网络状态查看，例如正在监听的端口信息。 其它 # tcprstat 可以用来统计服务端的数据处理时间，包括了最大最小值等统计信息。 collectd 一个 C 语言编写的多线程监控采集程序，同时可以参考 源码解析 。 dstat 一个使用 Python 编写的跨平台监控工具，包含系统监控，还可以通过插件扩展。 sysbench 不错的压测工具，通常用于数据库，不过也有系统性能压测。 prometheus 当前最常用的监控系统，包含了存储，还有 Grafana 展示等。 statsd 十分简单的监控协议，默认通过 JavaScript 实现，不过当前有很多其它语言实现。 netlink 类似于 TCP/IP 的内核通讯机制，用于在内核态和用户态之间传递数据。 zabbix 历史悠久、成熟的开源监控系统，提供了灵活的 API 接口。 系统配置 常见的相关配置，例如 swap、sysctl 等。 性能调优 # 可以使用 CPU 性能计数器、tracepoints、kprobes、uprobes 对程序的各个指标进行统计。</description></item><item><title>【专题】Linux 网络相关</title><link>https://gohalo.github.io/cn/blog/topic-linux-network/</link><pubDate>Sat, 10 Apr 2010 20:19:30 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-network/</guid><description/></item><item><title>【专题】Linux 安全相关</title><link>https://gohalo.github.io/cn/blog/topic-linux-security/</link><pubDate>Sat, 27 Mar 2010 21:18:34 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-security/</guid><description>&lt;p>介绍 Linux 中与安全相关的内容，例如 SSH、SELinux 等，当然，也包括了一些安全相关基本的概念，例如加密算法、TLS 等等，这里作为一个专题介绍一些常见概念。&lt;/p></description></item><item><title>【专题】Linux 容器介绍</title><link>https://gohalo.github.io/cn/blog/topic-linux-container/</link><pubDate>Fri, 12 Mar 2010 20:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-container/</guid><description>&lt;p>Linux 内核提供了 cgroup 以及 namespace 的基本隔离手段，然后在此基础上，提供了更上层的封装，包括了 Docker、rkt、PouchContainer 以及最新的 Podman 等等。&lt;/p></description></item><item><title>【专题】Linux 环境搭建</title><link>https://gohalo.github.io/cn/blog/topic-linux-environment-setup/</link><pubDate>Thu, 25 Feb 2010 22:10:42 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-linux-environment-setup/</guid><description>&lt;p>Linux 有多个发行版本，其中 RedHat、Debian 及其衍生版本占了很大一部分，大部分的基本功能相似，但是环境又略有区别，这里简单介绍其基础的环境使用，以及一些常见概念。&lt;/p></description></item><item><title>【专题】并发编程</title><link>https://gohalo.github.io/cn/blog/topic-concurrency-program/</link><pubDate>Tue, 26 Jan 2010 19:18:25 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/topic-concurrency-program/</guid><description/></item><item><title>Hello World</title><link>https://gohalo.github.io/cn/blog/hello-world/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0800</pubDate><guid>https://gohalo.github.io/cn/blog/hello-world/</guid><description>&lt;p>Hi, the world, I&amp;rsquo;m coooooooooming.&lt;/p>
&lt;p>Oooops, just examples, ignore me, darling.&lt;/p></description></item><item><title/><link>https://gohalo.github.io/cn/blog/hudi-consistency-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gohalo.github.io/cn/blog/hudi-consistency-model/</guid><description/></item><item><title/><link>https://gohalo.github.io/cn/blog/malloc-third-library/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gohalo.github.io/cn/blog/malloc-third-library/</guid><description> mimalloc # malloc free 主路径深度优化。 通过原子操作而非锁解决数据竞争。</description></item><item><title>归档</title><link>https://gohalo.github.io/cn/blog/archives/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gohalo.github.io/cn/blog/archives/</guid><description/></item><item><title>标签</title><link>https://gohalo.github.io/cn/blog/tags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://gohalo.github.io/cn/blog/tags/</guid><description/></item></channel></rss>