<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>RAFT 协议简介 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="Paxos 一直是分布式协议的标准，但是 Paxos 难于理解，更难以实现，例如 Google 的分布式锁系统 Chubby 在实现 Paxos 协议时就遇到很多坑。
来自 Stanford 的新的分布式协议研究称为 RAFT，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>RAFT 协议简介</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2018-04-13</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/database/ role=button>database</a></div></div><hr><div class=content><p>Paxos 一直是分布式协议的标准，但是 Paxos 难于理解，更难以实现，例如 Google 的分布式锁系统 Chubby 在实现 Paxos 协议时就遇到很多坑。</p><p>来自 Stanford 的新的分布式协议研究称为 RAFT，它是一个为真实世界应用建立的协议，主要注重协议的落地性和可理解性。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>RAFT 算法在许多方面和现有的一致性算法都很相似，其独有的特性如下：</p><ul><li>强领导者，日志只从领导者发送给其它从服务器，简化了对日志复制的管理。</li><li>领导选举，在所有一致性算法的心跳机制上增加了一个随机计时器来选举领导者，从而可以更加简单快捷地解决冲突。</li><li>日志一致，简单来说就是通过 Term 和 Index 保证所有的日志及其顺序全局唯一，同时不允许存在空洞 (Paxos允许)。</li><li>成员变更，使用一种共同一致的方法来处理集群成员变换的问题，在变更过程中集群依然可以继续工作。</li></ul><a class=anchor id=复制状态机></a><h2>复制状态机 <a href=#%e5%a4%8d%e5%88%b6%e7%8a%b6%e6%80%81%e6%9c%ba aria-hidden=true>#</a></h2><p>一致性算法实际上是基于这一模型的，需要保证复制日志相同，简单来说就是初始状态相同，以相同的顺序处理指令，那么各个节点会产生相同的状态以及状态序列。目前使用比较多的是基于日志的复制方式，这一复制过程也被称为原子广播。</p><p>实际系统中使用的一致性算法通常含有以下特性：</p><ul><li>安全性 safty，也就是在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。</li><li>可用性 livness，集群中只要多数机器、客户端可以相互通讯，那么集群就是可用的，如果机器异常崩溃，大部分场景可以从持久化中恢复。</li><li>非时序依赖，通常不会因为物理时钟、消息延迟导致可用性问题。</li></ul><a class=anchor id=拜占庭问题></a><h2>拜占庭问题 <a href=#%e6%8b%9c%e5%8d%a0%e5%ba%ad%e9%97%ae%e9%a2%98 aria-hidden=true>#</a></h2><p>这一问题实际上是 Lamport 老爷子在 《The Byzantine Generals Problem》中提出的，这实际上是一个虚构的故事，准确来说是研究分布式系统容错性的时候编出的一个故事。</p><p>不同的版本可能会略有出入，简单如下。</p><p>假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。</p><p>拜占庭将军问题更像是一个错误模型，简单地说，Byzantine Generals Problem 是针对所谓的 Byzantine Failure 来说的，而 Byzantine Failure 是指分布式系统中的某一恶意节点允许做任意事情去干扰系统的正常运行 (包括选择性不传递消息、选择性伪造消息等)，如何保证在这一场景下确保整个系统不会异常。</p><p>简单来说，就是在缺少可信的中央节点和可信任的通道的情况下，分布在网络中的各个节点如何达成共识的问题。</p><a class=anchor id=practical-byzantine-fault-tolerance-pbft></a><h4>Practical Byzantine Fault Tolerance, PBFT <a href=#practical-byzantine-fault-tolerance-pbft aria-hidden=true>#</a></h4><p>经典的 PBFT 的解决方案是需要所有节点均交换数据，有明显的扩展性问题。</p><a class=anchor id=proof-of-work-pow></a><h4>Proof of Work, POW <a href=#proof-of-work-pow aria-hidden=true>#</a></h4><p>在出现比特币之前，解决分布式系统一致性问题主要是 PAXOS 及其衍生算法，仅适用于中心化的分布式系统，这样的系统的没有不诚实的节点，也就是不会发送虚假错误消息，但允许出现网络不通或宕机出现的消息延迟。</p><p>在区块链的实现中通过 POW 来解决这一问题。</p><a class=anchor id=raft-算法></a><h1>RAFT 算法 <a href=#raft-%e7%ae%97%e6%b3%95 aria-hidden=true>#</a></h1><p>算法中的大部分工作是为了消除不确定性，例如不允许日志有空洞。为了方便理解，将算法分成了几个模块，包括了领导选举、日志复制、安全性、成员变更。</p><p>日志管理主要是通过 Leader 负责，从客户端接收日志，并将日志复制到其它从服务器上，同时通知其它从服务器什么时候将日志应用到状态机上，通过这一机制大大简化了对复制日志的管理。</p><p>Leader 会直接决定日志存放的位置，而不需要和其它服务器进行协商，当 Leader 宕机后，会从其它服务器上重新选举出来。</p><a class=anchor id=关于-term></a><h2>关于 Term <a href=#%e5%85%b3%e4%ba%8e-term aria-hidden=true>#</a></h2><p>也就是一个任期，此时的 Leader 不变，每次都会通过发送的消息进行同步更新，如果当前服务器保存的 term 较小，那么就会更新到更大的值。</p><p>其中 term 的标识从 1 开始单调递增，而且总是以选举开始，总的时间不定，可能无限长，也可能只有选举时间。而且因为网络的延迟，各个节点看到相同term的时间点不同，极端情况下可能会有丢失某个 term 的情况。</p><p>Term 相当于不依赖墙上时钟的逻辑时间，同样可以用来做一些常规的判断，例如判断是否是一个过期的 Leader、如果收到了一个过期的请求则直接丢弃。</p><p>如果 Candidate 和 Leader 发现自己的 term 过期，那么会自动切换到 Follower 状态。</p><a class=anchor id=选主逻辑></a><h1>选主逻辑 <a href=#%e9%80%89%e4%b8%bb%e9%80%bb%e8%be%91 aria-hidden=true>#</a></h1><p>基础的 RAFT 协议主要包含了如下几个角色：</p><ul><li><code>Leader</code> 处理客户端请求，并将写日志同步到 <code>Follower</code> 节点。</li><li><code>Candidate</code> 参与选主逻辑。</li><li><code>Follower</code> 复制 <code>Leader</code> 发送的日志、转发客户请求。</li></ul><p>RAFT 维护了单调递增的 Term 信息，值越大优先级越高，某个 Term 内最多只存在一个主节点，每个节点会通过 <code>log::set_term()</code> 持久化已知的 Term 信息；发送消息会附带该节点的 Term 信息，当节点接收到更大 Term 时会转换为 <code>Follower</code> 角色。</p><p><code>Leader</code> 在任期内会周期性的发送心跳，如果 <code>Follower</code> 一直没收到心跳，那就认为原 <code>Leader</code> 失效，则转为 <code>Candidate</code> 开始重新发起选举，选举信息会带上日志信息 (TODO 应该是已经提交的信)。</p><a class=anchor id=日志复制></a><h1>日志复制 <a href=#%e6%97%a5%e5%bf%97%e5%a4%8d%e5%88%b6 aria-hidden=true>#</a></h1><p>RAFT 的日志包含了 <code>(Term, Index, Command)</code>，其中 <code>Command</code> 的值协议本身并不关心，只有主节点可以收到写请求，从主节点来看大致会经历如下步骤：</p><ol><li>通过 <code>log::append()</code> 写入本地日志，当非 <code>Leader</code> 节点收到请求时会转发到 <code>Leader</code> 节点；</li><li>并行地向各个 <code>Follower</code> 发送 <code>Message::Append</code> 日志；</li><li>等待多数 <code>Follower</code> 节点的响应；</li><li>应用到状态机，返回给客户端；</li><li>通知其它节点应用日志。</li></ol><p>集群会保证提交的日志应用到状态机，不会发生回滚，注意，未提交的日志可能被覆盖。</p><a class=anchor id=安全性></a><h2>安全性 <a href=#%e5%ae%89%e5%85%a8%e6%80%a7 aria-hidden=true>#</a></h2><p>所有基于领导者的一致性算法中，领导者都必须包含所有已提交的日志，有些算法需要额外机制识别并复制到主节点，而 RAFT 则通过选主阶段的限制来达到这一目的，简单来说，就是只对比当前节点新的 <code>Candidate</code> 投票，可确保至少一个节点有最新提交数据。</p><a class=anchor id=multi-raft></a><h1>Multi RAFT <a href=#multi-raft aria-hidden=true>#</a></h1><p>原始的 RAFT 协议主节点会处理所有请求，而且每个保存了所有数据，这样单节点会很容易成为系统瓶颈，常规的解决方案是 Sharding 数据，也就是 MultiRaft 实现。</p><a class=anchor id=线性一致性></a><h1>线性一致性 <a href=#%e7%ba%bf%e6%80%a7%e4%b8%80%e8%87%b4%e6%80%a7 aria-hidden=true>#</a></h1><p>RAFT 只提供了基础的共识机制，考虑到复制延迟、分区、主备切换等场景，是无法通过直接读取单节点数据来达成目标的，包括 <code>Follower</code>、<code>Leader</code> 等节点，所以，为了实现线性一致性还需要其它额外的机制来保证，</p><p>最简单的是将线性读采用类似写的逻辑，走一遍完整的日志复制提交流程，也被称为 <code>LogRead</code>，这种方式满足要求但是性能会很差，常规的优化方法有 <code>ReadIndex</code> 和 <code>LeaseRead</code> 两种。</p><a class=anchor id=readindex></a><h2>ReadIndex <a href=#readindex aria-hidden=true>#</a></h2><p>在 Leader 中读取，执行流程如下：</p><ol><li>记录当前的 <code>CommitIndex</code> 保存为本地的 <code>ReadIndex</code> 变量；</li><li>向其它节点发起心跳，如果多数节点响应，那就能确定当前节点现在仍为 <code>Leader</code> 角色；</li><li>等待状态机至少应用到 <code>ReadIndex</code> 日志，就可以安全读取了；</li><li>执行读请求，将结果返回给客户端。</li></ol><p>其中关键的是第三步中的 <strong>至少</strong>，在 <code>ReadIndex</code> 以及之后都可以满足要求，通过心跳确保当前仍然为主，省去了日志复制流程，而心跳开销较小，相比来说效率要好很多。</p><p>注意，当某个节点被选举为主时，此时的 <code>CommitIndex</code> 并非最新，需要节点完成 <code>Noop</code> 日志后再提供服务。</p><a class=anchor id=leaseread></a><h2>LeaseRead <a href=#leaseread aria-hidden=true>#</a></h2><p>上述方式仍然存在 <code>Heartbeat</code> 交互。</p><a class=anchor id=性能优化></a><h1>性能优化 <a href=#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96 aria-hidden=true>#</a></h1><p>整个 RAFT 的处理流程如下：</p><ol><li>Leader 接收 Client 发送的请求；</li><li>Leader 将日志 Append 到本地；</li><li>Leader 将日志并发送给其它节点；</li><li>Leader 等待 Follower 结果，当多数节点提交成功则 Apply 到状态机；</li><li>Leader 将结果返回给 Client 节点；</li></ol><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><a class=anchor id=faq></a><h2>FAQ <a href=#faq aria-hidden=true>#</a></h2><a class=anchor id=raft-根-2pc-的区别和相同点是什么></a><h5>RAFT 根 2PC 的区别和相同点是什么？ <a href=#raft-%e6%a0%b9-2pc-%e7%9a%84%e5%8c%ba%e5%88%ab%e5%92%8c%e7%9b%b8%e5%90%8c%e7%82%b9%e6%98%af%e4%bb%80%e4%b9%88 aria-hidden=true>#</a></h5><p>严格来说两者的使用场景是不同的，RAFT 是共识算法，目的是为了保证各个节点的数据一致性，虽然在日志应用过程中分成了日志同步+日志应用两个阶段，但是其目的是保证该日志不同节点一致性。而 2PC 是为了处理分布式事务，其协调的是两个本地事务和全局事务的一致性。</p><a class=anchor id=为什么会有-noop-日志></a><h5>为什么会有 Noop 日志？ <a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89-noop-%e6%97%a5%e5%bf%97 aria-hidden=true>#</a></h5><p>这里的 <code>Noop</code> 日志是在节点当选 <code>Leader</code> 之后同步的日志，在作者毕业论文的 3.6.2 章节中有详细的介绍，为了保证日志的安全，节点当选后不会同步前任期的日志，而客户端何时提交数据又不确定，同时为了通过 <code>Log Matching Property</code> 保证各个节点数据一致性，那么就有了 <code>Noop</code> 日志。</p><a class=anchor id=apply-失败如何处理></a><h5>Apply 失败如何处理？ <a href=#apply-%e5%a4%b1%e8%b4%a5%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86 aria-hidden=true>#</a></h5><p>RAFT 负责将请求同步到多个节点，并保证提交的数据不丢失以及不同节点的数据一致性，但是，对于应用数据结果是没有要求的，那么实际处理时会将报错信息返回给客户端，同时将 <code>AppliedIndex</code> 前移。</p><p>也可以对错误进行分类，如果是业务上的报错那么如上处理，如果是内部异常，例如 Bug、OOM 等，那么最好是直接崩溃退出。</p><a class=anchor id=为什么不持久化-applied-和-commit-的-index-信息></a><h5>为什么不持久化 Applied 和 Commit 的 Index 信息？ <a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e6%8c%81%e4%b9%85%e5%8c%96-applied-%e5%92%8c-commit-%e7%9a%84-index-%e4%bf%a1%e6%81%af aria-hidden=true>#</a></h5><p>其中前者保存在状态机中，由其决定已经应用了多少日志；而后者则在主节点的选举过程中获得。</p><a class=anchor id=todo></a><h2>TODO <a href=#todo aria-hidden=true>#</a></h2><ul><li>Zookeeper 支持 Hierarchical Quorum 选主优化。</li></ul><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><ul><li>核心内容包括了 <a href=https://raft.github.io/>官网地址</a>、<a href=https://raft.github.io/raft.pdf>Paper(Extended Version)</a>、<a href=https://web.stanford.edu/~ouster/cgi-bin/papers/OngaroPhD.pdf>Thesis</a> 。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#复制状态机>复制状态机</a></li><li><a href=#拜占庭问题>拜占庭问题</a></li></ul></li><li><a href=#raft-算法>RAFT 算法</a><ul><li><a href=#关于-term>关于 Term</a></li></ul></li><li><a href=#选主逻辑>选主逻辑</a></li><li><a href=#日志复制>日志复制</a><ul><li><a href=#安全性>安全性</a></li></ul></li><li><a href=#multi-raft>Multi RAFT</a></li><li><a href=#线性一致性>线性一致性</a><ul><li><a href=#readindex>ReadIndex</a></li><li><a href=#leaseread>LeaseRead</a></li></ul></li><li><a href=#性能优化>性能优化</a></li><li><a href=#其它>其它</a><ul><li><a href=#faq>FAQ</a></li><li><a href=#todo>TODO</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>