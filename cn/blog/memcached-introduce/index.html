<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>分布式缓存 memcached | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="通常 Web 应用的数据都会持久化到数据库中，随着应用数据量以及访问量的增加，就会导致数据库负担加重，从而导致网站的延迟。
Memcached 是一个高性能的分布式内存缓存服务器，用于缓存数据库的查询结果，从而减少数据库的访问次数，提高动态 Web 应用的速度、提高扩展性。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>分布式缓存 memcached</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-10-19</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/network/ role=button>network</a></div></div><hr><div class=content><p>通常 Web 应用的数据都会持久化到数据库中，随着应用数据量以及访问量的增加，就会导致数据库负担加重，从而导致网站的延迟。</p><p>Memcached 是一个高性能的分布式内存缓存服务器，用于缓存数据库的查询结果，从而减少数据库的访问次数，提高动态 Web 应用的速度、提高扩展性。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>分布式缓存在设计时需要考虑几点常见的原则：A) 缓存本身的水平线性扩展；B) 缓存大并发下本身的性能问题，包括内存的管理问题，如内存的分配、管理、回收机制；C) 避免缓存的单点故障问题，以及分布式系统常见的多副本和副本一致性问题。</p><p><img alt="memcached logo" src=images/memcached-logo.png class="mx-auto d-block"></p><p>memcached 采用基于文本的简单通讯协议，可以直接通过 telnet 进行操作；其事件处理是基于 libevent；虽然，我们说 memcached 是分布式缓存服务器，但实际上各个服务器之间并不通讯，其分布式主要是通过客户端实现。</p><a class=anchor id=安装使用></a><h1>安装、使用 <a href=#%e5%ae%89%e8%a3%85%e4%bd%bf%e7%94%a8 aria-hidden=true>#</a></h1><p>在 CentOS 上可以通过 yum 简单安装，或者直接通过源码安装。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># yum install memcached                                # 直接安装
</span></span><span class=line><span class=cl># systemctl start memcached                            # 启动
</span></span><span class=line><span class=cl># ./configure &amp;&amp; make &amp;&amp; make test &amp;&amp; make install     # 通过源码编译
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ memcached -p 11211 -m 64m -d                         # 后台启动
</span></span><span class=line><span class=cl>$ telnet 127.1 11211                                   # 通过telnet链接
</span></span><span class=line><span class=cl>add foobar 0 60 5                                      # 添加，由重复则失败
</span></span><span class=line><span class=cl>get foobar                                             # 获取foobar的值
</span></span><span class=line><span class=cl>set foobar 0 60 5                                      # 存在则更新，否则添加
</span></span><span class=line><span class=cl>delete foobar                                          # 删除
</span></span><span class=line><span class=cl>stats                                                  # 查看状态，也可以使用memcached-tool
</span></span></code></pre></div><p>对于 add 和 set 命令，其中 0 为标志，60 表示数据存放 60s，5 表示放入多大数据。</p><p>上述是简单的启动和使用方式，常见的启动选项可以参考如下，详细内容查看 man 1 memcached 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>memcached [options]
</span></span><span class=line><span class=cl>   -p [num]
</span></span><span class=line><span class=cl>       指定 TCP 的监听端口，默认使用 11211。
</span></span><span class=line><span class=cl>   -c [num]
</span></span><span class=line><span class=cl>       可以同时处理的最大链接数，默认是 1024 。
</span></span><span class=line><span class=cl>   -b [num]
</span></span><span class=line><span class=cl>       设置 backlog 队列的大小，默认是 1024 。
</span></span><span class=line><span class=cl>   -m [num]
</span></span><span class=line><span class=cl>       用户可以使用多少MB的内存，默认是 64M 。
</span></span><span class=line><span class=cl>   -d
</span></span><span class=line><span class=cl>       后台运行。
</span></span><span class=line><span class=cl>   -P [filename]
</span></span><span class=line><span class=cl>       后台启动时指定 pidfile 的路径。
</span></span></code></pre></div><a class=anchor id=链接线程处理></a><h1>链接、线程处理 <a href=#%e9%93%be%e6%8e%a5%e7%ba%bf%e7%a8%8b%e5%a4%84%e7%90%86 aria-hidden=true>#</a></h1><p>线程通过 LIBEVENT_THREAD *threads 表示，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>main()
</span></span><span class=line><span class=cl>  |-... ...                               # 设置进程打开文件个数限制等
</span></span><span class=line><span class=cl>  |-daemonize()                           # 如果需要后台运行
</span></span><span class=line><span class=cl>  | |-fork()
</span></span><span class=line><span class=cl>  |-mlockall()                            # 锁定内存，保证内存不会换出
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-event_init()                          # 1. 初始化主线程的event_base，也就是libevent实例
</span></span><span class=line><span class=cl>  |-stats_init()                          # 统计状态的初始化
</span></span><span class=line><span class=cl>  |-assoc_init()                          # hash表的初始化
</span></span><span class=line><span class=cl>  |-conn_init()                           # 连接初始化
</span></span><span class=line><span class=cl>  |-slabs_init()                          # slabs结构的初始化
</span></span><span class=line><span class=cl>  |-sigignore()                           # 忽略SIGPIPE信号
</span></span><span class=line><span class=cl>  |-memcached_thread_init()               # 2. 创建工作线程，默认是4个，可以通过pstree -p PID查看
</span></span><span class=line><span class=cl>  | |
</span></span><span class=line><span class=cl>  | |-pipe()                              # 3. 创建pipe用于主线程和工作线程通讯
</span></span><span class=line><span class=cl>  | |
</span></span><span class=line><span class=cl>  | |-setup_thread()                      # 创建每个线程自己的libevent的event_base
</span></span><span class=line><span class=cl>  | | |-event_init()                      # 每个独立的线程都包含独立的event_base
</span></span><span class=line><span class=cl>  | | |-event_set()                       # 创建pipe的读事件监听，回调thread_libevent_process方法
</span></span><span class=line><span class=cl>  | | |-event_base_set()
</span></span><span class=line><span class=cl>  | | |-event_add()                       # 添加事件操作
</span></span><span class=line><span class=cl>  | | |-cq_init()                         # 4. 初始化每个工作线程的队列
</span></span><span class=line><span class=cl>  | | |-pthread_mutex_init()              # 初始化线程池
</span></span><span class=line><span class=cl>  | | |-cache_create()
</span></span><span class=line><span class=cl>  | |
</span></span><span class=line><span class=cl>  | |-create_worker()                     # 循环创建线程，真正的创建工作线程，实际是worker_libevent()
</span></span><span class=line><span class=cl>  |   |-pthread_attr_init()               # 属性初始化
</span></span><span class=line><span class=cl>  |   |-pthread_create()                  # 5. 创建线程worker_libevent()，直接启动
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-start_assoc_maintenance_thread()      # 启动
</span></span><span class=line><span class=cl>  |-start_item_crawler_thread()
</span></span><span class=line><span class=cl>  |-start_lru_maintainer_thread()
</span></span><span class=line><span class=cl>  |-start_slab_maintenance_thread()
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-clock_handler()                       # 初始化时间设置
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-server_sockets()                      # 6. 创建socket，绑定地址，设置非阻塞模式，包括TCP/UDP
</span></span><span class=line><span class=cl>  | |-server_socket()                     # 实际的绑定函数
</span></span><span class=line><span class=cl>  |   |-conn_new()                        # 7. 将监听socket添加到main_base的libevent的事件队列中
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-save_pid()                            # 保存PID到一个文件中
</span></span><span class=line><span class=cl>  |-event_base_loop()                     # 8. 启动主线程的libevetn循环
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>worker_libevent()                         # 新建的子线程，会初始化子线程的libevent
</span></span><span class=line><span class=cl>  |-register_thread_initialized()
</span></span><span class=line><span class=cl>  |-event_base_loop()                     # 开启事件循环，每个线程有自己的事件处理机制，启动libevent
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>event_handler()                           # Master/Worker线程libevent回调函数，此时有网络事件到达
</span></span><span class=line><span class=cl>  |-drive_machine()                       # 进入业务处理状态机
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>thread_libevent_process()                 # pipe接收回调函数
</span></span><span class=line><span class=cl>  |-read()                                # 读取pipe中的信息
</span></span></code></pre></div><p>主线程中如果有新的连接，会向其中一个线程的 pipe 中写入 1，子线程读取 pipe 中的数据，如果为 1，则说明从 pipe 中获取的数据是正确的。</p><p>在初始化完成之后，会忽略 SIGPIPE 信号，其中 PIPE 信号是当网络连接一端已经断开，这时发送数据，会发送 RST 包，当再次发送数据，会触发 PIPE 信号，而 PIPE 信号的默认动作是退出进程，因此忽略。</p><a class=anchor id=数据结构></a><h1>数据结构 <a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-hidden=true>#</a></h1><p>CQ_ITEM 是主线程 accept() 后返回的已建立连接的 fd 的封装，而 CQ 是一个管理 CQ_ITEM 的单向链表。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* An item in the connection queue. */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>conn_queue_item</span> <span class=n>CQ_ITEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>conn_queue_item</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>               <span class=n>sfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=n>conn_states</span>  <span class=n>init_state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>               <span class=n>event_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>               <span class=n>read_buffer_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=n>network_transport</span>     <span class=n>transport</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CQ_ITEM</span>          <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* A connection queue. */</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>conn_queue</span> <span class=n>CQ</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>conn_queue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CQ_ITEM</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CQ_ITEM</span> <span class=o>*</span><span class=n>tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_mutex_t</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pthread_t</span> <span class=n>thread_id</span><span class=p>;</span>               <span class=cm>/* unique ID of this thread */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>event_base</span> <span class=o>*</span><span class=n>base</span><span class=p>;</span>           <span class=cm>/* libevent handle this thread uses */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>event</span> <span class=n>notify_event</span><span class=p>;</span>         <span class=cm>/* listen event for notify pipe */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>notify_receive_fd</span><span class=p>;</span>             <span class=cm>/* receiving end of notify pipe */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>notify_send_fd</span><span class=p>;</span>                <span class=cm>/* sending end of notify pipe */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>thread_stats</span> <span class=n>stats</span><span class=p>;</span>         <span class=cm>/* Stats generated by this thread */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>conn_queue</span> <span class=o>*</span><span class=n>new_conn_queue</span><span class=p>;</span> <span class=cm>/* queue of new connections to handle */</span>
</span></span><span class=line><span class=cl>    <span class=kt>cache_t</span> <span class=o>*</span><span class=n>suffix_cache</span><span class=p>;</span>             <span class=cm>/* suffix cache */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>LIBEVENT_THREAD</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>conn</span> <span class=n>conn</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>conn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>    <span class=n>sfd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>sasl_conn_t</span> <span class=o>*</span><span class=n>sasl_conn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>authenticated</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=n>conn_states</span>  <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=n>bin_substates</span> <span class=n>substate</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>rel_time_t</span> <span class=n>last_cmd_time</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>event</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span>  <span class=n>ev_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>LIBEVENT_THREAD 是 memcached 里的线程结构封装，如上所示，每个线程都包含一个 CQ 队列，一条通知管道 pipe，一个 libevent 的实例 event_base 以及线程的状态。</p><p>另外一个重要的结构是对每个网络连接的封装 conn，这个结构体的成员变量比较多，暂时只列举了部分。</p><a class=anchor id=线程交互></a><h1>线程交互 <a href=#%e7%ba%bf%e7%a8%8b%e4%ba%a4%e4%ba%92 aria-hidden=true>#</a></h1><p>memcached 采用典型的 Master-Worker 线程模型，其模型很简单，Master 监听网络链接，接受链接请求之后通过线程间通讯来唤醒 Worker 线程，后续的读写操作都是通过 Worker 完成。</p><p>主线程和各个线程的处理都是通过 libevent 处理，通过实例化多个 libevent 实例实现，分别对应了一个主线程和 N 个 workers 线程。Master 线程和 Workers 线程全部都是通过 libevent 管理网络事件，也就是说实际上每个线程都是一个单独的 libevent 实例。</p><p>主线程的 libevent 实例在主线程初始化时设置，工作线程则在 setup_thread() 中建立 libevent 实例。</p><p>Master 线程负责监听客户端的建立连接请求，并 accept 连接，Workers 线程负责处理已经建立好的连接的读写等事件。</p><p><img alt="memcached threads" src=images/memcached-threads.png class="mx-auto d-block"></p><a class=anchor id=master-thread></a><h2>Master Thread <a href=#master-thread aria-hidden=true>#</a></h2><p>首先看看主线程是如何通知 workers 线程处理新连接的，在初始化时会添加监听事件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static struct event_base *main_base;           // 主libevent
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>static int server_socket(...) {
</span></span><span class=line><span class=cl>    ... ...
</span></span><span class=line><span class=cl>    for (next= ai; next; next= next-&gt;ai_next) {
</span></span><span class=line><span class=cl>        ... ...
</span></span><span class=line><span class=cl>        if (!(listen_conn_add = conn_new(sfd, conn_listening,
</span></span><span class=line><span class=cl>                                         EV_READ | EV_PERSIST, 1,
</span></span><span class=line><span class=cl>                                         transport, main_base))) {
</span></span><span class=line><span class=cl>            fprintf(stderr, &#34;failed to create listening connection\n&#34;);
</span></span><span class=line><span class=cl>            exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        ... ...
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>主线程的 libevent 注册的是监听 socket 描述字的可读事件，就是说当有建立连接请求时，主线程会处理，新建监听端口是通过 conn_new() 初始化，其回调的函数是 event_handler() 。</p><p>对于主线程来说，会进入到 conn_listening 分支，也就是调用 dispatch_conn_new() 函数；在该函数中，会创建一个新的 CQ_ITEM，然后通过 round robin 策略选择了一个 thread，并通过 cq_push 将这个 CQ_ITEM 放入了该线程的 CQ 队列里。</p><p>最后通过 write() 向该线程管道写了 1 字节数据，则该线程的 libevent 立即回调 thread_libevent_process() 函数进行处理。</p><a class=anchor id=worker-thread></a><h2>Worker Thread <a href=#worker-thread aria-hidden=true>#</a></h2><p>当 memcached 刚启动时，也就是当刚初始化完成之后，每个 workers 线程只有在自己线程管道的读端有数据时触发调用 thread_libevent_process() 方法，而主线程在有链接时会写入数据，该函数处理的就是主线程新建链接的请求。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static void thread_libevent_process(int fd, short which, void *arg) {
</span></span><span class=line><span class=cl>    ... ...
</span></span><span class=line><span class=cl>    if (read(fd, buf, 1) != 1)
</span></span><span class=line><span class=cl>        if (settings.verbose &gt; 0)
</span></span><span class=line><span class=cl>            fprintf(stderr, &#34;Can&#39;t read from libevent pipe\n&#34;);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    switch (buf[0]) {
</span></span><span class=line><span class=cl>    case &#39;c&#39;:
</span></span><span class=line><span class=cl>    item = cq_pop(me-&gt;new_conn_queue);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if (NULL != item) {
</span></span><span class=line><span class=cl>        conn *c = conn_new(item-&gt;sfd, item-&gt;init_state, item-&gt;event_flags,
</span></span><span class=line><span class=cl>                           item-&gt;read_buffer_size, item-&gt;transport, me-&gt;base);
</span></span><span class=line><span class=cl>        ... ...
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    /* we were told to pause and report in */
</span></span><span class=line><span class=cl>    case &#39;p&#39;:
</span></span><span class=line><span class=cl>    register_thread_initialized();
</span></span><span class=line><span class=cl>    break;
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>入参的 fd 是这个线程的管道读端的描述符，在上述的函数中，首先将管道的 1 个字节通知信号读出。需要注意的是，在水平触发模式下如果不处理该事件，则会被循环通知，直到该事件被处理。</p><p>cq_pop() 会从该线程的 CQ 队列中取队列头的一个 CQ_ITEM，这个 CQ_ITEM 是被主线程丢到这个队列里的，item->sfd 是已建立的连接的描述符，然后会调用 conn_new() 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>conn</span> <span class=o>*</span><span class=nf>conn_new</span><span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>event_set</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>event</span><span class=p>,</span> <span class=n>sfd</span><span class=p>,</span> <span class=n>event_flags</span><span class=p>,</span> <span class=n>event_handler</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>event_base_set</span><span class=p>(</span><span class=n>base</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=o>-&gt;</span><span class=n>ev_flags</span> <span class=o>=</span> <span class=n>event_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>event_add</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>event</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;event_add&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 conn_new() 中，为 sfd 描述符注册 libevent 的读事件，接着会调用 event_add() 函数，也就是对该描述符的事件处理交给当前这个 workers 线程处理。</p><p>可以看到新的连接被注册了一个事件，实际上是 EV_READ|EV_PERSIST 事件，当该连接有可读数据时会调用函数 event_handler()，实际上 event_handler() 里主要是调用 memcached 的核心方法 drive_machine() 。</p><p>而 Worker 线程最终会走到 conn_read 分支，可以参考如下从网上找的工作流程。</p><p><img alt="memcached master workers" src=images/memcached-master-workers.jpg class="mx-auto d-block"></p><p>也就是说，实际上，Master/Worker 线程的 libevent 实例都会调用 event_handler() 函数，而在该函数中的核心处理为其状态机的处理。</p><a class=anchor id=状态机></a><h1>状态机 <a href=#%e7%8a%b6%e6%80%81%e6%9c%ba aria-hidden=true>#</a></h1><p>Worker 线程在处理 libevent 的事件时，会进入状态机处理不同的逻辑，详细的调用逻辑如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>event_handler()                           # libevent回调函数，此时有网络事件到达
</span></span><span class=line><span class=cl>  |-drive_machine()                       # 进入业务处理状态机
</span></span></code></pre></div><p>drive_machine() 就是通过当前连接的 state 来判断该进行何种处理，Master 和 Workers 的 libevent 事件处理都会调用该函数，其链接的状态是通过一个 enum 声明。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>enum</span> <span class=n>conn_states</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>conn_listening</span><span class=p>,</span>  <span class=c1>// 主线程listen的主要状态，其工作就是把接到连接分发到worker子线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_new_cmd</span><span class=p>,</span>    <span class=c1>// 将链接设置为初始态，准备接收下个命令，会清空读写buffer
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_waiting</span><span class=p>,</span>    <span class=c1>// 等待读取socket，实际上就是挂起该链接，等待新的链接到来
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_read</span><span class=p>,</span>       <span class=c1>// 从客户端读取信息，也就是命令信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_parse_cmd</span><span class=p>,</span>  <span class=c1>// 尝试从读取的buffer中解析命令
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_write</span><span class=p>,</span>      <span class=c1>// 主要是out_string()函数，一般都是提示信息和返回的状态信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_nread</span><span class=p>,</span>      <span class=c1>// 读取固定大小的数据，会更新到item、hash、lru中，并调转到conn_write
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_swallow</span><span class=p>,</span>    <span class=c1>// 忽略不需要的数据
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_closing</span><span class=p>,</span>    <span class=c1>// 服务端主动调用close()关闭链接，并把conn结构体放到空闲队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_mwrite</span><span class=p>,</span>     <span class=c1>// 将这个链接中的msglist返回给客户端，可能会返回多个
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_closed</span><span class=p>,</span>     <span class=c1>// 链接已经被关闭
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>conn_max_state</span>   <span class=c1>// 由于assert判断
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>首先着重说一下 conn_swallow 状态，对于像 update 操作，如果分配 item 失败，显然后面读取的数据是无效的，不过客户端是不知道的，客户端会继续发送特定的数量的数据，就需要把读到的这些数据忽略掉。</p><p><img alt="memcached sates" src=images/memcached-states.jpg class="mx-auto d-block"></p><p>接下来详细查看 drive_machine() 函数的处理流程，首先查看下主线程 conn_listening 状态的处理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>drive_machine</span><span class=p>(</span><span class=n>conn</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stop</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>conn_listening</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>addrlen</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>sfd</span> <span class=o>=</span> <span class=nf>accept</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>sfd</span><span class=p>,</span> <span class=p>(</span><span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>addr</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>addrlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>sfd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=p>...</span> <span class=p>...</span>         <span class=c1>// 多种的错误处理
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>use_accept4</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 设置为非阻塞
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=nf>fcntl</span><span class=p>(</span><span class=n>sfd</span><span class=p>,</span> <span class=n>F_SETFL</span><span class=p>,</span> <span class=nf>fcntl</span><span class=p>(</span><span class=n>sfd</span><span class=p>,</span> <span class=n>F_GETFL</span><span class=p>)</span> <span class=o>|</span> <span class=n>O_NONBLOCK</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;setting O_NONBLOCK&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=nf>close</span><span class=p>(</span><span class=n>sfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>settings</span><span class=p>.</span><span class=n>maxconns_fast</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                <span class=n>stats</span><span class=p>.</span><span class=n>curr_conns</span> <span class=o>+</span> <span class=n>stats</span><span class=p>.</span><span class=n>reserved_fds</span> <span class=o>&gt;=</span> <span class=n>settings</span><span class=p>.</span><span class=n>maxconns</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=p>...</span> <span class=p>..</span> <span class=c1>// 超过了设置的最大链接数
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>   <span class=c1>// OK，分发给Worker线程，初始化状态为conn_new_cmd
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>dispatch_conn_new</span><span class=p>(</span><span class=n>sfd</span><span class=p>,</span> <span class=n>conn_new_cmd</span><span class=p>,</span> <span class=n>EV_READ</span> <span class=o>|</span> <span class=n>EV_PERSIST</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                     <span class=n>DATA_BUFFER_SIZE</span><span class=p>,</span> <span class=n>tcp_transport</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>stop</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=conn_new_cmd></a><h2>conn_new_cmd <a href=#conn_new_cmd aria-hidden=true>#</a></h2><p>子线程最初进入的状态就是 conn_new_cmd 状态，这个状态主要是做一些清理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>drive_machine</span><span class=p>(</span><span class=n>conn</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stop</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>conn_new_cmd</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=o>--</span><span class=n>nreqs</span><span class=p>;</span>     <span class=c1>// 记录每个工作线程处理，记录每个libevent实例处理的事件，通过初始启动参数配置
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>nreqs</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>                      <span class=c1>// 还可以处理请求
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>reset_cmd_handler</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>              <span class=c1>// 清空缓冲区
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>     <span class=c1>// 拒绝请求
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=o>-&gt;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=o>-&gt;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>conn_yields</span><span class=o>++</span><span class=p>;</span>    <span class=c1>// 更新统计数据
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>c</span><span class=o>-&gt;</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>stats</span><span class=p>.</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>rbytes</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=c1>// 已经将数据读取到了buffer中，因此需要发送一个event
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>update_event</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>EV_WRITE</span> <span class=o>|</span> <span class=n>EV_PERSIST</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span> <span class=p>(</span><span class=n>settings</span><span class=p>.</span><span class=n>verbose</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                            <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Couldn&#39;t update event</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_closing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>stop</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>reset_cmd_handler</span><span class=p>(</span><span class=n>conn</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=o>-&gt;</span><span class=n>cmd</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=o>-&gt;</span><span class=n>substate</span> <span class=o>=</span> <span class=n>bin_no_state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>item</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>item_remove</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>item</span><span class=p>);</span>  <span class=c1>// 如果有item，则直接删除
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>c</span><span class=o>-&gt;</span><span class=n>item</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>conn_shrink</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>            <span class=c1>// 整理缓冲区，暂不分析
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>rbytes</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>       <span class=c1>// 如果缓冲区还有数据，则直接到conn_parse_cmd中继续处理
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_parse_cmd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>   <span class=c1>// 否则进入等待状态，状态机没有数据要处理，就进入这个状态
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_waiting</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>根据是否有数据，分别会进入不同的状态，如果没有数据则会进入 conn_waiting 等待接收数据。</p><a class=anchor id=conn_waitingconn_read></a><h2>conn_waiting、conn_read <a href=#conn_waitingconn_read aria-hidden=true>#</a></h2><p>接下来主要是处理数据报文的接收，包括了 conn_waiting、conn_read 两个状态。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>drive_machine</span><span class=p>(</span><span class=n>conn</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stop</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>conn_waiting</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 更新libevent状态，也就是删除libevent事件后，重新注册libevent事件
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>update_event</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>EV_READ</span> <span class=o>|</span> <span class=n>EV_PERSIST</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>settings</span><span class=p>.</span><span class=n>verbose</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Couldn&#39;t update event</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_closing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_read</span><span class=p>);</span> <span class=c1>// 进入读数据状态
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>stop</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>conn_read</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 判断采用UDP协议还是TCP协议
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>res</span> <span class=o>=</span> <span class=nf>IS_UDP</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>transport</span><span class=p>)</span> <span class=o>?</span> <span class=nf>try_read_udp</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>:</span> <span class=nf>try_read_network</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>switch</span> <span class=p>(</span><span class=n>res</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>READ_NO_DATA_RECEIVED</span><span class=p>:</span> <span class=c1>// 未读取到数据
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_waiting</span><span class=p>);</span>    <span class=c1>// 则继续等待
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>READ_DATA_RECEIVED</span><span class=p>:</span>    <span class=c1>// 已经读取到数据
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_parse_cmd</span><span class=p>);</span>  <span class=c1>// 开始解析命令
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>READ_ERROR</span><span class=p>:</span>            <span class=c1>// 读取发生错误
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_closing</span><span class=p>);</span>    <span class=c1>// 直接关闭链接
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=nl>READ_MEMORY_ERROR</span><span class=p>:</span>     <span class=c1>// 申请内存发生错误，则继续尝试
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如果采用 TCP 协议则会调用 try_read_network() 从网络读取数据；对于 UDP 则比较简单，因为是数据报，读取到一个，就是一个完整的数据报，所以其处理过程简单。</p><a class=anchor id=conn_parse_cmd></a><h2>conn_parse_cmd <a href=#conn_parse_cmd aria-hidden=true>#</a></h2><p>从网络读取了数据之后，则会进入该状态，按协议来解析读取到的网络数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>drive_machine</span><span class=p>(</span><span class=n>conn</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>stop</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>switch</span><span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>conn_parse_cmd</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>try_read_command</span><span class=p>(</span><span class=n>c</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>     <span class=c1>// 尝试解析命令
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// 如果读取到的数据不够，则继续等待
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=nf>conn_set_state</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>conn_waiting</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>try_read_command</span><span class=p>(</span><span class=n>conn</span> <span class=o>*</span><span class=n>c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>c</span><span class=o>-&gt;</span><span class=n>protocol</span> <span class=o>==</span> <span class=n>binary_prot</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=nf>dispatch_bin_command</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=nf>process_command</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>c</span><span class=o>-&gt;</span><span class=n>rcurr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>命令解析包括了文本协议和二进制协议，其命令的处理分别调用不同的命令处理函数。</p><a class=anchor id=内存管理></a><h1>内存管理 <a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 aria-hidden=true>#</a></h1><p>对于 memcached 内存高效管理是其最重要的任务之一，为了减小内存碎片的产生，采用 slab 管理其内存。简单来说，就是分配一块大内存，然后按照不同的块切分这些内存，存储业务数据时，按需选择合适的内存空间存储数据。</p><p>默认分配 64M 内存，之后所有的数据都是在这 64M 空间进行存储，在启动之后，不会释放这些内存，直到进程退出。</p><p><img alt="memcached memory structure" src=images/memcached-02-01.png class="mx-auto d-block"></p><p>在 memcached 中，与内存相关的配置参数包括了设置内存大小、内存的增长因子，会在 slabs_init() 初始化的时候作为入参传入函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>slabclass_t</span> <span class=n>slabclass</span><span class=p>[</span><span class=n>MAX_NUMBER_OF_SLAB_CLASSES</span><span class=p>];</span>   <span class=c1>// 定义slab class最大值，64个
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>size_t</span> <span class=n>mem_limit</span>     <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>      <span class=c1>// 总的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>size_t</span> <span class=n>mem_malloced</span>  <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>      <span class=c1>// 初始化内存的大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span>  <span class=o>*</span><span class=n>mem_base</span>      <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>   <span class=c1>// 指向总的内存的首地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>void</span>  <span class=o>*</span><span class=n>mem_current</span>   <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>   <span class=c1>// 当前分配到的内存地址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>size_t</span> <span class=n>mem_avail</span>     <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>      <span class=c1>// 当前可用的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>slabs_init</span><span class=p>(</span><span class=k>const</span> <span class=kt>size_t</span> <span class=n>limit</span><span class=p>,</span> <span class=k>const</span> <span class=kt>double</span> <span class=n>factor</span><span class=p>,</span> <span class=k>const</span> <span class=kt>bool</span> <span class=n>prealloc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>POWER_SMALLEST</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//size表示申请空间的大小，其值由配置的chunk_size和单个item的大小来指定
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>item</span><span class=p>)</span> <span class=o>+</span> <span class=n>settings</span><span class=p>.</span><span class=n>chunk_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mem_limit</span> <span class=o>=</span> <span class=n>limit</span><span class=p>;</span>   <span class=c1>// 设置入参设置的内存上限
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>prealloc</span><span class=p>)</span> <span class=p>{</span>      <span class=c1>// 是否要预先分配设置的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>mem_base</span> <span class=o>=</span> <span class=nf>malloc</span><span class=p>(</span><span class=n>mem_limit</span><span class=p>);</span>  <span class=c1>// 通过malloc()申请内存，并将内存基址指向mem_base
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>mem_base</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>mem_current</span> <span class=o>=</span> <span class=n>mem_base</span><span class=p>;</span>    <span class=c1>// mem_current指向当前地址
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>mem_avail</span> <span class=o>=</span> <span class=n>mem_limit</span><span class=p>;</span>     <span class=c1>// 可用内存大小为mem_limit
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>         <span class=c1>// 预分配失败
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;Warning: Failed to allocate requested memory in&#34;</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34; one large chunk.</span><span class=se>\n</span><span class=s>Will allocate in smaller chunks</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>slabclass</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>slabclass</span><span class=p>));</span> <span class=c1>// 置空slab class数组
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 开始分配，i&lt;200 &amp;&amp; 单个chunk的size&lt;单个item最大大小/内存增长因子
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=o>++</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>POWER_LARGEST</span> <span class=o>&amp;&amp;</span> <span class=n>size</span> <span class=o>&lt;=</span> <span class=n>settings</span><span class=p>.</span><span class=n>item_size_max</span> <span class=o>/</span> <span class=n>factor</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>%</span> <span class=n>CHUNK_ALIGN_BYTES</span><span class=p>)</span>   <span class=c1>// 将size按照8byte对齐
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>size</span> <span class=o>+=</span> <span class=n>CHUNK_ALIGN_BYTES</span> <span class=o>-</span> <span class=p>(</span><span class=n>size</span> <span class=o>%</span> <span class=n>CHUNK_ALIGN_BYTES</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>slabclass</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span> <span class=o>=</span> <span class=n>size</span><span class=p>;</span>       <span class=c1>// slab对应chunk的大小
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>slabclass</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>perslab</span> <span class=o>=</span> <span class=n>settings</span><span class=p>.</span><span class=n>item_size_max</span> <span class=o>/</span> <span class=n>slabclass</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span><span class=p>;</span> <span class=c1>// slab对应的chunk的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>size</span> <span class=o>*=</span> <span class=n>factor</span><span class=p>;</span>                 <span class=c1>// size下一个值为按增长因子的倍数增长
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>settings</span><span class=p>.</span><span class=n>verbose</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>     <span class=c1>// 如果有打开调试信息，则输出调试信息
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;slab class %3d: chunk size %9u perslab %7u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>i</span><span class=p>,</span> <span class=n>slabclass</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span><span class=p>,</span> <span class=n>slabclass</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>perslab</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>power_largest</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>   <span class=c1>// size已经增长到1M，再增加一个slab
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>slabclass</span><span class=p>[</span><span class=n>power_largest</span><span class=p>].</span><span class=n>size</span> <span class=o>=</span> <span class=n>settings</span><span class=p>.</span><span class=n>item_size_max</span><span class=p>;</span>  <span class=c1>// slab的size为item_size_max
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>slabclass</span><span class=p>[</span><span class=n>power_largest</span><span class=p>].</span><span class=n>perslab</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>                    <span class=c1>// chunk个数为1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>settings</span><span class=p>.</span><span class=n>verbose</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span><span class=p>,</span> <span class=s>&#34;slab class %3d: chunk size %9u perslab %7u</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span><span class=p>,</span> <span class=n>slabclass</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>size</span><span class=p>,</span> <span class=n>slabclass</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>perslab</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>prealloc</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 在每个slab class中都先预分配一个1M的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>slabs_preallocate</span><span class=p>(</span><span class=n>power_largest</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=hash表></a><h1>Hash表 <a href=#hash%e8%a1%a8 aria-hidden=true>#</a></h1><p>在 memcached 中，其采用链接法来处理 Hash 冲突，如果冲突太高，则会导致链表过长，从而会导致查找时的耗时变长。</p><p>为次当表中元素的个数超过 Hash 容量的 1.5 倍时就进行扩容，扩容过程由独立的线程来完成，扩容过程中会采用 2 个 Hash 表，将老表中的数据通过 Hash 算法映射到新表中，每次移动的桶的数目可以配置，默认是每次移动老表中的 1 个桶。</p><p>在启动时，会通过 start_assoc_maintenance_thread() 函数启动一个线程，正常如果不需要扩容，则实际会调用 pthread 的 cond_wait() 函数一直等待。</p><p>首先看下如何在 hash 表中添加元素。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 在hash表中增加元素，不同于assoc_update，需要先确保没有相应的数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>assoc_insert</span><span class=p>(</span><span class=n>item</span> <span class=o>*</span><span class=n>it</span><span class=p>,</span> <span class=k>const</span> <span class=kt>uint32_t</span> <span class=n>hv</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>oldbucket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果正在扩容且目前进行扩容还没到需要插入元素的桶，则将元素添加到旧桶中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>expanding</span> <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>oldbucket</span> <span class=o>=</span> <span class=p>(</span><span class=n>hv</span> <span class=o>&amp;</span> <span class=nf>hashmask</span><span class=p>(</span><span class=n>hashpower</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)))</span> <span class=o>&gt;=</span> <span class=n>expand_bucket</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>it</span><span class=o>-&gt;</span><span class=n>h_next</span> <span class=o>=</span> <span class=n>old_hashtable</span><span class=p>[</span><span class=n>oldbucket</span><span class=p>];</span>  <span class=c1>// 添加元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>old_hashtable</span><span class=p>[</span><span class=n>oldbucket</span><span class=p>]</span> <span class=o>=</span> <span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>  <span class=c1>// 如果没扩容，或者扩容已经到了新的桶中，则添加元素到新表中
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>it</span><span class=o>-&gt;</span><span class=n>h_next</span> <span class=o>=</span> <span class=n>primary_hashtable</span><span class=p>[</span><span class=n>hv</span> <span class=o>&amp;</span> <span class=nf>hashmask</span><span class=p>(</span><span class=n>hashpower</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>        <span class=n>primary_hashtable</span><span class=p>[</span><span class=n>hv</span> <span class=o>&amp;</span> <span class=nf>hashmask</span><span class=p>(</span><span class=n>hashpower</span><span class=p>)]</span> <span class=o>=</span> <span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hash_items_counter_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>hash_items</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 还没开始扩容，但是表中元素个数已经超过Hash表容量的1.5倍，触发开始扩容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span> <span class=n>expanding</span> <span class=o>&amp;&amp;</span> <span class=n>hash_items</span> <span class=o>&gt;</span> <span class=p>(</span><span class=nf>hashsize</span><span class=p>(</span><span class=n>hashpower</span><span class=p>)</span> <span class=o>*</span> <span class=mi>3</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>assoc_start_expand</span><span class=p>();</span>  <span class=c1>// 唤醒扩容线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hash_items_counter_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>MEMCACHED_ASSOC_INSERT</span><span class=p>(</span><span class=nf>ITEM_key</span><span class=p>(</span><span class=n>it</span><span class=p>),</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>nkey</span><span class=p>,</span> <span class=n>hash_items</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>assoc_start_expand</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>   <span class=c1>// 唤醒对应的扩容线程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>started_expanding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>started_expanding</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>maintenance_cond</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=cas></a><h1>CAS <a href=#cas aria-hidden=true>#</a></h1><p>CAS 也即 Compare And Set 或 Compare And Swap，实现的是一中无锁方法，或者说是乐观锁的一种技术，过程中会使用 CPU 提供的原子操作指令，可以提高系统的并发性能，在 Memcached 中用来保证数据的一致性，不是为了实现严格的锁。</p><p>当多个应用尝试修改同一个数据时，会出现相互覆盖的情况，此时使用 CAS 版本号验证，可以有效的保证数据的一致性。每次存储数据时，都会将生成的 CAS 值和 item 一起存储，后续的 get 会返回对应的 CAS 值，执行 set 等操作时，需要将 CAS 值传入。</p><p>其处理函数为 do_store_item() 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
</span></span><span class=line><span class=cl>    ... ...
</span></span><span class=line><span class=cl>    } else if (comm == NREAD_CAS) {
</span></span><span class=line><span class=cl>        /* validate cas operation */
</span></span><span class=line><span class=cl>        if(old_it == NULL) {
</span></span><span class=line><span class=cl>            // LRU expired
</span></span><span class=line><span class=cl>            stored = NOT_FOUND;
</span></span><span class=line><span class=cl>            pthread_mutex_lock(&amp;c-&gt;thread-&gt;stats.mutex);
</span></span><span class=line><span class=cl>            c-&gt;thread-&gt;stats.cas_misses++;
</span></span><span class=line><span class=cl>            pthread_mutex_unlock(&amp;c-&gt;thread-&gt;stats.mutex);
</span></span><span class=line><span class=cl>        } else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {  // CAS值一致
</span></span><span class=line><span class=cl>            // cas validates
</span></span><span class=line><span class=cl>            // it and old_it may belong to different classes.
</span></span><span class=line><span class=cl>            // I&#39;m updating the stats for the one that&#39;s getting pushed out
</span></span><span class=line><span class=cl>            pthread_mutex_lock(&amp;c-&gt;thread-&gt;stats.mutex);
</span></span><span class=line><span class=cl>            c-&gt;thread-&gt;stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
</span></span><span class=line><span class=cl>            pthread_mutex_unlock(&amp;c-&gt;thread-&gt;stats.mutex);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            item_replace(old_it, it, hv);   // 执行存储逻辑
</span></span><span class=line><span class=cl>            stored = STORED;
</span></span><span class=line><span class=cl>        } else {   // CAS值不一致，不进行实际的存储
</span></span><span class=line><span class=cl>            pthread_mutex_lock(&amp;c-&gt;thread-&gt;stats.mutex);
</span></span><span class=line><span class=cl>            c-&gt;thread-&gt;stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
</span></span><span class=line><span class=cl>            pthread_mutex_unlock(&amp;c-&gt;thread-&gt;stats.mutex);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            if(settings.verbose &gt; 1) { // 打印错误日志
</span></span><span class=line><span class=cl>                fprintf(stderr, &#34;CAS:  failure: expected %llu, got %llu\n&#34;,
</span></span><span class=line><span class=cl>                        (unsigned long long)ITEM_get_cas(old_it),
</span></span><span class=line><span class=cl>                        (unsigned long long)ITEM_get_cas(it));
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            stored = EXISTS;
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>uint64_t get_cas_id(void) // 为新的item生成cas值
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    static uint64_t cas_id = 0;
</span></span><span class=line><span class=cl>    return ++cas_id;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>详细内容以及最新的版本可以查看官方网站 <a href=https://memcached.org/>www.memcached.org</a> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#安装使用>安装、使用</a></li><li><a href=#链接线程处理>链接、线程处理</a></li><li><a href=#数据结构>数据结构</a></li><li><a href=#线程交互>线程交互</a><ul><li><a href=#master-thread>Master Thread</a></li><li><a href=#worker-thread>Worker Thread</a></li></ul></li><li><a href=#状态机>状态机</a><ul><li><a href=#conn_new_cmd>conn_new_cmd</a></li><li><a href=#conn_waitingconn_read>conn_waiting、conn_read</a></li><li><a href=#conn_parse_cmd>conn_parse_cmd</a></li></ul></li><li><a href=#内存管理>内存管理</a></li><li><a href=#hash表>Hash表</a></li><li><a href=#cas>CAS</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>