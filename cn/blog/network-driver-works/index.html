<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux 网卡驱动的工作原理 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="如题所示，介绍网卡是如何接收数据，然后又是如何交给上层处理。因为鄙人的网卡驱动用的是 e1000e，所以就以此为例了。
Just enjoy it.
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux 网卡驱动的工作原理</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-04-03</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/network/ role=button>network</a></div></div><hr><div class=content><p>如题所示，介绍网卡是如何接收数据，然后又是如何交给上层处理。因为鄙人的网卡驱动用的是 e1000e，所以就以此为例了。</p><p>Just enjoy it.</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>网络设备有很多，但它们的工作原理基本相同，可以分为两个层次，分别为 MAC (Media Access Control) 对应于 OSI 的数据链路层，PHY (Physical Layer) 对应于物理层。</p><p>同时为了减小 CPU 的压力，底层很多采用 DMA 方式。</p><a class=anchor id=查看驱动></a><h1>查看驱动 <a href=#%e6%9f%a5%e7%9c%8b%e9%a9%b1%e5%8a%a8 aria-hidden=true>#</a></h1><p>对于网卡驱动，通常是以内核模块的方式提供，本机网卡对应的内核驱动可以通过如下方式查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 可以查看Ethernet、Wireless字样，以及Kernel driver in use:（也就是所使用的驱动)
</span></span><span class=line><span class=cl># lspci -vvv | less
</span></span><span class=line><span class=cl>... ...
</span></span><span class=line><span class=cl>00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I218-LM (rev 04)
</span></span><span class=line><span class=cl>        Subsystem: Dell Device 05cb
</span></span><span class=line><span class=cl>        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+
</span></span><span class=line><span class=cl>        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-
</span></span><span class=line><span class=cl>        Latency: 0
</span></span><span class=line><span class=cl>        Interrupt: pin A routed to IRQ 46
</span></span><span class=line><span class=cl>        Region 0: Memory at f7e00000 (32-bit, non-prefetchable) [size=128K]
</span></span><span class=line><span class=cl>        Region 1: Memory at f7e3c000 (32-bit, non-prefetchable) [size=4K]
</span></span><span class=line><span class=cl>        Region 2: I/O ports at f080 [size=32]
</span></span><span class=line><span class=cl>        Capabilities: [c8] Power Management version 2
</span></span><span class=line><span class=cl>                Flags: PMEClk- DSI+ D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+)
</span></span><span class=line><span class=cl>                Status: D0 NoSoftRst- PME-Enable- DSel=0 DScale=1 PME-
</span></span><span class=line><span class=cl>        Capabilities: [d0] MSI: Enable+ Count=1/1 Maskable- 64bit+
</span></span><span class=line><span class=cl>                Address: 00000000fee0f00c  Data: 41a4
</span></span><span class=line><span class=cl>        Capabilities: [e0] PCI Advanced Features
</span></span><span class=line><span class=cl>                AFCap: TP+ FLR+
</span></span><span class=line><span class=cl>                AFCtrl: FLR-
</span></span><span class=line><span class=cl>                AFStatus: TP-
</span></span><span class=line><span class=cl>        Kernel driver in use: e1000e
</span></span><span class=line><span class=cl>... ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看驱动相关的信息
</span></span><span class=line><span class=cl># modinfo e1000e
</span></span><span class=line><span class=cl>filename:       .../kernel/drivers/net/ethernet/intel/e1000e/e1000e.ko
</span></span><span class=line><span class=cl>version:        3.2.5-k
</span></span><span class=line><span class=cl>license:        GPL
</span></span><span class=line><span class=cl>description:    Intel(R) PRO/1000 Network Driver
</span></span><span class=line><span class=cl>author:         Intel Corporation, &lt;linux.nics@intel.com&gt;
</span></span><span class=line><span class=cl>... ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看对应的中断信息
</span></span><span class=line><span class=cl>$ cat /proc/interrupts
</span></span><span class=line><span class=cl>           CPU0       CPU1       CPU2       CPU3
</span></span><span class=line><span class=cl>... ...
</span></span><span class=line><span class=cl> 46:        853          0        930          0   PCI-MSI-edge      eth0
</span></span><span class=line><span class=cl>... ...
</span></span></code></pre></div><p>如上可以看到硬件的信息，以及所使用的驱动信息。</p><a class=anchor id=源码解析></a><h1>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h1><p>接下来查看下 e1000e 相关的驱动。</p><a class=anchor id=网络初始化></a><h2>网络初始化 <a href=#%e7%bd%91%e7%bb%9c%e5%88%9d%e5%a7%8b%e5%8c%96 aria-hidden=true>#</a></h2><p>网络设备相关的驱动在内核的 <code>drivers/net</code> 目录下，如上的 <code>e1000e</code> 驱动在 <code>net/ethernet/intel/e1000e</code> 目录下，接下来我们就以此为例。</p><p>首先是模块初始化函数，也就是 <code>module_init()</code> 宏指定的相关函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>char</span> <span class=n>e1000e_driver_name</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;e1000e&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>pci_driver</span> <span class=n>e1000_driver</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>name</span>     <span class=o>=</span> <span class=n>e1000e_driver_name</span><span class=p>,</span>             <span class=c1>// 驱动名称
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>.</span><span class=n>id_table</span> <span class=o>=</span> <span class=n>e1000_pci_tbl</span><span class=p>,</span>             <span class=c1>// 指定了那些设备可以使用该驱动
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>.</span><span class=n>probe</span>    <span class=o>=</span> <span class=n>e1000_probe</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>remove</span>   <span class=o>=</span> <span class=n>e1000_remove</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>driver</span>   <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>pm</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>e1000_pm_ops</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>shutdown</span> <span class=o>=</span> <span class=n>e1000_shutdown</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>err_handler</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>e1000_err_handler</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>e1000_init_module</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>pr_info</span><span class=p>(</span><span class=s>&#34;Intel(R) PRO/1000 Network Driver - %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>e1000e_driver_version</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>pr_info</span><span class=p>(</span><span class=s>&#34;Copyright(c) 1999 - 2014 Intel Corporation.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nf>pci_register_driver</span><span class=p>(</span><span class=o>&amp;</span><span class=n>e1000_driver</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>module_init</span><span class=p>(</span><span class=n>e1000_init_module</span><span class=p>);</span>
</span></span></code></pre></div><p>如上，实际的初始化，只是通过 <code>pci_register_driver()</code> 注册的 PCI 驱动。当然其它的驱动也类似，同样会在加载的时候都会通过该函数注册，然后，在该函数中会通过驱动对应的 <code>probe()</code> 函数探测设备，如果找到则加载驱动，注册添加一个网络设备。</p><p>现在已经定义一个 PCI 驱动，但是哪些 PCI 设备可以使用此驱动？ 实际上与 <code>e1000_driver.id_table</code> 中的定义相关，对于 e1000e 也就是通过 <code>struct pci_device_id e1000_pci_tbl[]</code> 定义。</p><p>接下来看看是如何匹配的。</p><p>首先介绍下 PCI 的相关内容，PCI 有 3 种地址空间：IO 空间、内存地址空间、配置空间。一个 PCI 配置空间至少有 256 字节，如下：</p><p><img alt="PCI 配置空间格式" src=images/pci-config.png class="mx-auto d-block"></p><p><code>id_table</code> 是 <code>struct pci_device_id</code> 类型的一个数组，每个元素就对应一条使用的 PCI 硬件信息，如果符合就可以使用这个驱动，例如我的网卡，其类型为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pci -nn | grep -E &#39;Ethernet controller.*Intel&#39;
</span></span><span class=line><span class=cl>00:19.0 Ethernet controller [0200]: Intel Corporation Ethernet Connection I218-LM [8086:155a] (rev 04)
</span></span></code></pre></div><p>刚好可以匹配上如下的记录。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define E1000_DEV_ID_PCH_LPTLP_I218_LM      0x155A
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>pci_device_id</span> <span class=n>e1000_pci_tbl</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=nf>PCI_VDEVICE</span><span class=p>(</span><span class=n>INTEL</span><span class=p>,</span> <span class=n>E1000_DEV_ID_PCH_LPTLP_I218_LM</span><span class=p>),</span> <span class=n>board_pch_lpt</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在 pci_driver 中的 probe 成员（也就是 e1000_probe() 函数）用来对设置进行一系列的初始化操作。在驱动和设备的初始化阶段，包括在总线上驱动注册初始化；驱动探测设备注册初始化；开启设备，初始化接收缓存。</p><p>网络设备通过 <code>struct net_device</code> 标示，包括硬件网络设备接口，如以太网；软件网络设备接口，如 loopback 。通过 dev_base 头指针将设备链接起来集体管理，每个节点代表一个网络设备接口。</p><p>另外，也个比较重要的是中断相关内容，也就是在 <code>e1000_open()</code> 函数中调用 <code>e1000_request_irq()</code> 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>e1000_request_irq</span><span class=p>(</span><span class=k>struct</span> <span class=n>e1000_adapter</span> <span class=o>*</span><span class=n>adapter</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* E1000E_INT_MODE_MSIX模式
</span></span></span><span class=line><span class=cl><span class=cm>     * # cat /proc/interrupts | grep eth0
</span></span></span><span class=line><span class=cl><span class=cm>     *   86          0          0          0  IR-PCI-MSI-edge      eth0-rx-0
</span></span></span><span class=line><span class=cl><span class=cm>     *    0          0          0          0  IR-PCI-MSI-edge      eth0-tx-0
</span></span></span><span class=line><span class=cl><span class=cm>     *   10          0          0          0  IR-PCI-MSI-edge      eth0
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>FLAG_MSI_ENABLED</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 如果是MSI
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>err</span> <span class=o>=</span> <span class=nf>request_irq</span><span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>pdev</span><span class=o>-&gt;</span><span class=n>irq</span><span class=p>,</span> <span class=n>e1000_intr_msi</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>netdev</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>netdev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* fall back to legacy interrupt */</span>
</span></span><span class=line><span class=cl>        <span class=nf>e1000e_reset_interrupt_capability</span><span class=p>(</span><span class=n>adapter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>adapter</span><span class=o>-&gt;</span><span class=n>int_mode</span> <span class=o>=</span> <span class=n>E1000E_INT_MODE_LEGACY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* E1000E_INT_MODE_MSI模式
</span></span></span><span class=line><span class=cl><span class=cm>     * # cat /proc/interrupts | grep eth0
</span></span></span><span class=line><span class=cl><span class=cm>     * 853          0        930          0   PCI-MSI-edge      eth0
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>err</span> <span class=o>=</span> <span class=nf>request_irq</span><span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>pdev</span><span class=o>-&gt;</span><span class=n>irq</span><span class=p>,</span> <span class=n>e1000_intr</span><span class=p>,</span> <span class=n>IRQF_SHARED</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=n>netdev</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>,</span> <span class=n>netdev</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>如上，在注册完设备之后，会通过 <code>request_irq()</code> 申请中断，不同的网卡类型会注册不同的中断处理函数，下面以 <code>e1000_intr()</code> 为例。</p><a class=anchor id=napi-new-api></a><h1>NAPI (New API) <a href=#napi-new-api aria-hidden=true>#</a></h1><p>报文接收是整个协议栈的入口，负责从网卡中把报文接收并送往内核协议栈相应协议处理模块处理。一般有中断和轮询两种方式，最开始，网络流量小，采用中断方式。</p><p>当流量增大时，有此引起的中断将会影响到系统的整体效率。例如，我们使用标准的 100M 网卡，可能实际达到的接收速率为 80MBits/s，而此时数据包平均长度为 1500Bytes，则每秒产生的中断数目为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>80M bits/s / (8 Bits/Byte * 1500 Byte) = 6667 个中断 /s
</span></span></code></pre></div><p>当每秒数千个中断请求时，那么很大一部分时间会消耗在中断上下文中；因此，当流量较大时，最好采用轮询的方式。而轮询，在请求较少时仍需要定时捞取数据，从而也会导致资源浪费。</p><p>而 NAPI 就是为了解决此问题。</p><p>除了中断次数之外，当系统压力很大，不得不丢数据报文时，最好的方式是在最底层直接丢弃。采用 NAPI 后，可以直接在网络驱动中丢弃，而不需要再通知到内核。</p><p>在网卡中断中，首先处理的是关闭中断，因为我们已经知道了现在有很多的报文需要去处理，关闭中断，从而防止其它的中断请求再次到来。接着就是通知 Network Subsystem 来处理现在已经接收的报文。</p><a class=anchor id=结构体></a><h2>结构体 <a href=#%e7%bb%93%e6%9e%84%e4%bd%93 aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>//----- 每个CPU会分配一个结构体
</span></span><span class=line><span class=cl>DEFINE_PER_CPU_ALIGNED(struct softnet_data, softnet_data);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct softnet_data {                         // 保存接收报文，每个CPU一个队列
</span></span><span class=line><span class=cl>    struct Qdisc        *output_queue;        // 输出帧的控制
</span></span><span class=line><span class=cl>    struct Qdisc        **output_queue_tailp;
</span></span><span class=line><span class=cl>    struct list_head    poll_list;            // 有输入帧待处理的设备链表
</span></span><span class=line><span class=cl>    struct sk_buff      *completion_queue;    // 已经成功被传递出的帧的链表
</span></span><span class=line><span class=cl>    struct sk_buff_head process_queue;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    unsigned int        dropped;
</span></span><span class=line><span class=cl>    struct sk_buff_head input_pkt_queue;      // 接收到数据会分配一个skb，并保存在该链表中，注意只针对非NAPI
</span></span><span class=line><span class=cl>                                              // 而NAPI有自己的私有队列
</span></span><span class=line><span class=cl>    struct napi_struct  backlog;              // 用来兼容非NAPI的驱动
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct napi_struct {
</span></span><span class=line><span class=cl>    struct list_head    poll_list;            // 等待被执行的设备链表，链表的头就是softnet_data.poll_list
</span></span><span class=line><span class=cl>    unsigned long       state;
</span></span><span class=line><span class=cl>    int                 weight;               // 标示设备的权重
</span></span><span class=line><span class=cl>    unsigned int        gro_count;
</span></span><span class=line><span class=cl>    int (*poll)(struct napi_struct *, int);   // NAPI都有poll虚函数，而非NAPI没有，初始化会赋值process_backlog
</span></span><span class=line><span class=cl>    struct net_device   *dev;                 // 指向具体的网络设备
</span></span><span class=line><span class=cl>    struct sk_buff      *gro_list;
</span></span><span class=line><span class=cl>    struct sk_buff      *skb;
</span></span><span class=line><span class=cl>    struct list_head    dev_list;             // 指向设备的NAPI链表
</span></span><span class=line><span class=cl>    struct hlist_node   napi_hash_node;
</span></span><span class=line><span class=cl>    unsigned int        napi_id;
</span></span><span class=line><span class=cl>};
</span></span></code></pre></div><p>上述结构体中有 Qdisc (Queueing Discipline)，即排队规则，也就是我们经常说的 QoS 。</p><a class=anchor id=与设备关联></a><h2>与设备关联 <a href=#%e4%b8%8e%e8%ae%be%e5%a4%87%e5%85%b3%e8%81%94 aria-hidden=true>#</a></h2><p>在网卡驱动中，同时会创建轮询函数，一般在网卡初始化的时候完成，通过 <code>nefif_napi_add()</code> 函数添加。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>netif_napi_add</span><span class=p>(</span><span class=k>struct</span> <span class=n>net_device</span> <span class=o>*</span><span class=n>dev</span><span class=p>,</span> <span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>napi</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>poll</span><span class=p>)(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=p>),</span> <span class=kt>int</span> <span class=n>weight</span><span class=p>);</span>
</span></span></code></pre></div><p>也就是用于将轮询函数与实际的网络设备 struct net_device 关联起来。上述函数的入参中包括了一个权重，该值通常是一个经验数据，一般 10Mb 的网卡设置为 16，而更快的网卡则设置为 64 。</p><a class=anchor id=通知软中断></a><h2>通知软中断 <a href=#%e9%80%9a%e7%9f%a5%e8%bd%af%e4%b8%ad%e6%96%ad aria-hidden=true>#</a></h2><p>通知是通过 <code>napi_schedule()</code> 函数进行，有如下的两种方式；其中 <code>napi_schedule_prep()</code> 是为了判定现在是否已经进入了轮询模式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//----- 将网卡预定为轮询模式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>napi_schedule</span><span class=p>(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//----- 或者
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=nf>napi_schedule_prep</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>        <span class=c1>// 返回0表示已经在做poll操作了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>__napi_schedule</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span></code></pre></div><p>接下来查看下源码的具体实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>bool</span> <span class=nf>napi_schedule_prep</span><span class=p>(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>!</span><span class=nf>napi_disable_pending</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=o>!</span><span class=nf>test_and_set_bit</span><span class=p>(</span><span class=n>NAPI_STATE_SCHED</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>state</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>napi_schedule</span><span class=p>(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>napi_schedule_prep</span><span class=p>(</span><span class=n>n</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=nf>__napi_schedule</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>____napi_schedule</span><span class=p>(</span><span class=k>struct</span> <span class=n>softnet_data</span> <span class=o>*</span><span class=n>sd</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>napi</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 把自己挂到per cpu的softnet_data上，触发NET_RX_SOFTIRQ软中断
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>list_add_tail</span><span class=p>(</span><span class=o>&amp;</span><span class=n>napi</span><span class=o>-&gt;</span><span class=n>poll_list</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sd</span><span class=o>-&gt;</span><span class=n>poll_list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>__raise_softirq_irqoff</span><span class=p>(</span><span class=n>NET_RX_SOFTIRQ</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>__napi_schedule</span><span class=p>(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>local_irq_save</span><span class=p>(</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>____napi_schedule</span><span class=p>(</span><span class=nf>this_cpu_ptr</span><span class=p>(</span><span class=o>&amp;</span><span class=n>softnet_data</span><span class=p>),</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>local_irq_restore</span><span class=p>(</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看到 <code>napi_schedule()</code> 基本操作是添加到链表中，然后触发软中断。</p><a class=anchor id=软中断></a><h2>软中断 <a href=#%e8%bd%af%e4%b8%ad%e6%96%ad aria-hidden=true>#</a></h2><p>软中断包括了读写中断，均在 <code>net_dev_init()</code> 函数中初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>net_dev_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>open_softirq</span><span class=p>(</span><span class=n>NET_TX_SOFTIRQ</span><span class=p>,</span> <span class=n>net_tx_action</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>open_softirq</span><span class=p>(</span><span class=n>NET_RX_SOFTIRQ</span><span class=p>,</span> <span class=n>net_rx_action</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nf>subsys_initcall</span><span class=p>(</span><span class=n>net_dev_init</span><span class=p>);</span>
</span></span></code></pre></div><a class=anchor id=轮询函数></a><h2>轮询函数 <a href=#%e8%bd%ae%e8%af%a2%e5%87%bd%e6%95%b0 aria-hidden=true>#</a></h2><p>驱动中创建轮询函数，它的工作是从网卡获取数据包并将其送入到网络子系统，函数声明如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>poll</span><span class=p>)(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>napi</span><span class=p>,</span> <span class=kt>int</span> <span class=n>weight</span><span class=p>);</span>
</span></span></code></pre></div><p>该函数在将网卡切换为轮询模式之后，用 poll() 方法处理接收队列中的数据包，如队列为空，则重新切换为中断模式。在切换回中断模式前，需要先通过 netif_rx_completer() 关闭轮询模式，然后开启网卡接收中断。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//----- 退出轮询模式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>__napi_complete</span><span class=p>(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>list_del</span><span class=p>(</span><span class=o>&amp;</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>poll_list</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>smp_mb__before_atomic</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>clear_bit</span><span class=p>(</span><span class=n>NAPI_STATE_SCHED</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>state</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>napi_complete</span><span class=p>(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * don&#39;t let napi dequeue from the cpu poll list
</span></span></span><span class=line><span class=cl><span class=cm>     * just in case its running on a different cpu
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>unlikely</span><span class=p>(</span><span class=nf>test_bit</span><span class=p>(</span><span class=n>NAPI_STATE_NPSVC</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>n</span><span class=o>-&gt;</span><span class=n>state</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>napi_gro_flush</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>local_irq_save</span><span class=p>(</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>__napi_complete</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>local_irq_restore</span><span class=p>(</span><span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>关于驱动需要做的修改，可以参考 <a href=http://lwn.net/Articles/30107/>Driver porting: Network drivers</a>，这篇是 2.6 时的文章，稍微有点老。</p><a class=anchor id=接收报文></a><h1>接收报文 <a href=#%e6%8e%a5%e6%94%b6%e6%8a%a5%e6%96%87 aria-hidden=true>#</a></h1><p>在 e1000e 驱动中，只有 NAPI，也就是在收到中断后，然后调用 NAPI 轮询。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>irqreturn_t</span> <span class=nf>e1000_intr</span><span class=p>(</span><span class=kt>int</span> <span class=n>__always_unused</span> <span class=n>irq</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>napi_schedule_prep</span><span class=p>(</span><span class=o>&amp;</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>napi</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>adapter</span><span class=o>-&gt;</span><span class=n>total_tx_bytes</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>adapter</span><span class=o>-&gt;</span><span class=n>total_tx_packets</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>adapter</span><span class=o>-&gt;</span><span class=n>total_rx_bytes</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>adapter</span><span class=o>-&gt;</span><span class=n>total_rx_packets</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>__napi_schedule</span><span class=p>(</span><span class=o>&amp;</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>napi</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>IRQ_HANDLED</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>e1000e_poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>napi_struct</span> <span class=o>*</span><span class=n>napi</span><span class=p>,</span> <span class=kt>int</span> <span class=n>weight</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>msix_entries</span> <span class=o>||</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>rx_ring</span><span class=o>-&gt;</span><span class=n>ims_val</span> <span class=o>&amp;</span> <span class=n>adapter</span><span class=o>-&gt;</span><span class=n>tx_ring</span><span class=o>-&gt;</span><span class=n>ims_val</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>tx_cleaned</span> <span class=o>=</span> <span class=nf>e1000_clean_tx_irq</span><span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>tx_ring</span><span class=p>);</span>        <span class=c1>// 查看并回收tx slot
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>adapter</span><span class=o>-&gt;</span><span class=nf>clean_rx</span><span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>rx_ring</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>work_done</span><span class=p>,</span> <span class=n>weight</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>tx_cleaned</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>work_done</span> <span class=o>=</span> <span class=n>weight</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* If weight not fully consumed, exit the polling mode */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>work_done</span> <span class=o>&lt;</span> <span class=n>weight</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>itr_setting</span> <span class=o>&amp;</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nf>e1000_set_itr</span><span class=p>(</span><span class=n>adapter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>napi_complete</span><span class=p>(</span><span class=n>napi</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>test_bit</span><span class=p>(</span><span class=n>__E1000_DOWN</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>state</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>adapter</span><span class=o>-&gt;</span><span class=n>msix_entries</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=nf>ew32</span><span class=p>(</span><span class=n>IMS</span><span class=p>,</span> <span class=n>adapter</span><span class=o>-&gt;</span><span class=n>rx_ring</span><span class=o>-&gt;</span><span class=n>ims_val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=nf>e1000_irq_enable</span><span class=p>(</span><span class=n>adapter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>work_done</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于接收过程，我们仅大致疏理一下其执行过程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>napi_gro_receive()
</span></span><span class=line><span class=cl> |-skb_gro_reset_offset()
</span></span><span class=line><span class=cl> |-dev_gro_receive()
</span></span><span class=line><span class=cl> |-napi_skb_finish()
</span></span><span class=line><span class=cl>   |-netif_receive_skb_internal()
</span></span><span class=line><span class=cl>     |-__netif_receive_skb()            # 进入上层的接收函数
</span></span></code></pre></div></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#查看驱动>查看驱动</a></li><li><a href=#源码解析>源码解析</a><ul><li><a href=#网络初始化>网络初始化</a></li></ul></li><li><a href=#napi-new-api>NAPI (New API)</a><ul><li><a href=#结构体>结构体</a></li><li><a href=#与设备关联>与设备关联</a></li><li><a href=#通知软中断>通知软中断</a></li><li><a href=#软中断>软中断</a></li><li><a href=#轮询函数>轮询函数</a></li></ul></li><li><a href=#接收报文>接收报文</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>