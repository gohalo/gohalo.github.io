<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>一致性模型详解 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="现实生活中，对于一个系统的组成会经常发生网络分区、消息丢失、发送延迟、消息重复、消息乱序等等，造成这一问题的原因有很多，包括光纤、交换机、网卡、主机硬件、操作系统、磁盘、虚拟化层、程序等等，都可能会出现各种各样的问题。
此时就需要有一个比较直观的正确性模型，包括如何定义、描述。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>一致性模型详解</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2019-12-30</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a></div></div><hr><div class=content><p>现实生活中，对于一个系统的组成会经常发生网络分区、消息丢失、发送延迟、消息重复、消息乱序等等，造成这一问题的原因有很多，包括光纤、交换机、网卡、主机硬件、操作系统、磁盘、虚拟化层、程序等等，都可能会出现各种各样的问题。</p><p>此时就需要有一个比较直观的正确性模型，包括如何定义、描述。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>数据库、分布式中存在多种一致性的定义，例如 ACID 中的 <code>Consistency</code>、RAFT/Paxos 中的 <code>Consensus</code> (共识)、CAP Theory 中的 <code>Consistency</code> 以及 MESI Cache 中的 <code>Coherence</code> 。这些概念在使用时很容易混淆，这里先介绍分布式系统中的相关概念。</p><p>分布式系统中与一致性相关的主要有，线性一致性 <code>Linearizability</code>、顺序一致性 <code>Sequential Consistency</code>、因果一致性 <code>Causality Consistency</code>、最终一致性 <code>Eventual Consistency</code> 四类。</p><a class=anchor id=现实></a><h2>现实 <a href=#%e7%8e%b0%e5%ae%9e aria-hidden=true>#</a></h2><p>当对某个全局资源进行操作时，本机上可能会消耗十几到几百个时钟周期，到分布式系统上会更加明显，那么每个操作可能会在期间的任意时间点发生，这也就是说，所有的操作会有两个特性：</p><ul><li>每个操作包括了请求 (Invocation) 和响应 (Response) 两个事件，而且请求一定早于响应。</li><li>每个操作的实际生效时间在请求和响应之间的任意时间。</li></ul><a class=anchor id=linearizability></a><h1>Linearizability <a href=#linearizability aria-hidden=true>#</a></h1><p>也被称为强一致性或者原子一致性，最早在 1978 年的 <a href=https://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf>Linearizability: A Correctness Condition for Concurrent Objects</a> 论文中给出了形式化的定义。简单来说，严格保证时间顺序一致，当某个操作完成后，后续其它操作应该读取到该操作的结果。</p><p>如下通过蓝色标识了事件可能发生的时间点，其符合线性一致性的要求。</p><p><img alt="Linearizability Possible Example" src=images/linearizability-example-possible.svg class="mx-auto d-block"></p><p>如下的事件，右侧是一种可能的事件发生顺序，其中 ClientD 请求是不能满足线性约束的，当然，也可以让 ClientD 满足要求，同样，此时的 ClientC 将不满足。</p><p><img alt="Linearizability Impossible Example" src=images/linearizability-example-impossible.svg class="mx-auto d-block"></p><p>这也就意味线性一致性对中间状态没有约束，如下的方式只能说是可能会满足线性一致，只有真正拿到最终的返回结果后才能判断是否满足一致性的要求。</p><p><img alt="Linearizability Basic" src=images/linearizability-basic.svg class="mx-auto d-block"></p><p>简言之，线性一致性允许读取到的是发起请求到结束请求之间的数据，但是不能会读取到发起请求前的老数据，这也是最严格的方式，成本也最高。如下是一个稍微复杂点的示例。</p><p><img alt="Linearizability Example" src=images/linearizability-example.svg class="mx-auto d-block"></p><p>虽然在 <code>Clint B</code> 看来，成功将 <code>x</code> 修改为了 <code>2</code>，而且读取到了 <code>2</code>，但是实际上已经有其它客户端将 <code>x</code> 修改为了 <code>4</code>，所以不满足线性一致性的要求，此时读取到的应该是 <code>4</code> 。</p><p>另外，这里只是定义了逻辑上的时间，而实际实现时的时间和事件顺序又另当别论。</p><a class=anchor id=sequential-consistency></a><h1>Sequential Consistency <a href=#sequential-consistency aria-hidden=true>#</a></h1><p>在提出线性一致性之前，Lamport 早在 1979 年就提出了顺序一致性的概念：</p><blockquote><p>A multiprocessor system is sequentially consistent if the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p></blockquote><p>另外，Lamport 上述的定义是基于单机的，如上所述，可以扩展推广到分布式系统领域。这个定义实际上对系统提出了两条访问共享对象时的约束：</p><ol><li>从单个线程 (或进程) 的角度上看，其指令的执行顺序以程序中的顺序为准；</li><li>从所有线程 (或进程) 的角度上看，指令的执行保持一个单一的顺序。</li></ol><p>其中，约束 1 保证了单进程的所有指令是按照程序中的顺序执行，也就是符合我们编码最初的预期，这里针对的是执行顺序，<strong>而非结果</strong>；约束 2 保证了所有的内存操作都是原子的或者说实时生效的，其执行顺序不必严格遵循时间顺序。</p><p><img alt="Sequential Consistency Basic" src=images/sequential-consistency-basic.svg class="mx-auto d-block"></p><p>对于顺序一致性来说，上述两种方式都是合法的，只要满足客户端看到的顺序一致性即可，不要求严格的全局时钟顺序，但是线性一致性则要求只能出现其中的一种结果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>前者的顺序为
</span></span><span class=line><span class=cl>A W(x, 1) =&gt; B W(x, 2) =&gt; C R(x, 1) -&gt; D R(x, 1) =&gt; C R(x, 2) =&gt; D R(x, 2)
</span></span><span class=line><span class=cl>后者的顺序为
</span></span><span class=line><span class=cl>B W(x, 2) =&gt; A W(x, 1) =&gt; C R(x, 2) =&gt; D R(x, 2) =&gt; C R(x, 1) =&gt; D R(x, 1)
</span></span></code></pre></div><p>最常见的如订阅系统、Twitter消息等，实际使用时，常见的数据库主备复制都是满足的。</p><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><a class=anchor id=linearizability-vs-serializability></a><h2>Linearizability VS. Serializability <a href=#linearizability-vs-serializability aria-hidden=true>#</a></h2><p>这两个概念是分布式、数据库中常见而且容易混淆的概念，简单来说，其区别可以概括为。</p><blockquote><p>Linearizability: single-operation, single-object, real-time order.</p><p>Serializability: multi-operation, multi-object, arbitrary total order.</p></blockquote><p>在 Linearizability 的定义里有顺序化 (Sequential)，而在 Serializability 的定义里有串行化 (Serial)，所以会导致这两个概念非常容易混淆，而实际上，这两个概念分别源自分布式系统和数据库，随着分布式数据库发展导致这两个概念比较容易混淆。</p><p>更多可以参考 <a href=http://www.bailis.org/blog/linearizability-versus-serializability/>Linearizability VS. Serializability</a> 中的内容。</p><a class=anchor id=linearizability-1></a><h3>Linearizability <a href=#linearizability-1 aria-hidden=true>#</a></h3><p>用来保证的是针对单个对象的多个操作行为，而且是在严格时序上的操作顺序。</p><p>简单来说，写对于应用来说是立即生效的，也就是说，当写入完成后，所有后续 (严格时序) 的读操作，获得的都是最新值；当读获取到一个值后，后面的操作将读取到该值或者最新的值。</p><p>对应了 CAP 理论中的 C 。</p><a class=anchor id=serializability></a><h3>Serializability <a href=#serializability aria-hidden=true>#</a></h3><p>保证的是针对多个对象的一组操作 (一般是事务)，确保这组操作等价于某个顺序执行过程。</p><p>注意，上述的顺序没有明确说是何种顺序，不必是严格的时间序，只需要某个可以确定存在的执行顺序即可，有点类似 SC 。</p><p>这是事务 (ACID) 的隔离 (Isolation) 级别，事务是有可能会读写多个对象的，该特性用于保证不同事务在执行时的效果跟串行化 (前一个事务结束了后一个事务才开始，没有重叠) 执行是一样。</p><p>注意，该特性不保证多个事务彼此之间的顺序，它只是一个保证数据库正确性条件。</p><a class=anchor id=strict-serializability></a><h3>Strict Serializability <a href=#strict-serializability aria-hidden=true>#</a></h3><p>也就是将 Linearizability 和 Serializability 结合起来，例如在事务 T1 中写入 X 的值，然后事务 T2 再读取 X 的值，那么对于 SS 来说，需要严格保证 T1 先于 T2 执行。</p><p>对于只提供了 Serializability 能力的数据库来说，是允许 T2 先于 T1 执行的。</p><p>实际上，如果数据库使用的锁来保证 (锁粒度较大)，那么就是 SS ；如果采用了 MVCC 实现，那么可能就只是 Serializability 。</p><a class=anchor id=总结></a><h3>总结 <a href=#%e6%80%bb%e7%bb%93 aria-hidden=true>#</a></h3><p>两者的实现都必须要有一个中间协调者才可以。真实场景是，默认数据库不会使用 Serializability ，多核的系统也不会使用 Linearizability ，如果要使用，那么会有非常高的成本，所以使用较多的是 Read Commit 以及 SC 。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><ul><li><a href="https://dl.acm.org/citation.cfm?id=1311750">How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs</a> Lamport 关于顺序一致性最早描述。</li><li><a href=https://jepsen.io/Consistency>jepsen.io</a> 用于验证分布式数据库一致性的工具，包含了很多基本概念的介绍。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#现实>现实</a></li></ul></li><li><a href=#linearizability>Linearizability</a></li><li><a href=#sequential-consistency>Sequential Consistency</a></li><li><a href=#其它>其它</a><ul><li><a href=#linearizability-vs-serializability>Linearizability VS. Serializability</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>