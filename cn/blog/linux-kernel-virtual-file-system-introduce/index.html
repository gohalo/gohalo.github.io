<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux VFS 文件系统 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="在次重申下，Linux 的设计理念是：一切都是文件！
也就是在 Linux 中，一切设备皆是以文件的形式进行操作，如网络套接字、硬件设备等。这一切都是通过一个中间层实现的，被称为 VFS (Virtual File System) 。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux VFS 文件系统</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-03-15</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>在次重申下，Linux 的设计理念是：一切都是文件！</p><p>也就是在 Linux 中，一切设备皆是以文件的形式进行操作，如网络套接字、硬件设备等。这一切都是通过一个中间层实现的，被称为 VFS (Virtual File System) 。</p><a class=anchor id=virtual-file-system-vfs></a><h1>Virtual File System, VFS <a href=#virtual-file-system-vfs aria-hidden=true>#</a></h1><p>总体上说 Linux 的文件系统主要可分为三大块：一是上层的文件系统的系统调用，也就是提供的统一文件系统 API；二是虚拟文件系统 VFS；三是挂载到 VFS 中的各实际文件系统，例如 ext4 。</p><p>按照类型文件系统可以分为三类：A) 磁盘文件系统，最常见，用来将数据保存在物理存储上，如 ext4、FAT、NTFS；B) 虚拟文件系统，如 procfs、sysfs；C) 网络文件系统，NFS 。</p><p>为了支持多种文件系统，Linux 内核在用户进程 (C标准库) 和文件系统之前实现了一个抽象层，虚拟文件系统，也就是 VFS 。</p><p>VFS 除了为所有文件系统的实现提供一个通用接口外，还提供了一些文件相关数据结构的磁盘高速缓存。例如最近最常使用的目录项对象被放在所谓目录项高速缓存（dentry cache）的磁盘高速缓存中，从而加速从文件路径名到最后一个路径分量的索引节点的转换过程。</p><a class=anchor id=数据结构></a><h2>数据结构 <a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-hidden=true>#</a></h2><p>对于文件，主要包括了两部分信息：A) 存储的数据本身；B) 该文件的组织和管理的信息。</p><p>后者就是 Linux 中维护的一些元数据 (metadata)，主要结构包括了 superblock、inode、dentry 和 file，用来支持如指示存储位置、历史数据、资源查找、文件纪录等功能。</p><p>在内存中, 每个文件都有一个 dentry(目录项) 和 inode (索引节点) 结构，dentry 记录着文件名，上级目录等信息，正是它形成了我们所看到的树状结构；而有关该文件的组织和管理的信息主要存放 inode 里面，它记录着文件在存储介质上的位置与分布。</p><p>另外，<code>dentry->d_inode</code> 指向相应的 inode 结构，dentry 与 inode 是多对一的关系，因为有可能一个文件有好几个文件名，如硬链接。</p><a class=anchor id=dentry-和-inode-的关系></a><h2>dentry 和 inode 的关系 <a href=#dentry-%e5%92%8c-inode-%e7%9a%84%e5%85%b3%e7%b3%bb aria-hidden=true>#</a></h2><p>在 Linux 进程中，是通过目录项 (dentry) 和索引节点 (inode) 描述文件的，而所谓 &ldquo;文件&rdquo; 就是按一定的格式存储在介质上的信息，所以一个文件其实包含了两方面的信息，一是存储的数据本身，二是有关该文件的组织和管理的信息。</p><p>在内存中, 每个文件都有一个 dentry 和 inode 结构，前者记录着文件名、上级目录等信息，所有的 dentry 用 d_parent 和 d_child连 接起来，就形成了我们熟悉的树状结构； 而有关该文件的组织和管理的信息主要存放 inode 里面，它记录着文件在存储介质上的位置与分布。</p><p>同时 dentry->d_inode 指向相应的 inode 结构，由于硬链接导致一个文件可能有好几个文件名，所以 dentry 与 inode 是多对一的关系。</p><p>inode 代表的是物理意义上的文件，通过 inode 可以得到一个数组，这个数组记录了文件内容的位置，如该文件位于硬盘的第 3、8、10 块，那么这个数组的内容就是 3、8、10。在同一个文件系统中可以通过索引节点号 inode->i_ino 计算出在介质上的位置，对于硬盘来说，可直接计算出对应的 inode 属于哪个块 (block)，从而找到相应的 inode 结构。</p><p>另外，对于某一种特定的文件系统而言，如 ext4，在内存中用 ext4_inode_info 结构体描述，包含了一个 inode 容器。就磁盘文件而言，dentry 和 inode 的信息保存在磁盘上，对于像 ext4 这样的磁盘文件来说，存储介质中的目录项和索引节点载体通过 ext4_inode、ext4_dir_entry_2 标示。</p><a class=anchor id=文件系统></a><h1>文件系统 <a href=#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f aria-hidden=true>#</a></h1><p>磁盘上的文件内容通过文件系统组织一系列的文件，通常这些文件保存在磁盘的不同分区上，当然不同的分区可能包含不同的文件系统类型，如 ext2、ext3、fat16、ntfs 等。</p><p>可以通过 <code>cat /proc/filesystems</code> 查看已经注册的文件系统。</p><p>对于每个文件系统，同时会有代码，或者是模块，来告诉我们如何操作这些文件。因此，在使用具体的文件之前，需要告诉内核该文件系统的相关信息，主要包括 A) 文件系统名称；B) 知道如何挂载；C) 如何查找文件的路径；D) 如何查找文件的内容。</p><a class=anchor id=数据结构-1></a><h2>数据结构 <a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84-1 aria-hidden=true>#</a></h2><a class=anchor id=file-system></a><h3>file system <a href=#file-system aria-hidden=true>#</a></h3><p>其中 <code>struct file_system_type</code> 包括了文件系统的主要参数，如下之列出了主要部分。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>file_system_type</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>;</span>                                     <span class=c1>// 文件系统的名称，如EXT4、FAT16、NTFS
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>fs_flags</span><span class=p>;</span>                                         <span class=c1>// 对应文件系统的类型，在该变量下定义了一些符号的宏
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>mount</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>file_system_type</span> <span class=o>*</span><span class=p>,</span>   <span class=c1>// 代替早期的get_sb()，用户挂载此文件系统时使用的回调函数
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=kt>int</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>kill_sb</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>super_block</span> <span class=o>*</span><span class=p>);</span>               <span class=c1>// 删除内存中的super block，在卸载文件系统时使用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>module</span> <span class=o>*</span><span class=n>owner</span><span class=p>;</span>                                 <span class=c1>// 指向实现这个文件系统的模块，通常为THIS_MODULE宏
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>file_system_type</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>                        <span class=c1>// 指向文件系统类型链表的下一个文件系统类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>hlist_head</span> <span class=n>fs_supers</span><span class=p>;</span>                          <span class=c1>// 该文件系统类型的超级块结构，都串连在这个表头下
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>另外，存在一个全局变量 <code>file_systems</code>，用于保存所有已经注册的文件系统。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>file_system_type</span> <span class=o>*</span><span class=n>file_systems</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=nf>DEFINE_RWLOCK</span><span class=p>(</span><span class=n>file_systems_lock</span><span class=p>);</span>
</span></span></code></pre></div><p>文件系统信息在内核中会通过单向链表保存，其中 <code>file_systems</code> 全局变量作为链头，同时对应一个 <code>file_systems_lock</code> 锁，当需要读写时需要先加锁，如上，可以通过 <code>cat /proc/filesystems</code> 查看已经注册的文件系统。</p><a class=anchor id=operation></a><h3>operation <a href=#operation aria-hidden=true>#</a></h3><p>与文件相关的操作包括了三部分：</p><ul><li>SuperBlock 包含了文件系统的元数据信息；</li><li>Inode 与文件相关的信息；</li><li>File 保存的文件主体。</li></ul><p>针对这三部分同时也对应了三类的操作 API 接口函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>super_operations</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>alloc_inode</span><span class=p>)(</span><span class=k>struct</span> <span class=n>super_block</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>destroy_inode</span><span class=p>)(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>sync_fs</span><span class=p>)(</span><span class=k>struct</span> <span class=n>super_block</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span> <span class=kt>int</span> <span class=n>wait</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>statfs</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=p>,</span> <span class=k>struct</span> <span class=n>kstatfs</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ... ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>inode_operations</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>lookup</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=p>,</span><span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>create</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=p>,</span><span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=p>,</span> <span class=kt>umode_t</span><span class=p>,</span> <span class=kt>bool</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>link</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=p>,</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=p>,</span><span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>mkdir</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=p>,</span><span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=p>,</span><span class=kt>umode_t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ... ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>file_operations</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>loff_t</span> <span class=p>(</span><span class=o>*</span><span class=n>llseek</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>,</span> <span class=kt>loff_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>ssize_t</span> <span class=p>(</span><span class=o>*</span><span class=n>read</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>,</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=kt>size_t</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>ssize_t</span> <span class=p>(</span><span class=o>*</span><span class=n>write</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=kt>size_t</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>open</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>// ... ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><a class=anchor id=文件系统注册></a><h1>文件系统注册 <a href=#%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%b3%a8%e5%86%8c aria-hidden=true>#</a></h1><p>这是最简单的，也就是直接添加到全局列表中。</p><p>在上面的结构体中包含了文件系统的名称，以及如何产生一个保存在内存中的 <code>super_block</code> 结构体。主要，通过 <code>register_filesystem()</code> 向 VFS 注册，对于编译到内核中的文件系统则是在内核初始化的时候注册，当然也可以在模块初始化的时候注册。</p><p>文件系统注册通过 <code>int register_filesystem(struct file_system_type * fs)</code> 来完成，该函数唯一的操作是将相应的结构体添加到 <code>file_systems</code> 链表中。</p><p>在 <code>struct file_system_type</code> 中通过链表与 <code>file_systems</code> 链头相连，而 <code>register_filesystem()</code> 也就是将对应的类型添加到链表中。</p><p>然后在通过 mount 命令挂载时，会指定相应的文件系统，然后通过对应的 <code>mount()</code> 函数从文件系统 (extN 是从硬盘上) 读取 <code>super_block</code> 并初始化。</p><p>新建 inode 实际通过 <code>new_inode()</code> 完成，而该函数最终会调用 <code>super_block->s_op->alloc_inode()</code> 完成。</p><a class=anchor id=mount-挂载></a><h1>Mount 挂载 <a href=#mount-%e6%8c%82%e8%bd%bd aria-hidden=true>#</a></h1><p>挂载就是将一个文件系统添加到一个目录上，对应的文件系统通常为磁盘文件系统，如 EXTN、NTFS、XFS、FAT16 等；当然也包括虚拟文件，如 proc、sysfs 等。</p><p>挂载时通常包括 A) 一个设备，可以是磁盘、软盘、CDROM 、U盘等；B) 一个对应的目录挂载点；C) 指定相应的文件系统。</p><p>一个挂载命令 mount 通常如下，包括了几个重要参数 fstype、devname、mountpoint、options，可以通过 <code>man 8 mount</code> 查看，对于函数的原型可以通过 <code>man 2 mount</code> 查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># mount -t ext4 /dev/sda1 /mnt -o ....
</span></span></code></pre></div><p>对于上述的命令也可以通过如下的程序执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ man 2 mount
</span></span><span class=line><span class=cl>... ...
</span></span><span class=line><span class=cl>int mount(const char *source, const char *target,
</span></span><span class=line><span class=cl>             const char *filesystemtype, unsigned long mountflags,
</span></span><span class=line><span class=cl>             const void *data);
</span></span><span class=line><span class=cl>... ...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ cat mount_test.c
</span></span><span class=line><span class=cl>#include &lt;stdio.h&gt;
</span></span><span class=line><span class=cl>#include &lt;sys/mount.h&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int main(int argc, char *argv[]) {
</span></span><span class=line><span class=cl>    if (mount(&#34;/dev/sda1&#34;, &#34;/mnt&#34;, &#34;ext4&#34;, 0, NULL)) {
</span></span><span class=line><span class=cl>        perror(&#34;mount failed&#34;);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    return 0;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ gcc -Wall -o mount_test mount_test.c                 # 编译
</span></span><span class=line><span class=cl>$ ./mount_test                                         # 执行命令挂载
</span></span><span class=line><span class=cl>$ findmnt /dev/sda1                                    # 查看执行结果
</span></span></code></pre></div><p>对于 <code>mount()</code> 函数，source 是要挂载的设备名，target 是要挂载到哪，filesystemtype 就是文件系统类型名，而剩余的两个参数 flags 和 data 对应于传入的参数。</p><p>其中 flags 相应宏定义在 <code>include/uapi/linux/fs.h</code> 中，如 <code>MS_RDONLY</code>、<code>MS_NOATIME</code> 等，这些 flags 会在 VFS 层被解析使用。而 data 则是每个文件系统各自支持的挂载选项，可以通过 strace 查看最终调用 <code>mount()</code> 接口是调用的命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ strace mount /dev/loop0 /mnt/foobar -o noquota,nodev
</span></span><span class=line><span class=cl>... ...
</span></span><span class=line><span class=cl>mount(&#34;/dev/loop0&#34;, &#34;/mnt/foobar&#34;, &#34;xfs&#34;, MS_MGC_VAL|MS_NODEV, &#34;noquota&#34;) = 0
</span></span><span class=line><span class=cl>... ...
</span></span></code></pre></div><p>其中 nodev 被解释为 flag，noquota 被当作了 mount data。</p><a class=anchor id=挂载过程></a><h2>挂载过程 <a href=#%e6%8c%82%e8%bd%bd%e8%bf%87%e7%a8%8b aria-hidden=true>#</a></h2><p>在内核中，<code>struct mount</code> 代表着一个 mount 实例，每次挂载都会新建一个该结构体，其中 <code>struct vfsmount mnt</code> 成员是它最核心的部分，过去所有的成员都保存在 vfsmount 结构体中，后来只保留了核心部分在 vfsmount ，这样使得 vfsmount 的内容更加精简，在很多情况下只需要传递 vfsmount。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// fs/mount.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>mount</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>hlist_node</span> <span class=n>mnt_hash</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>mount</span> <span class=o>*</span><span class=n>mnt_parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>vfsmount</span> <span class=n>mnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// include/linux/mount.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>vfsmount</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>dentry</span>  <span class=o>*</span><span class=n>mnt_root</span><span class=p>;</span>           <span class=c1>// 该文件系统的根目录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>super_block</span> <span class=o>*</span><span class=n>mnt_sb</span><span class=p>;</span>         <span class=c1>// 指向superblock
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>mnt_flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// include/linux/path.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>path</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>vfsmount</span> <span class=o>*</span><span class=n>mnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=n>dentry</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在全局文件系统树上要想确定一个位置不能由 dentry 唯一确定，因为有了挂载关系，一切都变的复杂了，比如一个文件系统可以挂装载到不同的挂载点。所以文件系统树的一个位置要由 <code>(mount, dentry)</code> 二元组，或者说 <code>(vfsmount, dentry)</code> 来确定，在内核中通过 <code>struct path</code> 表示。</p><p>下面查看 <code>sys_mount()</code> 的执行过程，实际上，mount 操作的过程就是新建一个 <code>struct mount</code>，然后将此结构和挂载点关联。之后，目录查找时就能沿着 mount 挂载点一级级向下查找文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sys_mount()
</span></span><span class=line><span class=cl> |-copy_mount_string()                  # 从用户空间复制文件系统类型名称、设备名称
</span></span><span class=line><span class=cl> |-copy_mount_options()                 # 获取data数据
</span></span><span class=line><span class=cl> |-do_mount()                           # 通过该函数调用已传入内核的参数
</span></span><span class=line><span class=cl>   |-user_path()                        # 把挂载点解析成path内核结构，也就是路径解析过程
</span></span><span class=line><span class=cl>   | |-user_path_at()
</span></span><span class=line><span class=cl>   |   |-filename_lookup()
</span></span><span class=line><span class=cl>   |- ... ...                           # 解析flags确定mount的操作类型，如bind、remount、newmount
</span></span><span class=line><span class=cl>   |-do_remount()                       # 重新挂载等操作，下面以挂载新节点为例
</span></span><span class=line><span class=cl>   |-do_new_mount()
</span></span><span class=line><span class=cl>     |-get_fs_type()                    # 通过文件系统名称，找到对应文件系统的类型
</span></span><span class=line><span class=cl>     |-vfs_kern_mount()                 # 通过该函数调用具体文件系统的处理函数，构建一个vfsmnt结构
</span></span><span class=line><span class=cl>     | |-alloc_vfsmnt()                 # 分配新的struct mount结构体，并初始化其中的一部分，
</span></span><span class=line><span class=cl>     | |                                # 构造一个root dentry，包含特定文件系统的super block信息
</span></span><span class=line><span class=cl>     | |-mount_fs()                     # 调用具体文件系统的mount回调函数
</span></span><span class=line><span class=cl>     | |  |-type-&gt;mount()               # 调用特定文件系统的回调函数
</span></span><span class=line><span class=cl>     | |- ... ...                       # 完成最后struct mount的初始化
</span></span><span class=line><span class=cl>     |
</span></span><span class=line><span class=cl>     |-do_add_mount()                   # 将得到的mnt结构添加到全局文件系统
</span></span><span class=line><span class=cl>       |-lock_mount()                   # 找到最新的挂载点，并加锁
</span></span><span class=line><span class=cl>       |-real_mount()                   # 挂载到对应的mount点，对挂载进行检查
</span></span><span class=line><span class=cl>       |-graft_tree()                   # 将newmount添加到全局文件系统中
</span></span></code></pre></div><p>在调用 <code>vfs_kern_mount()</code> 时，只有文件系统类型、挂载标记、设备名和挂载选项信息为参数，并没有 mountpoint 参数，其时这里只是用 type 中的 mount 回调函数读取设备的 superblock 信息，填充 mnt 结构，然后把 flag 和 data 解析后填充到 mnt 结构中。</p><p>就是说，通过 <code>vfs_kern_mount()</code> 会调用具体文件系统的 <code>mount()</code> 函数，生成 <code>struct mount</code>，最后通过 <code>do_add_mount()</code> 添加到全局的文件系统中。</p><a class=anchor id=系统调用></a><h1>系统调用 <a href=#%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-hidden=true>#</a></h1><p>对于文件的常见操作如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=s>&#34;syscall.txt&#34;</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=n>O_CREAT</span><span class=p>,</span> <span class=mo>0644</span><span class=p>);</span>   <span class=c1>// man 2 open
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span><span class=p>(</span><span class=n>fd</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error try to open &#39;syscall.txt&#39;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>ret</span> <span class=o>=</span> <span class=nf>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;just for test</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=mi>14</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Error try to write &#39;syscall.txt&#39;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>exit</span><span class=p>(</span><span class=n>EXIT_FAILURE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>close</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 Linux 内核中，每个打开的文件均由一个文件描述符 <code>struct file</code> 表示，而返回给用户的是在 <code>fd_array[]</code> 中的位置索引。</p><p>也即，该描述符在特定进程的数组中充当位置索引，这也意味着包括 <code>open()</code> 数组是 <code>task_struct -> files -> fd_arry</code>，该数组的元素包含了 file 结构，其中包括每个打开文件的所有必要信息。</p><a class=anchor id=sys_open></a><h2>sys_open <a href=#sys_open aria-hidden=true>#</a></h2><p>对于 open() 系统调用的的主要执行操作在 do_sys_open() 中，下面介绍其主要操作。</p><p>do_sys_open() 的操作大致为：A) 找到一个本进程没有使用的文件描述符 fd；B) 分配一个全新的 struct file 结构体；C) 根据传人的 pathname 查找或建立对应的 dentry；D) 建立 fd 到这个 struct file 结构体的联系。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sys_open()
</span></span><span class=line><span class=cl> |-force_o_largefile()               # 是否要强制使用大文件
</span></span><span class=line><span class=cl> |-do_sys_open()                     # 实际工作，返回索引
</span></span><span class=line><span class=cl>   |-build_open_flags()              # 检测传入的flag合法性，并转换为内核的格式struct open_flags
</span></span><span class=line><span class=cl>   |-getname()                       # 1. 将用户空间的路径名复制到内核空间，此时申请了内核内存
</span></span><span class=line><span class=cl>   | |-getname_flags()               #    主要的处理函数
</span></span><span class=line><span class=cl>   |-get_unused_fd_flags()           # 2. 查找一个未使用的文件描述符
</span></span><span class=line><span class=cl>   |-do_filp_open()                  # 3. 完成路径搜索并打开文件
</span></span><span class=line><span class=cl>   | |-path_openat()                 #    实际返回struct file结构体
</span></span><span class=line><span class=cl>   |   |-get_empty_filep()
</span></span><span class=line><span class=cl>   |   |-path_init()
</span></span><span class=line><span class=cl>   |   |-link_path_walk()
</span></span><span class=line><span class=cl>   |   |-do_last()                   #    打开文件的最后一步
</span></span><span class=line><span class=cl>   |     |-may_open()                #    进行权限检查
</span></span><span class=line><span class=cl>   |     |-vfs_open()
</span></span><span class=line><span class=cl>   |     | |-do_dentry_open()        ### 真正的针对文件系统的操作
</span></span><span class=line><span class=cl>   |     |-open_check_o_direct()     # 通过f-&gt;f_flags &amp; O_DIRECT判断
</span></span><span class=line><span class=cl>   |-fsnotify_open()                 # 4. 通过fsnotify机制唤醒文件系统中的监控进程
</span></span><span class=line><span class=cl>   |-fd_install()                    # 5. 为该文件描述符安装文件，设置current-&gt;files-&gt;fd[fd]=file
</span></span><span class=line><span class=cl>   |-putname()                       # 6. 释放之前申请的内核内存
</span></span></code></pre></div><p>在开始，sys_open() 会检测是否要强制支持大文件，在 64 位系统上 flags 会自动加上 O_LARGEFILE ，对于 32 位系统，文件最大受索引节点中表示文件大小的 32-bit 的 i_size 的影响，只能访问 2^32 字节，即 4GB ，而实际高位一般不用，所以通常只有 2G 。</p><p>加上 O_LAGEFILE 之后启用索引节点的 i_dir_acl 字段也可以一起表示文件的大小了，这样位数就变成了 64 位，也就是单文件最大为 2^64=16TB 。</p><p>do_last() 是文件打开操作的最后一步，其中很大一部分是针对 flag 的判断操作，关于 flags 的含义可以参考 man 2 open，该函数最终会调用 vfs_open() 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>vfs_open</span><span class=p>(</span><span class=k>const</span> <span class=k>struct</span> <span class=n>path</span> <span class=o>*</span><span class=n>path</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>filp</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=k>const</span> <span class=k>struct</span> <span class=n>cred</span> <span class=o>*</span><span class=n>cred</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>inode</span> <span class=o>=</span> <span class=n>path</span><span class=o>-&gt;</span><span class=n>dentry</span><span class=o>-&gt;</span><span class=n>d_inode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_op</span><span class=o>-&gt;</span><span class=n>dentry_open</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_op</span><span class=o>-&gt;</span><span class=nf>dentry_open</span><span class=p>(</span><span class=n>path</span><span class=o>-&gt;</span><span class=n>dentry</span><span class=p>,</span> <span class=n>filp</span><span class=p>,</span> <span class=n>cred</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>filp</span><span class=o>-&gt;</span><span class=n>f_path</span> <span class=o>=</span> <span class=o>*</span><span class=n>path</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>do_dentry_open</span><span class=p>(</span><span class=n>filp</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>cred</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>inode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>inode_operations</span>   <span class=o>*</span><span class=n>i_op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>对于 ext4，可以通过 cd fs/ext4 && grep -rne &lsquo;^const.*ext4.*inode_operations&rsquo; 查看，而 dentry_open() 指针并不存在，实际上会调用 do_dentry_open() 函数。</p><p>在 do_dentry_open() 中，会分配一个全新的 struct file 结构体，打开时会根据路径判断所属的文件系统，并执行具体类型的 open() 操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>do_dentry_open</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>f</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>open</span><span class=p>)(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=p>,</span> <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>),</span>
</span></span><span class=line><span class=cl>              <span class=k>const</span> <span class=k>struct</span> <span class=n>cred</span> <span class=o>*</span><span class=n>cred</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=nf>path_get</span><span class=p>(</span><span class=o>&amp;</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>f_path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>inode</span> <span class=o>=</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>f_inode</span> <span class=o>=</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>f_path</span><span class=p>.</span><span class=n>dentry</span><span class=o>-&gt;</span><span class=n>d_inode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>-&gt;</span><span class=n>f_mapping</span> <span class=o>=</span> <span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_mapping</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>-&gt;</span><span class=n>f_op</span> <span class=o>=</span> <span class=nf>fops_get</span><span class=p>(</span><span class=n>inode</span><span class=o>-&gt;</span><span class=n>i_fop</span><span class=p>);</span>                 <span class=c1>// 后续的操作都使用该行指定的操作
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>unlikely</span><span class=p>(</span><span class=nf>WARN_ON</span><span class=p>(</span><span class=o>!</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>f_op</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENODEV</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>cleanup_all</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=nf>security_file_open</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>cred</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>cleanup_all</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=nf>break_lease</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>f_flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>cleanup_all</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>open</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>open</span> <span class=o>=</span> <span class=n>f</span><span class=o>-&gt;</span><span class=n>f_op</span><span class=o>-&gt;</span><span class=n>open</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>open</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span> <span class=n>f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>cleanup_all</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>dentry</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>d_inode</span><span class=p>;</span>      <span class=cm>/* Where the name belongs to - NULL is negative */</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>path</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>vfsmount</span> <span class=o>*</span><span class=n>mnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>dentry</span> <span class=o>*</span><span class=n>dentry</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>file</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>path</span>     <span class=n>f_path</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span>    <span class=o>*</span><span class=n>f_op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>对于后续的 read()、write() 操作，实际调用的是 struct file_operations 指定的接口，如上述的 open() 函数接口，也就是 inode->i_fop 指定的值。</p><p>另外，可以参考 <a href=http://blog.chinaunix.net/uid-20522771-id-4419666.html>Linux 系统调用 open 七日游</a> 相当不错的介绍文件系统打开的过程。</p><a class=anchor id=sys_read></a><h2>sys_read <a href=#sys_read aria-hidden=true>#</a></h2><p>sys_read() 会根据用户空间传入的文件描述符 fd 取出对应的 struct file 结构体，获取 struct file 结构体的当前偏移量指针，从文件读取内容，存放到用户空间内存区，如果读取成功，唤醒相关等待进程，更新文件的当前指针，如果需要则释放对 file 结构的引用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sys_read()
</span></span><span class=line><span class=cl> |-fdget_pos()                        # 1. 通过fd获取struct file结构
</span></span><span class=line><span class=cl> |-file_pos_read()                    # 2. 获取当前的偏移量，也即file-&gt;f_pos
</span></span><span class=line><span class=cl> |-vfs_read()                         # 3. 调用VFS接口
</span></span><span class=line><span class=cl>   |-file-&gt;f_op-&gt;read()               # 3.1 如果指针存在
</span></span><span class=line><span class=cl>   |-do_sync_read()                   # 如果是异步读
</span></span><span class=line><span class=cl>     |-wait_on_sync_kiocb()           # 等待数据传输完成
</span></span></code></pre></div><p>通过 fdget_pos() 返回当前进程下标为 fd (文件描述符) 的 struct file 结构体，其中 current 为当前进程 task_struct，实际返回 current -> files_struct -> fdtable -> file[fd] 这个 struct file 结构体。</p><p>在此之前，以及通过 sys_open() 把进程的这个 fd 对应的文件从硬盘上读取或创建好了，所以这里可以之前从数组里面读取。注意，该函数同时会将 file->file_opeeration 设置为 inode->file_operation 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>vfs_read</span><span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>count</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=n>pos</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>ret</span> <span class=o>=</span> <span class=nf>rw_verify_area</span><span class=p>(</span><span class=n>READ</span><span class=p>,</span> <span class=n>file</span><span class=p>,</span> <span class=n>pos</span><span class=p>,</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span> <span class=o>=</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_op</span><span class=o>-&gt;</span><span class=n>read</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>f_op</span><span class=o>-&gt;</span><span class=nf>read</span><span class=p>(</span><span class=n>file</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>count</span><span class=p>,</span> <span class=n>pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>f_op</span><span class=o>-&gt;</span><span class=n>aio_read</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nf>do_sync_read</span><span class=p>(</span><span class=n>file</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>count</span><span class=p>,</span> <span class=n>pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>=</span> <span class=nf>new_sync_read</span><span class=p>(</span><span class=n>file</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=n>count</span><span class=p>,</span> <span class=n>pos</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>fsnotify_access</span><span class=p>(</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=nf>add_rchar</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=n>ret</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>inc_syscr</span><span class=p>(</span><span class=n>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>file</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>file_operations</span>    <span class=o>*</span><span class=n>f_op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>file_operations</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>ssize_t</span> <span class=p>(</span><span class=o>*</span><span class=n>read</span><span class=p>)</span> <span class=p>(</span><span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=p>,</span> <span class=kt>char</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=kt>size_t</span><span class=p>,</span> <span class=kt>loff_t</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>获取偏移量之后会调用 vfs_read()，该函数会把内核读取的文件内容存入 buf 指向的内存地址。如果是同步读，则会直接调用 file->f_op 对应的 read()，也就是直接调用 inode 对应的文件操作。</p><p>如果是异步，也即 f_op 中存在 aio_read() 函数，则会调用 do_sync_read() 。该函数首先会将 buf 和 len 保存，以供后续向用户空间传递数据。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#virtual-file-system-vfs>Virtual File System, VFS</a><ul><li><a href=#数据结构>数据结构</a></li><li><a href=#dentry-和-inode-的关系>dentry 和 inode 的关系</a></li></ul></li><li><a href=#文件系统>文件系统</a><ul><li><a href=#数据结构-1>数据结构</a></li></ul></li><li><a href=#文件系统注册>文件系统注册</a></li><li><a href=#mount-挂载>Mount 挂载</a><ul><li><a href=#挂载过程>挂载过程</a></li></ul></li><li><a href=#系统调用>系统调用</a><ul><li><a href=#sys_open>sys_open</a></li><li><a href=#sys_read>sys_read</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>