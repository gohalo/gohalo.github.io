<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Kernel 调度系统 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级和高优先级进程的需要尽可能调和等等。
什么时候以怎样的方式选择一个进程运行，就是所谓的调度策略 (Scheduling Policy)。
本文中，介绍下 Linux Kernel 中时如何实现的。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Kernel 调度系统</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2013-06-21</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>操作系统的调度算法必须实现几个互相冲突的目标：进程响应时间尽可能快，后台作业的吞吐量尽可能高，进程的饥饿现象尽可能避免，低优先级和高优先级进程的需要尽可能调和等等。</p><p>什么时候以怎样的方式选择一个进程运行，就是所谓的调度策略 (Scheduling Policy)。</p><p>本文中，介绍下 Linux Kernel 中时如何实现的。</p><a class=anchor id=调度器></a><h1>调度器 <a href=#%e8%b0%83%e5%ba%a6%e5%99%a8 aria-hidden=true>#</a></h1><p>Linux 的调度算法通过模块的方式实现，每种类型的调度器会有一个优先级，调度时会按照优先级遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行的那个程序。</p><a class=anchor id=调度类型></a><h2>调度类型 <a href=#%e8%b0%83%e5%ba%a6%e7%b1%bb%e5%9e%8b aria-hidden=true>#</a></h2><p>目前 Linux 中主要有两大类调度算法，CFS (完全公平调度算法) 以及 实时调度算法，在应用中，可以通过 <code>sched_setscheduler()</code> 函数修改进程的调度策略，目前有 5 种调度策略：</p><ul><li>SCHED_NORMAL<br>最常用的，调度策略主要用于 CFS 调度，存在静态优先级和动态优先级。</li><li>SCHED_BATCH<br>除了不能抢占外，与上相同，可让任务延长执行的时间 (time slice)，减小上下文切换的次数，以提高 cache 的利用率 (每次 context-switch 都会导致 cache-flush)。<br>该调度策略适用于周期批量执行的任务，而不适合交互性的产品，主要是由于任务的切换延迟，让人感觉系统性能不佳。</li><li>SCHED_IDLE<br>它甚至比 nice 19 还弱，用于空闲时需要处理的任务。</li><li>SCHED_RR<br>多次循环调度，拥有时间片，结束后会放在队列末尾。</li><li>SCHED_FIFO<br>先进先出规则，一次机会做完，没有时间片可以运行任意长的时间。</li></ul><p>其中前面三种策略使用的是 CFS 调度器类，后面两种使用 RT 调度器类。任何时候，实时进程的优先级都高于普通进程，实时进程只会被更高级的实时进程抢占。</p><a class=anchor id=调度时机></a><h2>调度时机 <a href=#%e8%b0%83%e5%ba%a6%e6%97%b6%e6%9c%ba aria-hidden=true>#</a></h2><p>Linux 调度时机主要有：</p><ol><li>进程状态转换的时刻：进程终止、进程睡眠；<br>进程调用 <code>sleep()</code> 或 <code>exit()</code> 等进行状态转换，此时会主动调用调度程序进行进程调度；</li><li>当前进程的时间片用完时（current->counter=0）<br>由于进程的时间片是由时钟中断来更新的，因此，这种情况和时机 4 是一样的。</li><li>设备驱动程序<br>当设备驱动程序执行长而重复的任务时，直接调用调度程序。在每次反复循环中，驱动程序都检查 <code>need_resched</code> 的值，如果必要，则调用调度程序 <code>schedule()</code> 主动放弃 CPU 。</li><li>进程从中断、异常及系统调用返回到用户态时<br>如前所述，不管是从中断、异常还是系统调用返回，最终都调用 <code>ret_from_sys_call()</code>，由这个函数进行调度标志的检测，如果必要，则调用调用调度程序。</li></ol><p>对于最后一条，那么为什么从系统调用返回时要调用调度程序呢？这主要是从效率考虑，从系统调用返回意味着要离开内核态而返回到用户态，而状态的转换要花费一定的时间，因此，在返回到用户态前，系统把在内核态该处理的事全部做完。</p><a class=anchor id=smp-负载均衡></a><h2>SMP 负载均衡 <a href=#smp-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1 aria-hidden=true>#</a></h2><p>在目前的 CFS 调度器中，每个 CPU 维护本地 RQ 所有进程的公平性，为了实现跨 CPU 的调度公平性，CFS 必须定时进行 load balance，将一些进程从繁忙的 CPU 的 RQ 中移到其他空闲的 RQ 中。</p><p>这个 load balance 的过程需要获得其它 RQ 的锁，这种操作降低了多运行队列带来的并行性。当然，load balance 引入的加锁操作依然比全局锁的代价要低，这种代价差异随着 CPU 个数的增加而更加显著。</p><p>但是，如果系统中的 CPU 个数有限，多 RQ 的优势便不明显了；而采用单一队列，每一个需要调度的新进程都可以在全局范围内查找最合适的 CPU ，而无需 CFS 那样等待 load balance 代码来决定，这减少了多 CPU 之间裁决的延迟，最终的结果是更小的调度延迟。</p><p>也就是说，CFS 为了维护多 CPU 上的公平性，所采用的负载平衡机制，可能会抵消了 per cpu queue 曾带来的好处。</p><a class=anchor id=cfs-完全公平调度></a><h1>CFS 完全公平调度 <a href=#cfs-%e5%ae%8c%e5%85%a8%e5%85%ac%e5%b9%b3%e8%b0%83%e5%ba%a6 aria-hidden=true>#</a></h1><p>Completely Fair Schedule, CFS 在 2.6.23 引入，同时包括了模块化、完全公平调度、组调度等一系列特性；按作者的说法：CFS 80% 的工作可以用一句话来概括，<strong>CFS 在真实的硬件上模拟了理想且精确的多任务处理器</strong>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>80% of CFS&#39;s design can be summed up in a single sentence: CFS basically models
</span></span><span class=line><span class=cl>an &#34;ideal, precise multi-tasking CPU&#34; on real hardware.
</span></span></code></pre></div><p>关于 CFS 的简单介绍可以查看内核文档 <a href=https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt>sched-design-CFS.txt</a> 。</p><a class=anchor id=简介></a><h2>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h2><p>该模型是从 RSDL/SD 中吸取了完全公平的思想，不再跟踪进程的睡眠时间，也不再企图区分交互式进程，它将所有的进程都统一对待，在既定的时间内每个进程都获得了公平的 CPU 占用时间，调度的依据就是每个进程的权重，这就是公平的含义。</p><p>为了实现完全公平调度，内核引入了虚拟时钟（virtual clock）的概念，统计进程已经运行的时间采用虚拟运行时间 (virtual runtime)，该值与具体的时钟晶振没有关系，只是为了公平分配 CPU 时间而提出的一种时间量度。</p><p>vt 是递增的，该值与其实际的运行时间成正比，与权重成反比；也就是说权重越高，对应的优先级越高，进而该进程虚拟时钟增长的就慢。权重的计算与静态优先级相关，该值在 <code>set_load_weight()</code> 函数中设置。</p><p>注意，优先级和权重之间的关系并不是简单的线性关系，内核使用一些经验数值来进行转化。</p><p>如上所述，这就意味着，vt 用来作为对进程进行排序的参考，而不能用来反映进程真实执行时间。</p><a class=anchor id=faqs></a><h2>FAQs <a href=#faqs aria-hidden=true>#</a></h2><p>CFS 的基本原理是在一个调度周期 (sched_latency_ns) 内让每个进程至少有机会运行一次，也就是说每个进程等待 CPU 的最长时间不超过这个调度周期。</p><p>然后根据进程的数量平分这个调度周期内的 CPU 使用权，由于进程的优先级 (nice) 不同，分割调度周期的时候要加权；每个进程的累计运行时间保存在自己的 vruntime 字段里，哪个进程的 vruntime 最小就获得本轮运行的权利。</p><a class=anchor id=新进程vruntime的初始值是0></a><h4>新进程vruntime的初始值是0？ <a href=#%e6%96%b0%e8%bf%9b%e7%a8%8bvruntime%e7%9a%84%e5%88%9d%e5%a7%8b%e5%80%bc%e6%98%af0 aria-hidden=true>#</a></h4><p>假如新进程 vruntime 的初值为 0 的话，也就是比老进程的值小很多，那么它在相当长的时间内都会保持抢占 CPU 的优势，老进程就要饿死了，这显然是不公平的。</p><p>所以 CFS 为每个 CPU 的运行队列 cfs_rq 维护了一个 min_vruntime 字段，记录该运行队列中所有进程的最小 vruntime 值，新进程的初始 vruntime 值就以其所在运行队列的 min_vruntime 为基础来设置，与老进程保持在合理的差距范围内。</p><a class=anchor id=休眠进程的vruntime一直保持不变吗></a><h4>休眠进程的vruntime一直保持不变吗？ <a href=#%e4%bc%91%e7%9c%a0%e8%bf%9b%e7%a8%8b%e7%9a%84vruntime%e4%b8%80%e7%9b%b4%e4%bf%9d%e6%8c%81%e4%b8%8d%e5%8f%98%e5%90%97 aria-hidden=true>#</a></h4><p>如果休眠进程的 vruntime 保持不变，而其它运行进程的 vruntime 一直在增加，那么休眠进程唤醒时，由于其 vruntime 相比要小很多，就会使它获得长时间抢占 CPU 的优势，从而导致其它进程饿死。</p><p>为此，CFS 会在休眠进程被唤醒时重新设置 vruntime 值，以 min_vruntime 值为基础，并进行一定的补偿。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>place_entity</span><span class=p>(</span><span class=k>struct</span> <span class=n>cfs_rq</span> <span class=o>*</span><span class=n>cfs_rq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sched_entity</span> <span class=o>*</span><span class=n>se</span><span class=p>,</span> <span class=kt>int</span> <span class=n>initial</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>u64</span> <span class=n>vruntime</span> <span class=o>=</span> <span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>min_vruntime</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * The &#39;current&#39; period is already promised to the current tasks,
</span></span></span><span class=line><span class=cl><span class=cm>     * however the extra weight of the new task will slow them down a
</span></span></span><span class=line><span class=cl><span class=cm>     * little, place the new task so that it fits in the slot that
</span></span></span><span class=line><span class=cl><span class=cm>     * stays open at the end.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>initial</span> <span class=o>&amp;&amp;</span> <span class=nf>sched_feat</span><span class=p>(</span><span class=n>START_DEBIT</span><span class=p>))</span>  <span class=cm>/* initial表示新进程 */</span>
</span></span><span class=line><span class=cl>        <span class=n>vruntime</span> <span class=o>+=</span> <span class=nf>sched_vslice</span><span class=p>(</span><span class=n>cfs_rq</span><span class=p>,</span> <span class=n>se</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* sleeps up to a single latency don&#39;t count. */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>initial</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* 休眠进程 */</span>
</span></span><span class=line><span class=cl>        <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>thresh</span> <span class=o>=</span> <span class=n>sysctl_sched_latency</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * Halve their sleep time&#39;s effect, to allow
</span></span></span><span class=line><span class=cl><span class=cm>         * for a gentler effect of sleepers:
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>sched_feat</span><span class=p>(</span><span class=n>GENTLE_FAIR_SLEEPERS</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=n>thresh</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>vruntime</span> <span class=o>-=</span> <span class=n>thresh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* ensure we never gain time by being placed backwards. */</span>
</span></span><span class=line><span class=cl>    <span class=n>se</span><span class=o>-&gt;</span><span class=n>vruntime</span> <span class=o>=</span> <span class=nf>max_vruntime</span><span class=p>(</span><span class=n>se</span><span class=o>-&gt;</span><span class=n>vruntime</span><span class=p>,</span> <span class=n>vruntime</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=休眠进程在唤醒时会立刻抢占cpu吗></a><h4>休眠进程在唤醒时会立刻抢占CPU吗？ <a href=#%e4%bc%91%e7%9c%a0%e8%bf%9b%e7%a8%8b%e5%9c%a8%e5%94%a4%e9%86%92%e6%97%b6%e4%bc%9a%e7%ab%8b%e5%88%bb%e6%8a%a2%e5%8d%a0cpu%e5%90%97 aria-hidden=true>#</a></h4><p>这由 CFS 的唤醒抢占特性决定，也即 sched_features 的 WAKEUP_PREEMPT 位。</p><p>由于休眠进程在唤醒时会获得 vruntime 的补偿，所以在醒来时抢占 CPU 是大概率事件，这也是 CFS 调度算法的本意，即保证交互式进程的响应速度，因为交互式进程等待用户输入会频繁休眠。</p><a class=anchor id=进程占用的cpu时间片可以无穷小吗></a><h4>进程占用的CPU时间片可以无穷小吗？ <a href=#%e8%bf%9b%e7%a8%8b%e5%8d%a0%e7%94%a8%e7%9a%84cpu%e6%97%b6%e9%97%b4%e7%89%87%e5%8f%af%e4%bb%a5%e6%97%a0%e7%a9%b7%e5%b0%8f%e5%90%97 aria-hidden=true>#</a></h4><p>假设有两个进程，它们的 vruntime 初值一样，当其中的一个进程运行后，它的 vruntime 就比另外的进大了，那么正在运行的进程什么时候会被抢占呢？</p><p>答案是：为了避免进程切换过于频繁造成太大的资源消耗，CFS 设定了进程占用 CPU 的最小时间值 (sched_min_granularity_ns)，正在 CPU 上运行的进程如果不足这个时间是不可以被调离 CPU 的。</p><p>另外，CFS 默认会把调度周期 sched_latency_ns 按照进程的数量平分，给每个进程平均分配相同的 CPU 时间片，但是如果进程数量太多的话，就会造成 CPU 时间片太小，如果小于上述的最小值，那么就以最小值为准，而调度周期也不再遵守 sched_latency_ns 。</p><a class=anchor id=进程切换cpu时vruntime会不会改变></a><h4>进程切换CPU时vruntime会不会改变？ <a href=#%e8%bf%9b%e7%a8%8b%e5%88%87%e6%8d%a2cpu%e6%97%b6vruntime%e4%bc%9a%e4%b8%8d%e4%bc%9a%e6%94%b9%e5%8f%98 aria-hidden=true>#</a></h4><p>在 SMP 系统上，当 CPU 的负载不同时会进行负载均衡，而每个 CPU 都有自己的运行队列，而每个队列中的 vruntime 也各不相同，比如可以对比下每个运行队列的 min_vruntime 值：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># grep min_vruntime /proc/sched_debug
</span></span><span class=line><span class=cl>  .min_vruntime                  : 526279705.695991
</span></span><span class=line><span class=cl>  .min_vruntime                  : 532370994.256253
</span></span><span class=line><span class=cl>  .min_vruntime                  : 720871453.830955
</span></span><span class=line><span class=cl>  .min_vruntime                  : 692323575.852029
</span></span></code></pre></div><p>显然，如果对 vruntime 不做处理直接切换，必然会导致不公平。</p><p>当进程从一个 CPU 的中出队 (dequeue_entity) 时，它的 vruntime 要减去队列的 min_vruntime 值；而当进程加入另一个 CPU 的运行队列 (enqueue_entiry) 时，它的 vruntime 要加上该队列的 min_vruntime 值。</p><p>这样，进程从一个 CPU 迁移到另一个 CPU 之后 vruntime 保持相对公平。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>dequeue_entity</span><span class=p>(</span><span class=k>struct</span> <span class=n>cfs_rq</span> <span class=o>*</span><span class=n>cfs_rq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sched_entity</span> <span class=o>*</span><span class=n>se</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * Normalize the entity after updating the min_vruntime because the
</span></span></span><span class=line><span class=cl><span class=cm>         * update can refer to the -&gt;curr item and we need to reflect this
</span></span></span><span class=line><span class=cl><span class=cm>         * movement in our normalized position.
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>DEQUEUE_SLEEP</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>se</span><span class=o>-&gt;</span><span class=n>vruntime</span> <span class=o>-=</span> <span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>min_vruntime</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=nf>enqueue_entity</span><span class=p>(</span><span class=k>struct</span> <span class=n>cfs_rq</span> <span class=o>*</span><span class=n>cfs_rq</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sched_entity</span> <span class=o>*</span><span class=n>se</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * Update the normalized vruntime before updating min_vruntime
</span></span></span><span class=line><span class=cl><span class=cm>         * through callig update_curr().
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ENQUEUE_WAKEUP</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>ENQUEUE_WAKING</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>se</span><span class=o>-&gt;</span><span class=n>vruntime</span> <span class=o>+=</span> <span class=n>cfs_rq</span><span class=o>-&gt;</span><span class=n>min_vruntime</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=源码解析></a><h1>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h1><p>接下来看看 Linux 中代码的实现。</p><a class=anchor id=相关结构体></a><h2>相关结构体 <a href=#%e7%9b%b8%e5%85%b3%e7%bb%93%e6%9e%84%e4%bd%93 aria-hidden=true>#</a></h2><p>Linux2.6.24 内核采用分层管理调度，也就是两层：第一层被称为核心调度器，在核心调度器下面为调度器类。调度算法实现相关的数据结构主要有运行实体 (struct rq)、调度类 (struct sched_class) 和运行队列。</p><p><img alt="scheduler stucture" src=images/scheduler_stucture.png class="mx-auto d-block"></p><p>首先是进程描述符中与调度相关的信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>task_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>prio</span><span class=p>,</span> <span class=n>static_prio</span><span class=p>,</span> <span class=n>normal_prio</span><span class=p>;</span>      <span class=c1>// 进程优先级
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>rt_priority</span><span class=p>;</span>                <span class=c1>// RT优先级
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>sched_class</span> <span class=o>*</span><span class=n>sched_class</span><span class=p>;</span>   <span class=c1>// 响应的调度类
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>sched_entity</span> <span class=n>se</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sched_rt_entity</span> <span class=n>rt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sched_dl_entity</span> <span class=n>dl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>policy</span><span class=p>;</span>                     <span class=c1>// 调度策略，默认为SCHED_NORMAL
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>cpumask_t</span> <span class=n>cpus_allowed</span><span class=p>;</span>                  <span class=c1>// 限制此进程在哪个处理器上运行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>就绪队列用于存储一些基本的用于调度的信息，包括实时调度的、CFS 调度的以及 DL 调度的，两者属于不同的调度实体，每个 CPU 会有一个 rq 结构体，也就是就绪队列。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>rq</span> <span class=p>{</span>                      <span class=c1>// @ kernel/sched/sched.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>spinlock_t</span> <span class=n>lock</span><span class=p>;</span>                     <span class=c1>// 锁
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>nr_running</span><span class=p>;</span>            <span class=c1>// 当前就绪对列进程的数目
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>load_weight</span> <span class=n>load</span><span class=p>;</span>             <span class=c1>// 当前就绪队列负荷
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>task_struct</span> <span class=o>*</span><span class=n>curr</span><span class=p>,</span> <span class=o>*</span><span class=n>idle</span><span class=p>;</span>     <span class=c1>// 分别指向当前以及空闲进程描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>cfs_rq</span> <span class=n>cfs</span><span class=p>;</span>                   <span class=c1>// 分别表示三个不同的就绪队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>rt_rq</span> <span class=n>rt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>dl_rq</span> <span class=n>dl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u64</span> <span class=n>clock</span><span class=p>;</span>                           <span class=c1>// 就绪队列的时钟，这个是周期更新的，真实的系统晶振时钟
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>cfs_rq</span> <span class=p>{</span>                  <span class=c1>// @ kernel/sched/sched.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>load_weight</span> <span class=n>load</span><span class=p>;</span>             <span class=c1>// 队列上所有进程的权重值weight总和
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>nr_running</span><span class=p>;</span>             <span class=c1>// 当前就绪队列的进程数=队列进程的总数+正在运行的那个进程
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>sched_entity</span> <span class=o>*</span><span class=n>curr</span><span class=p>;</span>           <span class=c1>// 指向当前进程的运行实体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>rb_root</span> <span class=n>tasks_timeline</span><span class=p>;</span>       <span class=c1>// 就绪队列的树跟
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>rb_node</span> <span class=o>*</span><span class=n>rb_leftmost</span><span class=p>;</span>         <span class=c1>// 保存红黑树最左边的节点，直接作为下一个运行进程
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>调度类 <code>sched_class</code> 为模块编程的上层支持，对于每个 Linux 新添加进来的调度算法都有自己的调度类实例，包括了 <code>fair_sched_class</code>、<code>rt_sched_class</code>、<code>dl_sched_class</code>、<code>idle_sched_class</code> 等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct sched_class {            // @ kernel/sched/sched.h
</span></span><span class=line><span class=cl>    const struct sched_class *next;                                           // 调度类组成单向链表
</span></span><span class=line><span class=cl>    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int wakeup);  // 向就绪队列插入进程
</span></span><span class=line><span class=cl>    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);   // 从就绪队列中删除
</span></span><span class=line><span class=cl>    void (*yield_task) (struct rq *rq);                                       // 进程主动放弃处理器
</span></span><span class=line><span class=cl>    void (*check_preempt_curr) (struct rq *rq, struct task_struct *p);        // 用一个新唤醒的进程抢占当前进程
</span></span><span class=line><span class=cl>    struct task_struct * (*pick_next_task) (struct rq *rq);                   // 选择下一个将要运行的进程
</span></span><span class=line><span class=cl>    void (*put_prev_task) (struct rq *rq, struct task_struct *p);
</span></span><span class=line><span class=cl>    void (*task_tick) (struct rq *rq, struct task_struct *p);                 // 由周期调度器调用
</span></span><span class=line><span class=cl>    void (*task_new) (struct rq *rq, struct task_struct *p);                  // 每次建立新进程调用此函数通知调度器
</span></span><span class=line><span class=cl>};
</span></span></code></pre></div><p>调度运行队列，也就是就绪队列，用于保存处于 ready 状态的进程，不同的调度算法使用不同的运行队列，对于 CFS 调度，运用的是红黑树；而对于实时调度为组链表。</p><p>运行实体，也就是调度单位，对应的结构为 <code>sched_entity</code>。调度器的调度单位不再是进程，而是可调度的实体，可以将多个进程捆绑在一起作为一个调度单位 (即调度实体) 进行调度，也就是说可调度实体可以是一个进程，也可以是多个进程构成的一个组。</p><p>另外，由于 CFS 不再有时间片的概念，但仍需要对每个进程运行的时间记账，从而确保每个进程只在公平分配给他的处理器时间内运行，相关信息同样保存在 sched_entity 中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct sched_entity {
</span></span><span class=line><span class=cl>    unsigned int        on_rq;                    // 是否在运行队列或正在执行，当前任务不会保存在红黑树中
</span></span><span class=line><span class=cl>    struct load_weight  load;                     // 该调度实体的权重，决定了运行时间以及被调用次数
</span></span><span class=line><span class=cl>    u64                 vruntime;                 // 存放进程的虚拟运行时间，用于调度器的选择
</span></span><span class=line><span class=cl>    u64                 exec_start                // 记录上次执行update_curr()的时间
</span></span><span class=line><span class=cl>    u64                 sum_exec_runtime;         // 进程总共执行的cpu clock，占用cpu的物理时间
</span></span><span class=line><span class=cl>    u64                 pre_sum_exec_runtime;     // 进程在切换经CPU时的sum_exec_runtime值
</span></span><span class=line><span class=cl>};
</span></span></code></pre></div><p>每个 <code>task_struct</code> 都嵌入了一个 <code>sched_entity</code>，这也就是为什么进程也是一个可调度实体。</p><a class=anchor id=代码实现></a><h2>代码实现 <a href=#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0 aria-hidden=true>#</a></h2><p>调度器的核心代码在 <code>kernel/sched</code> 目录下，包括 <code>sched_init()</code>、<code>schedule()</code>、<code>scheduler_tick()</code> 等，其中核心调度器包括了：</p><ul><li>周期性调度器，schedule_tick()<br>不负责进程的切换，只是定时更新调度相关的统计信息，以备主调度器使用。</li><li>主调度器，schedule()<br>完成进程的切换，将 CPU 的使用权从一个进程切换到另一个进程。</li></ul><p>我们知道在通过 <code>fork()</code>、<code>vfork()</code>、<code>clone()</code> 等函数时，进程创建最终都会调用 <code>do_fork()</code>，而该函数会调用 <code>copy_process()->sched_fork()</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>do_fork()
</span></span><span class=line><span class=cl> |-copy_process()
</span></span><span class=line><span class=cl> | |-security_task_create()
</span></span><span class=line><span class=cl> | |-dup_task_struct()
</span></span><span class=line><span class=cl> | |-sched_fork()
</span></span><span class=line><span class=cl> |-trace_sched_process_fork()
</span></span><span class=line><span class=cl> |-get_task_pid()
</span></span><span class=line><span class=cl> |-wake_up_new_task()
</span></span><span class=line><span class=cl> |-put_pid()
</span></span></code></pre></div><p>在 <code>sched_fork()</code> 函数中会复制父进程的优先级，并将 <code>fair_sched_class</code> 调度器类实例的地址赋给新进程中的 <code>sched_class</code> 指针。</p><a class=anchor id=scheduler_tick></a><h2>scheduler_tick() <a href=#scheduler_tick aria-hidden=true>#</a></h2><p><code>scheduler_tick()</code> 会以 HZ 为周期调度，用来更新运行队列的时钟及 load，然后调用当前进程的调度器类的周期调度函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>scheduler_tick()
</span></span><span class=line><span class=cl>  |-update_rq_clock()                 更新运行队列的时钟rq-&gt;clock
</span></span><span class=line><span class=cl>  |-curr-&gt;sched_class-&gt;task_tick()    执行调度器的周期性函数，以CFS为例
</span></span><span class=line><span class=cl>  | |-task_tick_fair()                CFS对应的task_tick()
</span></span><span class=line><span class=cl>  |   |-entity_tick()
</span></span><span class=line><span class=cl>  |     |-update_curr()
</span></span><span class=line><span class=cl>  |     |-update_cfs_shares()         对SMP有效
</span></span><span class=line><span class=cl>  |     |-check_preempt_tick()        检查当前进程是否运行了足够长的时间，是否需要抢占
</span></span><span class=line><span class=cl>  |-update_cpu_load_active()          更新运行队列load，将数组中先前存储的load向后移动一个位置，并插入新值
</span></span></code></pre></div><p>在 <code>update_cpu_load_active()</code> 中，更新运行队列的 load 本质是将数组中先前存储的负荷值向后移动一个位置，将当前负荷记入数组的第一个位置。</p><p>另外，<code>check_preempt_tick()</code> 函数用于检查当前进程是否运行了足够长的时间，如果超过了理想运行时间则无条件 resched；如果运行时间小于 <code>sysctl_sched_min_granularity</code> 那么也直接返回。</p><p>可以看到每个时钟都对会当前运行的 se 进行实质执行时间及虚拟执行时间进行更新，最后检查该进程是否运行的足够长的时间，如果是的话则将它置为 <code>TIF_NEED_RESCHED</code> 供主调度在适当的时机进行切换。</p><a class=anchor id=schedule></a><h2>schedule() <a href=#schedule aria-hidden=true>#</a></h2><p>核心调度函数为 <code>schedule()</code>，作为内核和其他部分用于调用进程调度器的入口，选择哪个进程可以运行，何时将其投入运行。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#调度器>调度器</a><ul><li><a href=#调度类型>调度类型</a></li><li><a href=#调度时机>调度时机</a></li><li><a href=#smp-负载均衡>SMP 负载均衡</a></li></ul></li><li><a href=#cfs-完全公平调度>CFS 完全公平调度</a><ul><li><a href=#简介>简介</a></li><li><a href=#faqs>FAQs</a></li></ul></li><li><a href=#源码解析>源码解析</a><ul><li><a href=#相关结构体>相关结构体</a></li><li><a href=#代码实现>代码实现</a></li><li><a href=#scheduler_tick>scheduler_tick()</a></li><li><a href=#schedule>schedule()</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>