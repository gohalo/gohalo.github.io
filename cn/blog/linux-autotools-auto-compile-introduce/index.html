<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux 自动编译 AutoTools | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。
这里简单介绍下 AutoTools 一系列工具的使用。
Autotools # 在 Linux 平台上，经常使用 configure-&amp;gt;make-&amp;gt;make install 从源码开始编译安装，也就是 GNU 构建系统，利用脚本和 make 程序在特定平台上编译软件，也就是利用 autotools 创建构建系统的项目。
注意，有些程序虽然也是采用上述的三步，但并未采用 autotools 实现，如 nginx 是作者编写的构建程序。
在 CentOS 中可以直接通过 yum install automake autoconf 安装相关的文件；利用 autotools 生成 Makefile 的过程如下图所示。
其中用到的核心工具包括了 Autoconf 和 Automake ，首先从用户和开发者角度看看两者的区别。关于 autotools 的简单处理流程可以参考 automake 中的 Setup Explained 内容。
用户视角 # configure 脚本是由软件开发者维护并发布给用户使用的 shell 脚本，该脚本作用是检测系统环境，最终目的是生成 Makefile 和 config.h 两个文件。
开发者在分发源码包时，除了源代码 (.c .h)，还有许多支撑软件构建的文件和工具，其中最重要的文件就是 Makefile.in 和 config.h.in 两个，在 configure 脚本执行成功后，将为每个 *."><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux 自动编译 AutoTools</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2015-11-30</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/c/cpp/ role=button>c/cpp</a></div></div><hr><div class=content><p>在 Linux 中，经常使用 GNU 构建系统，也就是利用脚本和 make 程序在特定平台上构建软件，这种方式几乎成为一种习惯，被广泛使用。</p><p>这里简单介绍下 AutoTools 一系列工具的使用。</p><a class=anchor id=autotools></a><h1>Autotools <a href=#autotools aria-hidden=true>#</a></h1><p>在 Linux 平台上，经常使用 <code>configure->make->make install</code> 从源码开始编译安装，也就是 GNU 构建系统，利用脚本和 make 程序在特定平台上编译软件，也就是利用 autotools 创建构建系统的项目。</p><p>注意，有些程序虽然也是采用上述的三步，但并未采用 autotools 实现，如 nginx 是作者编写的构建程序。</p><p>在 CentOS 中可以直接通过 <code>yum install automake autoconf</code> 安装相关的文件；利用 autotools 生成 Makefile 的过程如下图所示。</p><p><img alt=autotools src=images/autotools-process-1.png class="mx-auto d-block"></p><p>其中用到的核心工具包括了 Autoconf 和 Automake ，首先从用户和开发者角度看看两者的区别。关于 autotools 的简单处理流程可以参考 <a href=http://www.gnu.org/software/automake/manual/automake.html>automake</a> 中的 <code>Setup Explained</code> 内容。</p><a class=anchor id=用户视角></a><h2>用户视角 <a href=#%e7%94%a8%e6%88%b7%e8%a7%86%e8%a7%92 aria-hidden=true>#</a></h2><p><code>configure</code> 脚本是由软件开发者维护并发布给用户使用的 shell 脚本，该脚本作用是检测系统环境，最终目的是生成 Makefile 和 config.h 两个文件。</p><p>开发者在分发源码包时，除了源代码 (.c .h)，还有许多支撑软件构建的文件和工具，其中最重要的文件就是 Makefile.in 和 config.h.in 两个，在 configure 脚本执行成功后，将为每个 <code>*.in</code> 文件处理成对应的非 <code>*.in</code> 文件。</p><a class=anchor id=configure></a><h3>configure <a href=#configure aria-hidden=true>#</a></h3><p>configure 脚本会检查当前系统，而检查项的多少取决于开发者，一般来说，主要检查当前目标平台的程序、库、头文件、函数等的兼容性，而检查结果将作用于 config.h 和 Makefile 文件的生成，从而影响最终的编译。</p><p>用户可通过参数定制软件所需要包含的组件、安装路径等，一般会被五部分，可以通过 <code>--help</code> 参数查看当前软件提供了那些配置参数。</p><p>在 configure 在执行过程中，除了生成 Makefile 外，还会生成如下的临时文件：</p><ul><li>config.log 日志文件；</li><li>config.cache 缓存，以提高下一次 configure 的速度，需通过 -C 来指定才会生成；</li><li>config.status 实际调用编译工具构建软件的 shell 脚本。</li></ul><p>如果软件通过 libtool 构建，还会生成 libtool 脚本，关于 libtool 脚本如何生成，详见如下。</p><a class=anchor id=开发者视角></a><h2>开发者视角 <a href=#%e5%bc%80%e5%8f%91%e8%80%85%e8%a7%86%e8%a7%92 aria-hidden=true>#</a></h2><p>开发者除了编写软件本身的代码外，还需要负责生成构建软件所需要文件和工具，通过 autotools 工具可以解决一些常见的平台问题，但是编写依旧复杂。为了生成 configure 脚本和 Makefile.in 等文件，开发者需要创建并维护一个 configure.ac 文件，以及一系列的 Makefile.am 文件。</p><a class=anchor id=autoconf></a><h3>Autoconf <a href=#autoconf aria-hidden=true>#</a></h3><p>该工具用于生成一个可在类 Unix 系统下工作的 Shell 脚本，该脚本可在不同 *nix 平台下自动配置软件源代码包，也就是 configure 文件，生成脚本后与 autoconf 再无关系。</p><a class=anchor id=automake></a><h3>Automake <a href=#automake aria-hidden=true>#</a></h3><p>该工具通过 Makefile.am 文件自动生成 Makefile.in 文件，而 Makefile.am 基本上是一系列 make 宏定义，该文件需要手动编辑，也就是将对 Makefile 的编辑转义到了 Makefile.am 文件。</p><a class=anchor id=常见文件></a><h2>常见文件 <a href=#%e5%b8%b8%e8%a7%81%e6%96%87%e4%bb%b6 aria-hidden=true>#</a></h2><p>接下来看下一些常用的文件。</p><a class=anchor id=configureac></a><h4>configure.ac <a href=#configureac aria-hidden=true>#</a></h4><p>用于通过 autoconf 命令生成 configure 脚本，如下是一个 configure.ac 的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>AC_PREREQ([2.69])
</span></span><span class=line><span class=cl>AM_INIT_AUTOMAKE(hello, 1.0)
</span></span><span class=line><span class=cl>AC_INIT([hello], [1.0], [www.douniwan.com])
</span></span><span class=line><span class=cl>AC_CONFIG_SRCDIR([src/main.c])
</span></span><span class=line><span class=cl>AC_CONFIG_HEADERS([src/config.h])
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># Checks for programs.
</span></span><span class=line><span class=cl>AC_PROG_CC
</span></span><span class=line><span class=cl>AC_PROG_LIBTOOL
</span></span><span class=line><span class=cl># Checks for libraries.
</span></span><span class=line><span class=cl># Checks for header files.
</span></span><span class=line><span class=cl># Checks for typedefs, structures, and compiler characteristics.
</span></span><span class=line><span class=cl># Checks for library functions.
</span></span><span class=line><span class=cl>AC_CONFIG_FILES([Makefile                     # 主要是通过*.in模板生成响应的文件
</span></span><span class=line><span class=cl>                 src/Makefile
</span></span><span class=line><span class=cl>                 src/a/Makefile
</span></span><span class=line><span class=cl>                 src/b/Makefile])
</span></span><span class=line><span class=cl>AC_OUTPUT
</span></span></code></pre></div><p>以 <code>AC_</code> 开头的是一些宏调用，与 C 中的宏概念类似，会被替换展开；很多以 AC_PROG_XXX 开头的宏用于检查所需要的程序是否存在，详细可以查看 <a href=https://www.gnu.org/software/autoconf/manual/autoconf-2.69/html_node/Particular-Programs.html>Particular Program Checks</a>；对于一些特殊的函数或者文件则可以通过 <a href=https://www.gnu.org/software/autoconf/manual/autoconf-2.69/html_node/Generic-Programs.html>Generic Program and File Checks</a> 中定义的宏进行检查。</p><p>而 m4 是一个经典的宏工具，autoconf 正是构建在 m4 之上，可以简单理解为 autoconf 预先实现了大量用于检测系统可移植性的宏，这些宏在展开后就是大量的 shell 脚本。所以编写 configure.ac 需要对这些宏熟练掌握，并且合理调用，有时，甚至可以自己实现自己的宏。</p><a class=anchor id=configurescan></a><h4>configure.scan <a href=#configurescan aria-hidden=true>#</a></h4><p>通过 autoscan 命令可以得到一个初始化的 configure.scan 文件，然后重命名为 configure.ac 后，在此基础上编辑 configure.ac ，而 autoscan 通常 <strong>只用于首次初始化 configure.ac</strong> 。</p><p>autoscan 会扫描源码，并生成一些通用的宏调用、输入的声明以及输出的声明。</p><a class=anchor id=confighin></a><h4>config.h.in <a href=#confighin aria-hidden=true>#</a></h4><p>可以通过 autoheader 命令扫描 configure.ac 中的内容，并生成 config.h.in 文件；每当 configure.ac 文件有所变化，都可以再次执行 autoheader 更新 config.h.in 。</p><p>在 configure.ac 中通过 <code>AC_CONFIG_HEADERS([config.h])</code> 告诉 autoheader 应当生成 config.h.in 的路径；在最后的实际编译阶段，生成的编译命令会加上 <code>-DHAVE_CONFIG_H</code> 定义宏。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/bin/sh ../../libtool --tag=CC --mode=compile gcc -DHAVE_CONFIG_H ...
</span></span></code></pre></div><p>于是在代码中，可以通过下面代码安全的引用 config.h 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#ifdef HAVE_CONFIG_H
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;config.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>config.h 包含了大量的宏定义，其中包括软件包的名字等信息，程序可以直接使用这些宏；更重要的是，程序可以根据其中的对目标平台的可移植性相关的宏，通过条件编译，动态的调整编译行为。</p><a class=anchor id=makfileam></a><h4>Makfile.am <a href=#makfileam aria-hidden=true>#</a></h4><p>手工编写 Makefile 是一件相当烦琐的事情，而且，如果项目复杂的话，编写难度将越来越大；为此，可以通过 automake+Makefile.am 生成 Makefile.in 文件，通常一个 Makefile.am 的示例如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SUBDIRS         = a b
</span></span><span class=line><span class=cl>bin_PROGRAMS    = st
</span></span><span class=line><span class=cl>st_SOURCES      = main.c
</span></span><span class=line><span class=cl>st_LDADD        = $(top_builddir)/src/a/liba.la $(top_builddir)/src/b/libb.la
</span></span></code></pre></div><p>通过 SUBDIRS 声明了两个子目录，子目录的中的构建需要靠 a/Makefile.am 和 b/Makefile.am 来进行，这样多目录组织起来就方便多了。</p><p>bin_PROGRAMS 声明一个可执行文件，st_SOURCES 指定所依赖的源代码文件，st_LDADD 声明了可执行文件在连接时，需要依赖的 Libtool 库文件。</p><p>由于 automake 晚于 autoconf，所以 automake 是作为 autoconf 的扩展来实现的，在 configure.ac 中需要通过声明 AM_INIT_AUTOMAKE 告诉 autoconf 需要配置和调用 automake 。</p><a class=anchor id=aclocal></a><h4>aclocal <a href=#aclocal aria-hidden=true>#</a></h4><p>如上所述，configure.ac 是依靠宏展开来得到 configure 的，因此，能否成功生成取决于宏定义能否找到；默认 autoconf 会从安装路径下来寻找事先定义好了宏，而对于像 automake、libtool 和 gettext 等第三方扩展宏，甚至是开发者自行编写的宏就一无所知了。</p><p>于是，存在这个工具 aclocal，将在 configure.ac 同一目录下生成 aclocal.m4，在扫描 configure.ac 的过程中，将第三方扩展和开发者自己编写的宏定义复制进去；这样，autoconf 在遇到不认识的宏时，就会从 aclocal.m4 中查找。</p><a class=anchor id=libtool></a><h4>libtool <a href=#libtool aria-hidden=true>#</a></h4><p>libtool 试图解决不同平台下库文件的差异，实际是一个 shell 脚本，实际工作过程中，调用了目标平台的 cc 编译器和链接器，以及给予合适的命令行参数，libtool 可以单独使用。</p><p>automake 支持 libtool 构建声明，在 Makefile.am 中，普通的库文件目标写作 xxx_LIBRARIES ：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>noinst_LIBRARIES = liba.a
</span></span><span class=line><span class=cl>liba_SOURCES = ao1.c ao2.c ao3.c
</span></span></code></pre></div><p>而对于 libtool 目标，写作 xxx_LTLIBRARIES，并以 .la 作为后缀声明库文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>noinst_LTLIBRARIES = liba.la
</span></span><span class=line><span class=cl>liba_la_SOURCES = ao1.c ao2.c ao3.c
</span></span></code></pre></div><p>在 configure.ac 中需要声明 LT_INIT：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>AM_INIT_AUTOMAKE([foreign])
</span></span><span class=line><span class=cl>LT_INIT
</span></span><span class=line><span class=cl>...
</span></span></code></pre></div><p>有时，如果要用到 libtool 中的某些宏，则推荐将这些宏复制到项目中。首先，通过 <code>AC_CONFIG_MACRO_DIR([m4])</code> 指定使用 m4 目录存放第三方宏；然后在最外层的 Makefile.am 中加入 <code>ACLOCAL_AMFLAGS = -I m4</code> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#autotools>Autotools</a><ul><li><a href=#用户视角>用户视角</a></li><li><a href=#开发者视角>开发者视角</a></li><li><a href=#常见文件>常见文件</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>