<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux IO 多路复用 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="通过 IO 多路复用技术，系统内核缓冲 IO 数据，当某个 IO 准备好后，系统通知应用程序该 IO 可读或可写，这样应用程序可以马上完成相应的 IO 操作，而不需要等待系统完成相应 IO 操作，从而应用程序不必因等待 IO 操作而阻塞。
这里简单介绍下 Linux 中 IO 多路复用的使用。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux IO 多路复用</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2015-09-12</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>通过 IO 多路复用技术，系统内核缓冲 IO 数据，当某个 IO 准备好后，系统通知应用程序该 IO 可读或可写，这样应用程序可以马上完成相应的 IO 操作，而不需要等待系统完成相应 IO 操作，从而应用程序不必因等待 IO 操作而阻塞。</p><p>这里简单介绍下 Linux 中 IO 多路复用的使用。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>在 Linux 中，会将很多资源通过文件描述符表示，包括了文件系统、网络、物理设备等等。</p><p>文件描述符就是一个整数，默认会选择最小未使用的数值，其中有三个比较固定，比较特殊的值，0 是标准输入，1 是标准输出，2 是标准错误输出。</p><p>0、1、2 是整数表示的，对应的 FILE* 结构的表示就是 stdin、stdout、stderr。</p><a class=anchor id=select></a><h2>select <a href=#select aria-hidden=true>#</a></h2><p>select 可以用来监视多个文件句柄的状态变化，程序会阻塞在 select 直到被监视的文件句柄有一个或多个发生了状态改变，然后通知应用程序，应用程序 <strong>轮询</strong> 所有的 FD 集合，判断监控的 FD 是否有事件发生，并作相应的处理。</p><p>select 相关的声明和宏，通过宏来设置参数，相应的执行流程如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int select(int maxfd, fd_set * readfds, fd_set * writefds, fd_set * exceptfds, struct timeval * timeout);
</span></span><span class=line><span class=cl>FD_CLR(inr fd, fd_set* set);                               // 清除描述词组set中相关fd的位
</span></span><span class=line><span class=cl>FD_ISSET(int fd, fd_set *set);                             // 用来测试描述词组set中相关fd的位是否为真
</span></span><span class=line><span class=cl>FD_SET(int fd, fd_set*set);                                // 用来设置描述词组set中相关fd的位
</span></span><span class=line><span class=cl>FD_ZERO(fd_set *set);                                      // 用来清除描述词组set的全部位
</span></span><span class=line><span class=cl>struct timeval {
</span></span><span class=line><span class=cl>   time_t tv_sec;
</span></span><span class=line><span class=cl>   time_t tv_usec;
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 调用流程
</span></span><span class=line><span class=cl>fd_set readfso;                                            // 1.1 定义需要监视的描述符
</span></span><span class=line><span class=cl>FD_ZERO(&amp;readfso);                                         // 1.2 清空
</span></span><span class=line><span class=cl>FD_SET(fd, &amp;readfso);                                      // 1.3 设置需要监控的描述符，如fd=1
</span></span><span class=line><span class=cl>while(1) {
</span></span><span class=line><span class=cl>    readfs = readfso;
</span></span><span class=line><span class=cl>    ret = select(maxfd+1, &amp;readfds, NULL, NULL, timeout);  // 2.1 监听所关注的事件，在此为监听读事件
</span></span><span class=line><span class=cl>    if (ret &gt; 0)                                           // 3.1.1 监听事件发生
</span></span><span class=line><span class=cl>        for (i = 0; i &gt; FD_SETSIZE; i++)                   // 3.1.2 需要遍历所有fd
</span></span><span class=line><span class=cl>            if (FD_ISSET(fd, &amp;readfds))
</span></span><span class=line><span class=cl>                handleEvent();
</span></span><span class=line><span class=cl>    else if (ret == 0)                                     // 3.2 超时
</span></span><span class=line><span class=cl>        handle timeout
</span></span><span class=line><span class=cl>    else if (ret &lt; 0)                                      // 3.3 发生错误
</span></span><span class=line><span class=cl>        handle error
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>在 select 函数中，各个参数的含义如下。</p><ul><li>maxfd 为最大文件描述符+1，因此在程序中需要知道最大描述符的值。</li><li>接着的三个参数分别设置所监听的读、写、异常事件对应的描述符。该值传入需要监控事件的描述符，返回值保存了发生了的事件对应的描述符。</li><li>设置超时时间，NULL 表示一直等待。</li></ul><p>返回值：成功则返回文件描述符状态已改变的总数；如果返回 0 代表在描述词状态改变前已超过 timeout 时间；当有错误发生时则返回 -1，错误原因存于 errno ，此时参数 readfds, writefds, exceptfds 和 timeout 的值变成不可预测。</p><p>在有返回值时，需要通过 FD_ISSET 循环遍历各个描述符，从而文件描述符越多，效率也就越低。而且，每次调用 select 时都需要重新设置需要监控的文件描述符。</p><p>fd_set 在 <code>sys/select.h</code> 中定义，大致可以简化为如下的结构，也就是实际用数组表示，其中每一位代表一个文件描述符，最大可以表示 1024 个，也就是说 select 能监视的描述符最大为 1024 。最大可以监控的文件描述符数可以通过 FD_SETSIZE 获得，描述符需要通过对应的宏来配置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=kt>int</span>  <span class=n>__fds_bits</span><span class=p>[</span><span class=nf>__FD_SETSIZE</span><span class=p>(</span><span class=mi>1024</span><span class=p>)</span> <span class=o>/</span> <span class=nf>__NFDBITS</span><span class=p>(</span><span class=mi>8</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>long</span> <span class=kt>int</span><span class=p>))];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>fd_set</span><span class=p>;</span>
</span></span></code></pre></div><a class=anchor id=poll></a><h2>poll <a href=#poll aria-hidden=true>#</a></h2><p>和 select() 不一样，poll() 没有使用低效的三个基于位的文件描述符 set ，而是采用了一个单独的结构体 pollfd 数组，由 fds 指针指向这个数组，采用链表保存文件描述符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct pollfd {
</span></span><span class=line><span class=cl>    int fd;              /* 文件描述符 */
</span></span><span class=line><span class=cl>    short events;        /* 等待的事件 */
</span></span><span class=line><span class=cl>    short revents;       /* 实际发生了的事件 */
</span></span><span class=line><span class=cl>} ;
</span></span><span class=line><span class=cl>typedef unsigned long   nfds_t;
</span></span><span class=line><span class=cl>int poll(struct pollfd *fds, nfds_t nfds, int timeout);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct pollfd fds[MAX_CONNECTION] = {0};
</span></span><span class=line><span class=cl>fds[0].fd = 0;
</span></span><span class=line><span class=cl>fds[0].events = POLLIN;
</span></span><span class=line><span class=cl>ret = poll(fds, sizeof(fds)/sizeof(struct pollfd), -1)
</span></span><span class=line><span class=cl>if (ret &gt; 0)
</span></span><span class=line><span class=cl>    for (int i = 0; i &lt; MAX_CONNECTION; i++)
</span></span><span class=line><span class=cl>        if (fds[0].revents &amp; POLLIN)
</span></span><span class=line><span class=cl>            handleEvent(allConnection[i]);
</span></span><span class=line><span class=cl>else if (ret == 0)
</span></span><span class=line><span class=cl>    handle timeout
</span></span><span class=line><span class=cl>else if (ret &gt; 0)
</span></span><span class=line><span class=cl>    handle error
</span></span></code></pre></div><p>fds 表示需要监控的文件描述符；nfds 表示 fds 的大小，也即需要监控的描述符数量。如果 fd 为负，则忽略 events，revents 返回 0。</p><p>返回值与 select 的返回值含义相同。</p><a class=anchor id=epoll></a><h1>epoll <a href=#epoll aria-hidden=true>#</a></h1><p>epoll 是 Linux 内核为处理大批量句柄而作了改进的 poll，是 Linux 下多路复用 IO 接口 select/poll 的增强版本，它能显著减少程序在大量并发连接中只有少量活跃的情况下的系统 CPU 利用率。</p><a class=anchor id=对比></a><h2>对比 <a href=#%e5%af%b9%e6%af%94 aria-hidden=true>#</a></h2><p>select 模型的缺点：</p><ul><li>最大并发数限制，因为一个进程所打开的文件描述符是有限制的，由 FD_SETSIZE 设置，默认值是 1024/2048 ，因此 select 模型的最大并发数就被相应限制了。</li><li>效率问题，每次 select 调用返回都需要线性扫描全部的 FD 集合，确定那个描述符发生了相应事件，这样效率就会呈现线性下降。</li><li>内核/用户空间内存拷贝问题，在通知用户事件发生时采用内存拷贝。</li><li>触发方式采用的是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符的 IO 操作，那么之后每次 select 调用还是会将这些文件描述符通知进程。</li></ul><p>对于 poll 而言，2 和 3 都没有改掉，相比来说，epoll 要好的多。</p><ul><li>epoll 没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于 2048, 一般来说这个数目和系统内存关系很大 ，具体数目可以在 /proc/sys/fs/epoll/max_user_watches 中查看。</li><li>效率提升，epoll 最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll 的效率就会远远高于 select 和 poll。</li><li>内存拷贝，epoll 在这点上使用了“共享内存”，这个内存拷贝也省略了。mmap 加速内核与用户空间的信息传递，epoll 是通过内核于用户空间 mmap 同一块内存，避免了无谓的内存拷贝。</li></ul><a class=anchor id=函数接口></a><h2>函数接口 <a href=#%e5%87%bd%e6%95%b0%e6%8e%a5%e5%8f%a3 aria-hidden=true>#</a></h2><p>epoll 相关的函数主要有如下三种，分别用于创建，注册、修改、删除，等待事件发生。</p><a class=anchor id=创建></a><h4>创建 <a href=#%e5%88%9b%e5%bb%ba aria-hidden=true>#</a></h4><p>创建 epoll 文件描述符，<code>int epoll_create (int size)</code> 。</p><p>需要注意的是，当创建好 epoll 句柄后，它就是会占用一个 fd 值，在 linux 下如果查看 <code>/proc/&lt;PID>/fd/</code>，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 close() 关闭，否则可能导致 fd 被耗尽。</p><p>调用成功则返回与实例关联的文件描述符，该文件描述符与真实的文件没有任何关系，仅作为接下来调用的函数的句柄，实际就是申请一个内核空间，用来保存所关注的 fd 上发生的时将。size 为了与之前兼容，应该大于 0 ，现在是动态分配，而非指定支持事件的数目。正常返回值大于 0；发生错误时，返回 -1，errno 表明错误类型。</p><a class=anchor id=修改></a><h4>修改 <a href=#%e4%bf%ae%e6%94%b9 aria-hidden=true>#</a></h4><p>控制文件描述符，<code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code> 。</p><p>类似于相对于 select 模型中的 FD_SET 和 FD_CLR 宏，用于注册、修改、删除；与 select 不同的是，select 在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p><p>其中 <strong>参数 epfd 是 epoll_create()</strong> 创建 epoll 专用的文件描述符；op 用于表示对应的操作(EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL)；fd 表示需要监控的描述符；event 表示需要监控的事件。</p><a class=anchor id=等待></a><h4>等待 <a href=#%e7%ad%89%e5%be%85 aria-hidden=true>#</a></h4><p>等待事件 <code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code>，内核通过 events 返回发生事件的集合，maxevents 告之内核最多可以返回的事件数，该函数返回需要处理的事件数目，如返回 0 表示已超时。</p><p>等待 IO 事件的发生，epfd 是由 epoll_create() 生成的 epoll 专用的文件描述符；epoll_event 用于回传事件发生对应的数组；maxevents 表示能处理的最多的事件数；timeout 等待 IO 事件发生的超时值，-1 表示永久。</p><p>epoll_wait() 首先判断参数的有效性，最后会调用 ep_epoll() 函数。epoll 不仅会告诉应用程序有 IO 事件到来，还会告诉应用程序相关的信息，这些信息是应用程序填充的，因此根据这些信息应用程序就能直接定位到事件，而不必遍历整个 FD 集合。</p><a class=anchor id=epoll-的使用></a><h2>epoll() 的使用 <a href=#epoll-%e7%9a%84%e4%bd%bf%e7%94%a8 aria-hidden=true>#</a></h2><p>如下是 epoll 使用的数据结构，执行过程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct epoll_event {
</span></span><span class=line><span class=cl>    __uint32_t events;      // Epoll events
</span></span><span class=line><span class=cl>    epoll_data_t data;      // User data variable
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>typedef union epoll_data {
</span></span><span class=line><span class=cl>    void *ptr;
</span></span><span class=line><span class=cl>    int fd;
</span></span><span class=line><span class=cl>    __uint32_t u32;
</span></span><span class=line><span class=cl>    __uint64_t u64;
</span></span><span class=line><span class=cl>} epoll_data_t;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct epoll_event event;
</span></span><span class=line><span class=cl>struct epoll_event *events;
</span></span><span class=line><span class=cl>int efd = epoll_create(1);                        // 1. 创建文件描述符，大于0即可，实际内核中动态分配
</span></span><span class=line><span class=cl>if (efd == -1 || error == 0)
</span></span><span class=line><span class=cl>    error
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>event.data.fd = fd;                               // 2.1 设置需要监听的fd
</span></span><span class=line><span class=cl>event.events = EPOLLIN | EPOLLET;                 // 2.2 设置需要监听的事件
</span></span><span class=line><span class=cl>ret = epoll_ctl(efd, EPOLL_CTL_ADD, 0, &amp;event)    // 2.3 可以添加、修改、删除
</span></span><span class=line><span class=cl>if (ret == -1)
</span></span><span class=line><span class=cl>    error
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>events = calloc(MAX_EVENTS, sizeof event);        // 3.1 申请内存，可返回的最大事件数
</span></span><span class=line><span class=cl>while (1) {
</span></span><span class=line><span class=cl>    n = epoll_wait(efd, events, MAX_EVENTS, -1);  // 3.2 等待事件发生
</span></span><span class=line><span class=cl>    if (n == 0)                                   // 3.3 超时
</span></span><span class=line><span class=cl>        timeout
</span></span><span class=line><span class=cl>    else if (n &lt; 0)                               // 3.4 发生错误
</span></span><span class=line><span class=cl>        if(EINTT == errno)                        // 3.5 由于中断，忽略
</span></span><span class=line><span class=cl>            n = 0; continue;
</span></span><span class=line><span class=cl>        else
</span></span><span class=line><span class=cl>            error
</span></span><span class=line><span class=cl>    else                                          // 3.6 处理发生的事件
</span></span><span class=line><span class=cl>        for(i = 0; i &amp;lt; n; i++)
</span></span><span class=line><span class=cl>            if (events[i].data.fd == fd)
</span></span><span class=line><span class=cl>                handleEvent
</span></span><span class=line><span class=cl>            else if (enents[i].events &amp; EPOLLIN)   // 某些事件发生
</span></span><span class=line><span class=cl>                //
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>free(events);
</span></span><span class=line><span class=cl>close(fd);
</span></span></code></pre></div><p>结构体 epoll_event 用于注册所感兴趣的事件和回传所发生待处理的事件。epoll_data 联合体用来保存触发事件相关的描述符所对应的信息，可以保存很多类型的信息，如 fd 、指针等等，有了它，应用程序就可以直接定位目标了。</p><p>对于 epoll_data ，如一个 client 连接到服务器时，服务器通过调用 accept 函数可以得到 client 对应的 socket 文件描述符，并通过 epoll_data 的 fd 字段返回。</p><p>epoll_event 结构体的 events 字段是表示感兴趣的事件和被触发的事件，可能的取值为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>EPOLLIN ：对应的文件描述符可以读；
</span></span><span class=line><span class=cl>EPOLLOUT：对应的文件描述符可以写；
</span></span><span class=line><span class=cl>EPOLLPRI：对应的文件描述符有紧急的数据可读；
</span></span><span class=line><span class=cl>EPOLLERR：对应的文件描述符发生错误；
</span></span><span class=line><span class=cl>EPOLLHUP：对应的文件描述符被挂断；
</span></span><span class=line><span class=cl>EPOLLET ：对应的文件描述符有事件发生。
</span></span></code></pre></div><a class=anchor id=内核实现></a><h1>内核实现 <a href=#%e5%86%85%e6%a0%b8%e5%ae%9e%e7%8e%b0 aria-hidden=true>#</a></h1><p>如下是与 epoll 相关的结构设计，先看下与结构体相关的结构图。</p><p><img alt="io epoll structure" src=images/io-epoll-structure.png class="mx-auto d-block"></p><p>其中 <code>struct epitem</code> 是 epoll 的基本单元，对于每一个事件，都会建立一个 epitem 结构体，下面分别介绍一下几个主要的变量的含义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct epitem{
</span></span><span class=line><span class=cl>    struct rb_node rbn;         // 红黑树节点
</span></span><span class=line><span class=cl>    struct list_head rdllink;   // 双向链表节点，当epitem对应fd已经ready时，会在ep_poll_callback()函数中将该
</span></span><span class=line><span class=cl>                                //   结点链接到eventpoll中的rdllist循环链表中去，这样就将ready的epitem都串连起来了
</span></span><span class=line><span class=cl>    struct epoll_filefd ffd;    // 事件句柄信息，包含了一个fd以及fd对应的file指针
</span></span><span class=line><span class=cl>    struct eventpoll *ep;       // 指向其所属的eventpoll对象，用于获取与epitem对应的eventpoll
</span></span><span class=line><span class=cl>    struct epoll_event event;   // 期待发生的事件类型，对应了epoll_ctl()中的指针，用于存储用户空间的epoll_event拷贝
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</span></span></code></pre></div><p>当某一进程调用 <code>epoll_create()</code> 方法时，内核会创建一个 <code>eventpoll</code> 结构体，这个结构体中有两个成员与 epoll 的使用方式密切相关。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct eventpoll{
</span></span><span class=line><span class=cl>    struct rb_root  rbr;        // 红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件
</span></span><span class=line><span class=cl>                                //   它的结点都为epitem变量，通过它可以很方便的增删改查epitem
</span></span><span class=line><span class=cl>    struct list_head rdlist;    // 双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件
</span></span><span class=line><span class=cl>                                //   链表中的每个结点即为epitem中的rdllink
</span></span><span class=line><span class=cl>};
</span></span></code></pre></div><p>每一个 epoll 对象都有一个独立的 <code>eventpoll</code> 结构体，用于存放通过 <code>epoll_ctl()</code> 方法向 epoll 对象中添加进来的事件，这些事件都会挂载在红黑树中。</p><p>而所有添加到 epoll 中的事件都会与设备+网卡驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中就是 <code>ep_poll_callback()</code> 它会将发生的事件添加到 rdlist 双链表中。</p><p>接着再看下 <code>struct eppoll_entry</code> 结构体，它主要有这样几个变量：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>struct eppoll_entry {
</span></span><span class=line><span class=cl>    struct epitem *base;       // 指向其对应的epitem
</span></span><span class=line><span class=cl>    wait_queue_t wait;         // 等待队列的项，wait中有一个唤醒回调函数指针，该指针被初始化为ep_poll_callback
</span></span><span class=line><span class=cl>};
</span></span></code></pre></div><p>如上的 wait 成员会被挂在到设备的等待队列中，等待设备的唤醒，当设备因状态改变唤醒 wait 时，会执行 <code>ep_poll_callback</code>，而该函数会做这样一件事 <code>list_add_tail(&amp;epi->rdllink,&amp;ep->rdllist)</code> 。</p><a class=anchor id=初始化></a><h2>初始化 <a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 aria-hidden=true>#</a></h2><p>epoll 的几个接口实际都对应于 kernel 的 API ，主要位于 <code>fs/eventpoll.c</code> 文件中。在分析 epoll 时发现有 <code>fs_initcall()</code> 这样的调用，以此为例分析一下 Linux 的初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fs_initcall(eventpoll_init);                                      // fs/eventpoll.c
</span></span><span class=line><span class=cl>#define fs_initcall(fn) __define_initcall(fn, 5)                  // include/linux/init.h
</span></span><span class=line><span class=cl>#define __define_initcall(fn, id) \                               // 同上
</span></span><span class=line><span class=cl>      static initcall_t __initcall_##fn##id __used \
</span></span><span class=line><span class=cl>      __attribute__((__section__(&#34;.initcall&#34; #id &#34;.init&#34;))) = fn
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 最后展开为
</span></span><span class=line><span class=cl>static initcall_t __initcall_eventpoll_init5 __used
</span></span><span class=line><span class=cl>     __attribute__((__section__(&#34;.initcall5.init&#34;))) = eventpoll_init;
</span></span></code></pre></div><p>也就是在 <code>.initcall5.init</code> 段中定义了一个变量 <code>__initcall_eventpoll_init5</code> 并将改变量赋值为 <code>eventpoll_init</code>，内核中对初始化的调用过程如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>arch/x86/kernel/head_64.S
</span></span><span class=line><span class=cl> |-x86_64_start_kernel()                 arch/x86/kernel/head[64|32].c
</span></span><span class=line><span class=cl>   |-start_kernel()                      init/main.c
</span></span><span class=line><span class=cl>     |-rest_init()
</span></span><span class=line><span class=cl>       |-kernel_init()                   通过内核线程实现
</span></span><span class=line><span class=cl>         |-kernel_init_freeable()
</span></span><span class=line><span class=cl>           |-do_basic_setup()
</span></span><span class=line><span class=cl>             |-do_initcalls()
</span></span></code></pre></div><p>对于 epoll 来说，实际是在初始化过程中对变量进行初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>eventpoll_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sysinfo</span> <span class=n>si</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>si_meminfo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>si</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Allows top 4% of lomem to be allocated for epoll watches (per user).
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>max_user_watches</span> <span class=o>=</span> <span class=p>(((</span><span class=n>si</span><span class=p>.</span><span class=n>totalram</span> <span class=o>-</span> <span class=n>si</span><span class=p>.</span><span class=n>totalhigh</span><span class=p>)</span> <span class=o>/</span> <span class=mi>25</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>PAGE_SHIFT</span><span class=p>)</span> <span class=o>/</span>
</span></span><span class=line><span class=cl>        <span class=n>EP_ITEM_COST</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>BUG_ON</span><span class=p>(</span><span class=n>max_user_watches</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Initialize the structure used to perform epoll file descriptor
</span></span></span><span class=line><span class=cl><span class=cm>     * inclusion loops checks.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>ep_nested_calls_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>poll_loop_ncalls</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Initialize the structure used to perform safe poll wait head wake ups */</span>
</span></span><span class=line><span class=cl>    <span class=nf>ep_nested_calls_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>poll_safewake_ncalls</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Initialize the structure used to perform file&#39;s f_op-&gt;poll() calls */</span>
</span></span><span class=line><span class=cl>    <span class=nf>ep_nested_calls_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>poll_readywalk_ncalls</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * We can have many thousands of epitems, so prevent this from
</span></span></span><span class=line><span class=cl><span class=cm>     * using an extra cache line on 64-bit (and smaller) CPUs
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>BUILD_BUG_ON</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span> <span class=o>&lt;=</span> <span class=mi>8</span> <span class=o>&amp;&amp;</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>epitem</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>128</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Allocates slab cache used to allocate &#34;struct epitem&#34; items */</span>
</span></span><span class=line><span class=cl>    <span class=n>epi_cache</span> <span class=o>=</span> <span class=nf>kmem_cache_create</span><span class=p>(</span><span class=s>&#34;eventpoll_epi&#34;</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>epitem</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=mi>0</span><span class=p>,</span> <span class=n>SLAB_HWCACHE_ALIGN</span> <span class=o>|</span> <span class=n>SLAB_PANIC</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Allocates slab cache used to allocate &#34;struct eppoll_entry&#34; */</span>
</span></span><span class=line><span class=cl>    <span class=n>pwq_cache</span> <span class=o>=</span> <span class=nf>kmem_cache_create</span><span class=p>(</span><span class=s>&#34;eventpoll_pwq&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>eppoll_entry</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=n>SLAB_PANIC</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>主要是进行一些初始化配置，同时创建了 2 个内核 cache 用于存放 epitem 和 epoll_entry 。</p><a class=anchor id=创建对象></a><h2>创建对象 <a href=#%e5%88%9b%e5%bb%ba%e5%af%b9%e8%b1%a1 aria-hidden=true>#</a></h2><p>通过 <code>epoll_create()</code> 创建一个 epoll 实例，同时创建并初始化一个 <code>struct eventpoll</code>，其中返回值 epfd 所对应的 file 的 <code>private_data</code> 指针即指向了 <code>eventpoll</code> 变量，因此，知道 epfd 就可以拿到 file，即拿到了 <code>eventpoll</code> 变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE1</span><span class=p>(</span><span class=n>epoll_create</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span>  <span class=c1>// epoll_create函数带一个整型参数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>size</span> <span class=o>&lt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nf>sys_epoll_create1</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>          <span class=c1>// 实际上是调用epoll_create1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/* Open an eventpoll file descriptor.  */</span>
</span></span><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE1</span><span class=p>(</span><span class=n>epoll_create1</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>eventpoll</span> <span class=o>*</span><span class=n>ep</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=cm>/* Check the EPOLL_* constant for consistency.  */</span>
</span></span><span class=line><span class=cl>    <span class=nf>BUILD_BUG_ON</span><span class=p>(</span><span class=n>EPOLL_CLOEXEC</span> <span class=o>!=</span> <span class=n>O_CLOEXEC</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=o>~</span><span class=n>EPOLL_CLOEXEC</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Create the internal data structure (&#34;struct eventpoll&#34;).  */</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=nf>ep_alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=p>);</span>   <span class=c1>// 分配eventpoll结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>error</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=k>return</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Creates all the items needed to setup an eventpoll file. That is,
</span></span></span><span class=line><span class=cl><span class=cm>     * a file structure and a free file descriptor.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 创建与eventpoll结构体相对应的file结构，ep保存在file-&gt;private_data结构中，其中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// eventpoll_fops 为该文件所对应的操作函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>error</span> <span class=o>=</span> <span class=nf>anon_inode_getfd</span><span class=p>(</span><span class=s>&#34;[eventpoll]&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>eventpoll_fops</span><span class=p>,</span> <span class=n>ep</span><span class=p>,</span> <span class=n>O_RDWR</span> <span class=o>|</span> <span class=p>(</span><span class=n>flags</span> <span class=o>&amp;</span> <span class=n>O_CLOEXEC</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>error</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    	<span class=nf>ep_free</span><span class=p>(</span><span class=n>ep</span><span class=p>);</span>        <span class=c1>// 如果出错则释放该eventpoll结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><code>anon_inode_getfd()</code> 创建与 <code>struct eventpoll</code> 对应的 file 结构，其中 ep 保存在 <code>file->private_data</code> 结构中，同时为该新文件定义操作函数。</p><p>从这几行代码可以看出，<code>epoll_create()</code> 主要做了两件事：</p><ul><li>创建并初始化一个 <code>struct eventpoll</code> 变量；</li><li>创建 epoll 的 file 结构，并指定 file 的 <code>private_data</code> 指针指向刚创建的 <code>eventpoll</code> 变量，这样，只要根据 <code>epoll</code> 文件描述符 epfd 就可以拿到 file 进而就拿到了 <code>eventpoll</code> 变量，该 <code>eventpoll</code> 就是 <code>epoll_ctl()</code> 和 <code>epoll_wait()</code> 工作的场所。</li></ul><p>对外看来，<code>epoll_create()</code> 就做了一件事，那就是创建一个 epoll 文件，事实上，更关键的是，它创建了一个 <code>struct eventpoll</code> 变量，该变量为 <code>epoll_ctl()</code> 和 <code>epoll_wait()</code> 的工作打下了基础。</p><a class=anchor id=添加监控></a><h2>添加监控 <a href=#%e6%b7%bb%e5%8a%a0%e7%9b%91%e6%8e%a7 aria-hidden=true>#</a></h2><p><code>epoll_ctl()</code> 主要是针对 epfd 所对应的 epoll 实例进行增、删、改操作，一个新创建的 epoll 文件带有一个 <code>struct eventpoll</code> ，同时该结构体上再挂一个红黑树，红黑树上的每个节点挂的是 <code>struct epitem</code>，这个红黑树就是每次 <code>epoll_ctl()</code> 时 fd 存放的地方。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * epfd为该epoll套接字实例,op表示对应的操作，fd表示新加入的套接字，
</span></span></span><span class=line><span class=cl><span class=cm> * 结构体epoll_event 用于注册fd所感兴趣的事件和回传在fd上所发生待处理的事件
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE4</span><span class=p>(</span><span class=n>epoll_ctl</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>epfd</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>op</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>event</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>did_lock_epmutex</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>,</span> <span class=o>*</span><span class=n>tfile</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>eventpoll</span> <span class=o>*</span><span class=n>ep</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>epitem</span> <span class=o>*</span><span class=n>epi</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>epds</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 将用户传入的event_poll拷贝到epds中
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>ep_op_has_event</span><span class=p>(</span><span class=n>op</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nf>copy_from_user</span><span class=p>(</span><span class=o>&amp;</span><span class=n>epds</span><span class=p>,</span> <span class=n>event</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>epoll_event</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>error_return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Get the &#34;struct file *&#34; for the eventpoll file */</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EBADF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>file</span> <span class=o>=</span> <span class=nf>fget</span><span class=p>(</span><span class=n>epfd</span><span class=p>);</span> <span class=c1>// 获取该epoll套接字实例所对应的文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>error_return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Get the &#34;struct file *&#34; for the target file */</span>
</span></span><span class=line><span class=cl>    <span class=n>tfile</span> <span class=o>=</span> <span class=nf>fget</span><span class=p>(</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>tfile</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>error_fput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* The target file descriptor must support poll */</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EPERM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>tfile</span><span class=o>-&gt;</span><span class=n>f_op</span> <span class=o>||</span> <span class=o>!</span><span class=n>tfile</span><span class=o>-&gt;</span><span class=n>f_op</span><span class=o>-&gt;</span><span class=n>poll</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>error_tgt_fput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * We have to check that the file structure underneath the file descriptor
</span></span></span><span class=line><span class=cl><span class=cm>     * the user passed to us _is_ an eventpoll file. And also we do not permit
</span></span></span><span class=line><span class=cl><span class=cm>     * adding an epoll file descriptor inside itself.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>file</span> <span class=o>==</span> <span class=n>tfile</span> <span class=o>||</span> <span class=o>!</span><span class=nf>is_file_epoll</span><span class=p>(</span><span class=n>file</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>error_tgt_fput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * At this point it is safe to assume that the &#34;private_data&#34; contains
</span></span></span><span class=line><span class=cl><span class=cm>     * our own data structure.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>ep</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>private_data</span><span class=p>;</span> <span class=c1>// 获取epoll实例所对应的eventpoll结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * When we insert an epoll file descriptor, inside another epoll file
</span></span></span><span class=line><span class=cl><span class=cm>     * descriptor, there is the change of creating closed loops, which are
</span></span></span><span class=line><span class=cl><span class=cm>     * better be handled here, than in more critical paths.
</span></span></span><span class=line><span class=cl><span class=cm>     *
</span></span></span><span class=line><span class=cl><span class=cm>     * We hold epmutex across the loop check and the insert in this case, in
</span></span></span><span class=line><span class=cl><span class=cm>     * order to prevent two separate inserts from racing and each doing the
</span></span></span><span class=line><span class=cl><span class=cm>     * insert &#34;at the same time&#34; such that ep_loop_check passes on both
</span></span></span><span class=line><span class=cl><span class=cm>     * before either one does the insert, thereby creating a cycle.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>unlikely</span><span class=p>(</span><span class=nf>is_file_epoll</span><span class=p>(</span><span class=n>tfile</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>op</span> <span class=o>==</span> <span class=n>EPOLL_CTL_ADD</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>epmutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>did_lock_epmutex</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>ELOOP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>ep_loop_check</span><span class=p>(</span><span class=n>ep</span><span class=p>,</span> <span class=n>tfile</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>error_tgt_fput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>mtx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Try to lookup the file inside our RB tree, Since we grabbed &#34;mtx&#34;
</span></span></span><span class=line><span class=cl><span class=cm>     * above, we can be sure to be able to use the item looked up by
</span></span></span><span class=line><span class=cl><span class=cm>     * ep_find() till we release the mutex.
</span></span></span><span class=line><span class=cl><span class=cm>     * ep_find即从ep中的红黑树中根据tfile和fd来查找epitem
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>epi</span> <span class=o>=</span> <span class=nf>ep_find</span><span class=p>(</span><span class=n>ep</span><span class=p>,</span> <span class=n>tfile</span><span class=p>,</span> <span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=p>(</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>EPOLL_CTL_ADD</span><span class=p>:</span> <span class=c1>// 对应于socket上事件注册
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>epi</span><span class=p>)</span> <span class=p>{</span>     <span class=c1>// 红黑树中不存在这个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 确保&#34;出错、连接挂起&#34;被当做事件，将出错信息返回给应用
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>epds</span><span class=p>.</span><span class=n>events</span> <span class=o>|=</span> <span class=n>POLLERR</span> <span class=o>|</span> <span class=n>POLLHUP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>error</span> <span class=o>=</span> <span class=nf>ep_insert</span><span class=p>(</span><span class=n>ep</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>epds</span><span class=p>,</span> <span class=n>tfile</span><span class=p>,</span> <span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EEXIST</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>EPOLL_CTL_DEL</span><span class=p>:</span> <span class=c1>// 删除
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>epi</span><span class=p>)</span>        <span class=c1>// 存在则删除这个节点，不存在则报错
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>error</span> <span class=o>=</span> <span class=nf>ep_remove</span><span class=p>(</span><span class=n>ep</span><span class=p>,</span> <span class=n>epi</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOENT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>EPOLL_CTL_MOD</span><span class=p>:</span> <span class=c1>// 修改
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>epi</span><span class=p>)</span> <span class=p>{</span>      <span class=c1>// 存在则修改该fd所对应的事件，不存在则报错
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>epds</span><span class=p>.</span><span class=n>events</span> <span class=o>|=</span> <span class=n>POLLERR</span> <span class=o>|</span> <span class=n>POLLHUP</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>error</span> <span class=o>=</span> <span class=nf>ep_modify</span><span class=p>(</span><span class=n>ep</span><span class=p>,</span> <span class=n>epi</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>epds</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOENT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>mtx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=nl>error_tgt_fput</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>unlikely</span><span class=p>(</span><span class=n>did_lock_epmutex</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nf>mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>epmutex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fput</span><span class=p>(</span><span class=n>tfile</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>error_fput</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>fput</span><span class=p>(</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>error_return</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于往 epoll 实例中添加新的套接字，其实现主要通过 <code>ep_insert()</code> 完成，先分析 <code>epoll_wait</code> 再回过头来分析 <code>ep_insert()</code> 。</p><a class=anchor id=等待事件></a><h2>等待事件 <a href=#%e7%ad%89%e5%be%85%e4%ba%8b%e4%bb%b6 aria-hidden=true>#</a></h2><p><code>epoll_wait()</code> 用来等待 epoll 文件上的 IO 事件发生，其代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * Implement the event wait interface for the eventpoll file. It is the kernel
</span></span></span><span class=line><span class=cl><span class=cm> * part of the user space epoll_wait(2).
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE4</span><span class=p>(</span><span class=n>epoll_wait</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>epfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>__user</span> <span class=o>*</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span><span class=p>,</span> <span class=n>maxevents</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span><span class=n>file</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>eventpoll</span> <span class=o>*</span><span class=n>ep</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* The maximum number of event must be greater than zero */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>maxevents</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>maxevents</span> <span class=o>&gt;</span> <span class=n>EP_MAX_EVENTS</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Verify that the area passed by the user is writeable */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>access_ok</span><span class=p>(</span><span class=n>VERIFY_WRITE</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>maxevents</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>epoll_event</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EFAULT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>error_return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Get the &#34;struct file *&#34; for the eventpoll file */</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EBADF</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>file</span> <span class=o>=</span> <span class=nf>fget</span><span class=p>(</span><span class=n>epfd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>error_return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * We have to check that the file structure underneath the fd
</span></span></span><span class=line><span class=cl><span class=cm>     * the user passed to us _is_ an eventpoll file.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>is_file_epoll</span><span class=p>(</span><span class=n>file</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>error_fput</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * At this point it is safe to assume that the &#34;private_data&#34; contains
</span></span></span><span class=line><span class=cl><span class=cm>     * our own data structure.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>ep</span> <span class=o>=</span> <span class=n>file</span><span class=o>-&gt;</span><span class=n>private_data</span><span class=p>;</span>  <span class=c1>// 获取struct eventpoll结构
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Time to fish for events ... */</span>
</span></span><span class=line><span class=cl>    <span class=n>error</span> <span class=o>=</span> <span class=nf>ep_poll</span><span class=p>(</span><span class=n>ep</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>maxevents</span><span class=p>,</span> <span class=n>timeout</span><span class=p>);</span> <span class=c1>// 核心代码
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nl>error_fput</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>fput</span><span class=p>(</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nl>error_return</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>error</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以看出该函数主要时通过 epfd 获取对应的 <code>struct eventpoll</code> 结构，然后调用 <code>ep_poll()</code> 函数，下面来看 <code>ep_poll()</code> 的实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * ep_poll - Retrieves ready events, and delivers them to the caller supplied
</span></span></span><span class=line><span class=cl><span class=cm> *           event buffer.
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * @ep: Pointer to the eventpoll context.
</span></span></span><span class=line><span class=cl><span class=cm> * @events: Pointer to the userspace buffer where the ready events should be
</span></span></span><span class=line><span class=cl><span class=cm> *          stored.
</span></span></span><span class=line><span class=cl><span class=cm> * @maxevents: Size (in terms of number of events) of the caller event buffer.
</span></span></span><span class=line><span class=cl><span class=cm> * @timeout: Maximum timeout for the ready events fetch operation, in
</span></span></span><span class=line><span class=cl><span class=cm> *           milliseconds. If the @timeout is zero, the function will not block,
</span></span></span><span class=line><span class=cl><span class=cm> *           while if the @timeout is less than zero, the function will block
</span></span></span><span class=line><span class=cl><span class=cm> *           until at least one event has been retrieved (or an error
</span></span></span><span class=line><span class=cl><span class=cm> *           occurred).
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * Returns: Returns the number of ready events which have been fetched, or an
</span></span></span><span class=line><span class=cl><span class=cm> *          error code, in case of error.
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>ep_poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>eventpoll</span> <span class=o>*</span><span class=n>ep</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>__user</span> <span class=o>*</span><span class=n>events</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=kt>int</span> <span class=n>maxevents</span><span class=p>,</span> <span class=kt>long</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>eavail</span><span class=p>,</span> <span class=n>timed_out</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>flags</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>slack</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>wait_queue_t</span> <span class=n>wait</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>ktime_t</span> <span class=n>expires</span><span class=p>,</span> <span class=o>*</span><span class=n>to</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* The call waits for a maximum time of timeout milliseconds.
</span></span></span><span class=line><span class=cl><span class=cm>     * Specifying a timeout of -1 makes epoll_wait() wait indefinitely,
</span></span></span><span class=line><span class=cl><span class=cm>     * while specifying a timeout equal to zero makes epoll_wait()
</span></span></span><span class=line><span class=cl><span class=cm>     * to return immediately even if no events are available (return
</span></span></span><span class=line><span class=cl><span class=cm>     * code equal to zero).
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>timeout</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>struct</span> <span class=n>timespec</span> <span class=n>end_time</span> <span class=o>=</span> <span class=nf>ep_set_mstimeout</span><span class=p>(</span><span class=n>timeout</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>slack</span> <span class=o>=</span> <span class=nf>select_estimate_accuracy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>end_time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>to</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>expires</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=o>*</span><span class=n>to</span> <span class=o>=</span> <span class=nf>timespec_to_ktime</span><span class=p>(</span><span class=n>end_time</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>timeout</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * Avoid the unnecessary trip to the wait queue loop, if the
</span></span></span><span class=line><span class=cl><span class=cm>         * caller specified a non blocking operation.
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=n>timed_out</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=nf>spin_lock_irqsave</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>check_events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>fetch_events</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nf>spin_lock_irqsave</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果rdllist中还没有epitem时，就开始等待了
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>ep_events_available</span><span class=p>(</span><span class=n>ep</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>         * We don&#39;t have any available event to return to the caller.
</span></span></span><span class=line><span class=cl><span class=cm>         * We need to sleep here, and we will be wake up by
</span></span></span><span class=line><span class=cl><span class=cm>         * ep_poll_callback() when events will become available.
</span></span></span><span class=line><span class=cl><span class=cm>         */</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 初始化等待队列，等待队列项对应的线程即为当前线程
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>init_waitqueue_entry</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wait</span><span class=p>,</span> <span class=n>current</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 先将当前线程挂到等待队列上，之后在调用schedule_timeout时，就开始了超时等待了
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>__add_wait_queue_exclusive</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>wq</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>wait</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(;;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>             * We don&#39;t want to sleep if the ep_poll_callback() sends us
</span></span></span><span class=line><span class=cl><span class=cm>             * a wakeup in between. That&#39;s why we set the task state
</span></span></span><span class=line><span class=cl><span class=cm>             * to TASK_INTERRUPTIBLE before doing the checks.
</span></span></span><span class=line><span class=cl><span class=cm>             */</span>
</span></span><span class=line><span class=cl>             <span class=c1>// 因为会被阻塞，这里先设置线程状态为可中断
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>set_current_state</span><span class=p>(</span><span class=n>TASK_INTERRUPTIBLE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 整个循环的核心，其实就在看rdllist中是否有数据，或者等待超时
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// 应征了前面的说明，epoll_wait只需要等着收集数据即可
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=nf>ep_events_available</span><span class=p>(</span><span class=n>ep</span><span class=p>)</span> <span class=o>||</span> <span class=n>timed_out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>signal_pending</span><span class=p>(</span><span class=n>current</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>res</span> <span class=o>=</span> <span class=o>-</span><span class=n>EINTR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nf>spin_unlock_irqrestore</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>schedule_hrtimeout_range</span><span class=p>(</span><span class=n>to</span><span class=p>,</span> <span class=n>slack</span><span class=p>,</span> <span class=n>HRTIMER_MODE_ABS</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>timed_out</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nf>spin_lock_irqsave</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nf>__remove_wait_queue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>wq</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>wait</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>set_current_state</span><span class=p>(</span><span class=n>TASK_RUNNING</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nl>check_events</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Is it worth to try to dig for events ? */</span>
</span></span><span class=line><span class=cl>    <span class=n>eavail</span> <span class=o>=</span> <span class=nf>ep_events_available</span><span class=p>(</span><span class=n>ep</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>spin_unlock_irqrestore</span><span class=p>(</span><span class=o>&amp;</span><span class=n>ep</span><span class=o>-&gt;</span><span class=n>lock</span><span class=p>,</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>     * Try to transfer events to user space. In case we get 0 events and
</span></span></span><span class=line><span class=cl><span class=cm>     * there&#39;s still timeout left over, we go trying again in search of
</span></span></span><span class=line><span class=cl><span class=cm>     * more luck.
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>res</span> <span class=o>&amp;&amp;</span> <span class=n>eavail</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>        <span class=o>!</span><span class=p>(</span><span class=n>res</span> <span class=o>=</span> <span class=nf>ep_send_events</span><span class=p>(</span><span class=n>ep</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>maxevents</span><span class=p>))</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>timed_out</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>fetch_events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>调用 <code>epoll_wait()</code> 检查是否有事件发生时，只需检查 <code>eventpoll</code> 中 <code>rdlist</code> 链表是否有 <code>epitem</code> 元素即可。如果 rdlist 不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p><p><img alt="epoll data structure" src=images/epoll-data-structure.jpg class="mx-auto d-block"></p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#select>select</a></li><li><a href=#poll>poll</a></li></ul></li><li><a href=#epoll>epoll</a><ul><li><a href=#对比>对比</a></li><li><a href=#函数接口>函数接口</a></li><li><a href=#epoll-的使用>epoll() 的使用</a></li></ul></li><li><a href=#内核实现>内核实现</a><ul><li><a href=#初始化>初始化</a></li><li><a href=#创建对象>创建对象</a></li><li><a href=#添加监控>添加监控</a></li><li><a href=#等待事件>等待事件</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>