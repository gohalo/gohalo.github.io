<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>PostgreSQL 简单介绍 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="PostgreSQL 可以说是目前功能最强大、特性最丰富和结构最复杂的开源数据库管理系统，其中有些特性甚至连商业数据库都不具备。
这里简单介绍 PG 的常见操作。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>PostgreSQL 简单介绍</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2016-08-02</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/database/ role=button>database</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/postgresql/ role=button>postgresql</a></div></div><hr><div class=content><p>PostgreSQL 可以说是目前功能最强大、特性最丰富和结构最复杂的开源数据库管理系统，其中有些特性甚至连商业数据库都不具备。</p><p>这里简单介绍 PG 的常见操作。</p><img src=images/postgresql-logo.jpg alt="PostgreSQL Logo" width=180px>
<a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>PostgreSQL 可以说是目前功能最强大、特性最丰富和结构最复杂的开源数据库管理系统，其中有些特性甚至连商业数据库都不具备。这个起源于加州大学伯克利分校的数据库，现已成为一项国际开发项目，并且拥有广泛的用户群，尤其是在海外，目前国内使用者也越来越多。</p><p>PostgreSQL 基本上算是见证了整个数据库理论和技术的发展历程，由 UCB 计算机教授 Michael Stonebraker 于 1986 年创建。在此之前，Stonebraker 教授主导了关系数据库 Ingres 研究项目，88 年，提出了 Postgres 的第一个原型设计。</p><p>MySQL 号称是使用最广泛的开源数据库，而 PG 则被称为功能最强大的开源数据库。</p><a class=anchor id=安装></a><h2>安装 <a href=#%e5%ae%89%e8%a3%85 aria-hidden=true>#</a></h2><p>可以通过 yum 安装和源码安装，其中前者相比要简单很多，后者通常在调试源码时使用。</p><a class=anchor id=通过-yum-安装></a><h4>通过 YUM 安装 <a href=#%e9%80%9a%e8%bf%87-yum-%e5%ae%89%e8%a3%85 aria-hidden=true>#</a></h4><p>在 CentOS 中，可以直接通过 YUM 进行安装，不过默认的版本可能会比较低，在 CentOS 7 上默认安装的是 9.2，可以通过 yum info 查看当前的版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># yum install postgresql postgresql-server
</span></span></code></pre></div><p>如果要安装最新版本，可以从 <a href=http://yum.postgresql.org/>yum.postgresql.org</a> 上下载 repos 安装包，安装数据源。这也是推荐的一种方式，以下的 XXX 标记，根据不同的版本有所区别，不过操作大致相同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 安装相应PG版本的repository，并更新库
</span></span><span class=line><span class=cl># rpm -ivh pgdg-centos-XXX.rpm
</span></span><span class=line><span class=cl># yum update
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 安装相应的版本，包括常用的pgadmin工具
</span></span><span class=line><span class=cl># yum --enablerepo=pgdgXX install postgresqlXX-server pgadmin3_XX postgresqlXX-contrib
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 另外，安装完之后需要配置PATH环境变量，并使之生效
</span></span><span class=line><span class=cl># cat /etc/profile
</span></span><span class=line><span class=cl>pathmunge /usr/pgsql-X.X/bin
</span></span><span class=line><span class=cl># source /etc/profile
</span></span></code></pre></div><p>通过 YUM 方式安装后，同时会创建一个 postgres 用户，以及同名用户组，直接切换到该用户即可，执行相关的数据库操作即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># su - postgres
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 初始化db，如下是安装之后默认的数据存储目录
</span></span><span class=line><span class=cl>$ initdb -D /var/lib/pgsql/X.X/data
</span></span></code></pre></div><p>在 CentOS 7 中，对于会同时安装如下的启动文件，其它的 systemctl 操作基本就相同了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># ls /usr/lib/systemd/system/postgresql-X.X.service
</span></span><span class=line><span class=cl># systemctl start postgresql-X.X
</span></span></code></pre></div><a class=anchor id=通过源码安装></a><h4>通过源码安装 <a href=#%e9%80%9a%e8%bf%87%e6%ba%90%e7%a0%81%e5%ae%89%e8%a3%85 aria-hidden=true>#</a></h4><p>直接从官网 <a href=https://www.postgresql.org>www.postgresql.org</a> 下载相应版本的源码包。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 可以选择新建PG专用的用户
</span></span><span class=line><span class=cl># groupadd postgres
</span></span><span class=line><span class=cl># useradd -g postgres postgres
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 解压、编译
</span></span><span class=line><span class=cl>$ tar -xf postgresql-X.X.X.tar.bz2 &amp;&amp; cd postgresql-X.X.X
</span></span><span class=line><span class=cl>$ ./configure --prefix=/opt/postgre
</span></span><span class=line><span class=cl>$ make
</span></span><span class=line><span class=cl># make install
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 同样可以编译contrib目录下的一些工具
</span></span><span class=line><span class=cl>$ cd contrib &amp;&amp; make
</span></span><span class=line><span class=cl># make install
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 绑定数据库文件存储目录
</span></span><span class=line><span class=cl>$ export PGDATA=/home/andy/Workspace/databases/postgre/data
</span></span><span class=line><span class=cl>$ /opt/postgre/bin/initdb -D $PGDATA
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 常见操作，如启动、停止数据库
</span></span><span class=line><span class=cl>$ /opt/postgre/bin/pg_ctl -D $PGDATA -l logfile start
</span></span><span class=line><span class=cl>$ /opt/postgre/bin/pg_ctl -D $PGDATA -l logfile stop
</span></span></code></pre></div><a class=anchor id=日志查看></a><h2>日志查看 <a href=#%e6%97%a5%e5%bf%97%e6%9f%a5%e7%9c%8b aria-hidden=true>#</a></h2><p>PG 的日志分为三类，分别是 <code>pg_log</code>、<code>pg_xlog</code> 和 <code>pg_clog</code>，一般保存在 <code>$PGDATA</code> 对应的目录下。</p><ol><li>pg_log  数据库运行日志，默认开启，可以通过配置 <code>$PGDATA/postgresql.conf</code> 。</li><li>pg_xlog WAL日志，强制开启。</li><li>pg_clog 事务提交日志，记录事务的元数据，强制开启。</li></ol><a class=anchor id=防火墙selinux-设置></a><h2>防火墙、SELinux 设置 <a href=#%e9%98%b2%e7%81%ab%e5%a2%99selinux-%e8%ae%be%e7%bd%ae aria-hidden=true>#</a></h2><p>PG 默认使用 <code>5432</code> 端口，也可以在 <code>postgresql.conf</code> 文件中设置，可以使用如下命令开启防火墙端口。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># firewall-cmd --add-port=5432/tcp                          # 暂时有效
</span></span><span class=line><span class=cl># firewall-cmd --permanent --add-port=5432/tcp              # 永久生效
</span></span><span class=line><span class=cl>----- 在iptables中开启
</span></span><span class=line><span class=cl># iptables -A INPUT -p tcp --dport 5432 -m state --state NEW,ESTABLISHED -j ACCEPT
</span></span></code></pre></div><p>如果开启了 SELinux 服务，可能会在使用中遇到各种各样的权限问题。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 修改数据库的存放位置，必须添加一些新上下文来匹配新位置
</span></span><span class=line><span class=cl># semanage fcontext -a -t postgresql_db_t &#34;/new/location(/.*)?&#34;
</span></span><span class=line><span class=cl>----- 默认端口不起作用，需要匹配postgre的端口类型为你想要的端口
</span></span><span class=line><span class=cl># semanage port -a -t postgresql_port_t -p tcp 5433
</span></span><span class=line><span class=cl>----- 如果APP需要通过TCP/IP与PG交互，你需要告诉SELinux允许这个操作
</span></span><span class=line><span class=cl># setsebool -P httpd_can_network_connect_db on
</span></span></code></pre></div><a class=anchor id=设置用户和数据库></a><h2>设置用户和数据库 <a href=#%e8%ae%be%e7%bd%ae%e7%94%a8%e6%88%b7%e5%92%8c%e6%95%b0%e6%8d%ae%e5%ba%93 aria-hidden=true>#</a></h2><p>创建一个用户，并为用户创建一个数据库。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ psql -U postgres -W
</span></span><span class=line><span class=cl>psql (9.3.2)
</span></span><span class=line><span class=cl>Type &#34;help&#34; for help.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>postgres=# \password postgres         # 设置一下密码
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 可以通过如下方式创建用户、数据库
</span></span><span class=line><span class=cl>postgres=# CREATE USER foobar WITH PASSWORD &#39;justkidding&#39;;
</span></span><span class=line><span class=cl>postgres=# CREATE DATABASE test OWNER foobar;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 也可以直接在shell中创建
</span></span><span class=line><span class=cl>$ createuser foobar
</span></span><span class=line><span class=cl>$ createdb --owner=foobar test
</span></span></code></pre></div><a class=anchor id=配置></a><h2>配置 <a href=#%e9%85%8d%e7%bd%ae aria-hidden=true>#</a></h2><p>PG 主要使用了两个配置文件 <code>/var/lib/pgsql/data/{postgresql.conf, pg_hba.conf}</code>，其中一些配置参数可以通过命令行选项传给守护进程，此时会覆盖配置文件中的设置。</p><p>例如，如果想要修改服务的端口为 5433，创建一个名为 <code>/etc/systemd/system/postgresql.service</code> 的文件，包含以下内容。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>.include /lib/systemd/system/postgresql.service
</span></span><span class=line><span class=cl>[Service]
</span></span><span class=line><span class=cl>Environment=PGPORT=5433
</span></span></code></pre></div><p>当数据库安装后，可以通过编辑 <code>/var/lib/pgsql/data/pg_hba.conf</code> 文件来实现权限管理。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># TYPE    DATABASE        USER            ADDRESS                 METHOD
</span></span><span class=line><span class=cl>  host    all             all             127.0.0.1/32            md5
</span></span><span class=line><span class=cl>  local   all             postgres                                peer
</span></span></code></pre></div><a class=anchor id=常见操作></a><h1>常见操作 <a href=#%e5%b8%b8%e8%a7%81%e6%93%8d%e4%bd%9c aria-hidden=true>#</a></h1><p>接下来，我们使用默认的用户 postgres 登陆，执行一些 CURD (Create, Update, Read, Delete) 操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ /opt/postgre/bin/createdb test             # 创建test数据库
</span></span><span class=line><span class=cl>$ /opt/postgre/bin/psql test                 # 链接到test数据库
</span></span><span class=line><span class=cl>test=# create table test1(id integer);       # 建表
</span></span><span class=line><span class=cl>test=# insert into test1 values(1);          # 插入数据
</span></span><span class=line><span class=cl>test=# select * from test1;                  # 查询
</span></span></code></pre></div><p>也可以直接登陆创建。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ psql -U postgres -W                        # 直接登陆，默认无密码
</span></span><span class=line><span class=cl>postgres=# CREATE USER foobar WITH PASSWORD &#39;password&#39;;          # 创建用户
</span></span><span class=line><span class=cl>postgres=# CREATE DATABASE test OWNER foobar ENCODING &#39;UTF8&#39;;    # 以及数据库
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ psql -U foobar -W test
</span></span><span class=line><span class=cl>Password for user foobar: password
</span></span><span class=line><span class=cl>test=&gt; \q
</span></span></code></pre></div><p>可以直接修改配置文件，允许远程访问。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 修改/var/lib/pgsql/data/postgresql.conf
</span></span><span class=line><span class=cl>listen_addresses =&#39;*&#39;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 修改/var/lib/pgsql/data/pg_hba.conf
</span></span><span class=line><span class=cl>host    all             all             0.0.0.0/0            trust
</span></span></code></pre></div><a class=anchor id=修改配置></a><h2>修改配置 <a href=#%e4%bf%ae%e6%94%b9%e9%85%8d%e7%bd%ae aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 直接查看内部虚拟表
</span></span><span class=line><span class=cl>postgre=# SELECT name, unit FROM pg_settings;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 通过show命令查看
</span></span><span class=line><span class=cl>postgre=# SHOW ALL;
</span></span><span class=line><span class=cl>postgre=# SHOW maintenance_work_mem;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 修改数据库参数
</span></span><span class=line><span class=cl>postgre=# ALTER SYSTEM SET maintenance_work_mem= 1048576;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 恢复到默认设置值
</span></span><span class=line><span class=cl>postgre=# ALTER SYSTEM SET maintenance_work_mem= default;
</span></span></code></pre></div><p>可以直接修改 <code>postgresql.conf</code> 中的配置，然后重启。</p><a class=anchor id=状态查看></a><h2>状态查看 <a href=#%e7%8a%b6%e6%80%81%e6%9f%a5%e7%9c%8b aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 查看PG的当前进程
</span></span><span class=line><span class=cl># ps auxww | grep ^postgres
</span></span></code></pre></div><p>主要包括了两类进程，分别是启动时的后台进程，以及用户连接的进程；对于前者，其中 stats collector 和 autovacuum launcher 两个进程是可选启动的，各个进程作用如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postgres: 主进程，接收客户端连接，创建服务进程；启动时拉起和管理后台进程。
</span></span><span class=line><span class=cl>achiever process: 事务日志归档进程。
</span></span></code></pre></div><p>而用户进程通常格式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postgres: user database host activity
</span></span></code></pre></div><p>其中 activity 的状态为 idle (正在等待用户输入命令)、idle in transaction、waiting (等待锁) 等。</p><a class=anchor id=ctid></a><h2>CTID <a href=#ctid aria-hidden=true>#</a></h2><p>在 PG 中的 ctid 表示数据记录的物理行信息，用于标示一条记录位于那个数据块的那个位移上面，类似于 Oracle 中的 rowid 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postgres=# CREATE TABLE test(x int, y varchar(30), z date) TABLESPACE ts_demo;
</span></span><span class=line><span class=cl>CREATE TABLE
</span></span><span class=line><span class=cl>postgres=# INSERT INTO test VALUES(1, &#39;ShangHai&#39;, now()), (2, &#39;NanJing&#39;, now()), (3, &#39;HangZhou&#39;, now());
</span></span><span class=line><span class=cl>INSERT 0 3
</span></span><span class=line><span class=cl>postgres=# INSERT INTO test SELECT generate_series(4, 1000), &#39;JiNan &#39;||generate_series(4, 1000), now();
</span></span><span class=line><span class=cl>postgres=# SELECT ctid, * FROM test;
</span></span><span class=line><span class=cl>postgres=# ANALYZE test;
</span></span><span class=line><span class=cl>postgres=# SELECT relpages, reltuples FROM pg_class WHERE relname = &#39;t&#39;;
</span></span></code></pre></div><p>当删除了数据之后，原有的空间不会自动释放，可以通过 vacuum tbl 回收。</p><a class=anchor id=索引></a><h2>索引 <a href=#%e7%b4%a2%e5%bc%95 aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 创建唯一约束
</span></span><span class=line><span class=cl>postgres=# ALTER TABLE tbl ADD CONSTRAINT UK_tbl_col UNIQUE(x, y);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 创建函数索引
</span></span><span class=line><span class=cl>postgres=# CREATE INDEX idx_tbl_col ON tbl USING btree(UPPER(x), y);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 创建部分索引
</span></span><span class=line><span class=cl>postgres=# CREATE INDEX idx_tbl_col ON tbl USING btree(UPPER(x), y) WHERE z IS NULL;
</span></span></code></pre></div><a class=anchor id=常用命令></a><h2>常用命令 <a href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4 aria-hidden=true>#</a></h2><p>pgsql 常见的命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 查看帮助
</span></span><span class=line><span class=cl>postgre=# \h SELECT            # 查看SQL命令的帮助
</span></span><span class=line><span class=cl>postgre=# \?                   # 查看psql命令的帮助
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 导入/导出数据
</span></span><span class=line><span class=cl>postgre=# \i file.sql          # 从某个文件导入
</span></span><span class=line><span class=cl>postgre=# COPY weather FROM &#39;file.txt&#39;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 切换数据库，相当于MySQL的use dbname
</span></span><span class=line><span class=cl>postgre=# \c dbname username IP PORT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看数据库，相当于MySQL的show databases
</span></span><span class=line><span class=cl>postgre=# \l    \list
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看表，相当于MySQL的show tables
</span></span><span class=line><span class=cl>postgre=# \dt
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看表结构，相当于desc
</span></span><span class=line><span class=cl>postgre=# \d tblname           # \d+ tblname查看详细信息
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看索引
</span></span><span class=line><span class=cl>postgre=# \di
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看用户
</span></span><span class=line><span class=cl>postgre=# \du
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 在文本编辑器中编译，退出后执行
</span></span><span class=line><span class=cl>postgre=# \e
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看当前连接的信息
</span></span><span class=line><span class=cl>postgre=# \conninfo
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 其它杂项
</span></span><span class=line><span class=cl>postgre=# \! shell-command                   # 执行终端的命令
</span></span><span class=line><span class=cl>postgre=# \set COMP_KEYWORD_CASE upper       # 设置自动提示关键字大写显示
</span></span><span class=line><span class=cl>postgre=# \x auto                            # 如果列较多时，通过行显示，其中\x表示直接行显示
</span></span><span class=line><span class=cl>postgre=# \pset null ¤                       # 当值为NULL时显示如下的字符，以区分空格
</span></span></code></pre></div><p>PG 中通过 <code>::</code> 进行类型转换；另外，支持一些常见的字符串匹配函数，如 <code>ilike</code>、<code>~*</code> 等，详细可以参考 <a href=https://www.postgresql.org/docs/9.6/static/functions-matching.html>Pattern Matching</a> 。</p><a class=anchor id=常用概念></a><h1>常用概念 <a href=#%e5%b8%b8%e7%94%a8%e6%a6%82%e5%bf%b5 aria-hidden=true>#</a></h1><p>在 PostgreSQL 中，有各种各样的概念，常见的有表空间、数据库、模式、表、用户、角色等。</p><a class=anchor id=角色-vs-用户></a><h2>角色 VS. 用户 <a href=#%e8%a7%92%e8%89%b2-vs-%e7%94%a8%e6%88%b7 aria-hidden=true>#</a></h2><p>这两个可以理解为相同，只是两者在创建时默认行为的区别，其它基本一致。文档中，对两者进行了简单的说明 <code>CREATE USER is the same as CREATE ROLE except that it implies LOGIN.</code> ，也就是说如下的命令是等价的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CREATE ROLE foobar PASSWORD &#39;foobar&#39; LOGIN;
</span></span><span class=line><span class=cl>CREATE USER foobar PASSWORD &#39;foobar&#39;;
</span></span></code></pre></div><a class=anchor id=数据库-vs-模式></a><h2>数据库 VS. 模式 <a href=#%e6%95%b0%e6%8d%ae%e5%ba%93-vs-%e6%a8%a1%e5%bc%8f aria-hidden=true>#</a></h2><p>简单来说模式 (Schema) 就是对数据库 (Database) 的逻辑分割，而且在数据库创建的时候，已经默认创建了一个 public 模式，在此数据库中创建的对象，如表、函数、试图、索引、序列等都保存在这个模式中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 1. 创建一个数据库
</span></span><span class=line><span class=cl>CREATE DATABASE tsdb;
</span></span><span class=line><span class=cl>----- 2. 链接到新建的数据库，并查看其中的模式
</span></span><span class=line><span class=cl>\c tsdb
</span></span><span class=line><span class=cl>\dn
</span></span><span class=line><span class=cl>----- 3. 新建一张测试表
</span></span><span class=line><span class=cl>CREATE TABLE test(id INTEGER NOT NULL);
</span></span><span class=line><span class=cl>\d
</span></span><span class=line><span class=cl>----- 4. 创建新的模式，同时设置属主为默认用户，并查看当前库所有的表
</span></span><span class=line><span class=cl>CREATE SCHEMA foobar AUTHORIZATION postgres;
</span></span><span class=line><span class=cl>CREATE TABLE foobar.test (id INTEGER NOT NULL);
</span></span><span class=line><span class=cl>SELECT * FROM pg_tables WHERE schemaname NOT IN(&#39;pg_catalog&#39;, &#39;information_schema&#39;);
</span></span><span class=line><span class=cl>----- 5. 如果通过\d查看时，需要设置搜索路径
</span></span><span class=line><span class=cl>SHOW search_path;
</span></span><span class=line><span class=cl>SET search_path TO &#39;foobar,public&#39;
</span></span><span class=line><span class=cl>\d
</span></span></code></pre></div><p>也就是说，数据库通过模式做逻辑区分，而且一个数据库至少包含一个模式，接到一个数据库后，可以通过 <code>search_path</code> 设置搜索顺序。</p><a class=anchor id=表空间-vs-数据库></a><h2>表空间 VS. 数据库 <a href=#%e8%a1%a8%e7%a9%ba%e9%97%b4-vs-%e6%95%b0%e6%8d%ae%e5%ba%93 aria-hidden=true>#</a></h2><p>在通过 <code>CREATE DATABASE dbname</code> 语句创建数据库时，默认的数据库所有者是当前创建数据库的角色，默认表空间是系统的默认表空间 pg_default ，其主要原因是创建是通过克隆数据库模板实现的。</p><p>如上创建数据库时，如果没有指明数据库模板，系统将默认克隆 template1 数据库，其默认表空间是 pg_default ，其完整的语句如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CREATE DATABASE dbname OWNER foobar TEMPLATE template1 TABLESPACE tablespacename;
</span></span></code></pre></div><p>实际上可以通过如下的步骤进行测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 1. 切换到template1数据库并新建一个表进行测试
</span></span><span class=line><span class=cl>\c template1
</span></span><span class=line><span class=cl>CREATE TABLE test(id INTEGER NOT NULL);
</span></span><span class=line><span class=cl>INSERT INTO test VALUES (1);
</span></span><span class=line><span class=cl>----- 2. 创建一个表空间，需要注意对应的目录存在且为空
</span></span><span class=line><span class=cl>CREATE TABLESPACE tsfoobar OWNER postgres LOCATION &#39;/tmp/foobar&#39;;
</span></span><span class=line><span class=cl>----- 3. 创建一个数据库
</span></span><span class=line><span class=cl>CREATE DATABASE dbfoobar TEMPLATE template1 OWNERE postgres TABLESPACE tsfoobar;
</span></span></code></pre></div><p>链接查看新数据库时，实际上存在一个表，而且有上述写入的数据。表空间是一个存储区域，在一个表空间中可以存储多个数据库，尽管 PostgreSQL 不建议这么做，例如将索引保存到 SSD 中，而数据保存到 SATA 中。</p><a class=anchor id=常用特性></a><h1>常用特性 <a href=#%e5%b8%b8%e7%94%a8%e7%89%b9%e6%80%a7 aria-hidden=true>#</a></h1><a class=anchor id=sequece></a><h2>sequece <a href=#sequece aria-hidden=true>#</a></h2><p>序列对象，也被称为序列生成器，实际上就是用 <code>CREATE SEQUENCE</code> 创建的特殊的单行表，通常用来表生成唯一的标识符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 直接在建表时使用serial类型，默认生成为tblname+colname+&#39;seq&#39;
</span></span><span class=line><span class=cl>postgres=# CREATE TABLE tbl_seq(id SERIAL, name TEXT);
</span></span><span class=line><span class=cl>CREATE TABLE
</span></span><span class=line><span class=cl>postgres=# \d tbl_seq
</span></span><span class=line><span class=cl>                         Table &#34;public.tbl_seq&#34;
</span></span><span class=line><span class=cl> Column |  Type   |                      Modifiers
</span></span><span class=line><span class=cl>--------+---------+------------------------------------------------------
</span></span><span class=line><span class=cl> id     | integer | not null default nextval(&#39;tbl_seq_id_seq&#39;::regclass)
</span></span><span class=line><span class=cl> name   | text    |
</span></span><span class=line><span class=cl>postgres=# \d tbl_seq_id_seq
</span></span><span class=line><span class=cl>       Sequence &#34;public.tbl_seq_id_seq&#34;
</span></span><span class=line><span class=cl>    Column     |  Type   |        Value
</span></span><span class=line><span class=cl>---------------+---------+---------------------
</span></span><span class=line><span class=cl> sequence_name | name    | tbl_seq_id_seq
</span></span><span class=line><span class=cl> last_value    | bigint  | 1
</span></span><span class=line><span class=cl> start_value   | bigint  | 1
</span></span><span class=line><span class=cl> increment_by  | bigint  | 1
</span></span><span class=line><span class=cl> max_value     | bigint  | 9223372036854775807
</span></span><span class=line><span class=cl> min_value     | bigint  | 1
</span></span><span class=line><span class=cl> cache_value   | bigint  | 1
</span></span><span class=line><span class=cl> log_cnt       | bigint  | 0
</span></span><span class=line><span class=cl> is_cycled     | boolean | f
</span></span><span class=line><span class=cl> is_called     | boolean | f
</span></span><span class=line><span class=cl>Owned by: public.tbl_seq.id
</span></span><span class=line><span class=cl>postgres=# SELECT * FROM tbl_seq_id_seq;
</span></span><span class=line><span class=cl> sequence_name  | last_value | start_value | increment_by | ...
</span></span><span class=line><span class=cl>----------------+------------+-------------+--------------+ ...
</span></span><span class=line><span class=cl> tbl_seq_id_seq |          1 |           1 |            1 | ...
</span></span><span class=line><span class=cl>(1 row)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 单独创建序列，建表时指定，不过该列需要为int类型
</span></span><span class=line><span class=cl>postgres=# CREATE SEQUENCE seq_tblseq2 INCREMENT BY 1 MINVALUE 1 NO MAXVALUE START WITH 1;
</span></span><span class=line><span class=cl>CREATE SEQUENCE
</span></span><span class=line><span class=cl>postgres=# CREATE TABLE tbl_seq2(id INT NOT NULL DEFAULT nextval(&#39;seq_tblseq2&#39;), name TEXT);
</span></span><span class=line><span class=cl>CREATE TABLE
</span></span></code></pre></div><p>其中 <code>CREATE SEQUECE</code> 的语法可以参考 <a href=https://www.postgresql.com/docs/current/static/sql-createsequence.html>www.postgresql.com</a>，接下来看看如何使用序列。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postgres=# INSERT INTO tbl_seq VALUES(nextval(&#39;tbl_seq_id_seq&#39;), &#39;Lucy&#39;);
</span></span><span class=line><span class=cl>INSERT 0 1
</span></span><span class=line><span class=cl>postgres=# INSERT INTO tbl_seq(name) VALUES(&#39;Andy&#39;);
</span></span><span class=line><span class=cl>INSERT 0 1
</span></span></code></pre></div><p>还有一个问题是在数据迁移之后，如何设置 sequence 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postgres=# TRUNCATE tbl_seq;
</span></span><span class=line><span class=cl>TRUNCATE TABLE
</span></span><span class=line><span class=cl>postgres=# INSERT INTO tbl_seq(name) VALUES(&#39;Sanndy&#39;), (&#39;David&#39;), (&#39;Simon&#39;), (&#39;Peter&#39;);
</span></span><span class=line><span class=cl>INSERT 0 4
</span></span><span class=line><span class=cl>postgres=# select * from tbl_seq;
</span></span><span class=line><span class=cl> id |  name
</span></span><span class=line><span class=cl>----+--------
</span></span><span class=line><span class=cl>  8 | Sanndy
</span></span><span class=line><span class=cl>  9 | David
</span></span><span class=line><span class=cl> 10 | Simon
</span></span><span class=line><span class=cl> 11 | Peter
</span></span><span class=line><span class=cl>(4 rows)
</span></span><span class=line><span class=cl>postgres=# COPY tbl_seq TO &#39;/tmp/tbl_seq.sql&#39;;
</span></span><span class=line><span class=cl>COPY 4
</span></span><span class=line><span class=cl>postgres=# TRUNCATE tbl_seq;
</span></span><span class=line><span class=cl>TRUNCATE TABLE
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>------ 尝试恢复
</span></span><span class=line><span class=cl>postgres=# BEGIN
</span></span><span class=line><span class=cl>BEGIN
</span></span><span class=line><span class=cl>postgres=# COPY tbl_seq FROM &#39;/tmp/tbl_seq.sql&#39;;
</span></span><span class=line><span class=cl>COPY 4
</span></span><span class=line><span class=cl>postgres=# SELECT setval(&#39;tbl_seq_id_seq&#39;, max(id)) from tbl_seq;
</span></span><span class=line><span class=cl> setval
</span></span><span class=line><span class=cl>--------
</span></span><span class=line><span class=cl>     11
</span></span><span class=line><span class=cl>(1 row)
</span></span><span class=line><span class=cl>postgres=# END;
</span></span><span class=line><span class=cl>COMMIT
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>postgres=# INSERT INTO tbl_seq(name) VALUES(&#39;Monica&#39;);
</span></span><span class=line><span class=cl>INSERT 0 1
</span></span><span class=line><span class=cl>postgres=# select * from tbl_seq;
</span></span><span class=line><span class=cl> id |  name
</span></span><span class=line><span class=cl>----+--------
</span></span><span class=line><span class=cl>  8 | Sanndy
</span></span><span class=line><span class=cl>  9 | David
</span></span><span class=line><span class=cl> 10 | Simon
</span></span><span class=line><span class=cl> 11 | Peter
</span></span><span class=line><span class=cl> 12 | Monica
</span></span><span class=line><span class=cl>(5 rows)
</span></span></code></pre></div><p>其它的一些常用函数还包括了：</p><ol><li><code>nextval(seq)</code>：递增到下一个值，并返回当前值，即使多个会话并发执行该函数，每个进程也会安全的收到一个唯一的序列值。</li><li><code>currval(seq)</code>：当前会话返回的最近一次的值，如果从没有执行过 <code>nextval()</code> 则会返回错误。</li><li><code>setval(seq, bigint, boolean)</code>：重置序列对象的值，如果最后一个参数为 false，那么 nextval 首先返回该值，然后才开始递增。</li></ol><p>删除非常简单。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postgres=# DROP SEQUENCE seq;
</span></span></code></pre></div><a class=anchor id=cursor></a><h2>cursor <a href=#cursor aria-hidden=true>#</a></h2><p>在一个查询中，可以使用游标 (cursor)，防止一个大查询超过了内容的容量，而对于 PL/pgSQL 来说，FOR 语句则默认使用了游标。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>postgre=# CREATE TABLE foobar(id INT);
</span></span><span class=line><span class=cl>CREATE TABLE
</span></span><span class=line><span class=cl>postgre=# INSERT INTO foobar VALUES(generate_series(1, 1000));
</span></span><span class=line><span class=cl>INSERT 0 1000
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>postgre=# BEGIN;
</span></span><span class=line><span class=cl>BEGIN
</span></span><span class=line><span class=cl>postgre=# DECLARE cur CURSOR FOR SELECT * FROM foobar;
</span></span><span class=line><span class=cl>DECLARE CURSOR
</span></span><span class=line><span class=cl>postgre=# FETCH FIRST FROM cur;           # 移动到第一行，并返回第一行数据
</span></span><span class=line><span class=cl> id
</span></span><span class=line><span class=cl>----
</span></span><span class=line><span class=cl>  1
</span></span><span class=line><span class=cl>(1 row)
</span></span><span class=line><span class=cl>postgre=# FETCH NEXT FROM cur;            # 获取下一行
</span></span><span class=line><span class=cl> id
</span></span><span class=line><span class=cl>----
</span></span><span class=line><span class=cl>  2
</span></span><span class=line><span class=cl>(1 row)
</span></span><span class=line><span class=cl>postgre=# MOVE LAST IN cur;               # 移动到最后
</span></span><span class=line><span class=cl>MOVE 1
</span></span><span class=line><span class=cl>postgre=# CLOSE cur;                      # 关闭游标
</span></span><span class=line><span class=cl>CLOSE CURSOR
</span></span></code></pre></div><p>另外，PG 允许在函数中返回对 cursor 的引用，这样就可以直接通过函数返回一个大的对象。</p><a class=anchor id=常用程序></a><h2>常用程序 <a href=#%e5%b8%b8%e7%94%a8%e7%a8%8b%e5%ba%8f aria-hidden=true>#</a></h2><p>简单介绍下 PG 相关的程序，部分比较复杂的只是在此简单记录下，详细介绍可以参考后面的文章。</p><a class=anchor id=pg_config></a><h4>pg_config <a href=#pg_config aria-hidden=true>#</a></h4><p>用来显示当前版本的一些配置参数，如 bin 目录、版本信息、cpp flags 等。</p><a class=anchor id=pg_controldata></a><h4>pg_controldata <a href=#pg_controldata aria-hidden=true>#</a></h4><p>用来显示当前 cluster 的一些详细信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ pg_controldata -D $PGDATA
</span></span></code></pre></div><a class=anchor id=pg_test_fsync></a><h4>pg_test_fsync <a href=#pg_test_fsync aria-hidden=true>#</a></h4><p>用于测试不同的 wal_sync_method 参数所具有的性能。</p><a class=anchor id=pg_test_timing></a><h4>pg_test_timing <a href=#pg_test_timing aria-hidden=true>#</a></h4><p>用于时间测试的程序，详细可以参考文档。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>可以参考官方网站 <a href=http://www.postgresql.org/>www.postgresql.org</a>，以及 <a href=http://www.postgres.cn/>PostgreSQL 中文社区</a> 。国内 PG 研究比较多的人，可以查看 <a href=http://blog.163.com/digoal@126/>PostgreSQL Research</a>。</p><p>源码可以参考 <a href=https://github.com/postgres/postgres>Github Postgres</a> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#安装>安装</a></li><li><a href=#日志查看>日志查看</a></li><li><a href=#防火墙selinux-设置>防火墙、SELinux 设置</a></li><li><a href=#设置用户和数据库>设置用户和数据库</a></li><li><a href=#配置>配置</a></li></ul></li><li><a href=#常见操作>常见操作</a><ul><li><a href=#修改配置>修改配置</a></li><li><a href=#状态查看>状态查看</a></li><li><a href=#ctid>CTID</a></li><li><a href=#索引>索引</a></li><li><a href=#常用命令>常用命令</a></li></ul></li><li><a href=#常用概念>常用概念</a><ul><li><a href=#角色-vs-用户>角色 VS. 用户</a></li><li><a href=#数据库-vs-模式>数据库 VS. 模式</a></li><li><a href=#表空间-vs-数据库>表空间 VS. 数据库</a></li></ul></li><li><a href=#常用特性>常用特性</a><ul><li><a href=#sequece>sequece</a></li><li><a href=#cursor>cursor</a></li><li><a href=#常用程序>常用程序</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>