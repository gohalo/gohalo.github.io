<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>HTTPS 协议详解 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="我们知道 HTTP 采用的是明文传输，而在互联网中，比如要在淘宝买个东西，使用支付宝转个帐，必须要保证这些信息只有客户端和服务器才知道的，也就是通过 HTTPS 协议。
接下来，我们就看看 HTTPS 协议是如何实现的。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>HTTPS 协议详解</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-06-07</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/security/ role=button>security</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/tls/ssl/ role=button>tls/ssl</a></div></div><hr><div class=content><p>我们知道 HTTP 采用的是明文传输，而在互联网中，比如要在淘宝买个东西，使用支付宝转个帐，必须要保证这些信息只有客户端和服务器才知道的，也就是通过 HTTPS 协议。</p><p>接下来，我们就看看 HTTPS 协议是如何实现的。</p><p><img alt="https logo" src=images/https-logo.jpg class="mx-auto d-block"></p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>Secure Hypertext Transfer Protocol, HTTPS 也就是安全超文本传输协议，是一个安全通信通道，它基于 HTTP 开发用于在客户计算机和服务器之间交换信息。</p><p>实际上，简单来说，它是 HTTP 的安全版，是使用 SSL(Secure Socket Layer)/TLS(Transport Layer Security) 加密的 HTTP 协议。通过 TLS/SSL 协议的的身份验证、信息加密和完整性校验的功能，从而避免信息窃听、信息篡改和信息劫持的风险。</p><a class=anchor id=执行流程></a><h1>执行流程 <a href=#%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b aria-hidden=true>#</a></h1><p>我们直接从 WireShark 的官网网站上下载了一个 HTTPS 的示例，详细的下载地址可以参考文章末尾的参考内容。</p><p>首先，是正常的 TCP 开始的三次握手连接，在此就不做过多的介绍了；完成之后才会开始 SSL 之间的沟通，这也是接下来重点介绍的内容。</p><p>在进行正常的数据传输之前，会有一个协商的过程，包括了协议的版本、会话ID、加密算法 (含有一套，后面介绍)、压缩方法；另外，在该阶段，还会相互交换服务端和客户端的随机值。</p><a class=anchor id=1-client-hello></a><h2>1. Client Hello <a href=#1-client-hello aria-hidden=true>#</a></h2><p>示例中有两个会话的数据传输，分别是 SSLv2.0 以及 SSLv3.0，现在一般使用的是 v3.0，其中 v2.0 在该阶段会使用 challenge 机制，不过不太清楚详细内容，在 <a href=https://tools.ietf.org/rfc/rfc6101.txt>RFC-6101</a> 中略有介绍。</p><p>这里，仅介绍 v3.0 的内容。</p><p><img alt=https src=images/https-protocol-00.png class="mx-auto d-block"></p><p>在上述的图片中，包括了协议的版本信息，还有些比较重要的信息。</p><a class=anchor id=随机数></a><h5>随机数 <a href=#%e9%9a%8f%e6%9c%ba%e6%95%b0 aria-hidden=true>#</a></h5><p>开始的四个字节以 Unix 时间格式记录了客户端 UTC 时间 (从1970年1月1日开始到当前时刻所经历的秒数)；接着后面有 28 字节的随机数，在后面的过程中我们会用到这个 <strong>客户端的随机数</strong> 。</p><a class=anchor id=session-id-sid></a><h5>Session ID, SID <a href=#session-id-sid aria-hidden=true>#</a></h5><p>一般来说，第一次建立连接的时候 ID 是一个空值 (NULL)，当然也有可能会重用之前的会话，从而避免一个完整的握手过程。</p><a class=anchor id=密文族-cipher-suites></a><h5>密文族 (Cipher Suites) <a href=#%e5%af%86%e6%96%87%e6%97%8f-cipher-suites aria-hidden=true>#</a></h5><p>密文族是浏览器所支持的加密算法的清单，整个密文族有 20 种。</p><p>另外，有是还会有 Server_name 的扩展，能告诉服务器浏览器当前尝试访问的域名。</p><a class=anchor id=2-server-hello></a><h2>2. Server Hello <a href=#2-server-hello aria-hidden=true>#</a></h2><p>在服务端回复的报文中，包含了三部分子信息：Server Hello、Certificate、Server Hello Done，实际上这是第一个会话的内容，如果复用会话，这里的报文内容会有所区别。</p><p><img alt=https src=images/https-protocol-01.png class="mx-auto d-block"></p><a class=anchor id=server-hello></a><h4>Server Hello <a href=#server-hello aria-hidden=true>#</a></h4><p>在服务器发送的 Hello 握手报文中，同样包括了 4 字节的 UTC 时间戳以及 28 字节随机数；还有会话 ID 以及服务器最终选择的加密族。</p><p>可以看到，在一堆加密族中，最终选择的是 <code>TLS_RSA_WITH_3DES_EDE_CBC_SHA</code>，这也就意味着将会使用 RSA 公钥加密算法来区分证书签名和交换密钥；通过 <code>3DES_EDE_CBC</code> 加密算法来加密数据；利用 SHA 来做 hash 校验信息。</p><a class=anchor id=certificate></a><h4>Certificate <a href=#certificate aria-hidden=true>#</a></h4><p>也就是证书信息，该证书允许客户端在服务器上进行认证，证书的内容是明文保存的，可以通过浏览器查看，当然也包括了 WireShark 。</p><p><img alt=https src=images/https-protocol-02.png class="mx-auto d-block"></p><a class=anchor id=server-hello-done></a><h4>Server Hello Done <a href=#server-hello-done aria-hidden=true>#</a></h4><p>这是一个零字节信息，用于告诉客户端整个协商过程已经结束，并且表明服务器不会再向客户端询问证书。</p><a class=anchor id=3-校验证书></a><h2>3. 校验证书 <a href=#3-%e6%a0%a1%e9%aa%8c%e8%af%81%e4%b9%a6 aria-hidden=true>#</a></h2><p>此时，浏览器已经获取了服务器的证书，浏览器会通过证书确认网站是否受信，它会检查支持的域名、是否在证书有效时间范围内、确认证书所携带的公共密钥已被授权用于交换密钥。</p><p>为什么我们要信任这个证书？证书中所包含的签名是一串非常长的大端格式的数字：</p><p><img alt=https src=images/https-protocol-03.png class="mx-auto d-block"></p><p>在验证证书的有效性的时候，会逐级去寻找签发者的证书，直至根证书为结束，然后通过公钥一级一级验证数字签名的正确性。</p><a class=anchor id=4-生成-premaster></a><h2>4. 生成 Premaster <a href=#4-%e7%94%9f%e6%88%90-premaster aria-hidden=true>#</a></h2><p>当客户端通过了证书校验之后，会生成 48 字节的随机数，称为 Pre-master Secret 。如前所述，最终选择 RSA 来交换密钥，此时 pre-master 会用来计算 master secret 以及 key block 。</p><p><img alt=https src=images/https-protocol-04.png class="mx-auto d-block"></p><p>其中，<code>pre-master secret</code> 在发送时，会通过服务器的公钥进行加密。</p><p>另外，该报文中还通过 &ldquo;Change Cipher Spec&rdquo; 告知服务器，后面客户端发送的信息，都是按照之前协商好的算法进行。</p><p>而最后的 &ldquo;Encrypted Handshake Message&rdquo; 则包含了之前通讯中的 hash 和 MAC 信息。</p><a class=anchor id=5-计算-master-secret-以及-key-block></a><h2>5. 计算 Master Secret 以及 Key Block <a href=#5-%e8%ae%a1%e7%ae%97-master-secret-%e4%bb%a5%e5%8f%8a-key-block aria-hidden=true>#</a></h2><p>到此为止，服务端和客户端都知道了 Pre-master secret (48Bytes) + Client.random (28Bytes) + Server.random (28Bytes)，接下来就会按照协议，通过如下的算法生成 Master Secret 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>master_secret = PRF(pre_master_secret, &#34;master secret&#34;, ClientHello.random + ServerHello.random)
</span></span></code></pre></div><p>其中 PRF 是一个随机函数，定义如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR P_SHA-1(S2, label + seed)
</span></span></code></pre></div><p>在计算 Master Secret 的同时，服务器和客户端还会同时计算 Key Block ，算法如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>key_block = PRF(SecurityParameters.master_secret, &#34;key expansion&#34;,
</span></span><span class=line><span class=cl>    SecurityParameters.server_random + SecurityParameters.client_random);
</span></span></code></pre></div><p>Key Block 会被分为不同的 Blocks。</p><p><img alt=https src=images/https-key-blocks.png class="mx-auto d-block"></p><p>其中，MAC Key 用来对数据进行验证的，Encryption Key 用来对数据进行加解密的会话密钥。</p><a class=anchor id=6-服务端确认加密></a><h2>6. 服务端确认加密 <a href=#6-%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%a1%ae%e8%ae%a4%e5%8a%a0%e5%af%86 aria-hidden=true>#</a></h2><p>服务端在收到客户端发送的 &ldquo;Encrypted Message&rdquo; 消息之后，会对其中的值进行校验，如果校验失败则会关闭连接。</p><p><img alt=https src=images/https-protocol-05.png class="mx-auto d-block"></p><p>校验成功则会与客户端一样发送 &ldquo;Change Cipher Spec&rdquo; 。</p><a class=anchor id=7-发送加密信息></a><h2>7. 发送加密信息 <a href=#7-%e5%8f%91%e9%80%81%e5%8a%a0%e5%af%86%e4%bf%a1%e6%81%af aria-hidden=true>#</a></h2><p>到此为止，双方就可以愉快的发送加密信息了。</p><a class=anchor id=8-杂项></a><h2>8. 杂项 <a href=#8-%e6%9d%82%e9%a1%b9 aria-hidden=true>#</a></h2><p>记录下，杂七杂八的东西。</p><a class=anchor id=encrypted-handshake-message></a><h4>Encrypted Handshake Message <a href=#encrypted-handshake-message aria-hidden=true>#</a></h4><p>实际上，在应用数据在传输之前，也就是在握手中的加密数据，要附加上 MAC Secret，然后再对这个数据包使用 write encryption key 进行加密。</p><p>在服务端收到密文之后，使用 Client write encryption key 进行解密，客户端收到服务端的数据之后使用 Server write encryption key 进行解密，然后使用各自的 write MAC key 对数据的完整性包括是否被串改进行验证。</p><a class=anchor id=premaster-secret></a><h4>Premaster Secret <a href=#premaster-secret aria-hidden=true>#</a></h4><p>其长度为 48 个字节，前 2 个字节是协议版本号，剩下的 46 个字节填充一个随机数。</p><p>需要注意，前两个随机数都是明文传输的，窃听者是可以轻易获取到的，只有最后一个 PreMaster Secret 是加密传输的，只有拥有服务器私钥才能解密，一旦 PreMaster Secret 泄露，那么本次通信就就完全可被破解了。</p><a class=anchor id=关于随机数></a><h4>关于随机数 <a href=#%e5%85%b3%e4%ba%8e%e9%9a%8f%e6%9c%ba%e6%95%b0 aria-hidden=true>#</a></h4><p>如上，是通过三个随机数来生成最终的 Master Secret 的，SSL 协议不信任每个主机都能生成完全随机的随机数，所以这里需要服务器和客户端共生成 3 个随机数，每增加一个自由度，随机性就会相应增加。</p><a class=anchor id=攻击></a><h1>攻击 <a href=#%e6%94%bb%e5%87%bb aria-hidden=true>#</a></h1><p>Web 安全是一项系统工程，任何细微疏忽都可能导致整个安全壁垒土崩瓦解。</p><p>如上所述，虽然 HTTPS 提供了 内容加密、数据完整性、身份认证 三大安全保证；但是，也会受到非法根证书、服务端配置错误、SSL 库漏洞、私钥被盗等等风险的影响。</p><a class=anchor id=man-in-the-middle></a><h2>Man-in-the-middle <a href=#man-in-the-middle aria-hidden=true>#</a></h2><p>也就是中间人攻击，能够与网络通讯两端分别创建连接，交换其收到的数据，使得通讯两端都认为自己直接与对方对话，事实上整个会话都被中间人所控制。</p><p>类似于一些抓包调试工具，基本都是通过创建本地 Proxy 服务，再修改浏览器 Proxy 设置来达到拦截流量的目的，它们的工作原理与中间人攻击一致，常见的有 Fiddler、Charles 和 Whistle。</p><p>在此主要讨论 HTTPS 中间人，简单示意如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Server &lt;---&gt; Local Proxy &lt;---&gt; Browser
</span></span><span class=line><span class=cl>         ^                 ^
</span></span><span class=line><span class=cl>       HTTPS(1)          HTTPS(2)
</span></span></code></pre></div><p>上述 HTTPS(1) 连接，是中间人冒充客户端与服务端建立的连接，由于 HTTPS 服务端一般不认证客户端身份，这一步通常没有问题。</p><p>对于 HTTPS(2) 连接来说，中间人想要冒充服务端，必须拥有对应域名的证书私钥，而攻击者要拿到私钥，只能通过这些手段：1）去网站服务器上拿；2）从 CA 处签发证书；3）自己签发证书。</p><p>要防范前两点，需要保障主机安全避免私钥被盗，避免攻击者重签证书；对于自签证书，需要防止在客户端添加内置根证书，如下是 Fiddler 工具添加的受信根证书。</p><p><img alt="https root" src=images/https-man-in-the-middle.png class="mx-auto d-block"></p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><ul><li>一篇介绍 https 不错的文章，可以参考中文版 <a href=http://blog.jobbole.com/48369/>HTTPS连接的前几毫秒发生了什么</a>，或者英文版 <a href=http://www.moserware.com/2009/06/first-few-milliseconds-of-https.html>The First Few Milliseconds of an HTTPS Connection</a>，或者 [本地保存的版本](/reference/linux/The First Few Milliseconds of an HTTPS Connection.mht)；细节内容也可以参考协议的实现 <a href=https://tools.ietf.org/rfc/rfc6101.txt>SSL V3.0</a> 。</li><li>其中的示例是从 <a href=https://wiki.wireshark.org/SampleCaptures>WireShark SampleCaptures</a> 上下载的，也就是 <a href="https://wiki.wireshark.org/SampleCaptures?action=AttachFile&amp;do=get&amp;target=snakeoil2_070531.tgz">SSL with decryption keys</a>，也可以从 <a href=/reference/linux/ssl-example.tar.bz2>本地</a> 下载。</li><li><a href=http://blog.jobbole.com/95106/>使用 Wireshark 调试 HTTP/2 流量</a>，通过 FireFox 导出密钥，可以参考 <a href=/reference/linux/Wireshark_HTTP_2.mht>本地文档</a> 。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#执行流程>执行流程</a><ul><li><a href=#1-client-hello>1. Client Hello</a></li><li><a href=#2-server-hello>2. Server Hello</a></li><li><a href=#3-校验证书>3. 校验证书</a></li><li><a href=#4-生成-premaster>4. 生成 Premaster</a></li><li><a href=#5-计算-master-secret-以及-key-block>5. 计算 Master Secret 以及 Key Block</a></li><li><a href=#6-服务端确认加密>6. 服务端确认加密</a></li><li><a href=#7-发送加密信息>7. 发送加密信息</a></li><li><a href=#8-杂项>8. 杂项</a></li></ul></li><li><a href=#攻击>攻击</a><ul><li><a href=#man-in-the-middle>Man-in-the-middle</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>