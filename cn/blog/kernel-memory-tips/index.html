<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Kernel 内存杂项 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="简单介绍下内核中与内存相关的内容。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Kernel 内存杂项</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2015-02-21</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>简单介绍下内核中与内存相关的内容。</p><a class=anchor id=overcommit></a><h1>OverCommit <a href=#overcommit aria-hidden=true>#</a></h1><p>内核中内存的 OverCommit 就是操作系统承诺给所有进程的内存大小超过了实际可用的内存，主要是由于物理内存页的分配发生在使用时，而非申请时，也就是所谓的 COW 机制。</p><p>例如，程序通过 <code>malloc()</code> 申请了 200MB 内存，不过实际只使用了 100MB 的内存，也就是说，只要你来申请内存我就给你，寄希望于进程实际上用不到那么多内存。</p><p>如果申请了内存之后，确实会有大量进程使用内存，那么就会发生类似银行的 &ldquo;挤兑&rdquo;，此时就会使用 Linux 的 OOM killer 机制。</p><p>其行为可以通过 <code>vm.overcommit_memory</code> 参数修改，包括了三种取值：</p><ul><li>0 (Heuristic Overcommit Handling)，默认值<br>允许 OC ，不过如果申请的内存过大，那么系统会拒绝请求，而判断的算法在后面介绍。</li><li>1 (Always Overcommit)<br>允许 OC，对内存申请来者不拒。</li><li>2 (Don&rsquo;t Overcommit)<br>禁止 OC 。</li></ul><p>当上述的值为 2 时，会禁止 OC，那么怎么才算是 OC 呢？实际上，Kernel 设有一个阈值，申请的内存总数超过这个阈值就算 OC，阀值可以通过 <code>/proc/meminfo</code> 文件查看：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># grep -i commit /proc/meminfo
</span></span><span class=line><span class=cl>CommitLimit:    12162784 kB
</span></span><span class=line><span class=cl>Committed_AS:    6810268 kB
</span></span></code></pre></div><p>其中 <code>CommitLimit</code> 就是对应的阈值，超过了该值就算 Overcommit ，该值通过 <code>vm.overcommit_ratio</code> 或 <code>vm.overcommit_kbytes</code> 间接设置的，公式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CommitLimit = (Physical RAM * vm.overcommit_ratio / 100) + Swap
</span></span></code></pre></div><p>其中 <code>vm.overcommit_ratio</code> 的默认值是 50，也就是表示物理内存的 50% ，当然，也可以直接通过 <code>vm.overcommit_kbytes</code> 即可。注意，如果 huge pages 那么就需要从物理内存中减去，公式变成：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CommitLimit = ([total RAM] – [total huge TLB RAM]) * vm.overcommit_ratio / 100 + swap
</span></span></code></pre></div><p>另外，<code>/proc/meminfo</code> 中的 <code>Committed_AS</code> 表示所有进程已经申请的内存总大小；注意，是已经申请的，不是已经分配的。如果 <code>Committed_AS</code> 超过 <code>CommitLimit</code> 就表示发生了 OC 。</p><a class=anchor id=dentry-cache></a><h1>Dentry Cache <a href=#dentry-cache aria-hidden=true>#</a></h1><p>free 命令主要显示的用户的内存使用 (新版available可用)，包括使用 top 命令 (可以通过 Shift+M 内存排序)，对于 slab 实际上没有统计 (可以使用 slabtop 查看)，真实环境中，经常会出现 dentry(slab) 的内存消耗过大的情况。</p><p>dentry cache 是目录项高速缓存，记录了目录项到 inode 的映射关系，用于提高目录项对象的处理效率，当通过 stat() 查看文件信息、open() 打开文件时，都会创建 dentry cache 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 查看当前进程的系统调用
</span></span><span class=line><span class=cl># strace -f -e trace=open,stat,close,unlink -p $(ps aux | grep &#39;cmd&#39; | awk &#39;{print $2}&#39;)
</span></span></code></pre></div><p>不过这里有个比较奇怪的现象，从 <code>/proc/meminfo</code> 可以看出，slab 中的内存分为 SReclaimable 和 SUnreclaim 两部分；而占比比较大的是 SReclaimable 的内存，也就是可以回收的内存，但是，当通过 slabtop 命令查看 dentry 对应的使用率时，基本处于 100% 的使用状态。</p><p>那么，到底是什么意思？这部分内存能不能回收？</p><p>首先，<code>/proc/meminfo</code> 对应到源码中为 <code>fs/proc/meminfo.c</code>，在内核中与这两个状态相关的代码在 <code>mm/slub.c</code> 中 (如果是新版本的内核)；简单来说就是对应到了 <code>allocate_slab()</code> 和 <code>__free_slab()</code> 函数中，实际上源码中直接搜索 <code>NR_SLAB_RECLAIMABLE</code> 即可。</p><p>对应到源码码中，实际只要申请 cache 时使用了 <code>SLAB_RECLAIM_ACCOUNT</code> 标示，那么在进行统计时，就会被标记为 SReclaimable 。</p><p>也就是说 meminfo 中的 SReclaimable 标识的是可以回收的 cache，但是真正的回收操作是由各个申请模块控制的，对于 dentry 来说，真正的回收操作还是 dentry 模块自己负责。</p><a class=anchor id=解决方法></a><h2>解决方法 <a href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95 aria-hidden=true>#</a></h2><p>对于上述的 slab 内存占用过多的场景，在 Linux 2.6.16 之后提供了 <a href=https://linux-mm.org/Drop_Caches>drop caches</a> 机制，用于释放 page cache、inode/dentry caches ，方法如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 刷新文件系统缓存
</span></span><span class=line><span class=cl># sync
</span></span><span class=line><span class=cl>----- 释放Page Cache
</span></span><span class=line><span class=cl># echo 1 &gt; /proc/sys/vm/drop_caches
</span></span><span class=line><span class=cl>----- 释放dentries+inodes
</span></span><span class=line><span class=cl># echo 2 &gt; /proc/sys/vm/drop_caches
</span></span><span class=line><span class=cl>----- 释放pagecache, dentries, inodes
</span></span><span class=line><span class=cl># echo 3 &gt; /proc/sys/vm/drop_caches
</span></span><span class=line><span class=cl>----- 如果没有root权限，但是有sudo权限
</span></span><span class=line><span class=cl>$ sudo sysctl -w vm.drop_caches=3
</span></span></code></pre></div><p>注意，修改 drop_caches 的操作是无损的，不会释放脏页，所以需要在执行前执行 sync 以确保确实有可以释放的内存。</p><p>另外，除了上述的手动处理方式之外，还可以通过修改 <code>/proc/sys/vm/vfs_cache_pressure</code> 的参数，来调整自动清理 inode/dentry caches 的优先级，默认为 100 此时需要调大；关于该参数可以参考内核文档 <a href=https://www.kernel.org/doc/Documentation/sysctl/vm.txt>vm.txt</a>，简单摘抄如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This percentage value controls the tendency of the kernel to reclaim
</span></span><span class=line><span class=cl>the memory which is used for caching of directory and inode objects.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>At the default value of vfs_cache_pressure=100 the kernel will attempt to
</span></span><span class=line><span class=cl>reclaim dentries and inodes at a &#34;fair&#34; rate with respect to pagecache and
</span></span><span class=line><span class=cl>swapcache reclaim.  Decreasing vfs_cache_pressure causes the kernel to prefer
</span></span><span class=line><span class=cl>to retain dentry and inode caches. When vfs_cache_pressure=0, the kernel will
</span></span><span class=line><span class=cl>never reclaim dentries and inodes due to memory pressure and this can easily
</span></span><span class=line><span class=cl>lead to out-of-memory conditions. Increasing vfs_cache_pressure beyond 100
</span></span><span class=line><span class=cl>causes the kernel to prefer to reclaim dentries and inodes.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Increasing vfs_cache_pressure significantly beyond 100 may have negative
</span></span><span class=line><span class=cl>performance impact. Reclaim code needs to take various locks to find freeable
</span></span><span class=line><span class=cl>directory and inode objects. With vfs_cache_pressure=1000, it will look for
</span></span><span class=line><span class=cl>ten times more freeable objects than there are.
</span></span></code></pre></div><p>也就是说，当该文件对应的值越大时，系统的回收操作的优先级也就越高，不过内核对该值好像不敏感，一般会设置为 10000 。</p><p>接下来，看看如何保留部分内存。</p><a class=anchor id=min_free_kbytes></a><h2>min_free_kbytes <a href=#min_free_kbytes aria-hidden=true>#</a></h2><p>该参数在内核文档 <a href=https://www.kernel.org/doc/Documentation/sysctl/vm.txt>vm.txt</a>，简单摘抄如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>This is used to force the Linux VM to keep a minimum number
</span></span><span class=line><span class=cl>of kilobytes free.  The VM uses this number to compute a
</span></span><span class=line><span class=cl>watermark[WMARK_MIN] value for each lowmem zone in the system.
</span></span><span class=line><span class=cl>Each lowmem zone gets a number of reserved free pages based
</span></span><span class=line><span class=cl>proportionally on its size.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Some minimal amount of memory is needed to satisfy PF_MEMALLOC
</span></span><span class=line><span class=cl>allocations; if you set this to lower than 1024KB, your system will
</span></span><span class=line><span class=cl>become subtly broken, and prone to deadlock under high loads.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Setting this too high will OOM your machine instantly.
</span></span></code></pre></div><p>该参数值在 init_per_zone_wmark_min() 函数中设置，</p><p>该参数的主要用途是计算影响内存回收的三个参数 <code>watermark[min/low/high]</code>，每个 Zone 都保存了各自的参数值，不同的范围操作如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt; watermark[low]
</span></span><span class=line><span class=cl>  触发内核线程kswapd回收内存，直到该Zone的空闲内存数达到watermark[high]；
</span></span><span class=line><span class=cl>&lt; watermark[min]
</span></span><span class=line><span class=cl>  进行direct reclaim (直接回收)，即直接在应用程序的进程上下文中进行回收，再用
</span></span><span class=line><span class=cl>  回收上来的空闲页满足内存申请，因此实际会阻塞应用程序，带来一定的响应延迟，
</span></span><span class=line><span class=cl>  而且可能会触发系统OOM。
</span></span></code></pre></div><p>实际上，可以认为 <code>watermark[min]</code> 以下的内存属于系统的自留内存，用以满足特殊使用，所以不会给用户态的普通申请来用。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>关于内存的 OverCommit 可以参考内核文档 [vm/overcommit-accounting]( {{ site.kernel_docs_url }}/Documentation/vm/overcommit-accounting ) 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#overcommit>OverCommit</a></li><li><a href=#dentry-cache>Dentry Cache</a><ul><li><a href=#解决方法>解决方法</a></li><li><a href=#min_free_kbytes>min_free_kbytes</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>