<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>C 语言 Volatile 使用简介 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="C 语言中的 volatile 关键字大部分都见过，但是很少有人能明确其具体使用的场景。实际上，上层编程很少会用到，一般只有涉及到 IO、中断等与硬件交互的底层编程才会经常使用。
这里简单介绍其使用场景，使用方法。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>C 语言 Volatile 使用简介</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2018-05-20</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/c/cpp/ role=button>c/cpp</a></div></div><hr><div class=content><p>C 语言中的 volatile 关键字大部分都见过，但是很少有人能明确其具体使用的场景。实际上，上层编程很少会用到，一般只有涉及到 IO、中断等与硬件交互的底层编程才会经常使用。</p><p>这里简单介绍其使用场景，使用方法。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>volatile 是 C/C++ 标准中的一个关键字，会影响<strong>编译器</strong>的编译结果，用来表明对应变量随时可能发生变化，每次使用时需要重新读取，而非使用寄存器中的值。</p><p>注意，在 Java 中同样存在改关键字，但是含义完全不同，这里仅局限在 C/C++ 中的使用。</p><a class=anchor id=编译器></a><h2>编译器 <a href=#%e7%bc%96%e8%af%91%e5%99%a8 aria-hidden=true>#</a></h2><p>通过编译器将 C 代码转换为机器码，然后可以直接在硬件平台上运行，而不再需要源码。</p><p>与其它技术类似，在代码转换过程中，编译器会对代码进行优化，以降低生成机器码量，提高代码的执行速度，常见的优化方法有：A) 将内存变量缓存到寄存器；B) 调整指令顺序充分利用 CPU 。</p><p>那么带来的副作用的话就是，有部分非预期内的优化导致原有逻辑运行异常。</p><p>简单来说，在线程内读取一个变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后，再取变量值时，就直接从寄存器中取值。</p><p>线程内修改同样会同步到寄存器，但是其它线程修改了值，对于本线程是不可见的。</p><a class=anchor id=详解></a><h2>详解 <a href=#%e8%af%a6%e8%a7%a3 aria-hidden=true>#</a></h2><p>假设有如下的代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>uint32</span> <span class=n>status</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>status</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* 代码执行逻辑，不会修改 status 的值 */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 <code>while</code> 循环中不会修改 <code>status</code> 变量的值，那么对于编译器来说，会认为 <code>status</code> 一直不会修改，而直接将代码优化为类似 <code>while(1)</code> 的死循环。</p><p>但是实际上，<code>status</code> 的值会通过内存映射在 IO 设备中被修改。</p><p>当然，也可以通过关闭优化修复现在的问题，但是同样会带来其它的影响：</p><ol><li>每个编译器的优化方式不同，这段代码可能会不可移植；</li><li>仅仅因为这一段代码，可能会降低整个系统的运行效率。</li></ol><p>实际上，这一场景就是 <code>volatile</code> 经常使用的。</p><p>另外，需要注意，上述使用 <code>uint32</code> 类型只是为了方便说明，真正使用时，一般都是指针，然后将指针通过映射指向 IO 设备。</p><a class=anchor id=定义></a><h2>定义 <a href=#%e5%ae%9a%e4%b9%89 aria-hidden=true>#</a></h2><p>在 C 语言标准 <code>ISO/IEC 9899 C11</code> 的 6.7.3 中，有如下的定义：</p><blockquote><p>An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects.</p><p>A volatile declaration may be used to describe an object corresponding to a memory-mapped input/output port or an object accessed by an asynchronously interrupting function. Actions on objects so declared shall not be ‘‘optimized out’’ by an implementation or reordered except as permitted by the rules for evaluating expressions.</p></blockquote><p>也即是，如上所说的，如果将变量定义为 <code>volatile</code> 类型，这也就意味着该变量可能随时被修改，每次使用时应该重新读取。</p><a class=anchor id=示例></a><h1>示例 <a href=#%e7%a4%ba%e4%be%8b aria-hidden=true>#</a></h1><p>出了上述与底层硬件处理，另外的场景就是全局变量，最常见的有：A) ISR 中断服务中修改全局变量；B) 多线程编程中修改全局变量。在真正使用时，后者会更多。</p><p>多线程编程时，可以通过消息队列、共享内存等进行通讯，而全局变量实际上是一个简化后的共享内存。当两个线程通过全局变量共享数据，由于内核调度可能会将两个线程调度到不同的 CPU 核，那么其寄存器、上下文、L1/L2缓存都有可能会缓存该变量的值。</p><p>那么为了获取到最新的值，就需要明确告知编译器每次都要获取最新的值。</p><a class=anchor id=不使用优化></a><h2>不使用优化 <a href=#%e4%b8%8d%e4%bd%bf%e7%94%a8%e4%bc%98%e5%8c%96 aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>local</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Initial value of local : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>local</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Modified value of local: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>local</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>上述代码，通过 <code>gcc volatile.c -o volatile --save-temps</code> 进行编译，也就是没有进行优化，生成后的代码会较大。</p><p>其中 <code>--save-temps</code> 参数会保存中间生成的临时文件，包括了</p><ul><li><code>.i</code> 预处理后的代码。</li><li><code>.s</code> 汇编代码。</li><li><code>.o</code> 编译后机器码。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc volatile.c -o volatile --save-temps
</span></span><span class=line><span class=cl>$ ./volatile
</span></span><span class=line><span class=cl>Initial value of local : 10
</span></span><span class=line><span class=cl>Modified value of local: 100
</span></span><span class=line><span class=cl>$ ls -l volatile.s
</span></span><span class=line><span class=cl>-rw-r–r– 1 root root 773 Jan 01 16:21 volatile.s
</span></span></code></pre></div><a class=anchor id=优化后代码></a><h2>优化后代码 <a href=#%e4%bc%98%e5%8c%96%e5%90%8e%e4%bb%a3%e7%a0%81 aria-hidden=true>#</a></h2><p>代码不变，编译方式如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -O3 volatile.c -o volatile --save-temps
</span></span><span class=line><span class=cl>$ ./volatile
</span></span><span class=line><span class=cl>Initial value of local : 10
</span></span><span class=line><span class=cl>Modified value of local: 10
</span></span><span class=line><span class=cl>$ ls -l volatile.s
</span></span><span class=line><span class=cl>-rw-r–r– 1 root root 642 Jan 01 16:21 volatile.s
</span></span></code></pre></div><a class=anchor id=增加声明></a><h2>增加声明 <a href=#%e5%a2%9e%e5%8a%a0%e5%a3%b0%e6%98%8e aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>volatile</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>local</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>local</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Initial value of local : %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>local</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Modified value of local: %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>local</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -O3 volatile.c -o volatile --save-temps
</span></span><span class=line><span class=cl>$ ./volatile
</span></span><span class=line><span class=cl>Initial value of local : 10
</span></span><span class=line><span class=cl>Modified value of local: 100
</span></span><span class=line><span class=cl>$ ls -l volatile.s
</span></span><span class=line><span class=cl>-rw-r–r– 1 root root 694 Jan 01 16:21 volatile.s
</span></span></code></pre></div><p>注意，上述示例，不同的编译器优化的结果也不同，最新的 gcc 即使不添加 <code>volatile</code> 仍然可以输出期望的结果。</p><a class=anchor id=误使用></a><h1>误使用 <a href=#%e8%af%af%e4%bd%bf%e7%94%a8 aria-hidden=true>#</a></h1><p>实际上在内核中有关于 <code>volatile</code> 的一些讨论，可以参考 <a href=https://lwn.net/Articles/233479/>The trouble with volatile</a> 。</p><p>简单来说，<code>volatile</code> 无法解决一些常见的同步机制 (spin-lock、mutex等) ，所以对于共享数据一定要加锁；在加锁之后，可以保证数据不再是 <code>volatile</code> 易变的了，那么也就是没有必要再使用 <code>volatile</code> 了。</p><a class=anchor id=常见场景></a><h1>常见场景 <a href=#%e5%b8%b8%e8%a7%81%e5%9c%ba%e6%99%af aria-hidden=true>#</a></h1><p>相关的使用场景总结如下。</p><ol><li>mmap 映射后的 IO 空间，或者设备寄存器访问。</li><li>在 ISR 通过全局变量访问。</li><li>多线程编程中的共享全局变量。</li></ol></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#编译器>编译器</a></li><li><a href=#详解>详解</a></li><li><a href=#定义>定义</a></li></ul></li><li><a href=#示例>示例</a><ul><li><a href=#不使用优化>不使用优化</a></li><li><a href=#优化后代码>优化后代码</a></li><li><a href=#增加声明>增加声明</a></li></ul></li><li><a href=#误使用>误使用</a></li><li><a href=#常见场景>常见场景</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>