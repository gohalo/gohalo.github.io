<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>C 加载过程 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>C 加载过程</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2015-09-15</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/c/cpp/ role=button>c/cpp</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>这里主要讨论符号的动态链接过程，即程序在执行过程中，对其中包含的一些未确定地址的符号进行重定位的过程。</p><a class=anchor id=shell-执行></a><h1>Shell 执行 <a href=#shell-%e6%89%a7%e8%a1%8c aria-hidden=true>#</a></h1><p>在 Linux 中，可以在 Bash 中直接调用一个执行命令，甚至是一个脚本，脚本中甚至不需要指定解析器，这里简单介绍下 Bash 的执行过程。</p><p>目前一般使用的是虚拟终端，可以在当前终端中通过 <code>tty</code> 命令查看，假设为 <code>/dev/pts/27</code>，然后再通过 <code>ps -ef | grep pts/27 | grep bash | grep -v grep</code> 查看对应的 PID 。</p><p>打开另一个终端，通过 <code>pstack PID</code> 即可看到对应的调用堆栈。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>main()                               ← 各种初始化工作，shell.c
</span></span><span class=line><span class=cl> |-reader_loop()                     ← 死循环，通过read_command()读取命令，eval.c
</span></span><span class=line><span class=cl>   |-read_command()                  ← 通过parse_command()和yyparse()解析输入的命令，eval.c
</span></span><span class=line><span class=cl>   |-execute_command()               ← 开始执行命令，execute_cmd.c
</span></span><span class=line><span class=cl>     |-execute_command_internal()
</span></span><span class=line><span class=cl>       |-execute_simple_command()
</span></span><span class=line><span class=cl>         |-execute_disk_command()
</span></span><span class=line><span class=cl>           |-execve()                ← 通过系统调用执行
</span></span></code></pre></div><p>其中词法语法解析通过 <code>flex-biso</code> 解析，涉及的文件为 <code>parse.y</code>，没有找到词法解析的文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ rpm -qf `which bash`                      // 查看所属包
</span></span><span class=line><span class=cl>$ yumdownloader --source bash               // 下载源码
</span></span><span class=line><span class=cl>$ rpm2cpio bash-version.src.rpm | cpio -id  // 解压源码
</span></span></code></pre></div><p>通过 <code>strace ./hello</code> 查看系统调用，定位到 <code>execve()</code> ，也就是通过该函数执行。</p><a class=anchor id=内核加载></a><h1>内核加载 <a href=#%e5%86%85%e6%a0%b8%e5%8a%a0%e8%bd%bd aria-hidden=true>#</a></h1><p>上述的 <code>execve()</code> 实际上就是内核提供的一个系统调用，会将 ELF 文件加载到内存中，如果涉及到动态链接，那么还会在用户态中解析相关函数的地址，这也就是解析器的功能。</p><p>一般解析器是 <code>ld-linux.so.2</code>，解释器的装入/启动也由内核负责，详细可以查看 <a href=/post/kernel-memory-management-from-userspace-view.html>内存-用户空间</a> 中的介绍，在此只介绍 ELF 的加载过程。</p><a class=anchor id=内核模块></a><h2>内核模块 <a href=#%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97 aria-hidden=true>#</a></h2><p>如果要支持不同的执行格式，需要在内核中添加注册模块，每种类型通过 <code>struct linux_binfmt</code> 格式表示，其定义以及 ELF 的定义如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-v data-lang=v><span class=line><span class=cl><span class=kd>struct</span> <span class=nv>linux_binfmt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>struct</span> <span class=nv>list_head</span> <span class=nv>lh</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>struct</span> <span class=kn>module</span> <span class=o>*</span><span class=kn>module</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=nv>load_binary</span><span class=p>)(</span><span class=kd>struct</span> <span class=nv>linux_binprm</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=nv>load_shlib</span><span class=p>)(</span><span class=kd>struct</span> <span class=nv>file</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=nv>core_dump</span><span class=p>)(</span><span class=kd>struct</span> <span class=nv>coredump_params</span> <span class=o>*</span><span class=nv>cprm</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nv>unsigned</span> <span class=nv>long</span> <span class=nv>min_coredump</span><span class=p>;</span> <span class=cm>/* minimal dump size */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kd>struct</span> <span class=nv>linux_binfmt</span> <span class=nv>elf_format</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=kn>module</span>        <span class=o>=</span> <span class=nc>THIS_MODULE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nv>load_binary</span>   <span class=o>=</span> <span class=nv>load_elf_binary</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nv>load_shlib</span>    <span class=o>=</span> <span class=nv>load_elf_library</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nv>core_dump</span>     <span class=o>=</span> <span class=nv>elf_core_dump</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=nv>min_coredump</span>  <span class=o>=</span> <span class=nc>ELF_EXEC_PAGESIZE</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>其中的 <code>load_binary</code> 函数指针指向的就是一个可执行程序的处理函数，要支持 ELF 文件的运行，则必须通过 <code>register_binfmt()</code> 向内核登记这个数据结构，加入到内核支持的可执行程序的队列中。</p><p>当要运行程序时，则扫描该队列，让各对象所提供的处理程序 (ELF中即为<code>load_elf_binary()</code>)，逐一前来认领，如果某个格式的处理程序发现相符后，便执行该格式映像的装入和启动。</p><a class=anchor id=内核加载-1></a><h2>内核加载 <a href=#%e5%86%85%e6%a0%b8%e5%8a%a0%e8%bd%bd-1 aria-hidden=true>#</a></h2><p>内核执行 <code>execv()</code> 或 <code>execve()</code> 系统调用时，会通过 <code>do_execve()</code> 调用，该函数先打开目标映像文件，并读入文件的头部信息，也就是开始 128 字节。</p><p>然后，调用另一个 <code>search_binary_handler()</code> 函数，该函数中会搜索上面提到的 Linux 支持的可执行文件类型队列，让各种可执行程序的处理程序前来认领和处理。</p><p>如果类型匹配，则调用 <code>load_binary</code> 函数指针所指向的处理函数来处理目标映像文件，对于 ELF 文件也就是 <code>load_elf_binary()</code> 函数，下面主要就是分析 <code>load_elf_binary()</code> 的执行过程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>load_elf_binary</span><span class=p>(</span><span class=k>struct</span> <span class=n>linux_binprm</span> <span class=o>*</span><span class=n>bprm</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 上述已经读取 128 字节的头部信息 */</span>
</span></span><span class=line><span class=cl>    <span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span> <span class=o>=</span> <span class=o>*</span><span class=p>((</span><span class=k>struct</span> <span class=n>elfhdr</span> <span class=o>*</span><span class=p>)</span><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>retval</span> <span class=o>=</span> <span class=o>-</span><span class=n>ENOEXEC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 首先校验ELF的头部信息，也就是&#34;\177ELF&#34; */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>memcmp</span><span class=p>(</span><span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_ident</span><span class=p>,</span> <span class=n>ELFMAG</span><span class=p>,</span> <span class=n>SELFMAG</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 只能是可执行文件(ET_EXEC)或者动态库(ET_DYN) */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_type</span> <span class=o>!=</span> <span class=n>ET_EXEC</span> <span class=o>&amp;&amp;</span> <span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_type</span> <span class=o>!=</span> <span class=n>ET_DYN</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 读取ELF的头部信息，也就是整个Program Header Table，一个可执行程序必须至少有一个段，且不能超过64K */</span>
</span></span><span class=line><span class=cl>    <span class=n>retval</span> <span class=o>=</span> <span class=nf>kernel_read</span><span class=p>(</span><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>,</span> <span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_phoff</span><span class=p>,</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=n>elf_phdata</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>!=</span> <span class=n>size</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>retval</span> <span class=o>=</span> <span class=o>-</span><span class=n>EIO</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>out_free_ph</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 在for循环中，用来寻找和处理目标映像的&#34;解释器&#34;段，可以通过 ???????? 查看 */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_phnum</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>elf_ppnt</span><span class=o>-&gt;</span><span class=n>p_type</span> <span class=o>==</span> <span class=n>PT_INTERP</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 找到后就根据其位置的p_offset和大小p_filesz把整个&#34;解释器&#34;段的内容读入缓冲区，实际上
</span></span></span><span class=line><span class=cl><span class=cm>             * 这个&#34;解释器&#34;段实际上只是一个字符串，即解释器的文件名，如&#34;/lib/ld-linux.so.2&#34;
</span></span></span><span class=line><span class=cl><span class=cm>             */</span>
</span></span><span class=line><span class=cl>            <span class=n>retval</span> <span class=o>=</span> <span class=nf>kernel_read</span><span class=p>(</span><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>,</span> <span class=n>elf_ppnt</span><span class=o>-&gt;</span><span class=n>p_offset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=n>elf_interpreter</span><span class=p>,</span> <span class=n>elf_ppnt</span><span class=o>-&gt;</span><span class=n>p_filesz</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>!=</span> <span class=n>elf_ppnt</span><span class=o>-&gt;</span><span class=n>p_filesz</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>retval</span> <span class=o>=</span> <span class=o>-</span><span class=n>EIO</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>out_free_interp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=cm>/* 通过open_exec()打开这个文件，再通过kernel_read()读入开始的128个字节，也就是解释器的头部 */</span>
</span></span><span class=line><span class=cl>            <span class=n>interpreter</span> <span class=o>=</span> <span class=nf>open_exec</span><span class=p>(</span><span class=n>elf_interpreter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>retval</span> <span class=o>=</span> <span class=nf>PTR_ERR</span><span class=p>(</span><span class=n>interpreter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=nf>IS_ERR</span><span class=p>(</span><span class=n>interpreter</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>out_free_interp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>retval</span> <span class=o>=</span> <span class=nf>kernel_read</span><span class=p>(</span><span class=n>interpreter</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>bprm</span><span class=o>-&gt;</span><span class=n>buf</span><span class=p>,</span> <span class=n>BINPRM_BUF_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>!=</span> <span class=n>BINPRM_BUF_SIZE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>retval</span> <span class=o>=</span> <span class=o>-</span><span class=n>EIO</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>goto</span> <span class=n>out_free_dentry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>elf_ppnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 从目标映像的程序头中搜索类型为PT_LOAD的段；在二进制映像中，只有类型为PT_LOAD的段才是需要加载的。
</span></span></span><span class=line><span class=cl><span class=cm>     * 只是在加载前，需要确定加载的地址，包括页对齐、该段的p_vaddr域的值；在确定了装入地址后，就会通过
</span></span></span><span class=line><span class=cl><span class=cm>     * elf_map()建立用户空间虚拟地址空间与目标映像文件中某个连续区间之间的映射，其返回值就是实际映射的
</span></span></span><span class=line><span class=cl><span class=cm>     * 起始地址。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>elf_ppnt</span> <span class=o>=</span> <span class=n>elf_phdata</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_phnum</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>elf_ppnt</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>elf_ppnt</span><span class=o>-&gt;</span><span class=n>p_type</span> <span class=o>!=</span> <span class=n>PT_LOAD</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>error</span> <span class=o>=</span> <span class=nf>elf_map</span><span class=p>(</span><span class=n>bprm</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>,</span> <span class=n>load_bias</span> <span class=o>+</span> <span class=n>vaddr</span><span class=p>,</span> <span class=n>elf_ppnt</span><span class=p>,</span> <span class=n>elf_prot</span><span class=p>,</span> <span class=n>elf_flags</span><span class=p>,</span> <span class=n>total_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>BAD_ADDR</span><span class=p>(</span><span class=n>error</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>retval</span> <span class=o>=</span> <span class=nf>IS_ERR</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>error</span><span class=p>)</span> <span class=o>?</span>
</span></span><span class=line><span class=cl>                <span class=nf>PTR_ERR</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>error</span><span class=p>)</span> <span class=o>:</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>out_free_dentry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 若存在PT_INTERP段，则通过load_elf_interp()加载，并把进入用户空间的入口地址设置成load_elf_interp()
</span></span></span><span class=line><span class=cl><span class=cm>     * 的返回值，即解释器映像的入口地址；如果不装入解释器，那么这个入口地址就是目标映像本身的入口地址，
</span></span></span><span class=line><span class=cl><span class=cm>     * 也就是静态编译的程序。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>elf_interpreter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>elf_entry</span> <span class=o>=</span> <span class=nf>load_elf_interp</span><span class=p>(</span><span class=o>&amp;</span><span class=n>loc</span><span class=o>-&gt;</span><span class=n>interp_elf_ex</span><span class=p>,</span> <span class=n>interpreter</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>interp_map_addr</span><span class=p>,</span> <span class=n>load_bias</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nf>IS_ERR</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>elf_entry</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>interp_load_addr</span> <span class=o>=</span> <span class=n>elf_entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>elf_entry</span> <span class=o>+=</span> <span class=n>loc</span><span class=o>-&gt;</span><span class=n>interp_elf_ex</span><span class=p>.</span><span class=n>e_entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nf>BAD_ADDR</span><span class=p>(</span><span class=n>elf_entry</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>retval</span> <span class=o>=</span> <span class=nf>IS_ERR</span><span class=p>((</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=n>elf_entry</span><span class=p>)</span> <span class=o>?</span>  <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=nl>elf_entry</span> <span class=p>:</span> <span class=o>-</span><span class=n>EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>out_free_dentry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>reloc_func_desc</span> <span class=o>=</span> <span class=n>interp_load_addr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>elf_entry</span> <span class=o>=</span> <span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>.</span><span class=n>e_entry</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 完成加载且启动用户空间的映像运行之前，还需要为目标映像和解释器准备好一些有关的信息，这些信息包括常
</span></span></span><span class=line><span class=cl><span class=cm>     * 规的argc、envc等等，还有一些&#34;辅助向量(Auxiliary Vector)&#34;。这些信息需要复制到用户空间，使它们在CPU
</span></span></span><span class=line><span class=cl><span class=cm>     * 进入解释器或目标映像的程序入口时出现在用户空间堆栈上。这里的create_elf_tables()就起着这个作用。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=n>retval</span> <span class=o>=</span> <span class=nf>create_elf_tables</span><span class=p>(</span><span class=n>bprm</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>loc</span><span class=o>-&gt;</span><span class=n>elf_ex</span><span class=p>,</span> <span class=n>load_addr</span><span class=p>,</span> <span class=n>interp_load_addr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>retval</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 最后，通过start_thread()宏将eip和esp改成新的地址，就使得CPU在返回用户空间时就进入新的程序入口。如果存
</span></span></span><span class=line><span class=cl><span class=cm>     * 在解释器映像，那么这就是解释器映像的程序入口(动态链接)，否则就是目标映像的程序入口(静态链接)。
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=nf>start_thread</span><span class=p>(</span><span class=n>regs</span><span class=p>,</span> <span class=n>elf_entry</span><span class=p>,</span> <span class=n>bprm</span><span class=o>-&gt;</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=用户态执行></a><h1>用户态执行 <a href=#%e7%94%a8%e6%88%b7%e6%80%81%e6%89%a7%e8%a1%8c aria-hidden=true>#</a></h1><p>内核加载完之后，那么就交给了用户态执行，在 <code>main()</code> 运行之前通常会先执行一段代码，运行这些代码的函数称为 <strong>入口函数</strong> 或 <strong>入口点</strong> ，大致的步骤如下：</p><ul><li>操作系统创建进程后，把控制权交给程序入口，这个入口往往是运行库中的某个入口函数。</li><li>入口函数对运行库和程序运行环境进行初始化，包括堆、I/O、线程、全局变量构造等。</li><li>入口函数在完成初始化之后，调用 <code>main()</code> 函数，正式开始执行程序主体部分。</li><li><code>main()</code> 执行完后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁、关闭 IO 等，然后进行系统调用结束进程。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ readelf -h main | grep &#39;Entry point&#39;
</span></span><span class=line><span class=cl>  Entry point address:               0x4004a0
</span></span></code></pre></div><p><code>ld.so</code> (Dynamic Linker/Loader) 和 <code>ldd</code> 都会使用到 ELF 格式中的 <code>.dynstr</code> (dynamic linking string table) 字段，如果通过 <code>strip -R .dynstr hello</code> 命令将该字段删除，那么 <code>ldd</code> 就会报错。</p><a class=anchor id=常见概念></a><h2>常见概念 <a href=#%e5%b8%b8%e8%a7%81%e6%a6%82%e5%bf%b5 aria-hidden=true>#</a></h2><p>解释器 <code>.interp</code> 分区用于指定程序动态装载、链接器 <code>ld-linux.so</code> 的位置，而过程链接表 <code>plt</code>、全局偏移表 <code>got</code>、重定位表则用于辅助动态链接过程。</p><a class=anchor id=符号></a><h3>符号 <a href=#%e7%ac%a6%e5%8f%b7 aria-hidden=true>#</a></h3><p>对于可执行文件除了编译器引入的一些符号外，主要就是用户自定义的全局变量、函数等，而对于可重定位文件仅仅包含用户自定义的一些符号。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 生成可重定位文件，并通过nm命令查看ELF文件的符号表信息
</span></span><span class=line><span class=cl>$ gcc -c main.c
</span></span><span class=line><span class=cl>$ nm main.o
</span></span><span class=line><span class=cl>0000000000000000 B global
</span></span><span class=line><span class=cl>0000000000000000 T main
</span></span><span class=line><span class=cl>                 U printf
</span></span></code></pre></div><p>上面包含全局变量、自定义函数以及动态链接库中的函数，但不包含局部变量，而且发现这三个符号的地址都没有确定。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 生成可执行文件
</span></span><span class=line><span class=cl>$ gcc -o main main.o
</span></span><span class=line><span class=cl>$ nm main | egrep &#34;main$| printf|global$&#34;
</span></span><span class=line><span class=cl>0000000000601038 B global
</span></span><span class=line><span class=cl>000000000040052d T main
</span></span><span class=line><span class=cl>                 U printf@@GLIBC_2.2.5
</span></span></code></pre></div><p>经链接之后，<code>global</code> 和 <code>main</code> 的地址都已经确定了，但是 <code>printf</code> 却还没，因为它是动态链接库 <code>glibc</code> 中定义函数，需要动态链接，而不是这里的静态链接。</p><p>也就是说 main.o 中的符号地址没有确定，而经过链接后部分符号地址已经确定，也就是对符号的引用变成了对地址的引用，这样程序运行时就可通过访问内存地址而访问特定的数据。对于动态链接库，也就是上述的 <code>printf()</code> 则需要在运行时通过动态链接器 ld-linux.so 进行重定位，即动态链接。</p><p>另外，除了 nm 还可以用 <code>readelf -s</code> 查看 <code>.dynsym</code> 表或者用 <code>objdump -tT</code> 查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ nm -D /lib64/libc-2.17.so | grep &#34;\ printf$&#34;
</span></span></code></pre></div><p>注意，在部分新系统上，如果不使用参数 <code>-D</code> ，那么可能会无法查看符号表，因为 nm 默认打印 <code>.symtab</code> 和 <code>.strtab</code>，不过一般在打包时会通过 strip 删除掉，只保留了动态符号 (在 <code>.dynsym</code> 和 <code>.dynstr</code> 中)，以便动态链接器在执行程序时寻址这些外部用到的符号。</p><a class=anchor id=加载过程></a><h1>加载过程 <a href=#%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b aria-hidden=true>#</a></h1><p>依赖动态库时，会在加载时根据可执行文件的地址和动态库的对应符号的地址推算出被调用函数的地址，这个过程被称为动态链接。</p><p>假设，现在使用的是 Position Independent Code, PIC 模型，动态库加载的过程以及一些环境变量可以通过 <code>man ld-linux</code> 查看。</p><a class=anchor id=1-获取动态链接器></a><h4>1. 获取动态链接器 <a href=#1-%e8%8e%b7%e5%8f%96%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%99%a8 aria-hidden=true>#</a></h4><p>首先，读取 ELF 头部信息，解析出 <code>PT_INTERP</code> 信息，确定动态链接器的路径，可以通过 <code>readelf -l foobar</code> 查看，一般是 <code>/lib/ld-linux.so.2</code> 或者 <code>/lib64/ld-linux-x86-64.so.2</code> 。</p><a class=anchor id=2-加载动态库></a><h4>2. 加载动态库 <a href=#2-%e5%8a%a0%e8%bd%bd%e5%8a%a8%e6%80%81%e5%ba%93 aria-hidden=true>#</a></h4><p>关于加载的详细顺序可以查看 <code>man ld</code> 中 rpath-link 的介绍，一般顺序为：</p><ol><li>链接时 <code>-rpath-link</code> 参数指定路径，只用于链接时使用，编译时通过 <code>-Wl,rpath-link=</code> 指定；</li><li>链接时通过 <code>-rpath</code> 参数指定路径，除了用于链接时使用，还会在运行时使用，编译时可利用 <code>-Wl,rpath=</code> 指定，会生成 <code>DT_RPATH</code> 或者 <code>DT_RUNPATH</code> 定义，可以通过 <code>readelf -d main | grep -E (RPATH|RUNPATH)</code> 查看；</li><li>查找 <code>DT_RUNPATH</code> 或者 <code>DT_RPATH</code> 指定的路径，如果前者存在则忽略后者；</li><li>依次查看 <code>LD_RUN_PATH</code> 和 <code>LD_LIBRARY_PATH</code> 环境变量指定路径；</li><li>查找默认路径，一般是 <code>/lib</code> 和 <code>/usr/lib</code> ，然后是 <code>/etc/ld.so.conf</code> 文件中的配置。</li></ol><p>另外，需要加载哪些库通过 <code>DT_NEEDED</code> 字段来获取，每条对应了一个动态库，可以通过 <code>readelf -d main | grep NEEDED</code> 查看。</p><a class=anchor id=示例程序></a><h2>示例程序 <a href=#%e7%a4%ba%e4%be%8b%e7%a8%8b%e5%ba%8f aria-hidden=true>#</a></h2><p>利用如下的示例程序。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename: foobar.c */</span>
</span></span><span class=line><span class=cl><span class=cp>#define _GNU_SOURCE
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dlfcn.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>foobar</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Dl_info</span> <span class=n>dl_info</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>dladdr</span><span class=p>((</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>foobar</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>dl_info</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>fprintf</span><span class=p>(</span><span class=n>stdout</span><span class=p>,</span> <span class=s>&#34;load .so at: %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dl_info</span><span class=p>.</span><span class=n>dli_fname</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename: main.c */</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>foobar</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nf>foobar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-makefile data-lang=makefile><span class=line><span class=cl><span class=c># filename: Makefile
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>all</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    gcc --shared -fPIC foobar.c -o libfoobar.so -ldl
</span></span><span class=line><span class=cl>    gcc main.c -o main -Wl,-rpath-link<span class=o>=</span>/foobar -ldl -lfoobar -L./
</span></span><span class=line><span class=cl>    readelf -d main <span class=p>|</span> grep -E <span class=o>(</span>RPATH<span class=p>|</span>RUNPATH<span class=o>)</span>
</span></span></code></pre></div><p>然后可以通过依次设置如上的加载路径进行测试。<strong>注意</strong>，在对 <code>/etc/ld.so.conf</code> 文件设置后需要通过 <code>ldconfig</code> 更新 cache 才会生效。</p><p>另外，推荐使用 <code>DT_RUNPATH</code> 而非 <code>DT_RPATH</code> ，此时，在编译时需要用到 <code>--enable-new-dtags</code> 参数。</p><a class=anchor id=版本管理></a><h2>版本管理 <a href=#%e7%89%88%e6%9c%ac%e7%ae%a1%e7%90%86 aria-hidden=true>#</a></h2><p>不同版本的动态库可能会不兼容，那么如果程序在编译时指定动态库是某个低版本，运行是用的一个高版本，可能会导致无法运行。</p><p>假设有如下的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename:hello.c */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>hello</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello %s!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename:hello.h */</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>hello</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>);</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># filename: Makefile
</span></span><span class=line><span class=cl>all:
</span></span><span class=line><span class=cl>    gcc hello.c -fPIC -shared -Wl,-soname,libhello.so.0 -o libhello.so.0.0.1
</span></span></code></pre></div><p>需要注意是，参数 <code>-Wl,soname</code> 中间没有空格，<code>-Wl</code> 选项用来告诉编译器将后面的参数传递给链接器，而 <code>-soname</code> 则指定了动态库的 <code>soname</code>。运行后在当前目录下会生成一个 <code>libhello.so.0.0.1</code> 文件，当运行 <code>ldconfig -n .</code> 命令时，当前目录会多一个符号连接。</p><p>这个软链接是根据编译生成 <code>libhello.so.0.0.1</code> 时指定的 <code>-soname</code> 生成的，会保存到编译生成的文件中，可以通过 <code>readelf -d foobar</code> 查看依赖的库。</p><p>所以关键就是这个 soname，它相当于一个中间者，当我们的动态库只是升级一个小版本时，可以让它的 soname 相同，而可执行程序只认 soname 指定的动态库，这样依赖这个动态库的可执行程序不需重新编译就能使用新版动态库的特性。</p><a class=anchor id=测试程序></a><h3>测试程序 <a href=#%e6%b5%8b%e8%af%95%e7%a8%8b%e5%ba%8f aria-hidden=true>#</a></h3><p>示例程序如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename:main.c */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;hello.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>hello</span><span class=p>(</span><span class=s>&#34;foobar&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后可以通过 <code>gcc main.c -L. -lhello -o main</code> 编译，不过此时会报 <code>cannot find -lhello.so.0</code> 错误，也就是找不到对应的库。</p><p>在 Linux 中，编译时指定 <code>-lhello</code> 时，链接器会去查找 <code>libhello.so</code> 这样的文件，如果当前目录下没有这个文件，那么就会导致报错；此时，可以通过 <code>ln -s libhello.so.0.0.1 libhello.so</code> 建立这样一个软链接。</p><p>通过 <code>ldd</code> 查看时，发现实际依赖的是 <code>libhello.so.0</code> 而非 <code>libhello</code> 也不是 <code>libhello.so.0.0.1</code> ，其实在生成 main 程序的过程有如下几步：</p><ol><li>链接器通过编译命令 <code>-L. -lhello</code> 在当前目录查找 <code>libhello.so</code> 文件；</li><li>读取 <code>libhello.so</code> 链接指向的实际文件，这里是 <code>libhello.so.0.0.1</code>；</li><li>读取 <code>libhello.so.0.0.1</code> 中的 <code>SONAME</code>，这里是 <code>libhello.so.0</code>；</li><li>将 <code>libhello.so.0</code> 记录到 <code>main</code> 程序的二进制数据里。</li></ol><p>也就是说 <code>libhello.so.0</code> 是已经存储到 main 程序的二进制数据里的，不管这个程序在哪里，通过 <code>ldd</code> 查看它依赖的动态库都是 <code>libhello.so.0</code> 。</p><p>那么，在部署时，只需要安装 <code>libhello.so.0</code> 即可。</p><a class=anchor id=版本更新></a><h3>版本更新 <a href=#%e7%89%88%e6%9c%ac%e6%9b%b4%e6%96%b0 aria-hidden=true>#</a></h3><p>假设动态库需要做一个小小的改动。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename:hello.c */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=kt>void</span> <span class=nf>hello</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;hello %s, welcom to our world!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>由于改动较小，编译动态库时仍然指定相同的 soname 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc hello.c -fPIC -shared -Wl,-soname,libhello.so.0 -o libhello.so.0.0.2
</span></span></code></pre></div><p>然后重新运行 <code>ldconfig -n .</code> 即可，会发现链接指向了新版本，然后直接运行即可。</p><p>同样，假如我们的动态库有大的改动，编译动态库时指定了新的 soname，如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc hello.c -fPIC -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0.0
</span></span></code></pre></div><p>将动态库文件拷贝到运行目录，并执行 <code>ldconfig -n .</code>，不过此时需要重新编译才可以。</p><a class=anchor id=问题排查></a><h2>问题排查 <a href=#%e9%97%ae%e9%a2%98%e6%8e%92%e6%9f%a5 aria-hidden=true>#</a></h2><p>可以通过如下方法查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>LD_TRACE_LOADED_OBJECTS=1 LD_BIND_NOW=1 LD_TRACE_PRELINKING=t /lib/ld-linux.so.2 python.so | grep ^undefined
</span></span></code></pre></div></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#shell-执行>Shell 执行</a></li><li><a href=#内核加载>内核加载</a><ul><li><a href=#内核模块>内核模块</a></li><li><a href=#内核加载-1>内核加载</a></li></ul></li><li><a href=#用户态执行>用户态执行</a><ul><li><a href=#常见概念>常见概念</a></li></ul></li><li><a href=#加载过程>加载过程</a><ul><li></li><li><a href=#示例程序>示例程序</a></li><li><a href=#版本管理>版本管理</a></li><li><a href=#问题排查>问题排查</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>