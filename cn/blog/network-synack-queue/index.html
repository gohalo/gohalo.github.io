<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux 网络半链接、链接队列 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="我们知道在建立链接阶段，需要完成三次握手，而这一阶段是在内核中完成，为此保存了两个队列：半链接队列 (SYN队列)、链接队列 (Accepted队列)。
那么，这两个队列分别对应到内核中的那些成员？队列的大小由那些参数决定？当队列满了之后，对应用的影响是什么？其报错的内容是什么？
在这篇文章里大致介绍下。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux 网络半链接、链接队列</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2015-08-05</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/network/ role=button>network</a></div></div><hr><div class=content><p>我们知道在建立链接阶段，需要完成三次握手，而这一阶段是在内核中完成，为此保存了两个队列：半链接队列 (SYN队列)、链接队列 (Accepted队列)。</p><p>那么，这两个队列分别对应到内核中的那些成员？队列的大小由那些参数决定？当队列满了之后，对应用的影响是什么？其报错的内容是什么？</p><p>在这篇文章里大致介绍下。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>Linux 内核中的协议栈，在管理 TCP 链接时使用了两个队列，包括：半链接队列，用来保存处于 SYN_SENT 和 SYN_RECV 状态的请求；Accepted 队列，用来保存已经处于 established 状态，但是应用层还没来得及调用 accept() 取走的请求。</p><p>对这两个队列比较关心的，也就是这两队列在内核中的对象是什么，其长度又是怎么定义的。</p><p>注意，这两个队列都是在服务端的，而我们监听端口的建立是通过 listen() 完成，基本可以判断出来，两个队列的初始化操作也基本在该接口中调用完成。</p><p>所以首先看的是 listen() 系统调用。</p><a class=anchor id=listen-队列初始化></a><h2>listen() 队列初始化 <a href=#listen-%e9%98%9f%e5%88%97%e5%88%9d%e5%a7%8b%e5%8c%96 aria-hidden=true>#</a></h2><p>首先开始讨论的是 backlog 参数，英语中的原意是 &ldquo;积压未办之事；没交付的订货&rdquo; 。</p><p>讨论 backlog 时，容易想到 socket 编程中 <code>listen()</code> 接口的 backlog 参数，而该参数与 Linux 内核中的 backlog 是否一样？通过 <code>man 2 listen</code> 可以看到，对应该接口中 backlog 的解释如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int listen(int sockfd, int backlog);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The backlog argument defines the maximum length to which the queue
</span></span><span class=line><span class=cl>of pending connections for sockfd may grow. If a connection request
</span></span><span class=line><span class=cl>arrives when the queue is full, the client may receive an error with
</span></span><span class=line><span class=cl>an indication of ECONNREFUSED or, if the underlying protocol supports
</span></span><span class=line><span class=cl>retransmission, the request may be ignored so that a later reattempt
</span></span><span class=line><span class=cl>at connection succeeds.
</span></span></code></pre></div><p>这里的解释非常简短，对于我们的帮助实际并不是很大，还是那句话 &ldquo;Show me the CODE!!!&rdquo; 。</p><p>首先是 <code>listen()</code> 系统调用的入口，按照上述的说法，可以想像的到，<code>listen()</code> 系统调用必然要分配一个 <code>listen_sock</code> 结构体。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE2</span><span class=p>(</span><span class=n>listen</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>backlog</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>err</span><span class=p>,</span> <span class=n>fput_needed</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>somaxconn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sock</span> <span class=o>=</span> <span class=nf>sockfd_lookup_light</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>err</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fput_needed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sock</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* backlog 会选择 listen() 传入的参数与 net.core.somaxconn 的最小值 */</span>
</span></span><span class=line><span class=cl>        <span class=n>somaxconn</span> <span class=o>=</span> <span class=nf>sock_net</span><span class=p>(</span><span class=n>sock</span><span class=o>-&gt;</span><span class=n>sk</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>core</span><span class=p>.</span><span class=n>sysctl_somaxconn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>((</span><span class=kt>unsigned</span> <span class=kt>int</span><span class=p>)</span><span class=n>backlog</span> <span class=o>&gt;</span> <span class=n>somaxconn</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>backlog</span> <span class=o>=</span> <span class=n>somaxconn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>err</span> <span class=o>=</span> <span class=nf>security_socket_listen</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=n>backlog</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=cm>/* 实际会调用 inet_listen() */</span>
</span></span><span class=line><span class=cl>            <span class=n>err</span> <span class=o>=</span> <span class=n>sock</span><span class=o>-&gt;</span><span class=n>ops</span><span class=o>-&gt;</span><span class=nf>listen</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span> <span class=n>backlog</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>fput_light</span><span class=p>(</span><span class=n>sock</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>,</span> <span class=n>fput_needed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>err</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>也就是取得入参与 <code>somaxconn</code> 的最小值后，调用 <code>inet_listen()</code> 函数，在该函数中会初始化半链接队列，并设置 accepted 队列的最大值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>inet_listen</span><span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=kt>int</span> <span class=n>backlog</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 如果已经处于 listen 状态了，那么之修改 backlog */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>old_state</span> <span class=o>!=</span> <span class=n>TCP_LISTEN</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>                        <span class=c1>// fastopen相关暂时忽略
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>err</span> <span class=o>=</span> <span class=nf>inet_csk_listen_start</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>backlog</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>out</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_max_ack_backlog</span> <span class=o>=</span> <span class=n>backlog</span><span class=p>;</span>  <span class=c1>// 设置accept队列的最大值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>接着来看 inet_csk_listen_start() 函数的实现，其主要工作是调用 reqsk_queue_alloc() 新分配一个 listen socket 以及相应的 accept 队列；然后对申请的端口进行判断。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>inet_csk_listen_start</span><span class=p>(</span><span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>nr_table_entries</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 在下面的函数中分配listen_sock以及相应的accept队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>rc</span> <span class=o>=</span> <span class=nf>reqsk_queue_alloc</span><span class=p>(</span><span class=o>&amp;</span><span class=n>icsk</span><span class=o>-&gt;</span><span class=n>icsk_accept_queue</span><span class=p>,</span> <span class=n>nr_table_entries</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 这里之所以还要再次判断一下端口，是为了防止另一个进程 程在我们调用listen之前改变了这个端口的信息.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_state</span> <span class=o>=</span> <span class=n>TCP_LISTEN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_prot</span><span class=o>-&gt;</span><span class=nf>get_port</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>inet</span><span class=o>-&gt;</span><span class=n>inet_num</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 将端口赋值给sport，并加入到inet_hashinfo(上面已经分析过)的listening_hash hash链表中.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>inet</span><span class=o>-&gt;</span><span class=n>inet_sport</span> <span class=o>=</span> <span class=nf>htons</span><span class=p>(</span><span class=n>inet</span><span class=o>-&gt;</span><span class=n>inet_num</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>sk_dst_reset</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_prot</span><span class=o>-&gt;</span><span class=nf>hash</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span>  <span class=c1>// 这里调用__inet_hash实现的
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>对于半链接队列，实际是在 reqsk_queue_alloc() 中完成，在该函数中同样会完成 listen_sock 新建。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>reqsk_queue_alloc</span><span class=p>(</span><span class=k>struct</span> <span class=n>request_sock_queue</span> <span class=o>*</span><span class=n>queue</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>nr_table_entries</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>size_t</span> <span class=n>lopt_size</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>listen_sock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>listen_sock</span> <span class=o>*</span><span class=n>lopt</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>nr_table_entries</span> <span class=o>=</span> <span class=kt>min_t</span><span class=p>(</span><span class=n>u32</span><span class=p>,</span> <span class=n>nr_table_entries</span><span class=p>,</span> <span class=n>sysctl_max_syn_backlog</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nr_table_entries</span> <span class=o>=</span> <span class=kt>max_t</span><span class=p>(</span><span class=n>u32</span><span class=p>,</span> <span class=n>nr_table_entries</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nr_table_entries</span> <span class=o>=</span> <span class=nf>roundup_pow_of_two</span><span class=p>(</span><span class=n>nr_table_entries</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>lopt_size</span> <span class=o>+=</span> <span class=n>nr_table_entries</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>request_sock</span> <span class=o>*</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>lopt_size</span> <span class=o>&lt;=</span> <span class=p>(</span><span class=n>PAGE_SIZE</span> <span class=o>&lt;&lt;</span> <span class=n>PAGE_ALLOC_COSTLY_ORDER</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>lopt</span> <span class=o>=</span> <span class=nf>kzalloc</span><span class=p>(</span><span class=n>lopt_size</span><span class=p>,</span> <span class=n>GFP_KERNEL</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                      <span class=n>__GFP_NOWARN</span> <span class=o>|</span>
</span></span><span class=line><span class=cl>                      <span class=n>__GFP_NORETRY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>lopt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>lopt</span> <span class=o>=</span> <span class=nf>vzalloc</span><span class=p>(</span><span class=n>lopt_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>lopt</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=n>ENOMEM</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>get_random_bytes</span><span class=p>(</span><span class=o>&amp;</span><span class=n>lopt</span><span class=o>-&gt;</span><span class=n>hash_rnd</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>lopt</span><span class=o>-&gt;</span><span class=n>hash_rnd</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=nf>rwlock_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>syn_wait_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>rskq_accept_head</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lopt</span><span class=o>-&gt;</span><span class=n>nr_table_entries</span> <span class=o>=</span> <span class=n>nr_table_entries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lopt</span><span class=o>-&gt;</span><span class=n>max_qlen_log</span> <span class=o>=</span> <span class=nf>ilog2</span><span class=p>(</span><span class=n>nr_table_entries</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>write_lock_bh</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>syn_wait_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>queue</span><span class=o>-&gt;</span><span class=n>listen_opt</span> <span class=o>=</span> <span class=n>lopt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>write_unlock_bh</span><span class=p>(</span><span class=o>&amp;</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>syn_wait_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>实际上，如果 listen(&mldr;, 20)，且内核参数值如下，那么此时 nr_table_entries = 16、max_qlen_log = 4 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sysctl -w net.ipv4.tcp_max_syn_backlog=2
</span></span><span class=line><span class=cl>$ sysctl -w net.core.somaxconn=3
</span></span></code></pre></div><p>但是，对于一个 <code>listen sock</code>，我们真的能保存 16 个 <code>SYN_RCV</code> 状态的链接吗？答案是 &ldquo;不能&rdquo; 。</p><a class=anchor id=数据结构></a><h3>数据结构 <a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-hidden=true>#</a></h3><p>上面介绍了两个队列的创建过程，接下来再看下相关的数据结构。擦，有点本末倒置 ^_^</p><p>每当一个 SYN 请求到来时，都会新建一个 request_sock 结构体，并加入到 listen_sock.request_sock 的 hash 表中。完成握手后，将它放入到 inet_connection_sock.request_sock_queue 队列中；这样当 accept() 函数调用时，就会直接从这个队列中读取。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>request_sock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sock_common</span>      <span class=n>__req_common</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>request_sock</span>     <span class=o>*</span><span class=n>dl_next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u16</span>             <span class=n>mss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u8</span>              <span class=n>num_retrans</span><span class=p>;</span> <span class=cm>/* number of retransmits */</span>
</span></span><span class=line><span class=cl>    <span class=n>u8</span>              <span class=nl>cookie_ts</span><span class=p>:</span><span class=mi>1</span><span class=p>;</span> <span class=cm>/* syncookie: encode tcpopts in timestamp */</span>
</span></span><span class=line><span class=cl>    <span class=n>u8</span>              <span class=nl>num_timeout</span><span class=p>:</span><span class=mi>7</span><span class=p>;</span> <span class=cm>/* number of timeouts */</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* The following two fields can be easily recomputed I think -AK */</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>             <span class=n>window_clamp</span><span class=p>;</span> <span class=cm>/* window clamp at creation time */</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>             <span class=n>rcv_wnd</span><span class=p>;</span>      <span class=cm>/* rcv_wnd offered first time */</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>             <span class=n>ts_recent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span>           <span class=n>expires</span><span class=p>;</span>     <span class=c1>// 这个请求在队列中存活的时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>request_sock_ops</span>   <span class=o>*</span><span class=n>rsk_ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>sock</span>         <span class=o>*</span><span class=n>sk</span><span class=p>;</span>             <span class=c1>// 链接成功的socket数目???
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>u32</span>             <span class=n>secid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>             <span class=n>peer_secid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>listen_sock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>u8</span>          <span class=n>max_qlen_log</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u8</span>          <span class=n>synflood_warned</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 2 bytes hole, try to use */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>         <span class=n>qlen</span><span class=p>;</span>                               <span class=c1>// 当前的半连接队列的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span>         <span class=n>qlen_young</span><span class=p>;</span>                         <span class=c1>// 队列新成员的个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span>         <span class=n>clock_hand</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>         <span class=n>hash_rnd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>                 <span class=n>nr_table_entries</span><span class=p>;</span>                   <span class=c1>// 当前的syn_backlog(半开连接队列)的最大值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>request_sock</span> <span class=o>*</span><span class=n>syn_table</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>              <span class=c1>// 存放SYN队列，也即半链接队列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>request_sock_queue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>request_sock</span>       <span class=o>*</span><span class=n>rskq_accept_head</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>request_sock</span>       <span class=o>*</span><span class=n>rskq_accept_tail</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>rwlock_t</span>                  <span class=n>syn_wait_lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u8</span>                        <span class=n>rskq_defer_accept</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>listen_sock</span>        <span class=o>*</span><span class=n>listen_opt</span><span class=p>;</span>          <span class=c1>// 对应的listen_sock结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>fastopen_queue</span>     <span class=o>*</span><span class=n>fastopenq</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>inet_connection_sock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inet_sock</span>          <span class=n>icsk_inet</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>request_sock_queue</span> <span class=n>icsk_accept_queue</span><span class=p>;</span>    <span class=c1>// 已经建立链接的FIFO队列
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>__u8</span>                      <span class=n>icsk_syn_retries</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span>             <span class=n>icsk_timeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>timer_list</span>         <span class=n>icsk_retransmit_timer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>timer_list</span>         <span class=n>icsk_delack_timer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>u32</span>                       <span class=n>icsk_user_timeout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>上述的结构体中，只包括了半链接的队列长度，而对于 accept 队列的长度，实际保存在 sock 结构体中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>short</span>      <span class=n>sk_ack_backlog</span><span class=p>;</span>     <span class=c1>// 队列长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>short</span>      <span class=n>sk_max_ack_backlog</span><span class=p>;</span> <span class=c1>// 最大的队列长度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>该 sock 是 server 端的 listen 队列长度，而 client 只保留成 request_sock 。</p><p>最后，当 accept() 从 icsk_accept_queue 队列中取得 request_sock 之后，将该变量从这个队列中释放，然后在 BSD 层新建一个 socket 结构，并将它和接收端新建的 sock 结构关联起来。</p><a class=anchor id=accept-系统调用></a><h2>accept() 系统调用 <a href=#accept-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-hidden=true>#</a></h2><p>最终调用的是 inet_csk_accept() 函数，该函数会调用 reqsk_queue_get_child() 从 accept 队列中取一个 request_sock。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=nf>inet_csk_accept</span><span class=p>(</span><span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>request_sock_queue</span> <span class=o>*</span><span class=n>queue</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>icsk</span><span class=o>-&gt;</span><span class=n>icsk_accept_queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 查找已经建立的链接
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=nf>reqsk_queue_empty</span><span class=p>(</span><span class=n>queue</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>timeo</span> <span class=o>=</span> <span class=nf>sock_rcvtimeo</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>flags</span> <span class=o>&amp;</span> <span class=n>O_NONBLOCK</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* If this is a non blocking socket don&#39;t sleep */</span>
</span></span><span class=line><span class=cl>        <span class=n>error</span> <span class=o>=</span> <span class=o>-</span><span class=n>EAGAIN</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>timeo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>out_err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>error</span> <span class=o>=</span> <span class=nf>inet_csk_wait_for_connect</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>timeo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>out_err</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>req</span> <span class=o>=</span> <span class=nf>reqsk_queue_remove</span><span class=p>(</span><span class=n>queue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>newsk</span> <span class=o>=</span> <span class=n>req</span><span class=o>-&gt;</span><span class=n>sk</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>sk_acceptq_removed</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=源码解析></a><h1>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h1><p>内核中与队列相关的设置参数如下：</p><ul><li>net.ipv4.tcp_max_syn_backlog[256]：用于保存半链接队列。注意，如果开启了 syncookies，那么基本上没有限制，所以在如下的实验中要关闭 cookies 。</li><li>net.core.somaxconn[128]：Accepted 队列最大长度，表示最多有 129 个 established 链接等待 accept()。</li></ul><a class=anchor id=握手过程></a><h2>握手过程 <a href=#%e6%8f%a1%e6%89%8b%e8%bf%87%e7%a8%8b aria-hidden=true>#</a></h2><p>如上所述，握手链接过程包括了如下的步骤：</p><ol><li>收到客户端的 SYN 请求，并将这个请求放入 syn_table 中去；</li><li>服务器端回复 SYNACK；</li><li>收到客户端的 ACK；</li><li>放入 accept queue 中。</li></ol><p>对于 IPv4 来说，对应的操作函数通过如下结构体定义：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=k>struct</span> <span class=n>inet_connection_sock_af_ops</span> <span class=n>ipv4_specific</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>conn_request</span>      <span class=o>=</span> <span class=n>tcp_v4_conn_request</span><span class=p>,</span>   <span class=c1>// 对应收到SYN请求
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>.</span><span class=n>syn_recv_sock</span>     <span class=o>=</span> <span class=n>tcp_v4_syn_recv_sock</span><span class=p>,</span>  <span class=c1>// 对应收到ACK请求
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>接下来查看各个阶段的内容。</p><a class=anchor id=客户端发送-syn-请求报文到服务端></a><h4>客户端发送 SYN 请求报文到服务端 <a href=#%e5%ae%a2%e6%88%b7%e7%ab%af%e5%8f%91%e9%80%81-syn-%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87%e5%88%b0%e6%9c%8d%e5%8a%a1%e7%ab%af aria-hidden=true>#</a></h4><p>此时，客户端和服务端分别处于 SYN_SENT 和 SYN_RECV 状态。</p><p>其中服务端的处理流程如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>tcp_v4_do_rcv()
</span></span><span class=line><span class=cl> |-tcp_v4_hnd_req()                         # 被动打开时的处理，包括收到SYN或ACK
</span></span><span class=line><span class=cl> |-sock_rps_save_rxhash()                   # 如果返回值nsk!=sk，则表示是收到了ACK报文
</span></span><span class=line><span class=cl> |-tcp_child_process()                      # 处理新的sock
</span></span><span class=line><span class=cl>   |-tcp_rcv_state_process()
</span></span><span class=line><span class=cl>     |-icsk-&gt;icsk_af_ops-&gt;conn_request()    # 实际调用tcp_v4_conn_request()
</span></span><span class=line><span class=cl>       |-tcp_conn_request()
</span></span></code></pre></div><p>tcp_conn_request() 函数是主要的处理流程，其处理流程如下，在此重点关注一下 drop 的处理逻辑。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tcp_conn_request</span><span class=p>(</span><span class=k>struct</span> <span class=n>request_sock_ops</span> <span class=o>*</span><span class=n>rsk_ops</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>const</span> <span class=k>struct</span> <span class=n>tcp_request_sock_ops</span> <span class=o>*</span><span class=n>af_ops</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 1. 判断半链接队列是否已满，listen_sock.qlen &gt;&gt; listen_sock.max_qlen_log */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>((</span><span class=n>sysctl_tcp_syncookies</span> <span class=o>==</span> <span class=mi>2</span> <span class=o>||</span>         <span class=c1>// 为2表示用来测试
</span></span></span><span class=line><span class=cl><span class=c1></span>         <span class=nf>inet_csk_reqsk_queue_is_full</span><span class=p>(</span><span class=n>sk</span><span class=p>))</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>isn</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>want_cookie</span> <span class=o>=</span> <span class=nf>tcp_syn_flood_action</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>skb</span><span class=p>,</span> <span class=n>rsk_ops</span><span class=o>-&gt;</span><span class=n>slab_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>want_cookie</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>drop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 2. 判断accept队列是否已满，sock.sk_ack_backlog &gt; sock.sk_max_ack_backlog；
</span></span></span><span class=line><span class=cl><span class=cm>     * 以及 listen_sock.qlen_young 的值是否大于 1 。
</span></span></span><span class=line><span class=cl><span class=cm>     * 也就意味着，如果全连接队列满了，且有未重传过的半连接，则直接丢弃SYN请求
</span></span></span><span class=line><span class=cl><span class=cm>     */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=nf>sk_acceptq_is_full</span><span class=p>(</span><span class=n>sk</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nf>inet_csk_reqsk_queue_young</span><span class=p>(</span><span class=n>sk</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>NET_INC_STATS_BH</span><span class=p>(</span><span class=nf>sock_net</span><span class=p>(</span><span class=n>sk</span><span class=p>),</span> <span class=n>LINUX_MIB_LISTENOVERFLOWS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>drop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 链接未满，申请一个struct request_sock变量 */</span>
</span></span><span class=line><span class=cl>    <span class=n>req</span> <span class=o>=</span> <span class=nf>inet_reqsk_alloc</span><span class=p>(</span><span class=n>rsk_ops</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>req</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>drop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* OK, 一切正常，发送 SYNACK */</span>
</span></span><span class=line><span class=cl>    <span class=n>err</span> <span class=o>=</span> <span class=n>af_ops</span><span class=o>-&gt;</span><span class=nf>send_synack</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>dst</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>fl</span><span class=p>,</span> <span class=n>req</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=nf>skb_get_queue_mapping</span><span class=p>(</span><span class=n>skb</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>foc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>fastopen</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* 实际调用 inet_csk_reqsk_queue_hash_add() 函数将该请求添加到半链接队列中 */</span>
</span></span><span class=line><span class=cl>        <span class=n>af_ops</span><span class=o>-&gt;</span><span class=nf>queue_hash_add</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>req</span><span class=p>,</span> <span class=n>TCP_TIMEOUT_INIT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=判断半链接队列是否已满></a><h4>判断半链接队列是否已满 <a href=#%e5%88%a4%e6%96%ad%e5%8d%8a%e9%93%be%e6%8e%a5%e9%98%9f%e5%88%97%e6%98%af%e5%90%a6%e5%b7%b2%e6%bb%a1 aria-hidden=true>#</a></h4><p>该判断通过 inet_csk_reqsk_queue_is_full(sk) 实现，也即比较如下的值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>listen_sock.qlen &gt;&gt; listen_sock.max_qlen_log 。
</span></span></code></pre></div><p>其中的 qlen 代表的是 listen_sock 中的 syn_table 的长度，那什么是 max_qlen_log 呢？可以直接参考上面的介绍。</p><a class=anchor id=判断accept队列已满></a><h4>判断accept队列已满 <a href=#%e5%88%a4%e6%96%adaccept%e9%98%9f%e5%88%97%e5%b7%b2%e6%bb%a1 aria-hidden=true>#</a></h4><p>在上述的第二步中，在通过 sk_acceptq_is_full() 判断 accept 队列已满的情况下，同是也会判断 listen_sock 结构体中的 qlen_young 变量是否大于 1 。</p><p>而 qlen_young 是对 syn_table 的计数，当进入 syn_table 时加 1，出了syn_table 时减 1 。</p><p>首先介绍一下什么是 qlen_young，下面是摘抄自网络上的注释：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>qlen_young
</span></span><span class=line><span class=cl>sum of new open_request on syn_table. after TCP_TIMEOUT_INIT, if the open_request
</span></span><span class=line><span class=cl>hadn&#39;t be acked, then it can retrans corresponding syn/ack and it becoms old , the
</span></span><span class=line><span class=cl>qlen_young will dec 1. when open_request migrate to acceptq the qlen_yong will also
</span></span><span class=line><span class=cl>dec 1 except it had been retransmitted.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>see tcp_synack_timer() for more details about qlen_young and clock_hand.
</span></span></code></pre></div><p>这也就意味着，qlen_young 记录了半链接队列里面第一次接收到的 SYN 报文数量，当然，其中不含已经超时重传的链接。</p><p>这也就意味着，如果 accept 队列满了，那么 qlen_young 就一直增加，而新来的请求就会直接被 drop 掉。但是，真实情况是，我们在客户端却很少发现这种情况，Why？？？</p><p>原因有两个：A) 客户端会不断重试，通过 tcp_syn_retries 设置；B) 在 inet_csk_reqsk_queue_prune() 函数中，会不断尝试发送 SYN+ACK 报文，此时 qlen_young 会减小。</p><p>这也就是说，在第一次的时候，之前的握手过程都没有重传过，所以这个 syn 包 server 端会直接 drop 掉，之后 client 会重传 syn，当 inet_csk_reqsk_queue_yong(sk) &lt; 1 时，那么这个 syn 会被 server 端接受。server 会回复 synack 给 client，这样一来两边的状态就变为 client(ESTABLISHED)+server(SYN_SENT) 。</p><a class=anchor id=客户端回复-ack-报文到服务端></a><h3>客户端回复 ACK 报文到服务端 <a href=#%e5%ae%a2%e6%88%b7%e7%ab%af%e5%9b%9e%e5%a4%8d-ack-%e6%8a%a5%e6%96%87%e5%88%b0%e6%9c%8d%e5%8a%a1%e7%ab%af aria-hidden=true>#</a></h3><p>当 client 收到 synack 后回复 ack 给 server，此时 server 端的处理流程为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>tcp_v4_do_rcv()
</span></span><span class=line><span class=cl> |-tcp_rcv_state_process()
</span></span><span class=line><span class=cl>   |-tcp_check_req()
</span></span><span class=line><span class=cl>   | |-inet_csk(sk)-&gt;icsk_af_ops-&gt;syn_recv_sock()     # 实际调用tcp_v4_syn_recv_sock()
</span></span><span class=line><span class=cl>   |   |-sk_acceptq_is_full()                         # 判断接收队列是否已满
</span></span><span class=line><span class=cl>   |   |-tcp_create_openreq_child()                   # 完成三次握手之后，才正式创建新的socket
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   |-req-&gt;rsk_ops-&gt;send_reset()                       # 如果设置了overflow，则会返回reset报文
</span></span></code></pre></div><p>如果 server 端设置了 sysctl_tcp_abort_on_overflow 那么 server 会发送 rst 给 client，并删除掉这个链接；否则 server 端只是记录一下 LINUX_MIB_LISTENOVERFLOWS，然后返回。</p><p>默认情况下是不会设置的，server 端只是标记连接请求块的 acked 标志，之后连接建立定时器，会遍历半连接表，重新发送 synack，重复上面的过程，具体的过程可以查看 inet_csk_reqsk_queue_prune()，重传会直到超过 synack 重传的阀值，才会把该连接从半连接链表中删除。</p><p>在函数 tcpp_create_openreq_child() 中才真正 clone 出一个新的 socket，也就是只有通过了 3 次握手后，Linux 才会产生新的 socket。而在 3 次握手中所传的 socket 实际上是 server 处于 listen 状态的 socket，那也就是说这个 socket 只有一个 TCP_LISTEN 状态。</p><a class=anchor id=实验></a><h1>实验 <a href=#%e5%ae%9e%e9%aa%8c aria-hidden=true>#</a></h1><p>为了方便我们观察，需要修改一下 Linux 内核的配置参数。首先查看下操作系统默认的内核参数值，为了后面恢复。下面是自己笔记本上的默认配置参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sysctl net.ipv4.tcp_max_syn_backlog
</span></span><span class=line><span class=cl>net.ipv4.tcp_max_syn_backlog = 256
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sysctl net.core.somaxconn
</span></span><span class=line><span class=cl>net.core.somaxconn = 128
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sysctl net.ipv4.tcp_syncookies
</span></span><span class=line><span class=cl>net.ipv4.tcp_syncookies = 1
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sysctl net.ipv4.tcp_abort_on_overflow
</span></span><span class=line><span class=cl>net.ipv4.tcp_abort_on_overflow = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sysctl net.ipv4.tcp_syn_retries
</span></span><span class=line><span class=cl>net.ipv4.tcp_syn_retries = 6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sysctl net.ipv4.tcp_synack_retries
</span></span><span class=line><span class=cl>net.ipv4.tcp_synack_retries = 5
</span></span></code></pre></div><p>为了方便查看，我们先修改几个参数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ sysctl -w net.ipv4.tcp_max_syn_backlog=2        # 将半链接队列设置较小的值
</span></span><span class=line><span class=cl>$ sysctl -w net.core.somaxconn=3                  # 监听队列的长度同样设小
</span></span><span class=line><span class=cl>$ sysctl -w net.ipv4.tcp_syncookies=0             # 关闭sync cookies
</span></span><span class=line><span class=cl>$ sysctl -w net.ipv4.tcp_syn_retries=2            # 当客户端无法链接时，重发SYN报文的次数，设置较小值
</span></span><span class=line><span class=cl>$ sysctl -w net.ipv4.tcp_synack_retries=20        # 服务端没有收到ACK时，重发SYN+ACK的次数，同样设置较大值
</span></span></code></pre></div><p>在代码中使用的是 listen(&mldr;, 20)，那么在设置完内核参数之后，我们首先计算一下两个队列的长度，其实上面已经计算过了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- accept队列长度
</span></span><span class=line><span class=cl>entries = min(backlog/*from listen()*/, net.core.somaxconn) = 3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 半链接队列长度
</span></span><span class=line><span class=cl>entries = min(entries, net.ipv4.sysctl_max_syn_backlog) = 2
</span></span><span class=line><span class=cl>entries = max(entries, 8) = 8
</span></span><span class=line><span class=cl>entries = roundup_pow_of_two( 8 + 1) = 16
</span></span></code></pre></div><p>也就是说，半链接队列大小是 16；accept 队列大小是 3 。</p><a class=anchor id=测试程序></a><h2>测试程序 <a href=#%e6%b5%8b%e8%af%95%e7%a8%8b%e5%ba%8f aria-hidden=true>#</a></h2><p>测试程序直接用 C 写的一个简单回显程序，源码可以从 <a href=/reference/linux/network/syn_ack.tar.bz2 title=简单的回显测试程序源码>本地</a> 直接下载。</p><p>这个程序非常简单，服务端每次最多只会处理一个请求，只有当第一个客户端关闭之后，才会接着响应其它的请求，否则就一直保存在内核的队列中。</p><p>上述的服务器默认使用 8080 端口，为了观察方便，我们直接通过 ss 监控链接数，命令如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># watch -n 1 &#34;ss -tann &#39;( sport = 8080 or dport = 8080 )&#39;&#34;
</span></span></code></pre></div><p>也就是查看源端口或者目的端口是 8080 的所有 TCP 链接，且每秒刷新一次。</p><p>接下来验证的时候简单分为两个场景，是否设置 net.ipv4.tcp_abort_on_overflow 。</p><a class=anchor id=设置-tcp_abort_on_overflow></a><h2>设置 tcp_abort_on_overflow <a href=#%e8%ae%be%e7%bd%ae-tcp_abort_on_overflow aria-hidden=true>#</a></h2><p>如果设置 overflow=1 则在尝试建立第 6 个链接时报错 Connection reset by peer 。</p><p><img alt=设置overflow时的参数 src=images/network-synack-overflow-1.png class="mx-auto d-block"></p><p>其中包括了一个 accept 的链接 + 四个在 accept 队列中的链接，那么在尝试建第六个的时候就会报错。</p><p>这里有个问题，我们设置的 accept 队列是 3，为什么保存了 4 个链接，可以参考如下的介绍，忘了从那里摘抄的了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-v data-lang=v><span class=line><span class=cl><span class=nc>When</span> <span class=nc>I</span> <span class=nv>use</span> <span class=nv>linux</span> <span class=nc>TCP</span> <span class=nv>socket</span><span class=p>,</span> <span class=nv>and</span> <span class=nv>find</span> <span class=nv>there</span> <span class=k>is</span> <span class=nv>a</span> <span class=nv>bug</span> <span class=k>in</span> <span class=nv>function</span> <span class=nf>sk_acceptq_is_full</span><span class=p>():</span>
</span></span><span class=line><span class=cl>  <span class=nc>When</span> <span class=nv>a</span> <span class=nv>new</span> <span class=nc>SYN</span> <span class=nv>comes</span><span class=p>,</span> <span class=nc>TCP</span> <span class=kn>module</span> <span class=nv>first</span> <span class=nv>checks</span> <span class=nv>its</span> <span class=nv>validation</span><span class=p>.</span> <span class=nc>If</span> <span class=nv>valid</span><span class=p>,</span> <span class=nv>send</span> <span class=nc>SYN</span><span class=o>+</span><span class=nc>ACK</span> <span class=nv>to</span>
</span></span><span class=line><span class=cl><span class=nv>the</span> <span class=nv>client</span> <span class=nv>and</span> <span class=nv>add</span> <span class=nv>the</span> <span class=nv>sock</span> <span class=nv>to</span> <span class=nv>the</span> <span class=nv>syn</span> <span class=nv>hash</span> <span class=nv>table</span><span class=p>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nc>Next</span> <span class=nv>time</span> <span class=k>if</span> <span class=nv>received</span> <span class=nv>the</span> <span class=nv>valid</span> <span class=nc>ACK</span> <span class=k>for</span> <span class=nc>SYN</span><span class=o>+</span><span class=nc>ACK</span> <span class=nv>from</span> <span class=nv>the</span> <span class=nv>client</span><span class=p>.</span> <span class=nv>server</span> <span class=nv>will</span> <span class=nv>accept</span> <span class=nv>this</span>
</span></span><span class=line><span class=cl><span class=nv>connection</span> <span class=nv>and</span> <span class=nv>increase</span> <span class=nv>the</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_ack_backlog</span> <span class=p>(</span><span class=nv>which</span> <span class=k>is</span> <span class=nv>done</span> <span class=k>in</span> <span class=nv>function</span> <span class=nf>tcp_check_req</span><span class=p>()).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nc>We</span> <span class=nv>check</span> <span class=nv>wether</span> <span class=nv>acceptq</span> <span class=k>is</span> <span class=nv>full</span> <span class=k>in</span> <span class=nv>function</span> <span class=nf>tcp_v4_syn_recv_sock</span><span class=p>().</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nc>Consider</span> <span class=nv>an</span> <span class=nl>example</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nc>After</span> <span class=nf>listen</span><span class=p>(</span><span class=nv>sockfd</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span> <span class=nv>system</span> <span class=nv>call</span><span class=p>,</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_max_ack_backlog</span> <span class=k>is</span> <span class=nv>set</span> <span class=nv>to</span> <span class=mi>1</span><span class=p>.</span> <span class=nc>As</span> <span class=nv>we</span> <span class=nv>know</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_ack_backlog</span> <span class=k>is</span> <span class=nv>initialized</span> <span class=nv>to</span> <span class=mi>0</span><span class=p>.</span> <span class=nc>Assuming</span> <span class=nf>accept</span><span class=p>()</span> <span class=nv>system</span> <span class=nv>call</span> <span class=k>is</span> <span class=nv>not</span> <span class=nv>invoked</span> <span class=nv>now</span><span class=p>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mi>1</span><span class=p>.</span> <span class=mi>1</span><span class=nv>st</span> <span class=nv>connection</span> <span class=nv>comes</span><span class=p>.</span> <span class=nv>invoke</span> <span class=nf>sk_acceptq_is_full</span><span class=p>().</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_ack_backlog</span><span class=o>=</span><span class=mi>0</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_max_ack_backlog</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=nv>function</span> <span class=k>return</span> <span class=mi>0</span> <span class=nv>accept</span> <span class=nv>this</span> <span class=nv>connection</span><span class=p>.</span> <span class=nc>Increase</span> <span class=nv>the</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_ack_backlog</span>
</span></span><span class=line><span class=cl><span class=mi>2</span><span class=p>.</span> <span class=mi>2</span><span class=nv>nd</span> <span class=nv>connection</span> <span class=nv>comes</span><span class=p>.</span> <span class=nv>invoke</span> <span class=nf>sk_acceptq_is_full</span><span class=p>().</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_ack_backlog</span><span class=o>=</span><span class=mi>1</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_max_ack_backlog</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=nv>function</span> <span class=k>return</span> <span class=mi>0</span> <span class=nv>accept</span> <span class=nv>this</span> <span class=nv>connection</span><span class=p>.</span> <span class=nc>Increase</span> <span class=nv>the</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_ack_backlog</span>
</span></span><span class=line><span class=cl><span class=mi>3</span><span class=p>.</span> <span class=mi>3</span><span class=nv>rd</span> <span class=nv>connection</span> <span class=nv>comes</span><span class=p>.</span> <span class=nv>invoke</span> <span class=nf>sk_acceptq_is_full</span><span class=p>().</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_ack_backlog</span><span class=o>=</span><span class=mi>2</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_max_ack_backlog</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=nv>function</span> <span class=k>return</span> <span class=mi>1</span><span class=p>.</span> <span class=nc>Refuse</span> <span class=nv>this</span> <span class=nv>connection</span><span class=p>.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nc>I</span> <span class=nv>think</span> <span class=vm>it</span> <span class=nv>has</span> <span class=nv>bugs</span><span class=p>.</span> <span class=nv>after</span> <span class=nv>listen</span> <span class=nv>system</span> <span class=nv>call</span><span class=p>.</span> <span class=nv>sk</span><span class=o>-</span><span class=p>&gt;</span><span class=nv>sk_max_ack_backlog</span><span class=o>=</span><span class=mi>1</span> <span class=nv>but</span> <span class=nv>now</span> <span class=vm>it</span> <span class=nv>can</span> <span class=nv>accept</span> <span class=mi>2</span> <span class=nv>connections</span><span class=p>.</span>
</span></span></code></pre></div><p>也就是说，accept 的链接数总是 +1 。</p><a class=anchor id=取消-tcp_abort_on_overflow></a><h2>取消 tcp_abort_on_overflow <a href=#%e5%8f%96%e6%b6%88-tcp_abort_on_overflow aria-hidden=true>#</a></h2><p>将该参数设置为 0 时，在 accept 队列溢出时就不会发送 rst 报文，而是直接 drop 报文。如果此时通过 tcpdump 之类的工具查看时，可以发现客户端一直在重试。</p><p><img alt=取消overflow时的参数 src=images/network-synack-overflow-0.png class="mx-auto d-block"></p><p>此时，是在尝试建立第 9 个链接时报错 Connection timed out 。</p><p>我们在上述的计算过程中，半链接队列应该是 16 个才对，此时只有 3 个处于 SYN-RECV 的报文，这是为什么？ 还是看一下代码。</p><p>仍然是在 tcp_conn_request() 函数中，在已经尝试建立链接时，会发现如下的代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>tcp_conn_request</span><span class=p>(</span><span class=k>struct</span> <span class=n>request_sock_ops</span> <span class=o>*</span><span class=n>rsk_ops</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>const</span> <span class=k>struct</span> <span class=n>tcp_request_sock_ops</span> <span class=o>*</span><span class=n>af_ops</span><span class=p>,</span>
</span></span><span class=line><span class=cl>             <span class=k>struct</span> <span class=n>sock</span> <span class=o>*</span><span class=n>sk</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sk_buff</span> <span class=o>*</span><span class=n>skb</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* Kill the following clause, if you dislike this way. */</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>sysctl_tcp_syncookies</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>         <span class=p>(</span><span class=n>sysctl_max_syn_backlog</span> <span class=o>-</span> <span class=nf>inet_csk_reqsk_queue_len</span><span class=p>(</span><span class=n>sk</span><span class=p>)</span> <span class=o>&lt;</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=n>sysctl_max_syn_backlog</span> <span class=o>&gt;&gt;</span> <span class=mi>2</span><span class=p>))</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>         <span class=o>!</span><span class=nf>tcp_peer_is_proven</span><span class=p>(</span><span class=n>req</span><span class=p>,</span> <span class=n>dst</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                     <span class=n>tmp_opt</span><span class=p>.</span><span class=n>saw_tstamp</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>drop_and_release</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在上述的判断中，可以从 1 到 3 计算一下，当尝试建立第 4 个链接时，就会为 true ，那么就直接将报文 drop 掉了。</p><a class=anchor id=总结></a><h1>总结 <a href=#%e6%80%bb%e7%bb%93 aria-hidden=true>#</a></h1><p>listen() 中的入参 backlog 不仅影响到了链接队列，还影响到了半链接队列。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#listen-队列初始化>listen() 队列初始化</a></li><li><a href=#accept-系统调用>accept() 系统调用</a></li></ul></li><li><a href=#源码解析>源码解析</a><ul><li><a href=#握手过程>握手过程</a></li></ul></li><li><a href=#实验>实验</a><ul><li><a href=#测试程序>测试程序</a></li><li><a href=#设置-tcp_abort_on_overflow>设置 tcp_abort_on_overflow</a></li><li><a href=#取消-tcp_abort_on_overflow>取消 tcp_abort_on_overflow</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>