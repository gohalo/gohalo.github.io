<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Rust 内存管理 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="Rust 中的内存管理跟其它语言基本类似，提供了浅复制和深复制两种方式，使用时略有区别，这里简单介绍。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Rust 内存管理</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2021-09-18</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/rust/ role=button>rust</a></div></div><hr><div class=content><p>Rust 中的内存管理跟其它语言基本类似，提供了浅复制和深复制两种方式，使用时略有区别，这里简单介绍。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>在 Rust 中，两个 Trait 都可以用来复制数据，区别是：</p><ul><li><code>Copy</code> 通过按位拷贝的方式进行复制，赋值、传参等场景中会调用该函数。</li><li><code>Clone</code> 可以通过 <code>clone()</code> 方法进行复制，用户可以自定义，需要显示调用。</li></ul><p>两种 <code>trait</code> 都可以通过 <code>#[derive(Copy, Clone)]</code> 自动派生，也就是编译器自动生成实现，用户可以根据使用场景决定只实现其中一个还是两个都实现。</p><p>注意，自动派生会遍历每个成员变量执行对应的 <code>trait</code> 实现，这也就意味着如果有些类型不支持，那么只能自己实现。</p><p>接着一步步看一些使用过程中常见的问题，已经如何更加 Rustacean 。</p><a class=anchor id=copy-vs-clone></a><h1>Copy VS. Clone <a href=#copy-vs-clone aria-hidden=true>#</a></h1><p><code>Copy</code> 实际上是一个 <code>Marker Trait</code>，只对编译器有效，不会生成函数，所以，如下两种方式是等价的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=w> </span><span class=nb>Copy</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Foobar</span><span class=w> </span><span class=p>{}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Clone</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>MyStruct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>MyStruct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>*</span><span class=bp>self</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Copy, Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Foobar</span><span class=p>{}</span><span class=w>
</span></span></span></code></pre></div><p>进行赋值时，默认会转移所有权，但是，当实现了 <code>Copy</code> 特征之后，那么就会采用按位复制 (浅拷贝) 执行，所有权不会发生转移，假设有如下代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[allow(dead_code)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug, Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Rectangle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>width</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>height</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rectangle</span><span class=p>{</span><span class=n>width</span>: <span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=n>height</span>: <span class=mi>20</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r3</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r1</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;copy </span><span class=si>{:?}</span><span class=s>, clone </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r2</span><span class=p>,</span><span class=w> </span><span class=n>r3</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>编译时会在 <code>let r3 = r1.clone()</code> 地方报 <code>borrow of moved value: r1</code> 的错误，也就是前面的 <code>let r2 = r1</code> 发生了所有权转移，如果要避免，可以添加 <code>Copy trait</code> 实现。</p><p>修改也很简答，只需要将 <code>#[derive(Debug, Clone)]</code> 修改为 <code>#[derive(Debug, Clone, Copy)]</code> 即可，此时就会使用类似 <code>memcpy</code> 方式复制。</p><p>这种场景下两种实现方式效果相同，每次都会复制了一份数据，各个变量之间不会发生相互干扰。</p><a class=anchor id=clone></a><h2>Clone <a href=#clone aria-hidden=true>#</a></h2><p>如上，这种方式需要手动调用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[allow(dead_code)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug, Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Rectangle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>width</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>height</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rectangle</span><span class=p>{</span><span class=n>id</span>: <span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Rectangle&#34;</span><span class=p>),</span><span class=w> </span><span class=n>width</span>: <span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=n>height</span>: <span class=mi>20</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r1</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;orignal </span><span class=si>{:?}</span><span class=s>, clone </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r1</span><span class=p>.</span><span class=n>id</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>(),</span><span class=w> </span><span class=n>r2</span><span class=p>.</span><span class=n>id</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>此时两个变量中 <code>id: String</code> 指向的是堆上的不同内存。</p><p>将上述的结构体修改为 <code>#[derive(Debug, Clone, Copy)]</code>，那么在 <code>id: String</code> 变量的地方会报 <code>this field does not implement Copy</code> 的错误，显然，并非所有类型都可以实现 <code>Copy</code> 这个 <code>trait</code> 。如果 <code>String</code> 类型允许 <code>Copy</code>，那么两个变量会指向相同的栈内存，那么就可能会出现内存重复释放。</p><p>这种方式需要复制内存，效率比较低，最好通过引用、Arc 等方式。</p><a class=anchor id=derive></a><h2>Derive <a href=#derive aria-hidden=true>#</a></h2><p>对结构体使用自动推导需要确保所有的成员变量同样支持 Copy 接口，常见的 String Vec 是不支持的，而不可变引用支持。</p><a class=anchor id=其它></a><h2>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h2><p>在 Rust 内部，Copy 被定义为如下，也就是实现 Copy 必须要同时实现 Clone 。这个依赖实际上是语义上或者实际使用场景中的最佳实践，通过 Clone 可以进行深复制，而 Copy 只复制必要内容，是对 Clone 的一种性能上优化。</p><p>所以，只有当存在成本高的深复制方式时，才有必要优化为浅复制，否则只需要通过浅复制即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=nb>Copy</span>: <span class=nb>Clone</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><a class=anchor id=drop></a><h1>Drop <a href=#drop aria-hidden=true>#</a></h1><p>通常用于 Resource Acquisition Is Initialization, RAII 场景，一般就是智能指针场景，或者有些用户自定义的清理逻辑。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=cp>#[allow(dead_code)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[derive(Debug, Clone)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>struct</span> <span class=nc>Rectangle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>id</span>: <span class=nb>String</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>width</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>height</span>: <span class=kt>u32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=nb>Drop</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Rectangle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>drop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Drop data </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>id</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Rectangle</span><span class=p>{</span><span class=n>id</span>: <span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Rectangle&#34;</span><span class=p>),</span><span class=w> </span><span class=n>width</span>: <span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=n>height</span>: <span class=mi>20</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>r1</span><span class=p>.</span><span class=n>clone</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;orignal </span><span class=si>{:?}</span><span class=s>, clone </span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>r1</span><span class=p>.</span><span class=n>id</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>(),</span><span class=w> </span><span class=n>r2</span><span class=p>.</span><span class=n>id</span><span class=p>.</span><span class=n>as_ptr</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>drop</span><span class=p>(</span><span class=n>r1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>drop</span><span class=p>(</span><span class=n>r2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Rust 会按照变量声明的顺序调用清理逻辑，包括代码中声明的变量，以及结构体中的变量，不允许手动调用析构函数，不过可以通过 <code>drop(val)</code> 这种方式显示删除。</p><p>另外，实现了 <code>Drop</code> 和 <code>Copy</code> 是不允许同时存在的，这也很显然，通过位复制方式得到的新变量是可以直接清理的，而使用 <code>Drop</code> 自定义又不会用到 <code>Copy</code> 实现。</p><a class=anchor id=manuallydrop></a><h2>ManuallyDrop <a href=#manuallydrop aria-hidden=true>#</a></h2><p>一个包装器，用来禁止编译器自动调用 <code>T</code> 的析构函数，可以控制某些场景下的资源清理逻辑。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>std</span>::<span class=n>mem</span>::<span class=n>ManuallyDrop</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>val</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ManuallyDrop</span>::<span class=n>new</span><span class=p>(</span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&#34;Hello World!&#34;</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>val</span><span class=p>.</span><span class=n>truncate</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span><span class=w> </span><span class=c1>// handle value safty
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>val</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>ManuallyDrop</span>::<span class=nb>drop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>上述是通过手动方式释放资源，另外，还可以如下方式重新获取封装的对象，这样 <code>Rust</code> 会自动释放资源。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>v0</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>unsafe</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>ManuallyDrop</span>::<span class=n>take</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w> </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{:?}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=n>v0</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>不过建议使用 <code>ManuallyDrop::into_inner(val);</code> 这种方式。另外 <code>std::mem::forget&lt;T></code> 函数实现，使用的就是 <code>ManuallyDrop::new</code> 方法。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#copy-vs-clone>Copy VS. Clone</a><ul><li><a href=#clone>Clone</a></li><li><a href=#derive>Derive</a></li><li><a href=#其它>其它</a></li></ul></li><li><a href=#drop>Drop</a><ul><li><a href=#manuallydrop>ManuallyDrop</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>