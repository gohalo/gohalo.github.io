<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>时序数据库简介 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="时序数据以时间作为主要的查询纬度，通常会将连续的多个时间序列数据绘制成线，可制作基于时间的多纬度报表，用揭示其趋势、规律、异常，除了实时在线预测和预警，还可以做离线的数据分析甚至是机器学习。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>时序数据库简介</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2016-09-12</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/database/ role=button>database</a></div></div><hr><div class=content><p>时序数据以时间作为主要的查询纬度，通常会将连续的多个时间序列数据绘制成线，可制作基于时间的多纬度报表，用揭示其趋势、规律、异常，除了实时在线预测和预警，还可以做离线的数据分析甚至是机器学习。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>不同的时序数据库定义可能会有所不同，如下是其使用时常见的基本概念。</p><ul><li><code>metric</code> 指标，相当于关系型数据库中的 table；</li><li>data point 数据点，相当于关系型数据库中的 row；</li><li>timestamp 时间戳，代表数据点产生的时间，一般是必须的列，常作为主健；</li><li>field 度量下的不同字段，一般存放随着时间戳的变化而变化的数据；</li><li>tag 标签，一般存放的是标示数据点来源的属性信息。</li></ul><p>通常 timestamp 加上所有的 tags 可以认为是 table 的 key；如下图是采集风向的数据：</p><p><img alt="timeseries metric wind" src=images/timeseries-metric-wind.jpg class="mx-auto d-block"></p><a class=anchor id=存储方案></a><h1>存储方案 <a href=#%e5%ad%98%e5%82%a8%e6%96%b9%e6%a1%88 aria-hidden=true>#</a></h1><p>一般分为了单机存储以及分布式存储。</p><a class=anchor id=单机存储></a><h2>单机存储 <a href=#%e5%8d%95%e6%9c%ba%e5%ad%98%e5%82%a8 aria-hidden=true>#</a></h2><p>如果只存储数据，直接写日志即可，但因为需要快速聚合查询，所以需要考虑存储的结构。</p><p>传统数据库存储采用的都是 B-Tree，主要用于在查询和顺序插入时有利于减少寻道次数，对于普通机械磁盘，一般寻道时间大概需要 10ms 左右，对于随机读写大部分时间会消耗在寻道上，从而导致整个查询非常慢。</p><p>虽然 SSD 具有更快的寻道时间，但并没有从根本上解决这个问题，而且会引入新的问题。</p><p>对于 90% 以上场景都是写入的时序数据库，B Tree 很明显是不合适，大部分采用 LSM Tree 替换，如 HBase、Cassandra 等；LSM Tree 包括内存里的数据结构和磁盘上的文件两部分，分别对应 HBase 里的 MemStore/HLog 以及 Cassandra 里的 MemTable/SSTable 。</p><p>LSM Tree 的操作流程如下：</p><ol><li>数据写入和更新先写入内存里的数据结构，为了避免数据丢失同时也会先写到 WAL 文件中。</li><li>内存里的数据会定时或者当达到固定大小时刷到磁盘，这些磁盘上的文件不会被修改。</li><li>随着磁盘上积累的文件越来越多，会定时的进行合并操作，消除冗余数据，减少文件数量。</li></ol><p><img alt="timeseries lsmtree arch" src=images/timeseries-lsmtree-arch.png class="mx-auto d-block"></p><p>可以看到 LSM Tree 的核心思想就是通过内存写和后续磁盘的顺序写入获得更高的写入性能，避免了随机写入，但同时也牺牲了读取性能，因为同一个 key 的值可能存在于多个 HFile 中。</p><p>为了获取更好的读取性能，可以通过 BloomFilter 和 Compaction 机制。</p><a class=anchor id=分布式存储></a><h2>分布式存储 <a href=#%e5%88%86%e5%b8%83%e5%bc%8f%e5%ad%98%e5%82%a8 aria-hidden=true>#</a></h2><p>时序数据库面向的是海量数据的写入存储读取，单机是无法解决问题的，所以需要采用多机存储，也就是分布式存储；除了数据量的问题之外，通常也可以通过分布式解决单点问题。</p><p>对于分布式存储首先需要考虑如何将数据分布到多台机器上面，目前采用最多的是分片，也可以通过单独结点管理数据分片；关于分片，其核心问题是分片方法的选择和分片的设计。</p><a class=anchor id=分片方法></a><h4>分片方法 <a href=#%e5%88%86%e7%89%87%e6%96%b9%e6%b3%95 aria-hidden=true>#</a></h4><p>时序数据库的分片方法和其他分布式系统是相通的，基本分为如下几种：</p><ul><li>哈希分片，实现简单，均衡性较好，但是集群不易扩展，动态增删结点容易导致大部分数据重新分布。</li><li>一致性哈希，这种方案均衡性好，集群扩展容易，只是实现相比略微复杂，例如 DynamoDB(Amazon)、Cassandra 。</li><li>范围划分，通常配合全局有序，复杂度在于合并和分裂，例如 Hbase 。</li></ul><a class=anchor id=分片设计></a><h4>分片设计 <a href=#%e5%88%86%e7%89%87%e8%ae%be%e8%ae%a1 aria-hidden=true>#</a></h4><p>所谓的分片设计，简单来说就是通过什么计算分片，这是非常有技巧的，将会直接影响读写性能。</p><p>结合时序数据的特点，通常会根据 metric+tags 进行分片，因为往往会按照一个时间范围查询，这样相同 metric 和 tags 的数据会在一台机器上连续存放，顺序的磁盘读取是很快的。</p><p>如下图，第一行和第三行都是同样的 tag(sensor=95D8-7913;city=上海)，所以分配到同样的分片，而第五行虽然也是同样的 tag，但是根据时间范围再分段，被分到了不同的分片；而第二、四、六行与上述相同。</p><p><img alt="timeseries metric sharding examples" src=images/timeseries-metric-sharding-examples.jpg class="mx-auto d-block"></p><a class=anchor id=数据查询></a><h1>数据查询 <a href=#%e6%95%b0%e6%8d%ae%e6%9f%a5%e8%af%a2 aria-hidden=true>#</a></h1><p>对于时序数据的查询分为两种：原始数据的查询和时序数据聚合运算的查询，前者主要对历史高精度时序数据的查询，查询结果粒度太细，并不利于分析其规律或者趋势，也不适合展现给用户；后者主要用来对数据做分析。</p><a class=anchor id=索引设计></a><h1>索引设计 <a href=#%e7%b4%a2%e5%bc%95%e8%ae%be%e8%ae%a1 aria-hidden=true>#</a></h1><p><img alt="data point" src=images/datapoint.svg class="mx-auto d-block"></p><p>如上所示，时序数据库很关键的是 <code>Label</code> 的管理 (也被称为 <code>Tag</code> 两个语义上相同)，包括了用户自定义的实现，也包括类似 <code>Prometheus</code> 通过 <code>__name__</code> 指定表名，也就是将 <code>__xxx__</code> 作为内部使用。</p><p>在使用时有两个场景：A) 写入需要判断是否存在；B) 读取则需要通过 <code>Label</code> 组合快速过滤所需时间线。</p><p>相比其它系统的标签来说，时序场景的 <code>Label</code> 有如下几个特点：</p><ul><li><code>SchemaLess</code> 对应的 <code>Label</code>、<code>Field</code> 是动态变化的，无需建表时指定。</li><li>可能出现高基数场景，例如主机 ID (主机监控)、用户 ID (URL 监控) 等，虽然不建议但仍会出现。</li><li>随着时间变化，昨天存在的内容今天可能已经消失，尤其是当前容器实现方式，其变化的速率会更快。</li></ul><p>时序数据 <code>Series</code> 通过 <code>Measurement</code> <code>Labels</code> <code>Field</code> 唯一确定，为减少内存占用，会将 Key 字符串映射为自增整型 ID 使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>----- 主要是写入过程中使用
</span></span><span class=line><span class=cl>cpu,host=xxx,region=west#idle   123
</span></span><span class=line><span class=cl>cpu,host=yyy,region=west#idle   456
</span></span></code></pre></div><p>查询时，将维护相关的倒排索引。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>{host=node1}   sid1,sid2,sid3
</span></span><span class=line><span class=cl>{host=node2}   sid2,sid3,sid5
</span></span><span class=line><span class=cl>{region=west}  sid3,sid5,sid9
</span></span><span class=line><span class=cl>{region=east}  sid2,sid3,sid7
</span></span></code></pre></div><p>查询的几种场景。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>----- 严格匹配，可以直接通过上述Key定位
</span></span><span class=line><span class=cl>host=node1 AND region=west
</span></span><span class=line><span class=cl>----- 多个匹配
</span></span><span class=line><span class=cl>host=(node1|node2) AND region=west
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 正则表示
</span></span><span class=line><span class=cl>host=~node* AND region=west
</span></span><span class=line><span class=cl>----- 取非
</span></span><span class=line><span class=cl>host!~node* AND region=west
</span></span></code></pre></div><p>后续的正则模糊匹配有几种场景：A) 倒排通过 Hash 实现，只能支持 Get 请求，此时的 Scan 需要全表扫描，那么就需要再增加倒排索引；B) 倒排通过 BTree 实现则可以支持前缀索引。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>host    node1,node2
</span></span><span class=line><span class=cl>region  west,east
</span></span></code></pre></div><p>根据实现的策略，可以对 Tag 进行分类，例如 <code>region</code> <code>node</code> 类似会全局使用，但是像 CPU 的 <code>core</code>、Disk 的 <code>mount</code> 等只与具体的指标关联，无需全局存储。</p><a class=anchor id=最佳实践></a><h2>最佳实践 <a href=#%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5 aria-hidden=true>#</a></h2><p>方案设计过程中希望能提供机制而非策略，同时希望有零成本的抽象，但是在设计过程中必定会有些取舍，这里简单整理推荐使用的最佳场景。</p><div class="notice tip mb-2 ms-5"><div class="notice-title fw-bolder py-1 px-2"><span class="notice-icon text-center"><i class="fa fa-thumbs-o-up" aria-hidden=true></i></span>
提示</div><div class="notice-body py-2 px-2">所谓的零成本指的是，使用过程中无需对不需要的功能付出成本，在具体的某个场景下已经是最优的策略。</div></div><ul><li>不同的指标作为单独表使用，其采集间隔可能不同，例如 <code>cpu</code> <code>disk</code> <code>net</code> 等等。</li><li>采用多级分区，其中时间必须，同时允许使用类似 <code>region</code>、<code>service</code> 这种通用方式。</li><li>分桶尽量保证数据的均衡。</li></ul><a class=anchor id=数据量分析></a><h2>数据量分析 <a href=#%e6%95%b0%e6%8d%ae%e9%87%8f%e5%88%86%e6%9e%90 aria-hidden=true>#</a></h2><p>在设计时分成了 <code>Partition</code> <code>Shard</code> 两个层级，也就是分区、分桶的设计，前者通常包含时间，后者需要确保数据均衡不要发生太大的倾斜，如下针对监控场景进行简单分析。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>host     -&gt; 500w
</span></span><span class=line><span class=cl>service  -&gt; 5k
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>region   -&gt; 20
</span></span><span class=line><span class=cl>metric   -&gt; 20
</span></span></code></pre></div><p>上述是 <code>Label</code> 中 <code>Key</code> 及其对应的可能数据量，注意，这里不会出现笛卡尔积的场景，上述最多会有 <code>host</code> 指定的数据量。</p><a class=anchor id=乱序数据></a><h2>乱序数据 <a href=#%e4%b9%b1%e5%ba%8f%e6%95%b0%e6%8d%ae aria-hidden=true>#</a></h2><p>例如 <code>Prometheus</code> 只允许时序数据递增，当出现乱序会报 <code>Out of order</code> 的错误，而超过某个 <code>Block</code> 可表示的时间范围则会报 <code>Out of Bound</code> 的错误，而真实的现实可能会出现乱序的场景，尤其是增加了重试逻辑之后。</p><p>处理乱序数据需要考虑几个场景：</p><ul><li>内存中如何保存。</li><li>如何执行持久化。</li><li>已经持久化的数据如何修改。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#存储方案>存储方案</a><ul><li><a href=#单机存储>单机存储</a></li><li><a href=#分布式存储>分布式存储</a></li></ul></li><li><a href=#数据查询>数据查询</a></li><li><a href=#索引设计>索引设计</a><ul><li><a href=#最佳实践>最佳实践</a></li><li><a href=#数据量分析>数据量分析</a></li><li><a href=#乱序数据>乱序数据</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>