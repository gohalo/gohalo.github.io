<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux Cache VS. Buffer | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="实际上 Buffer 和 Cache 是两个用烂的词，在不同的场景下其语义会有所区别。在 Linux 的内存管理中，Buffer 是指 Buffer Cache(缓冲区缓存)，Cache 是指 Page Cache(页面缓存)。
这里简单介绍其概念。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux Cache VS. Buffer</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2018-07-28</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>实际上 Buffer 和 Cache 是两个用烂的词，在不同的场景下其语义会有所区别。在 Linux 的内存管理中，Buffer 是指 Buffer Cache(缓冲区缓存)，Cache 是指 Page Cache(页面缓存)。</p><p>这里简单介绍其概念。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>曾经 Buffer 被用来做 IO 设备的写缓存，Cache 被用来作为 IO 设备的读缓存，这里的 IO 设备，主要指的是块设备文件和文件系统上的普通文件；但是现在，它们的意义已经不一样了。</p><p>在当前的内核中，PageCache 就是针对内存页的缓存，如果有内存是以 Page 进行分配管理的，都可以使用 PageCache 作为其缓存来管理使用。</p><p>当然，不是所有的内存都是以 Page 为单位进行管理，也有很多是针对块 Block 进行管理的，如果这部分需要使用到 Cache 功能，则都集中到 BufferCache 中，从这一角度来说，改称为 BlockCache 更为合适。</p><a class=anchor id=前世今生></a><h2>前世今生 <a href=#%e5%89%8d%e4%b8%96%e4%bb%8a%e7%94%9f aria-hidden=true>#</a></h2><p>简单来说，两者都是为了优化磁盘 IO 的读写速率，其中 PageCache 缓存了文件页用来优化文件 IO；而 BufferCache 缓存了磁盘块用来优化块设备的 IO 。</p><p>很多的类 Unix 系统采用了与 Linux 2.4 之前版本类似的策略，也就是文件缓存在 PageCache 而磁盘块缓存在 BufferCache。</p><p>而实际上，大部分文件是通过文件系统呈现，而且存储在磁盘上，这就会导致同一份文件保存了两份，不优雅也不高效，为此，在 Linux 2.4 版本之后，就将两者进行了统一。</p><p>如果被缓存的数据即是文件数据又是块数据 (对于文件来说大部分的数据是的，元数据不是)，此时 BufferCache 会有指针指向 PageCache ，这样数据就只需要在内存中缓存一份。当讨论磁盘缓存时，其实就是 PageCache ，它缓存了磁盘文件数据，从而提高 IO 的吞吐量。</p><p>当然，目前 BufferCache 仍然是存在的，因为还存在需要执行的块 IO。因为大多数块都是用来存储文件数据，所以大部分 BufferCache 都指向了 PageCache；但还是有一小部分块并不是文件数据，例如元数据、RawBlock IO，此时还需要通过 BufferCache 来缓存。</p><p>明白了这两套缓存系统的区别，就可以理解它们究竟都可以用来做什么了。</p><a class=anchor id=page-cache></a><h2>Page Cache <a href=#page-cache aria-hidden=true>#</a></h2><p>主要用来作为文件系统上的文件数据的缓存，常见的是针对文件的 <code>read()/write()</code> 操作，另外也包括了通过 <code>mmap()</code> 映射之后的块设备，也就是说，事实上 Page Cache 负责了大部分的块设备文件的缓存工作。</p><a class=anchor id=buffer-cache></a><h2>Buffer Cache <a href=#buffer-cache aria-hidden=true>#</a></h2><p>BufferCache 用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用，例如格式化文件系统时。</p><a class=anchor id=总结></a><h2>总结 <a href=#%e6%80%bb%e7%bb%93 aria-hidden=true>#</a></h2><p>磁盘有逻辑 (文件系统) 和物理 (磁盘块) 两种操作，分别对应了 Page Cache 和 Buffer Cache 。简单来说，如果直接通过 <code>read()/write()</code> 等直接去操作文件，那使用的就是 Page Cache 缓存，而使用 dd 等命令直接操作磁盘块，就是 Buffer Cache 缓存。</p><p>注意，块 Block 的大小由所使用块设备决定，而页在 x86 上无论是 32 位还是 64 位都是 4K 。</p><a class=anchor id=测试></a><h1>测试 <a href=#%e6%b5%8b%e8%af%95 aria-hidden=true>#</a></h1><p>那么 free 命令中的 buffers 和 cache 是什么意思？</p><p>该命令读取的是 <code>/proc/meminfo</code> 文件中的数据，可以从是否有 available 判断是否为最新版本，对于老版本计算方式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cache = Cached + SwapCached + SReclaimable;
</span></span><span class=line><span class=cl>available = MemFree + Buffers + cache
</span></span></code></pre></div><a class=anchor id=free></a><h2>free <a href=#free aria-hidden=true>#</a></h2><p>新版的 free 命令输出如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ free -wm
</span></span><span class=line><span class=cl>              total        used        free      shared     buffers       cache   available
</span></span><span class=line><span class=cl>Mem:           7881        3109         797        1113         309        3665        3310
</span></span><span class=line><span class=cl>Swap:          7936         260        7676
</span></span></code></pre></div><ul><li>buffers，表示块设备 (block device) 所占用的缓存页，包括了直接读写块设备以及文件系统元数据 (metadata) 比如 SuperBlock 所使用的缓存页；</li><li>cached，表示普通文件系统中数据所占用的缓存页。</li></ul><p>如上所述，该命令读取的是 <code>/proc/meminfo</code> 文件中的 Buffers 和 Cached 数据，而在内核中的实现实际上对应了 <code>meminfo_proc_show()@fs/proc/meminfo.c</code> 函数，内容如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>meminfo_proc_show</span><span class=p>(</span><span class=k>struct</span> <span class=n>seq_file</span> <span class=o>*</span><span class=n>m</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>si_meminfo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>  <span class=c1>// 通过nr_blockdev_pages()函数填充bufferram
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>si_swapinfo</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cached</span> <span class=o>=</span> <span class=nf>global_page_state</span><span class=p>(</span><span class=n>NR_FILE_PAGES</span><span class=p>)</span> <span class=o>-</span>
</span></span><span class=line><span class=cl>            <span class=nf>total_swapcache_pages</span><span class=p>()</span> <span class=o>-</span> <span class=n>i</span><span class=p>.</span><span class=n>bufferram</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cached</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cached</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>seq_printf</span><span class=p>(</span><span class=n>m</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;Buffers:        %8lu kB</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;Cached:         %8lu kB</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ... ..
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>K</span><span class=p>(</span><span class=n>i</span><span class=p>.</span><span class=n>bufferram</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=nf>K</span><span class=p>(</span><span class=n>cached</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=c1>// ... ..
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>如上计算 cached 公式中，<code>global_page_state(NR_FILE_PAGES)</code> 实际读取的 <code>vmstat[NR_FILE_PAGES]</code>，也就是用于统计所有缓存页 (page cache) 的总和，它包括：</p><blockquote><p>swap cache 主要是针对匿名内存页，例如用户进程通过 malloc() 申请的内存页，当要发生 swapping 换页时，如果一个匿名页要被换出时，会先计入到 swap cache，但是不会立刻写入物理交换区，因为 Linux 的原则是除非绝对必要，尽量避免 IO。</p><p>所以 swap cache 中包含的是被确定要 swapping 换页，但是尚未写入物理交换区的匿名内存页。</p></blockquote><a class=anchor id=验证></a><h2>验证 <a href=#%e9%aa%8c%e8%af%81 aria-hidden=true>#</a></h2><p>如上，读取 EXT4 文件系统的目录会使用到 &ldquo;buffers&rdquo;，这里使用 find 命令扫描文件系统，观察 &ldquo;buffers&rdquo; 增加的情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># sync
</span></span><span class=line><span class=cl># echo 3 &gt; /proc/sys/vm/drop_caches
</span></span><span class=line><span class=cl>$ free -wk; find ~ -name &#34;not exits file&#34; &gt;/dev/null 2&gt;&amp;1; free -wk
</span></span><span class=line><span class=cl>              total        used        free      shared     buffers       cache   available
</span></span><span class=line><span class=cl>Mem:        8070604     3260408     3445852     1102588        5236     1359108     3418844
</span></span><span class=line><span class=cl>Swap:       8127484      300172     7827312
</span></span><span class=line><span class=cl>              total        used        free      shared     buffers       cache   available
</span></span><span class=line><span class=cl>Mem:        8070604     3249764     3207336     1087716      250484     1363020     3417764
</span></span><span class=line><span class=cl>Swap:       8127484      300172     7827312
</span></span></code></pre></div><p>再测试下直接读取 block device 并观察 &ldquo;buffers&rdquo; 增加的现象：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># sync
</span></span><span class=line><span class=cl># echo 3 &gt; /proc/sys/vm/drop_caches
</span></span><span class=line><span class=cl># free -wk; dd if=/dev/sda1 of=/dev/null count=200M; free -wk
</span></span><span class=line><span class=cl>              total        used        free      shared     buffers       cache   available
</span></span><span class=line><span class=cl>Mem:        8070604     3244516     3486124     1094648         932     1339032     3451048
</span></span><span class=line><span class=cl>Swap:       8127484      300172     7827312
</span></span><span class=line><span class=cl>532480+0 records in
</span></span><span class=line><span class=cl>532480+0 records out
</span></span><span class=line><span class=cl>272629760 bytes (273 MB) copied, 0.612241 s, 445 MB/s
</span></span><span class=line><span class=cl>              total        used        free      shared     buffers       cache   available
</span></span><span class=line><span class=cl>Mem:        8070604     3245032     3218528     1094868      267196     1339848     3427012
</span></span><span class=line><span class=cl>Swap:       8127484      300172     7827312
</span></span></code></pre></div><p>找个比较大的文件，然后通过 cat 命令读取，可以看到对应的 cache 会增加。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># sync
</span></span><span class=line><span class=cl># echo 3 &gt; /proc/sys/vm/drop_caches
</span></span><span class=line><span class=cl># free -wk; cat /your/big/file/path; free -wk
</span></span><span class=line><span class=cl>              total        used        free      shared     buffers       cache   available
</span></span><span class=line><span class=cl>Mem:        8070604     3244516     3486124     1094648         932      423384     3451048
</span></span><span class=line><span class=cl>Swap:       8127484      300172     7827312
</span></span><span class=line><span class=cl>532480+0 records in
</span></span><span class=line><span class=cl>532480+0 records out
</span></span><span class=line><span class=cl>272629760 bytes (273 MB) copied, 0.612241 s, 445 MB/s
</span></span><span class=line><span class=cl>              total        used        free      shared     buffers       cache   available
</span></span><span class=line><span class=cl>Mem:        8070604     3245032     3218528     1094868        2354     1019960     3427012
</span></span><span class=line><span class=cl>Swap:       8127484      300172     7827312
</span></span></code></pre></div><a class=anchor id=mincore></a><h1>mincore <a href=#mincore aria-hidden=true>#</a></h1><p>在内核中有个 <code>man mincore(2)</code> 的系统调用，其实现在 <code>mm/mincore.c</code> 中，主要用来判断页面的状态，可以使用 <code>fincore</code> 工具查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mincore -- determine whether pages are resident in memory
</span></span></code></pre></div><p>最早是由 google 开发，不过已经是七八年前的事情了，现在几乎不再维护，可以从 github 上查找相关的代码。</p><p>去掉了异常处理之外，其处理过程大致如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>fd = open(fname, O_RDONLY);
</span></span><span class=line><span class=cl>if (fstat(fd, &amp;stat) &lt; 0) {
</span></span><span class=line><span class=cl>file_pages = (stat.st_size + page_size - 1) / page_size;
</span></span><span class=line><span class=cl>vec = malloc(file_pages);
</span></span><span class=line><span class=cl>fmap = mmap(NULL, stat.st_size, PROT_NONE, MAP_SHARED, fd, 0);
</span></span><span class=line><span class=cl>if (mincore(fmap, stat.st_size, vec) != 0 ) {
</span></span><span class=line><span class=cl>if (vec[i] &amp; 1) {
</span></span></code></pre></div><p><code>open()</code> 获得文件描述符，<code>fstat()</code> 获取文件的长度，页面的大小可以通过系统调用获取，一般是 4K ，有了文件大小，就知道了，需要多少个 <code>int</code> 来存放结果。</p><p><code>mmap()</code> 建立映射关系，<code>mincore()</code> 获取文件页面的驻留情况，从起始地址开始，长度是 filesize，结果保存在 <code>vec</code> 数组里，如果 <code>vec[i] & 1 == 1</code> 那么表示该页面驻留在内存中，否则没有对应缓存。</p><p>另外，一个不错的工具可以参考 <a href=https://github.com/hoytech/vmtouch/>vmtouch</a> 。</p><a class=anchor id=回收-cache></a><h1>回收 Cache <a href=#%e5%9b%9e%e6%94%b6-cache aria-hidden=true>#</a></h1><p>内核在内存将要耗尽时，会触发内存回收的工作，一般来说主要释放的是 Buffer/Cache 的内存，但是这种清缓存的操作也并不是没有成本。</p><p>理解 Buffer Cache 的作用，那么如果要清理缓存，那么必须要保证数据的一致性，所以一般在清理的时候同时会伴随这 IO 彪高。因为内核要对比内存中的数据和对应硬盘文件上的数据是否一致，如果不一致需要写回，之后才能回收。</p><a class=anchor id=手动触发></a><h2>手动触发 <a href=#%e6%89%8b%e5%8a%a8%e8%a7%a6%e5%8f%91 aria-hidden=true>#</a></h2><p>在系统中除了内存将被耗尽的时候可以清缓存以外，还可以使用下面这个文件来人工触发缓存清除的操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># echo 1 &gt; /proc/sys/vm/drop_caches
</span></span></code></pre></div><p>其中的取值可以是 <code>1</code> <code>2</code> <code>3</code>，代表的含义为：</p><ul><li><code>1</code> 清除 PageCache；</li><li><code>2</code> 回收 slab 分配器中的对象 (包括目录项缓存和 inode 缓存)，slab 是内核中管理内存的一种机制，其中很多缓存数据实现都是用的 PageCache；</li><li><code>3</code> 清除 PageCache 和 slab 分配器中的缓存对象。</li></ul><p>这部分内核代码位于 <code>fs/drop_caches.c</code> 里面。</p><a class=anchor id=fadvise></a><h2>fadvise <a href=#fadvise aria-hidden=true>#</a></h2><p>除了上述粗暴的方法外，Linux 还提供了 <code>posix_fadvise()</code> 系统调用，允许用户给 Linux 提建议。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &lt;fcntl.h&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int posix_fadvise(int fd, off_t offset, off_t len, int advice);
</span></span></code></pre></div><p>其中比较常用的有两个选项，可以通过 <code>posix_fadvise(2)</code> 查看，信息摘抄如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>POSIX_FADV_WILLNEED
</span></span><span class=line><span class=cl>	The specified data will be accessed in the near future.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>POSIX_FADV_DONTNEED
</span></span><span class=line><span class=cl>	The specified data will not be accessed in the near future.
</span></span></code></pre></div><p>其中，其含义如下：</p><ul><li><code>POSIX_FADV_WILLNEED</code> 相当于说，这个文件在不久的将来要用，请准备好相应的页面(从磁盘读入内存)，相当于预读。</li><li><code>POSIX_FADV_DONTNEED</code> 相当于告知 Linux ，这个文件不用了，直接回收掉吧，类似于 sync 操作。</li></ul><p>在 PostgreSQL 中有如下的应用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>FilePrefetch</span><span class=p>(</span><span class=n>File</span> <span class=n>file</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>int</span> <span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#if defined(USE_POSIX_FADVISE) &amp;&amp; defined(POSIX_FADV_WILLNEED)
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=kt>int</span> <span class=n>returnCode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>Assert</span><span class=p>(</span><span class=nf>FileIsValid</span><span class=p>(</span><span class=n>file</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nf>DO_DB</span><span class=p>(</span><span class=nf>elog</span><span class=p>(</span><span class=n>LOG</span><span class=p>,</span> <span class=s>&#34;FilePrefetch: %d (%s) &#34;</span> <span class=n>INT64_FORMAT</span> <span class=s>&#34; %d&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>file</span><span class=p>,</span> <span class=n>VfdCache</span><span class=p>[</span><span class=n>file</span><span class=p>].</span><span class=n>fileName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=p>(</span><span class=n>int64</span><span class=p>)</span> <span class=n>offset</span><span class=p>,</span> <span class=n>amount</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>returnCode</span> <span class=o>=</span> <span class=nf>FileAccess</span><span class=p>(</span><span class=n>file</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>returnCode</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>returnCode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>returnCode</span> <span class=o>=</span> <span class=nf>posix_fadvise</span><span class=p>(</span><span class=n>VfdCache</span><span class=p>[</span><span class=n>file</span><span class=p>].</span><span class=n>fd</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>amount</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                 <span class=n>POSIX_FADV_WILLNEED</span><span class=p>);</span> <span class=c1>//预读
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>returnCode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=nf>Assert</span><span class=p>(</span><span class=nf>FileIsValid</span><span class=p>(</span><span class=n>file</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>pg_flush_data</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>off_t</span> <span class=n>amount</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#if defined(USE_POSIX_FADVISE) &amp;&amp; defined(POSIX_FADV_DONTNEED)
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=k>return</span> <span class=nf>posix_fadvise</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>offset</span><span class=p>,</span> <span class=n>amount</span><span class=p>,</span> <span class=n>POSIX_FADV_DONTNEED</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span></code></pre></div><p>通过 <code>fadvise</code> 就能把某文件彻底赶出缓存，代码非常简单。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>clear_file_cache</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>stat</span> <span class=n>st</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=nf>stat</span><span class=p>(</span><span class=n>filename</span> <span class=p>,</span> <span class=o>&amp;</span><span class=n>st</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span> <span class=p>,</span> <span class=s>&#34;stat localfile failed, path:%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=nf>open</span><span class=p>(</span><span class=n>filename</span><span class=p>,</span> <span class=n>O_RDONLY</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span> <span class=n>fd</span> <span class=o>&lt;</span> <span class=mi>0</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>fprintf</span><span class=p>(</span><span class=n>stderr</span> <span class=p>,</span> <span class=s>&#34;open localfile failed, path:%s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>filename</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//clear cache by posix_fadvise
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span> <span class=nf>posix_fadvise</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=n>st</span><span class=p>.</span><span class=n>st_size</span><span class=p>,</span><span class=n>POSIX_FADV_DONTNEED</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Cache FADV_DONTNEED failed, %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=nf>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;Cache FADV_DONTNEED done</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中 <code>vmtouch -e</code> 以及 <code>linux-ftools</code> 中的 <code>linux-fadvise</code> 提供了类似的功能，实际最终调用的都是 <code>posix_fadvise()</code> 接口。</p><p>关于 <code>posix_fadvise()</code> 接口的内核实现，可以参考霸爷的 <a href=http://blog.yufeng.info/archives/1917>posix_fadvise 清除缓存的误解和改进措施</a> 。</p><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><a class=anchor id=stap></a><h2>stap <a href=#stap aria-hidden=true>#</a></h2><p>可以通过 stap 脚本查看是谁在消耗 Cache，不过配置起来比较麻烦，暂不介绍了，后面补充吧。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>一个不错的工具 linux-ftools，可以直接从 <a href=/reference/linux/monitor/linux-ftools.tar.bz2>本地下载</a> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#前世今生>前世今生</a></li><li><a href=#page-cache>Page Cache</a></li><li><a href=#buffer-cache>Buffer Cache</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#测试>测试</a><ul><li><a href=#free>free</a></li><li><a href=#验证>验证</a></li></ul></li><li><a href=#mincore>mincore</a></li><li><a href=#回收-cache>回收 Cache</a><ul><li><a href=#手动触发>手动触发</a></li><li><a href=#fadvise>fadvise</a></li></ul></li><li><a href=#其它>其它</a><ul><li><a href=#stap>stap</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>