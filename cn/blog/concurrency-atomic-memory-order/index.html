<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>原子操作内存序介绍 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="当多个线程同时访问一个变量时，会导致数据竞争问题，会导致结果未定义。而且从实现来说，即时是一条语句，从硬件层面仍不能保证读写操作是原子的，例如变量在寄存器中，修改后才写入内存。
通常使用的是 Mutex 操作，不过常用的还有原子操作。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>原子操作内存序介绍</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2022-10-01</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a></div></div><hr><div class=content><p>当多个线程同时访问一个变量时，会导致数据竞争问题，会导致结果未定义。而且从实现来说，即时是一条语句，从硬件层面仍不能保证读写操作是原子的，例如变量在寄存器中，修改后才写入内存。</p><p>通常使用的是 Mutex 操作，不过常用的还有原子操作。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>时任 ARM 工程师，参与了 ARM64 的 SMMU、内存模型等架构设计的 Will Deacon，在 Kernel Recipes 2018 中进行了名为 <code>Evolution and use of relaxed concurrency primitives</code> 的演讲中，曾用了这样一句话来形容多核带来的同步问题 <code>We ask for performance, but they give us concurrency</code> 。</p><p>本来，多核系统的出现是为了解决单核系统的性能瓶颈，但与之相伴的 Concurrency(并发) 却又是不可避免的。</p><blockquote><p>Concurrency(并发) VS. Parallelism(并行) 并发是逻辑上的同时发生，具有同时处理多个任务的能力，但是两者不一定同时发生。并行则是物理意义上的同时发生，并发不一定是并行。</p><ul><li>吃饭吃到一半，电话来了，你一直到吃完了以后才接，说明你不支持并发也不支持并行。</li><li>吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，说明你支持并发。</li><li>吃饭吃到一半，电话来了，你一边打电话一边吃饭，说明你支持并行。</li></ul><p>并发的关键是具有处理多个任务的能力，不一定是同时处理；而并行的关键是要有同时处理多个任务的能力。</p></blockquote><p>当前 CPU 大部分都是多核的，一个具有并发能力的程序，为了充分利用 CPU 资源，那么对应一般就会是并行的。</p><a class=anchor id=原子操作></a><h2>原子操作 <a href=#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c aria-hidden=true>#</a></h2><p>Mutex 通常是由操作系统或者库实现，而 Atomic 原子操作则需要由底层硬件提供支持。</p><p>原子操作是解决数据竞争、线程同步的基础操作，包括像 <code>mutex</code>、<code>rwlock</code> 也基本都是基于原子操作来实现的并发控制，详细可以查看内核的代码实现。</p><p>原子变量包含了三种基础操作：</p><ul><li><code>Load</code> 读取原子变量中的值；</li><li><code>Store</code> 将值保存到原子变量中；</li><li><code>ReadModifyWrite, RMW</code> 原子执行读取、修改、写入操作。</li></ul><p>实际上基于 RMW 有很多常用的操作，例如 <code>fetch_add</code> 自增、<code>exchange</code> 返回当前值并写入指定值。</p><p>不同的平台里，虽然底层实现基本相同，但是有些语言可能会在上层进行封装，例如 C++ 通过函数重载，几乎可以不用感知原子变量。如下以 C++ 为例介绍。</p><a class=anchor id=内存序></a><h2>内存序 <a href=#%e5%86%85%e5%ad%98%e5%ba%8f aria-hidden=true>#</a></h2><p>在 C++ 中使用时，需要同时指定 内存顺序 (<a href=https://en.cppreference.com/w/cpp/atomic/memory_order>Memory Order</a>)，不同内存顺序有不同的语义，可以实现不同顺序模型，对应性能也各不相同，C++ 中的内存顺序定义如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>memory_order</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>memory_order_relaxed</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>memory_order_consume</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>memory_order_acquire</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>memory_order_release</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>memory_order_acq_rel</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>memory_order_seq_cst</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>默认采用的是顺序一致性 Sequentially Consistent Ordering，可以实现较强的一致性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void store(T desired, std::memory_order order = std::memory_order_seq_cst);
</span></span><span class=line><span class=cl>T load(std::memory_order order = std::memory_order_seq_cst) const;
</span></span></code></pre></div><p>虽然可以实现较强的一致性，但是会导致性能下降，所以，一些高性能场景下通常会选择其它模型，此时就需要显示通过原子操作指定模型了。</p><p>另外，如上所述 std::atomic 重载了运算符，所以，如果使用默认内存序，那么可以像使用普通变量一样使用原子变量，否则需要显示指定。而且，不同的原子操作支持的内存序是不同的，表格如下。</p><p>通过这六种内存顺序相互组合可以实现如下几种顺序模型 (Ordering Model)：</p><ul><li><code>Sequencial Consistent Ordering</code> 实现同步且保证全局顺序一致，是一致性最强的模型，也是默认的顺序模型。</li><li><code>Release-Acquire Ordering</code> 实现同步，但不保证保证全局顺序一致的模型。</li><li><code>Relaxed Ordering</code> 不能实现同步，只保证单个变量原子性的模型。</li></ul><p>如下进行详细介绍。</p><a class=anchor id=基本概念></a><h1>基本概念 <a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-hidden=true>#</a></h1><p>在介绍具体的内存序之前，这里先介绍基本的概念。</p><a class=anchor id=modification-orders></a><h2>Modification Orders <a href=#modification-orders aria-hidden=true>#</a></h2><p>一个原子变量的所有修改操作总是存在一个所有线程都认可的先后顺序，即使这些修改操作是在不同的线程中执行的，而这个顺序就是所谓的修改顺序 (<code>Modification Order</code>)，在 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order>CPP Reference Memory Order</a> 中包含了一些详细约束。</p><p>注意，每次运行的顺序可能不同，但是每次运行时所有线程看到的顺序总是一致的，无论使用哪种内存序 (即使最松散的 <code>memory_order_relaxed</code> 类型)，原子变量的操作总能满足修改顺序一致性。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;atomic&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>writer</span><span class=p>(</span><span class=kt>int</span> <span class=n>start</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>start</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>usleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>reader</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>usleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span><span class=o>-&gt;</span><span class=n>push_back</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>dump</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>i</span> <span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v1</span><span class=p>,</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>w1</span><span class=p>(</span><span class=n>writer</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span> <span class=n>r1</span><span class=p>(</span><span class=n>reader</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v1</span><span class=p>),</span> <span class=n>w2</span><span class=p>(</span><span class=n>writer</span><span class=p>,</span> <span class=mi>1</span><span class=p>),</span> <span class=n>r2</span><span class=p>(</span><span class=n>reader</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>v2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>w1</span><span class=p>.</span><span class=n>join</span><span class=p>(),</span> <span class=n>w2</span><span class=p>.</span><span class=n>join</span><span class=p>(),</span> <span class=n>r1</span><span class=p>.</span><span class=n>join</span><span class=p>(),</span> <span class=n>r2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>dump</span><span class=p>(</span><span class=n>v1</span><span class=p>),</span> <span class=n>dump</span><span class=p>(</span><span class=n>v2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>有两个线程按照奇偶写入，另外两个线程则读取，为了便于观察各个线程之间增加了休眠时间，防止一直出现 <code>8</code> <code>9</code> 这种不变的数字，如下是一个可能的执行结果。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1 2 5 6 9 9 9 9 9 9
</span></span><span class=line><span class=cl>0 2 5 6 8 9 9 9 9 9
</span></span></code></pre></div><p>首先，读取不太可能看到每次的修改结果，例如调度到读取线程时可能已经执行了多次；但是读取的每次修改顺序是一致的，例如 <code>r1</code> 看到 <code>4</code> 先于 <code>7</code>，那么 <code>r2</code> 同样也是看到 <code>4</code> 先于 <code>7</code>，反之亦然。</p><p>也就是有个全局层面的一致性顺序。</p><a class=anchor id=happens-before></a><h2>Happens Before <a href=#happens-before aria-hidden=true>#</a></h2><p>这是一个非常重要的逻辑概念，如果 <code>A</code> <code>Happens Before</code> <code>B</code> 那么操作 <code>A</code> 的结果对于操作 <code>B</code> 可见，可以是同一个线程间的两个操作，也可以是不同线程间的两个操作，以此可以解决数据竞争 (Data Race)。</p><p>个人认为，这决定了代码实际运行时的前后依赖关系，无论是否为多线程。</p><a class=anchor id=sequenced-before-单线程></a><h3>Sequenced Before 单线程 <a href=#sequenced-before-%e5%8d%95%e7%ba%bf%e7%a8%8b aria-hidden=true>#</a></h3><p>单线程很容易理解，语句按照顺序执行，前面的语句先于后面的语句执行，或者正式地说，前面的语句总是 <code>sequenced-before</code> 后面的语句。注意，同一语句的顺序是不确定的，详见 <a href=https://en.cppreference.com/w/cpp/language/eval_order>Order of Evaluation</a> 中的介绍。另外，如果两个语句之间没有相互依赖关系，那么也无法保证顺序。</p><blockquote><p>求值 (Evaluation) 实际上包含了两部分操作：A) <code>Value Computation</code> 计算表达式的值；B) <code>Side Effect</code> 则是读写对象。语言本身并未规定表达式的求值顺序，例如 <code>f1()+f2()+f3()</code>、<code>func(f1(), f2(), f3())</code> 中三个函数可以是任意的排列顺序。同时，像 <code>i = i++ + i</code> 这种语句的行为也未定义。</p></blockquote><p>显然，<code>sequenced-before</code> 具有传递性，如果 <code>A</code> <code>sequenced-before</code> <code>K</code>，且 <code>K</code> <code>sequenced-before</code> <code>B</code>，那么可以推断出 <code>A</code> <code>sequenced-before</code> 操作 <code>B</code> 。</p><p>而且 <code>sequenced-before</code> 可以直接构成 <code>happens-before</code> 的关系，也就是说，如果 <code>A</code> <code>sequenced-before</code> <code>B</code> 则 <code>A</code> <code>happens-before</code> <code>B</code> 。例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>            <span class=c1>// (1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// (2)
</span></span></span></code></pre></div><p>在单线程中，语句 <code>(1)</code> 在语句 <code>(2)</code> 前面，因此语句 <code>(1)</code> <code>sequenced-before</code> 语句 <code>(2)</code>，也就是说 <code>(1)</code> <code>happens-before</code> 语句 <code>(2)</code>，所以 <code>(2)</code> 可以打印出 <code>(1)</code> 赋值的结果。</p><a class=anchor id=synchronizes-with-vs-inter-thread-happens-before></a><h3>Synchronizes-With VS. Inter-Thread Happens-Before <a href=#synchronizes-with-vs-inter-thread-happens-before aria-hidden=true>#</a></h3><p>多线程要复杂很多，因为多线程是并发执行的，如果没有正确的同步操作那么可能无法保证两个操作间的 <code>happens-before</code> 关系。当通过一些方法 (例如，加互斥锁) 让不同线程的两个操作同步，那么称这两个操作有 <code>synchronizes-with</code> 的关系。</p><p>当线程 <code>1</code> 中的操作 <code>A</code> <code>synchronizes-with</code> 线程 <code>2</code> 中的操作 <code>B</code>，那么可以称操作 <code>A</code> <code>inter-thread happens-before</code> 操作 <code>B</code>，也就是线程间的 <code>happens-before</code> 关系，而且还允许 <code>A</code> 前面或 <code>B</code> 后面接一个 <code>sequenced-before</code> 操作，例如，当 <code>B</code> 同时 <code>sequenced-before</code> <code>K</code>，那也意味着 <code>A</code> <code>inter-thread happens-before</code> <code>K</code>。</p><p>注意，虽然 <code>sequenced-before</code> 和 <code>inter-thread happens-before</code> 都具有传递性，但 <code>happens-before</code> 是没有传递性的。</p><p>例如有如下操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>         <span class=c1>// A
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mutex</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span> <span class=c1>// B
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mutex</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>      <span class=c1>// C
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span> <span class=c1>// D
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>其中 <code>mutex.unlock()</code> 操作 <code>synchronize-with</code> <code>mutex.lock()</code> 操作，对于如上代码，可以推断出。</p><ul><li>根据单线程中的语句顺序，有 <code>A</code> <code>sequenced-before</code> <code>B</code> 且 <code>C</code> <code>sequenced-before</code> <code>D</code> 。</li><li>因为 <code>B</code> <code>synchronize-with</code> <code>C</code> 且 <code>C</code> <code>sequenced-before</code> <code>D</code>，所以 <code>B</code> <code>inter-thread happens-before</code> <code>D</code>。</li><li>因为 <code>A</code> <code>sequenced-before</code> <code>B</code> 且 <code>B</code> <code>inter-thread happens-before</code> <code>D</code>，所以 <code>A</code> <code>inter-thread happens-before</code> <code>D</code>，最终 <code>A</code> <code>happens-before</code> <code>D</code>。</li></ul><p>所以，在 <code>D</code> 中可以看到 <code>A</code> 的修改。</p><p>这里是由 <code>mutex</code> 完成 <code>synchronize-with</code> 操作的，实际上，针对单个原子变量的 <code>release-acquire</code> 也可以达到，从而可以优化性能，可以查看 <a href=https://en.cppreference.com/w/cpp/atomic/memory_order>Synchronize With</a> 中的介绍。</p><a class=anchor id=其它></a><h2>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h2><p>注意，<code>happens-before</code> 是语言在语义层面的概念，并不代表指令在 CPU 中执行时的实际顺序，为了优化性能，会在编译器以及 CPU 中在不破坏的前提下对指令进行重排。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>虽然有 <code>a++;</code> <code>happens-before</code> <code>b++;</code>，因为两个变量没有依赖关系，实际编译后可能会先执行 <code>b++</code> 操作，甚至是最后执行 <code>a + b + 2</code> 操作，因为这并不影响语义。</p><a class=anchor id=内存顺序></a><h1>内存顺序 <a href=#%e5%86%85%e5%ad%98%e9%a1%ba%e5%ba%8f aria-hidden=true>#</a></h1><p>并发系统设计的时候，关键就是如何根据内存模型实现 <code>synchronize-with</code> 关系，也就是如何使用上述的六种内存顺序以及何种组合可以实现 <code>synchronize-with</code> 关系，如下表格是不同模型的支持能力。</p><p><img alt="memory order" src=images/memory_order.jpg class="mx-auto d-block"></p><a class=anchor id=sequencial-consistent></a><h2>Sequencial Consistent <a href=#sequencial-consistent aria-hidden=true>#</a></h2><p>对应了默认 <code>memory_order_seq_cst</code> 模型，所有线程看到的所有操作都有一个一致的顺序，即使这些操作是在不同线程中针对的不同变量，而之前修改顺序指的是单一变量，而这里是将这种一致性扩展到了所有变量。</p><p>注意，这里并不要求每次都一样，但每次运行中的每个线程看到的顺序都相同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>{</span><span class=nb>false</span><span class=p>},</span> <span class=n>y</span><span class=p>{</span><span class=nb>false</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>z</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_seq_cst</span><span class=p>);</span> <span class=c1>// (1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_seq_cst</span><span class=p>);</span> <span class=c1>// (2)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_x_then_y</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_seq_cst</span><span class=p>));</span> <span class=c1>// (3)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_seq_cst</span><span class=p>))</span> <span class=o>++</span><span class=n>z</span><span class=p>;</span> <span class=c1>// (4)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>read_y_then_x</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_seq_cst</span><span class=p>));</span> <span class=c1>// (5)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_seq_cst</span><span class=p>))</span> <span class=o>++</span><span class=n>z</span><span class=p>;</span> <span class=c1>// (6)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>a</span><span class=p>(</span><span class=n>thread1</span><span class=p>),</span> <span class=n>b</span><span class=p>(</span><span class=n>thread2</span><span class=p>),</span> <span class=n>c</span><span class=p>(</span><span class=n>read_x_then_y</span><span class=p>),</span> <span class=n>d</span><span class=p>(</span><span class=n>read_y_then_x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>.</span><span class=n>join</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>join</span><span class=p>(),</span> <span class=n>c</span><span class=p>.</span><span class=n>join</span><span class=p>(),</span> <span class=n>d</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>assert</span><span class=p>(</span><span class=n>z</span><span class=p>.</span><span class=n>load</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// (7)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>因为 <code>SeqCst</code> 可以保证全局修改顺序，对应 <code>(7)</code> 处的断言永远不会失败，分析如下。</p><p>如果先执行 <code>(1)</code> 后执行 <code>(2)</code>，则 <code>read_y_then_x()</code> 中循环 <code>(5)</code> 退出时，能保证 <code>y</code> 为 <code>true</code>，此时 <code>x</code> 也必然为 <code>true</code>，因此 <code>(6)</code> 会被执行; 同理，反之亦然。</p><p><code>SeqCst</code> 可以实现 <code>synchronizes-with</code> 关系，如果一个 <code>SeqCst</code> 的 <code>load</code> 操作在某个原子变量上读到了一个 <code>SeqCst</code> 的 <code>store</code> 操作在这个原子变量中写入的值，则 <code>store</code> 操作 <code>synchronizes-with</code> <code>load</code> 操作。上述示例中，有 <code>(1) synchronizes-with (3)</code> 和 <code>(2) synchronizes-with (5)</code> 。</p><p>注意，实现 <code>Sequencial Consistent</code> 模型存在一定开销，因为现在 CPU 通常有多核，每个核心还有自己的缓存，为了做到全局顺序一致性，每次写入操作都必须同步给其它核心，所以，如果不需要全局顺序一致，可以考虑其它更宽松的顺序模型。</p><a class=anchor id=relaxed></a><h2>Relaxed <a href=#relaxed aria-hidden=true>#</a></h2><p>对应 <code>memory_order_relaxed</code> 模型，此时只能保证操作的原子性和修改顺序一致性 (应该是单个变量)，无法实现 <code>synchronize-with</code> 关系，例如如下示例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>{</span><span class=nb>false</span><span class=p>},</span> <span class=n>y</span><span class=p>{</span><span class=nb>false</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span> <span class=c1>// (1)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span> <span class=c1>// (2)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>));</span> <span class=c1>// (3)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>());</span> <span class=c1>// (4)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>在 <code>thread1</code> 中的操作针对的是不同变量，那么在某些线程看来，有可能是 <code>x</code> 先变成 <code>true</code>，在另外的线程可能是 <code>y</code> 先变成 <code>true</code>，所以，上述的代码 <code>(4)</code> 可能失败。</p><p><code>relaxed</code> 顺序模型开销很小，在 <code>x86</code> 架构下不会生成额外指令，只需要编译器确保为原子操作。其中 <code>std::shared_ptr</code> 增加引用计数时用的就是 <code>relaxed</code> 模型，但是减少时，因为涉及到析构操作同步，所以不能使用。</p><a class=anchor id=acquire-release></a><h2>Acquire Release <a href=#acquire-release aria-hidden=true>#</a></h2><p>会涉及到 <code>memory_order_acquire</code> <code>memory_order_release</code> 和 <code>memory_order_acq_rel</code> 三种内存顺序，原子操作和内存序的支持度可以参考之前的表格。可以实现 <code>synchronize-with</code> 关系，如果一个 <code>acquire</code> 操作在同一个原子变量上读取到了一个 <code>release</code> 操作写入的值，那么这个 <code>release</code> 操作 <code>synchronize-with</code> 这个 <code>acquire</code> 操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>{</span><span class=nb>false</span><span class=p>},</span> <span class=n>y</span><span class=p>{</span><span class=nb>false</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>));</span> <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>));</span> <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>上述可以推导出 <code>2 synchronizes-with 3</code>，而且 <code>3 sequenced-before 4</code> 从而有 <code>2 inter-thread happens-before 4</code>；另外 <code>1 sequenced-before 2</code> 而 <code>2 inter-thread happens-before 4</code> 可以得到 <code>1 inter-thread happens-before 4</code>。</p><p>所以有 <code>1 happens-before 4</code> 也就是 <code>4</code> 能读取到 <code>1</code> 中写入值，断言不失败，即使 <code>1/4</code> 使用 <code>relaxed</code> 模型。</p><p>其开销相比 <code>SeqCst</code> 要小，在 x86 上 <code>release/acquire</code> 不会生成额外指令，编译器会确保所有指令不会重排到 <code>acquire</code> 前以及 <code>release</code> 之后，所以，这也是最常用场景。</p><a class=anchor id=release-sequence></a><h2>Release Sequence <a href=#release-sequence aria-hidden=true>#</a></h2><p>上述的 <code>SeqCst</code> 和 <code>AcqRel</code> 模型，要实现 <code>synchronizes-with</code> 关系必须要操作同一个原子变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>x</span><span class=p>{</span><span class=mi>0</span><span class=p>},</span> <span class=n>y</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>);</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>y</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span> <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread3</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>y</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>));</span>     <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>x</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// 5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>上述例子中，对于 <code>4</code> 在 <code>y</code> 非 <code>0</code> 时会退出循环，此时可能读取到 <code>2</code> 或 <code>3</code> 写入的值，如果是后者则无法保证 <code>2</code> 与 <code>4</code> 的同步关系，那么 <code>5</code> 的断言就可能会失败。不过，并非只有 <code>AcqRel</code> 才构成 <code>synchronizes-with</code> 关系，为此引入了 <code>Release Sequence</code> 概念。</p><p>针对某个原子变量 <code>M</code> 的 <code>Release</code> 操作 <code>A</code> 完成后，接下来 <code>M</code> 上可能还存在一连串其它操作，主要包括两类操作(可以使用任意内存序)：A) 同一线程上的写操作；B) 任意线程上的 <code>RMW</code> 操作。将这一连串操作称为，以 <code>Release</code> 操作 <code>A</code> 为首的 <code>Release Sequence</code> 。</p><p>那么上述的 <code>synchronizes-with</code> 修改为，如果一个 <code>Acquire</code> 操作读取到了同一个原子变量上 <code>Release</code> 写入值，或者以这个 <code>Release</code> 操作为首的 <code>Release Sequence</code> 写入的值，那么可以断定，这个 <code>Release</code> 操作 <code>synchronizes-with</code> 这个 <code>Acquire</code> 操作。</p><p>如下是一个简单示例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>flag</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread1</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span> <span class=c1>// 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>flag</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span> <span class=c1>// 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>expected</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>flag</span><span class=p>.</span><span class=n>compare_exchange_strong</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>std</span><span class=o>::</span><span class=n>memory_order_relaxed</span><span class=p>))</span> <span class=c1>// 3
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>expected</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>thread3</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>flag</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>2</span><span class=p>);</span> <span class=c1>// 4
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>assert</span><span class=p>(</span><span class=n>data</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=o>==</span> <span class=mi>42</span><span class=p>);</span> <span class=c1>// 5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><blockquote><p><code>bool compare_exchange_strong(T& expected, T desired, std::memory_order success, std::memory_order failure);</code></p><p>如果当前值等于 <code>expected</code> 时，用 <code>desired</code> 替换，返回 <code>true</code>；否则不做任何操作，同时将 <code>expected</code> 更新为当前值，并返回 <code>false</code> 。</p><p>另外，还有一个 <code>compare_exchange_weak()</code> 版本，允许在字段值和 <code>expected</code> 一样时返回 <code>false</code>，并且没有将字段值设置为 <code>desire</code> 的值，也就是 <code>spuriously fail</code>，某些平台上的性能会更好。</p></blockquote><p>步骤 <code>3</code> 会一直循环等待 <code>flag</code> 的从 <code>0</code> 变为 <code>1</code>，然后原子将 <code>flag</code> 设置为 <code>2</code>，此时的 <code>3</code> 属于 <code>2</code> 的 <code>Release Sequence</code>，当循环 <code>4</code> 退出时，实际上已经读到了 <code>3</code> 写入的值，也就是以 <code>Release</code> 操作 <code>2</code> 为首的 <code>Release Sequence</code> 写入的值，所以有 <code>2 synchronizes-with 4</code>，因此 <code>1 happens-before 5</code>，那么 <code>5</code> 处的断言不会失败。</p><p>注意，<code>3</code> 处的 <code>compare_exchange_strong</code> 的内存顺序是 <code>memory_order_relaxed</code>，所以 <code>2</code> 与 <code>3</code> 并不构成 <code>synchronizes-with</code> 关系. 也就是说, 当循环 <code>3</code> 退出时, 并不能保证 <code>thread2</code> 能读到 <code>data.at(0)</code> 为 <code>42</code>。但是 <code>3</code> 属于 <code>2</code> 的 <code>Release Sequence</code>, 当 <code>4</code> 以 <code>memory_order_acquire</code> 的内存顺序读到 <code>2</code> 的 <code>Release Sequence</code> 写入的值时, 可以与 <code>2</code> 构成 <code>Synchronizes With</code> 的关系。</p><a class=anchor id=consume></a><h2>Consume <a href=#consume aria-hidden=true>#</a></h2><p>对应了 <code>memory_order_consume</code> 内存序，是 <code>AcqRel</code> 模型的特例，同时会涉及到数据间的相互依赖关系，为此需要引入 <code>Carries Dependency</code> 和 <code>Dependency-Ordered Before</code> 两个新概念。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#原子操作>原子操作</a></li><li><a href=#内存序>内存序</a></li></ul></li><li><a href=#基本概念>基本概念</a><ul><li><a href=#modification-orders>Modification Orders</a></li><li><a href=#happens-before>Happens Before</a></li><li><a href=#其它>其它</a></li></ul></li><li><a href=#内存顺序>内存顺序</a><ul><li><a href=#sequencial-consistent>Sequencial Consistent</a></li><li><a href=#relaxed>Relaxed</a></li><li><a href=#acquire-release>Acquire Release</a></li><li><a href=#release-sequence>Release Sequence</a></li><li><a href=#consume>Consume</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>