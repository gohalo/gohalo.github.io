<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>GCC 安全编译选项 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，例如 ASLR、NX 等等，这里简单介绍一些常见的使用项。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>GCC 安全编译选项</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2018-04-09</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/c/cpp/ role=button>c/cpp</a></div></div><hr><div class=content><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，例如 ASLR、NX 等等，这里简单介绍一些常见的使用项。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，例如 NX ASLR PIE CANARY FORTIFY RELRO 等手段，存在 NX 的话就不能直接执行栈上的数据，存在 ASLR 的话各个系统调用的地址就是随机化的等等。</p><p>GCC 在生成代码时，实际上已经提供了一些针对安全相关的编译选项。</p><a class=anchor id=aslr-地址随机></a><h2>ASLR 地址随机 <a href=#aslr-%e5%9c%b0%e5%9d%80%e9%9a%8f%e6%9c%ba aria-hidden=true>#</a></h2><p>Address Space Layout Randomization, ASLR 地址空间布局随机化，该技术在 2005 年的 Kernel 2.6.12 版本中引入，会将进程的某些内存空间地址进行随机化来增大入侵者预测目的地址的难度，从而降低进程被成功入侵的风险。</p><p>当前 Linux、Windows 等主流操作系统都已经采用该项技术。</p><a class=anchor id=linux-aslr></a><h2>Linux ASLR <a href=#linux-aslr aria-hidden=true>#</a></h2><p>在 Linux 中会通过 <code>randomize_va_space</code> 文件配置相关的 ASLR 级别，总共包含了三个：</p><ul><li>0 没有随机化，也就是关闭 ASLR 。</li><li>1 保留的随机化，其中共享库、栈、mmap 以及 VDSO 将被随机化。</li><li>2 完全的随机化，在 1 的基础上，通过 brk() 分配的内存空间也将被随机化。</li></ul><p>可以通过如下方式查看或者修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># sysctl -n kernel.randomize_va_space
</span></span><span class=line><span class=cl># cat /proc/sys/kernel/randomize_va_space
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># sysctl -w kernel.randomize_va_space=0
</span></span><span class=line><span class=cl># echo 0 &gt; /proc/sys/kernel/randomize_va_space
</span></span></code></pre></div><p>看到这里列出的几项内存空间，很自然有两个地方十分值得注意，</p><p>那么对于 代码段(text) 和 数据段(data bss) 是否被随机化了？堆是否被随机化了？</p><a class=anchor id=pie></a><h2>PIE <a href=#pie aria-hidden=true>#</a></h2><p>多次运行上述程序会发现，随机化的只有堆和栈空间，而代码段和数据段是没有被随机化的。</p><blockquote><p>Position Independent Executable, PIE 是 gcc 提供的功能，需要连接到 <code>scrt1.o</code> ，然后可以像共享库一样在内存任何位置装载。而标准可执行程序需要固定的地址，并且只有被装载到这个地址时，程序才能正确执行。</p></blockquote><p>实际山，在 Linux 中是通过 PIE 机制来负责代码段和数据段的随机化工作，而不是 ASLR ，当然也同时需要 ASLR 同时开启才可以。</p><p>要开启 PIE 需要在使用 gcc 进行编译链接时添加 <code>-fpie</code> <code>-pie</code> 选项，这样使得在利用缓冲溢出和移动操作系统中存在的其它内存崩溃缺陷时采用面向返回的编程 (Return Oriented Programming) 方法变得难得多。</p><a class=anchor id=pie-vs-pic></a><h3>PIE VS. PIC <a href=#pie-vs-pic aria-hidden=true>#</a></h3><p>GCC 中的参数 PIE 和 PIC 都可以用来生成跟位置没有关系的 Symbol ，其中 A) PIE 用在可执行文件；B) PIC 用在共享库文件 。使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -o test test.c                // 默认不开启PIE
</span></span><span class=line><span class=cl>$ gcc -fpie -pie -o test test.c     // 开启PIE 强度为1
</span></span><span class=line><span class=cl>$ gcc -fPIE -pie -o test test.c     // 开启PIE 最高强度2
</span></span><span class=line><span class=cl>$ gcc -fpic -o test test.c          // 开启PIC 强度为1 不会开启PIE
</span></span><span class=line><span class=cl>$ gcc -fPIC -o test test.c          // 开启PIC 最高强度2 不会开启PIE
</span></span></code></pre></div><p>如果中间会生成 <code>.o</code> 文件，那么只需要添加 <code>-fPIC</code> 参数即可，只有在最终生成二进制文件时才需要添加 <code>-fPIE -pie</code> 参数。</p><a class=anchor id=堆随机化></a><h2>堆随机化 <a href=#%e5%a0%86%e9%9a%8f%e6%9c%ba%e5%8c%96 aria-hidden=true>#</a></h2><p>这里会有些复杂，因为 Linux 中堆空间可以通过 <code>mmap()</code> 以及 <code>brk()</code> 这两个系统调用完成的，而在不同的等级上面可能会只有部分接口被随机化。</p><p>一般谁使用 glibc 中的 <code>malloc()</code> 类接口分配内存，通过 <code>man 3 malloc</code> 可以发现其中有相关的介绍，也就是当超过了 <code>MMAP_THRESHOLD</code> 大小后会使用 <code>mmap()</code>，否则使用 <code>brk()</code> 申请。</p><p>如果当前 ASLR 等级为 1，那么当申请空间大于 128K 时，系统通过 <code>mmap()</code> 分配空间，得到的地址是随机的；而当申请空间小于 128K 时，系统是通过 <code>brk()</code> 进行分配的，得到的地址是静止的。</p><a class=anchor id=栈保护></a><h1>栈保护 <a href=#%e6%a0%88%e4%bf%9d%e6%8a%a4 aria-hidden=true>#</a></h1><p>针对的是一种很常见的栈溢出攻击，</p><a class=anchor id=不执行数据></a><h2>不执行数据 <a href=#%e4%b8%8d%e6%89%a7%e8%a1%8c%e6%95%b0%e6%8d%ae aria-hidden=true>#</a></h2><p>Linux 和 Windows 平台都支持对非可执行代码的保护，在 Linux 平台中被称为 NX (No-eXecute protect) ，在 Windows 中叫做 DEP (Data Execution Prevention) 。</p><p>其基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 ShellCode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令。</p><p><img alt="nx dep" src=images/gcc-nx-dep.jpg class="mx-auto d-block"></p><p>GCC 编译器默认开启了 NX 选项，可以通过添加 <code>-z execstack</code> 编译参数关闭 NX 选项。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -o test test.c                    // 默认开启 NX 保护
</span></span><span class=line><span class=cl>$ gcc -z execstack -o test test.c       // 禁用 NX 保护
</span></span><span class=line><span class=cl>$ gcc -z noexecstack -o test test.c     // 开启 NX 保护
</span></span></code></pre></div><a class=anchor id=栈溢出保护></a><h2>栈溢出保护 <a href=#%e6%a0%88%e6%ba%a2%e5%87%ba%e4%bf%9d%e6%8a%a4 aria-hidden=true>#</a></h2><p>当启用栈保护后，函数开始执行的时候会先往栈里插入 Cookie 信息，函数返回时会验证 Cookie 信息是否合法，非法则停止运行。</p><p>攻击者在覆盖返回地址的时候往往也会将 Cookie 信息给覆盖掉，导致栈保护检查失败进而阻止 ShellCode 的执行，在 Linux 中将 Cookie 信息称为 Canary 。</p><p>GCC 在 4.2 版本中添加了 <code>-fstack-protector</code> 和 <code>-fstack-protector-all</code> 编译参数以支持栈保护功能，4.9 新增了 <code>-fstack-protector-strong</code> 编译参数让保护的范围更广，在编译时可以控制是否开启栈保护以及程度，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -o test test.c                        // 默认不开启 Canary 保护
</span></span><span class=line><span class=cl>$ gcc -fno-stack-protector -o test test.c   // 禁用栈保护
</span></span><span class=line><span class=cl>$ gcc -fstack-protector -o test test.c      // 启用堆栈保护，只为局部变量中含有 char 数组的函数插入保护代码
</span></span><span class=line><span class=cl>$ gcc -fstack-protector-all -o test test.c  // 启用堆栈保护，为所有函数插入保护代码
</span></span></code></pre></div><a class=anchor id=fortify></a><h2>FORTIFY <a href=#fortify aria-hidden=true>#</a></h2><p>用于检查是否存在缓冲区溢出的错误，针对的是字符串、内存操作函数，例如 memcpy memset strcpy strcats snprintf 等等。</p><p>可以通过 <code>_FORTIFY_SOURCE</code> 宏定义检查的级别：</p><ul><li><code>_FORTIFY_SOURCE=1</code> 仅在编译时检查。</li><li><code>_FORTIFY_SOURCE=2</code> 在程序运行时也会检查，如果判断到缓冲区溢出则会直接终止程序。</li></ul><p>实际上 GCC 会到生成了一些附加代码，通过对数组大小的大小进行判断，从而达到防止缓冲区溢出的作用，使用示例如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -o test test.c                          // 默认不会开启检查
</span></span><span class=line><span class=cl>$ gcc -D_FORTIFY_SOURCE=1 -o test test.c      // 较弱的检查
</span></span><span class=line><span class=cl>$ gcc -D_FORTIFY_SOURCE=2 -o test test.c      // 较强的检查
</span></span></code></pre></div><a class=anchor id=relro></a><h1>RELRO <a href=#relro aria-hidden=true>#</a></h1><p>在 Linux 系统安全领域，数据可写的存储区就会是攻击的目标，尤其是存储函数指针的区域，所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处。</p><p>GCC 提供了一种 Read Only Relocation 的方法，其原理为是由 linker 指定 binary 的一块经过 dynamic linker 处理过 relocation 之后的区域为只读.</p><p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对 Global Offset Table, GOT 攻击。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcc -o test test.c                     // 默认是 Partial RELRO
</span></span><span class=line><span class=cl>gcc -z norelro -o test test.c          // 关闭
</span></span><span class=line><span class=cl>gcc -z lazy -o test test.c             // 部分开启 即Partial RELRO
</span></span><span class=line><span class=cl>gcc -z now -o test test.c              // 全部开启
</span></span></code></pre></div><p>如果 RELRO 为 &ldquo;Partial RELRO&rdquo;，说明对 GOT 表具有写权限。</p><a class=anchor id=动态库搜索路径></a><h1>动态库搜索路径 <a href=#%e5%8a%a8%e6%80%81%e5%ba%93%e6%90%9c%e7%b4%a2%e8%b7%af%e5%be%84 aria-hidden=true>#</a></h1><p>防止将一些动态库恶意替换，以达到攻击目的。</p><p>详细的加载过程可以参考 <code>man 1 ld</code> 中关于 <code>-rpath-link</code> 选项的介绍，比较关键的是使用 <code>--rpath</code> 或者 <code>LD_LIBRARY_PATH</code> 指定，分别是在编译阶段或者环境变量指定。</p><a class=anchor id=rpath-vs-runpath></a><h2>RPATH VS. RUNPATH <a href=#rpath-vs-runpath aria-hidden=true>#</a></h2><p>在通过 <code>rpath</code> 指定路径后，会在二进制文件中生成这两个参数，可以通过 <code>readelf -d main | grep -E (RPATH|RUNPATH)</code> 命令查看，老版本中使用的是 <code>RPATH</code> 新版本使用 <code>RUNPATH</code> 替换掉。</p><p>查找动态库的过程中，大致的顺序是 <code>RPATH</code> <code>LD_LIBRARY_PATH</code> <code>RUNPATH</code> ，所以，如果使用的是 <code>RPATH</code> 用户将无法进行调整，所以建议使用 <code>RUNPATH</code> ，这也是 gcc 的默认值。</p><p>可以通过 <code>-Wl,--disable-new-dtags</code> 表明使用 <code>RPATH</code> ；通过 <code>-Wl,--enable-new-dtags</code> 标示使用 <code>RUNPATH</code> 。</p><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><a class=anchor id=checksec></a><h2>checksec <a href=#checksec aria-hidden=true>#</a></h2><p>checksec 是一个 Bash 脚本，可以用来检查可执行文件属性，例如 <code>PIE</code> RELRO PaX Canaries, ASLR, Fortify Source等等属性。</p><p>详细可以查看官网 <a href=http://www.trapkit.de/tools/checksec.html>TrapKit CheckSec</a> 或者 <a href=https://github.com/slimm609/checksec.sh/>Github CheckSec</a> ，也可以直接使用 <a href=/reference/security/checksec>本地保存</a> 。</p><a class=anchor id=总结></a><h1>总结 <a href=#%e6%80%bb%e7%bb%93 aria-hidden=true>#</a></h1><p>各种安全选择的编译参数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- (OS) Linux开启地址随机化
</span></span><span class=line><span class=cl>echo 2 &gt; /proc/sys/kernel/randomize_va_space
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- (GCC) 栈保护，优先strong(4.9后gcc)，次优all
</span></span><span class=line><span class=cl>-fstack-protector-strong -fstack-protector-all
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- (GCC) GOT表保护，建议添加-z,now全部保护
</span></span><span class=line><span class=cl>-Wl, -z,relro
</span></span><span class=line><span class=cl>-Wl, -z,relro -z,now
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- (GCC) 不建议指定搜索路径，用户可以配置但是需要保护目录权限
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- (GCC) 堆栈不可执行
</span></span><span class=line><span class=cl>-Wl,-z,noexecstack
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- (GCC) 生成地址无关代码
</span></span><span class=line><span class=cl>-fPIC
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- (GCC) 随机化
</span></span><span class=line><span class=cl>-fPIE
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- (GCC) 检查缓冲区溢出(可选)
</span></span><span class=line><span class=cl>_FORTIFY_SOURCE=2
</span></span></code></pre></div><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p><a href=https://eklitzke.org/memory-protection-and-aslr>Memory Protection and ASLR on Linux</a> 关于 Linux 中 ASLR 机制的介绍。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#aslr-地址随机>ASLR 地址随机</a></li><li><a href=#linux-aslr>Linux ASLR</a></li><li><a href=#pie>PIE</a></li><li><a href=#堆随机化>堆随机化</a></li></ul></li><li><a href=#栈保护>栈保护</a><ul><li><a href=#不执行数据>不执行数据</a></li><li><a href=#栈溢出保护>栈溢出保护</a></li><li><a href=#fortify>FORTIFY</a></li></ul></li><li><a href=#relro>RELRO</a></li><li><a href=#动态库搜索路径>动态库搜索路径</a><ul><li><a href=#rpath-vs-runpath>RPATH VS. RUNPATH</a></li></ul></li><li><a href=#其它>其它</a><ul><li><a href=#checksec>checksec</a></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>