<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux 进程状态 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="Linux 中的进程在不同的阶段会通过其状态显示，一般来说会有 7 种，相当于一个状态机运行。
这里简单介绍，以及一些常见的特殊状态。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux 进程状态</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2017-02-16</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>Linux 中的进程在不同的阶段会通过其状态显示，一般来说会有 7 种，相当于一个状态机运行。</p><p>这里简单介绍，以及一些常见的特殊状态。</p><a class=anchor id=进程状态></a><h1>进程状态 <a href=#%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81 aria-hidden=true>#</a></h1><p>Linux是一个多用户，多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，而每个进程会有不同的状态，可以参考 <code>task_state_array[]@fs/proc/array.c</code> 中的内容。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static const char * const task_state_array[] = {
</span></span><span class=line><span class=cl>    &#34;R (running)&#34;,      /*   0 */
</span></span><span class=line><span class=cl>    &#34;S (sleeping)&#34;,     /*   1 */
</span></span><span class=line><span class=cl>    &#34;D (disk sleep)&#34;,   /*   2 */
</span></span><span class=line><span class=cl>    &#34;T (stopped)&#34;,      /*   4 */
</span></span><span class=line><span class=cl>    &#34;t (tracing stop)&#34;, /*   8 */
</span></span><span class=line><span class=cl>    &#34;X (dead)&#34;,         /*  16 */
</span></span><span class=line><span class=cl>    &#34;Z (zombie)&#34;,       /*  32 */
</span></span><span class=line><span class=cl>};
</span></span></code></pre></div><p>其中进程的转换过程如下所示。</p><p><img alt=process src=images/process-status-transform.gif class="mx-auto d-block"></p><a class=anchor id=r-task_running可执行状态></a><h5>R (TASK_RUNNING，可执行状态) <a href=#r-task_running%e5%8f%af%e6%89%a7%e8%a1%8c%e7%8a%b6%e6%80%81 aria-hidden=true>#</a></h5><p>只有在该状态的进程才可能在 CPU 上运行，这些进程的 <code>struct task_struct</code> 会被放入对应 CPU 的可执行队列中，进程调度器会从可执行队列中分别选择一个进程在该 CPU 上运行。</p><a class=anchor id=s-task_interruptible可中断的睡眠状态></a><h5>S (TASK_INTERRUPTIBLE，可中断的睡眠状态) <a href=#s-task_interruptible%e5%8f%af%e4%b8%ad%e6%96%ad%e7%9a%84%e7%9d%a1%e7%9c%a0%e7%8a%b6%e6%80%81 aria-hidden=true>#</a></h5><p>在等待某事件的发生 (例如 socket 连接、信号量等) 而被挂起，对应的 TCB 被放入对应事件的等待队列中，当事件发生时 (由外部中断触发或由其它进程触发)，对应的等待队列中的一个或多个进程将被唤醒。</p><a class=anchor id=d-task_uninterruptible不可中断的睡眠状态></a><h5>D (TASK_UNINTERRUPTIBLE，不可中断的睡眠状态) <a href=#d-task_uninterruptible%e4%b8%8d%e5%8f%af%e4%b8%ad%e6%96%ad%e7%9a%84%e7%9d%a1%e7%9c%a0%e7%8a%b6%e6%80%81 aria-hidden=true>#</a></h5><p>进程同样处于睡眠状态，但该进程是不可中断的，也就是进程不响应异步信号，即使使用 <code>kill -9</code> 信号。</p><a class=anchor id=t-task_stopped-or-task_traced暂停状态或跟踪状态></a><h5>T (TASK_STOPPED or TASK_TRACED，暂停状态或跟踪状态) <a href=#t-task_stopped-or-task_traced%e6%9a%82%e5%81%9c%e7%8a%b6%e6%80%81%e6%88%96%e8%b7%9f%e8%b8%aa%e7%8a%b6%e6%80%81 aria-hidden=true>#</a></h5><p>向进程发送一个 SIGSTOP 信号，它就会因响应该信号而进入该状态，其中 SIGSTOP 与 SIGKILL 信号一样，是强制的，不允许用户进程通过 signal 系列的系统调用重新设置对应的信号处理函数。</p><a class=anchor id=特殊状态></a><h1>特殊状态 <a href=#%e7%89%b9%e6%ae%8a%e7%8a%b6%e6%80%81 aria-hidden=true>#</a></h1><p>子进程是通过父进程创建的，子进程的结束和父进程的运行是一个异步过程，父进程永远无法预测子进程到底什么时候结束。当一个进程完成它的工作终止之后，它的父进程需要调用 <code>wait()</code> 或者 <code>waitpid()</code> 取得子进程的终止状态。</p><p>当父子进程在不同时间点退出时，那么就可能会进入到异常状态。</p><a class=anchor id=孤儿进程></a><h3>孤儿进程 <a href=#%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b aria-hidden=true>#</a></h3><p>一个父进程退出，相应的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。</p><p>孤儿进程将被 <code>init</code> 进程所收养，并由 <code>init</code> 进程收集它们的完成状态，也就是说，孤儿进程没有危害，最终仍然回被 <code>init</code> 回收。</p><a class=anchor id=僵尸进程></a><h3>僵尸进程 <a href=#%e5%83%b5%e5%b0%b8%e8%bf%9b%e7%a8%8b aria-hidden=true>#</a></h3><p>一个进程使用 <code>fork</code> 创建子进程，如果子进程退出后父进程没有调用 <code>wait</code> 或 <code>waitpid</code> 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，仍然占用进程表，显示为 <code>defunct</code> 状态。</p><p>可以通过重启或者杀死父进程解决。</p><a class=anchor id=示例></a><h2>示例 <a href=#%e7%a4%ba%e4%be%8b aria-hidden=true>#</a></h2><p>在 Linux 中，进程退出时，内核释放该进程所有的部分资源，包括打开的文件、占用的内存等。但仍为其保留一定的信息，包括进程号 PID、退出的状态、运行时间等，直到父进程通过 <code>wait()</code> 或 <code>waitpid()</code> 来获取时才释放。</p><p>如果父进程一直存在，那么该进程的进程号就会一直被占用，而系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p><p>如下是两个示例，分别为孤儿进程和僵尸进程。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>pid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fpid</span> <span class=o>&amp;</span><span class=n>lt</span><span class=p>;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;error in fork!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// child process.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process create, pid: %d</span><span class=se>\t</span><span class=s>ppid:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=nf>getpid</span><span class=p>(),</span><span class=nf>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>   <span class=c1>// sleep for 5s until father process exit.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process exit, pid: %d</span><span class=se>\t</span><span class=s>ppid:%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=nf>getpid</span><span class=p>(),</span><span class=nf>getppid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;father process create</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>sleep</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;father process exit</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>//static void sig_child(int signo)
</span></span></span><span class=line><span class=cl><span class=c1>//{
</span></span></span><span class=line><span class=cl><span class=c1>//     pid_t        pid;
</span></span></span><span class=line><span class=cl><span class=c1>//     int        stat;
</span></span></span><span class=line><span class=cl><span class=c1>//     while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &amp;gt; 0)
</span></span></span><span class=line><span class=cl><span class=c1>//            printf(&#34;child %d terminated.\n&#34;, pid);
</span></span></span><span class=line><span class=cl><span class=c1>//}
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>pid_t</span> <span class=n>fpid</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// signal(SIGCHLD, sig_child);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>fpid</span> <span class=o>=</span> <span class=nf>fork</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fpid</span> <span class=o>&amp;</span><span class=n>lt</span><span class=p>;</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;error in fork!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>fpid</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;child process(%d)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=nf>getpid</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=nf>exit</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;father process</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>sleep</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>system</span><span class=p>(</span><span class=s>&#34;ps -o pid,ppid,state,tty,command | grep defunct | grep -v grep&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>第一个是孤儿进程，第二次输出时其父进程 PID 变成了 <code>init(PID=1)</code>；第二个是僵尸进程，进程退出时会产生 <code>SIGCHLD</code> 信号，父进程可以通过捕获该信号进行处理。</p><a class=anchor id=task_stopped></a><h2>TASK_STOPPED <a href=#task_stopped aria-hidden=true>#</a></h2><p><code>TASK_STOPPED</code>，进程终止，通常是由于向进程发送了 <code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code>、<code>SIGTTOU</code> 信号，此时可以通过 <code>kill -9(SIGKILL) pid</code> 尝试杀死进程，如果不起作用则 <code>kill -18 pid</code> ，也就是发个 <code>SIGCONT</code> 信号过去。</p><a class=anchor id=孤儿进程接管></a><h1>孤儿进程接管 <a href=#%e5%ad%a4%e5%84%bf%e8%bf%9b%e7%a8%8b%e6%8e%a5%e7%ae%a1 aria-hidden=true>#</a></h1><p>如上所述，所谓的孤儿进程是指，当父进程被 <code>kill</code> 掉，其子进程就会成为孤儿进程 <code>Orphaned Process</code>，并被 <code>init(PID=1)</code> 所接管。</p><p>那么，孤儿进程如何被接管的？</p><p>在 Linux 内核中，有如下的代码 <a href=https://github.com/torvalds/linux/blob/eae21770b4fed5597623aad0d618190fa60426ff/kernel/exit.c#L479>Kernel find_new_reaper()</a> ，其开头的注释摘抄如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/*
</span></span><span class=line><span class=cl> * When we die, we re-parent all our children, and try to:
</span></span><span class=line><span class=cl> * 1. give them to another thread in our thread group, if such a member exists
</span></span><span class=line><span class=cl> * 2. give it to the first ancestor process which prctl&#39;d itself as a
</span></span><span class=line><span class=cl> *    child_subreaper for its children (like a service manager)
</span></span><span class=line><span class=cl> * 3. give it to the init process (PID 1) in our pid namespace
</span></span><span class=line><span class=cl> */
</span></span></code></pre></div><p>也就是说，接管分三步：A) 找到相同线程组里其他可用的线程；B) 如果没有找到则进行第二步；C) 最后交由 <code>PID=1</code> 的进程管理。</p><a class=anchor id=subreaper></a><h2>SubReaper <a href=#subreaper aria-hidden=true>#</a></h2><p>当一个进程被标记为 <code>SubReaper</code> 后，这个进程所创建的所有子进程，包括子进程的子进程，都将被标记拥有一个 <code>SubReaper</code> 。</p><p>当某个进程成为孤儿进程时，会沿着它的进程树向祖先进程找一个最近的是 <code>SubReaper</code> 且运行着的进程，这个进程将会接管这个孤儿进程。</p><a class=anchor id=tinit></a><h2>tinit <a href=#tinit aria-hidden=true>#</a></h2><p>其功能类似于 <code>init</code> 进程，实际上就是模拟 <code>init</code> 进程的僵尸进程回收，一般用于容器中，用于回收容器中退出的进程。</p><a class=anchor id=uninterruptable></a><h1>Uninterruptable <a href=#uninterruptable aria-hidden=true>#</a></h1><p>Linux 中有一个 <code>uninterruptable</code> 状态，此时的进程不接受任何的信号，包括了 <code>kill -9</code> ，通常是在等待 IO，比如磁盘、网络、其它外设等。如果 IO 设备出现了问题，或者 IO 响应慢，那么就会有很多进程处于 D 状态。</p><p>当出现了这类的进程后，要么等待 IO 设备满足请求，要么重启系统。</p><p>所以，为什么会出现这一状态？为什么内核不能正常回收？</p><a class=anchor id=正常-sleep></a><h2>正常 Sleep <a href=#%e6%ad%a3%e5%b8%b8-sleep aria-hidden=true>#</a></h2><p>一般来说，当一个进程在系统调用中正常休眠时，它会收到异步的信号，例如 <code>SIGINT</code>，此时会做如下的处理：</p><ol><li>系统调用立即返回，并返回 <code>-EINTR</code> 错误码；</li><li>设置的信号回调函数被调用；</li><li>如果进程仍然在运行，那么会获取到系统调用返回的错误码，并决定是否继续运行。</li></ol><p>也就是说，正常的 Sleep 允许进程收到信号后做一些清理操作。</p><a class=anchor id=何时出现></a><h2>何时出现 <a href=#%e4%bd%95%e6%97%b6%e5%87%ba%e7%8e%b0 aria-hidden=true>#</a></h2><p>进程会通过系统调用来调用 IO 设备，正常来说这一过程很快，用户几乎不会察觉，但是当 IO 设备异常或者设备驱动有 bug ，就可能会出现上述的状态。</p><p>例如通过 <code>read()</code> 系统调用读取磁盘上的数据，如果是机械磁盘，那么磁盘需要寻道、移动读针、读取数据，然后才会返回结果，那么在读取数据的过程中就处于 uninterruptable 状态。</p><p>正常这一过程很快，用户几乎无法感知。</p><a class=anchor id=为什么></a><h2>为什么 <a href=#%e4%b8%ba%e4%bb%80%e4%b9%88 aria-hidden=true>#</a></h2><p>这主要是因为，IO 请求比较特殊，它必须按照固定的顺序执行，甚至有些时序的要求，如果操作不是原子性的，那么就可能导致 IO 设备异常，可能会无法响应下次请求，可能会被死锁，这都跟具体的设备有关。</p><p>一个好的设备驱动需要处理这些异常场景，除非出现了 bug ，也就是说只有在一些极端场景下才会出现。</p><a class=anchor id=killable></a><h2>KillAble <a href=#killable aria-hidden=true>#</a></h2><p>在 2.6.25 版本中引入了新的 <code>TASK_KILLABLE</code> 状态，会屏蔽普通信号，但可以响应强制信号，不过这个同样要依赖设备驱动的实现，详细可以参考 <a href=https://lwn.net/Articles/288056/>TASK_KILLABLE</a> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#进程状态>进程状态</a><ul><li></li></ul></li><li><a href=#特殊状态>特殊状态</a><ul><li></li><li><a href=#示例>示例</a></li><li><a href=#task_stopped>TASK_STOPPED</a></li></ul></li><li><a href=#孤儿进程接管>孤儿进程接管</a><ul><li><a href=#subreaper>SubReaper</a></li><li><a href=#tinit>tinit</a></li></ul></li><li><a href=#uninterruptable>Uninterruptable</a><ul><li><a href=#正常-sleep>正常 Sleep</a></li><li><a href=#何时出现>何时出现</a></li><li><a href=#为什么>为什么</a></li><li><a href=#killable>KillAble</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>