<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Datafusion 使用简介 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="基本上分成了 OLAP Batch Streaming
算子落盘 # 存在 spill_count 指标， spill_record_batches read_spill_as_stream
SQL # SQL 解析依赖 SQLParser 实现，在 datafusion::sql 中将 sqlparser 重新导出，有也就意味着如下两种使用方式相同。
use datafusion::sql::sqlparser::parser::ParserError; use sqlparser::parser::ParserError; 而 DataFusion 是在 SQLParser 基础上的定制化开发，可以根据场景配置不同的方言 Dialect，常见的如 MySQL、PostgreSQL 等。
Plan # LogicalPlan # 逻辑执行计划。
ExecutionPlan # 物理执行计划节点，支持流式、并行读取数据，包含了 Projection Filter Limit 算子，当执行 execute() 方法时，只是将物理执行计划生成 RecordBatchStream 算子，形成数据流算子树，当执行 collect() 操作时才开始真正的数据流动。
会通过 DefaultPhysicalPlanner 生成执行计划，也可以通过实现 PhysicalPlanner 特征扩展。最终会通过 create_physical_plan 方法将逻辑计划转换为物理计划，每个节点是 ExecutionPlan 类型。
执行计划树时，会从根节点开始执行 execute 方法，这里不会开始处理数据，而是将物理算子转换为 RecordBatchStream 类型，只有当执行类似 collect 时才会真正执行。
TableProvider # 用于自定义表或者数据源，其中核心的是 scan 函数"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Datafusion 使用简介</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2024-10-16</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/warehouse/ role=button>warehouse</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/rust/ role=button>rust</a></div></div><hr><div class=content><p>基本上分成了 OLAP Batch Streaming</p><a class=anchor id=算子落盘></a><h1>算子落盘 <a href=#%e7%ae%97%e5%ad%90%e8%90%bd%e7%9b%98 aria-hidden=true>#</a></h1><p>存在 spill_count 指标，
spill_record_batches
read_spill_as_stream</p><a class=anchor id=sql></a><h1>SQL <a href=#sql aria-hidden=true>#</a></h1><p>SQL 解析依赖 <a href=https://github.com/apache/datafusion-sqlparser-rs>SQLParser</a> 实现，在 <code>datafusion::sql</code> 中将 <code>sqlparser</code> 重新导出，有也就意味着如下两种使用方式相同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>datafusion</span>::<span class=n>sql</span>::<span class=n>sqlparser</span>::<span class=n>parser</span>::<span class=n>ParserError</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>sqlparser</span>::<span class=n>parser</span>::<span class=n>ParserError</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>而 DataFusion 是在 SQLParser 基础上的定制化开发，可以根据场景配置不同的方言 <code>Dialect</code>，常见的如 MySQL、PostgreSQL 等。</p><a class=anchor id=plan></a><h1>Plan <a href=#plan aria-hidden=true>#</a></h1><a class=anchor id=logicalplan></a><h2>LogicalPlan <a href=#logicalplan aria-hidden=true>#</a></h2><p>逻辑执行计划。</p><a class=anchor id=executionplan></a><h2>ExecutionPlan <a href=#executionplan aria-hidden=true>#</a></h2><p>物理执行计划节点，支持流式、并行读取数据，包含了 Projection Filter Limit 算子，当执行 <code>execute()</code> 方法时，只是将物理执行计划生成 <code>RecordBatchStream</code> 算子，形成数据流算子树，当执行 <code>collect()</code> 操作时才开始真正的数据流动。</p><p>会通过 <code>DefaultPhysicalPlanner</code> 生成执行计划，也可以通过实现 <code>PhysicalPlanner</code> 特征扩展。最终会通过 <code>create_physical_plan</code> 方法将逻辑计划转换为物理计划，每个节点是 <code>ExecutionPlan</code> 类型。</p><p>执行计划树时，会从根节点开始执行 <code>execute</code> 方法，这里不会开始处理数据，而是将物理算子转换为 <code>RecordBatchStream</code> 类型，只有当执行类似 <code>collect</code> 时才会真正执行。</p><a class=anchor id=tableprovider></a><h2>TableProvider <a href=#tableprovider aria-hidden=true>#</a></h2><p>用于自定义表或者数据源，其中核心的是 <code>scan</code> 函数</p><p>JanKaul/iceberg-rust</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#5520 --&gt; MemTable 支持 insert into
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pub trait TableProvider: Sync + Send {
</span></span><span class=line><span class=cl>    async fn scan(
</span></span><span class=line><span class=cl>        &amp;self,
</span></span><span class=line><span class=cl>        state: &amp;dyn Session,
</span></span><span class=line><span class=cl>        projection: Option&lt;&amp;Vec&lt;usize&gt;&gt;,
</span></span><span class=line><span class=cl>        filters: &amp;[Expr],
</span></span><span class=line><span class=cl>        limit: Option&lt;usize&gt;,
</span></span><span class=line><span class=cl>    ) -&gt; Result&lt;Arc&lt;dyn ExecutionPlan&gt;&gt;;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>可以返回自定义的 ExecutionPlan ，或者借助类似 ParquetExecBuilder 这种方式
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>示例参考
</span></span><span class=line><span class=cl>datafusion-example/examples/custom_datasource.rs
</span></span><span class=line><span class=cl>datafusion/core/src/datasourc/physical_plan/parquet.rs
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>datafusion-example/examples/dataframe_output.rs    通过建表语句输出
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>datafusion/core/src/datasource/file_format/csv.rs  数据读取
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>docs/source/library-user-guide/custom-table-providers.md
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Table::new()
</span></span><span class=line><span class=cl> |-Table::new_with_options()
</span></span><span class=line><span class=cl>   |-storage::parse_uri()
</span></span><span class=line><span class=cl>   |-Table::load_configs() 加载配置
</span></span><span class=line><span class=cl>     |-Storage::new()
</span></span><span class=line><span class=cl>     |-Storage::get_file_data() 读取并解析 .hoodie/hoodie.properties 文件中的内容
</span></span><span class=line><span class=cl>     |-HudiConfigs::new() 简单对 HashMap 的封装
</span></span><span class=line><span class=cl>     |-Table::validate_configs()
</span></span></code></pre></div><p>ObjectStore 最初由 Influx 编写，后来贡献给了 Arrow ，示例可以参考 alamb/rust_object_store_demo 中的实现。</p><a class=anchor id=recordbatch></a><h1>RecordBatch <a href=#recordbatch aria-hidden=true>#</a></h1><p>这是 Arrow 内存计算用的结构体，方便通过 SIMD 进行加速，实现在 <code>arrow-array</code> 包中的 <code>src/record_batch.rs</code> 文件中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>pub type SchemaRef = Arc&lt;Schema&gt;;
</span></span><span class=line><span class=cl>pub struct RecordBatch {
</span></span><span class=line><span class=cl>    schema: SchemaRef,
</span></span><span class=line><span class=cl>    columns: Vec&lt;Arc&lt;dyn Array&gt;&gt;,
</span></span><span class=line><span class=cl>    row_count: usize, // 单独保存，同时可以应对不存在列的场景
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>pub type ArrayRef = Arc&lt;dyn Array&gt;;
</span></span></code></pre></div><p>常见操作如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let a: Arc&lt;dyn Array&gt; = batch.column(0);   // 获取第一列数据
</span></span><span class=line><span class=cl>ensure!(a.data_type() == DataType::Int32); // 确保数据类型正确
</span></span><span class=line><span class=cl>// 获取真正的底层数据
</span></span><span class=line><span class=cl>let a: &amp;Int32Array = a.as_any().downcast_ref().context(&#34;type mismatch&#34;)?;
</span></span></code></pre></div><p>Arrow Columnar Format</p><p>nvim-dap
lldb</p><p>SIMD优化是在Arrow库中实现的，不过当前依赖 nightly 才可以，关于 Rust 中的 SIMD 实现可以参考
Rust语言中SIMD计算加速指令的使用
https://rustmagazine.github.io/rust_magazine_2021/chapter_8/hw-rust-simd.html</p><p>针对类型不错的介绍
https://github.com/skyzh/type-exercise-in-rust</p><p>https://github.com/jankaul/iceberg-rust</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cargo fmt --all -- --check
</span></span><span class=line><span class=cl>cargo tarpaulin --engine llvm --no-dead-code --no-fail-fast --all-features --workspace -o html
</span></span></code></pre></div><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><p>在源码中有很多不错的压测、示例代码可供参考：</p><ul><li><code>benchmarks</code> 保存了很多不错的测试用例，尤其支持不同版本的性能压测对比。</li><li><code>datafusion-examples</code> 很多入门级别的示例，可以根据不同的使用场景参考。</li><li><code>datafusion/core/tests/data</code> 测试用的数据，同时通过 <code>test-utils</code> 包可以很容易加载。</li></ul><p>其中测试数据可以通过类似如下方式加载，注意，需要通过 <code>export DATAFUSION_TEST_DATA=/your/path/datafusion/core/tests/data</code> 环境变量指定路径。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>datafusion</span>::<span class=n>common</span>::<span class=n>test_util</span>::<span class=n>datafusion_test_data</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cp>#[tokio::main]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>async</span><span class=w> </span><span class=k>fn</span> <span class=nf>main</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=p>()</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>testdata</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>datafusion_test_data</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ctx</span><span class=p>.</span><span class=n>register_csv</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=s>&#34;ordered_table&#34;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;</span><span class=si>{testdata}</span><span class=s>/window_1.csv&#34;</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>CsvReadOptions</span>::<span class=n>new</span><span class=p>().</span><span class=n>file_sort_order</span><span class=p>(</span><span class=fm>vec!</span><span class=p>[</span><span class=fm>vec!</span><span class=p>[</span><span class=n>col</span><span class=p>(</span><span class=s>&#34;ts&#34;</span><span class=p>).</span><span class=n>sort</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)]]),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>.</span><span class=k>await</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><a class=anchor id=datasource></a><h1>DataSource <a href=#datasource aria-hidden=true>#</a></h1><p>存在 <code>FileFormat</code> 定义了当前支持的文件格式，包括了 <code>Parquet</code> <code>CSV</code> <code>JSON</code> <code>AVRO</code> 等，底层通过 <code>ObjectStore</code> 实现。</p><p>各种格式会实现 <code>infer_schema</code> 函数，用来推断各种数据格式，默认会读取前 1k 行数据进行推断。</p><a class=anchor id=执行器></a><h1>执行器 <a href=#%e6%89%a7%e8%a1%8c%e5%99%a8 aria-hidden=true>#</a></h1><p><code>DataFrame</code> 类似于 <code>Saprk</code> 和 <code>Pandas</code> 的实现，是带有表结构 <code>Schema</code> 的二维数据，后面可以跟很多类似 <code>filter</code> <code>select</code> <code>aggregate</code> <code>limit</code> 的算子，注意，其是 <code>Lazy</code> 执行的，这样使用时可以作额外的优化，常见的执行方式有如下几种：</p><ul><li><code>collect</code> 执行查询同时将结果缓存到 <code>Vec&lt;RecordBatch></code> 中。</li><li><code>execute_stream</code> 流式执行，会返回 <code>SendableRecordBatchStream</code> 并在后续调用 <code>next()</code> 时执行。</li><li><code>cache</code> 执行并将结果缓存到内存中的 <code>DataFrame</code> 对象。</li></ul><p>基于 Rust 中 Async 的实现也天然具有了 <code>Stream</code> 流式的特性，当然对于物化算子 (也被称为 Pipeline Breaker，例如 Sort、Hash 等) 需要阻塞等待所有的输入数据，然后才会有具体的输出，大部分算子都是流式读取 <code>RecordBatch</code> 并输出 <code>RecordBatch</code> 变量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SessionContext.sql
</span></span><span class=line><span class=cl> |-SessionContext.sql_with_option()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>DataFrame.collect() == 都是在 PhysicalPlan 中执行
</span></span><span class=line><span class=cl> |-DataFrame.task_ctx()
</span></span><span class=line><span class=cl> |-DataFrame.create_physical_plan()
</span></span><span class=line><span class=cl> |-collect() == ExecutionPlan 的实现，入参是上述的返回值
</span></span><span class=line><span class=cl>   |-execute_stream()
</span></span><span class=line><span class=cl>   |-common::collect()
</span></span><span class=line><span class=cl>     |-SendableRecordBatchStream.try_collect()
</span></span><span class=line><span class=cl>       |-TryCollect::new() 这里会将上述的流进行收集
</span></span></code></pre></div><p>通过 SessionContext 维护用户与真正引擎之间的接口，支持从数据源创建 DataFrame、注册表 (后续可以通过 SQL 使用)、执行 SQL 等。另外，除了可以通过 SQL 执行之外，还可以使用类似 <code>col</code> <code>lit</code> <code>alias</code> 的接口生成逻辑执行计划。</p><p>执行时还会创建 TaskContext 对象，维护了 SessionID TaskID 相关信息。</p><a class=anchor id=cpu-io-bound></a><h2>CPU IO Bound <a href=#cpu-io-bound aria-hidden=true>#</a></h2><p><code>DataFrame</code> 的运行态使用的是 <code>Tokio</code> 包，而在官方文档 <a href>CPU-bound tasks and blocking code</a> 中有如下的介绍。</p><p>在 <a href=https://thenewstack.io/using-rustlangs-async-tokio-runtime-for-cpu-bound-tasks>Using Rustlang&rsquo;s Async Tokio Runtime for CPU-Bound Tasks</a> 文章中有详细的介绍，其实现也比较简单，基本原理就是通过 <code>DedicatedExecutor</code> 将 IO 和 CPU 任务分开执行，同时保留了对 Async 语义的支持。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><ul><li><a href=https://github.com/apache/datafusion-ballista>Ballista</a> 分布式查询引擎，设计灵感来自 SparkSQL 但是基于技术栈不同。</li><li><a href=https://github.com/ArroyoSystem/arroyo>Arroyo</a> 流处理引擎，类似于 Flink 实现。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#算子落盘>算子落盘</a></li><li><a href=#sql>SQL</a></li><li><a href=#plan>Plan</a><ul><li><a href=#logicalplan>LogicalPlan</a></li><li><a href=#executionplan>ExecutionPlan</a></li><li><a href=#tableprovider>TableProvider</a></li></ul></li><li><a href=#recordbatch>RecordBatch</a></li><li><a href=#其它>其它</a></li><li><a href=#datasource>DataSource</a></li><li><a href=#执行器>执行器</a><ul><li><a href=#cpu-io-bound>CPU IO Bound</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>