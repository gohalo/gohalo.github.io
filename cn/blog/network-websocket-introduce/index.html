<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Websocket 协议详解 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="对于 HTTP 协议，通信只能由客户端发起，服务端无法主动向客户端推送信息，通过轮询方式就很消耗资源。
为了达到实时响应以及良好的用户体验，通常通过 AJAX 实现异步无刷新请求功能，不过只能在浏览器异步请求服务器，也就是拉取；而推送一般通过类似 Comet 的技术，略显复杂。
而 WebSocket 是一种全新的协议，将 TCP 的 Socket 应用在了 web page 上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工工作模式。
这里详细介绍其实现。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Websocket 协议详解</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2020-07-25</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/network/ role=button>network</a></div></div><hr><div class=content><p>对于 HTTP 协议，通信只能由客户端发起，服务端无法主动向客户端推送信息，通过轮询方式就很消耗资源。</p><p>为了达到实时响应以及良好的用户体验，通常通过 AJAX 实现异步无刷新请求功能，不过只能在浏览器异步请求服务器，也就是拉取；而推送一般通过类似 Comet 的技术，略显复杂。</p><p>而 WebSocket 是一种全新的协议，将 TCP 的 Socket 应用在了 web page 上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工工作模式。</p><p>这里详细介绍其实现。</p><p><img alt="websocket logo" src=images/logo.jpg class="mx-auto d-block"></p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>WebSocket 协议的标准为 <a href=https://tools.ietf.org/html/rfc6455>RFC6455</a> ，相比其它协议 (例如 HTTP) 来说，要简单很多。该协议会借用 HTTP 协议的 <code>101 switch protocol</code> 来达到协议转换的，从 HTTP 协议切换成 WebSocket 通信协议，而且没有同源的限制，底层基于 TCP 协议，客户端可以与任意服务器通信，协议标识符是 ws (如果加密，则为wss)。</p><p>该协议是基于 Frame 而非 Stream ，也就是说，数据的传输不是像传统的流式读写一样按字节发送，而是采用一帧一帧的 Frame，并且每个 Frame 都定义了严格的数据结构，因此所有的信息就在这个 Frame 载体中。</p><p>默认情况下，WebSocket 协议使用 80 端口建立普通连接，加密的 TLS 连接默认使用 443 端口，与 HTTP 相同。</p><a class=anchor id=控制帧-vs-数据帧></a><h2>控制帧 VS. 数据帧 <a href=#%e6%8e%a7%e5%88%b6%e5%b8%a7-vs-%e6%95%b0%e6%8d%ae%e5%b8%a7 aria-hidden=true>#</a></h2><p>控制帧用来标识 WebSocket 的状态信息、控制分片、关闭连接等等。如果有 Payload 数据那么必须要小于 125 字节，而且不允许被分片，目前的话，包括了 Opcode <code>0x08</code> 关闭连接、<code>0x09</code> Ping 帧、<code>0x0A</code> Pong 帧。</p><p>而数据帧是用来真正发送数据，包括了 Opcode 为是 <code>0x01</code> UTF-8 文本和 <code>0x02</code> 二进制数据两种。</p><a class=anchor id=服务器握手响应></a><h2>服务器握手响应 <a href=#%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%8f%a1%e6%89%8b%e5%93%8d%e5%ba%94 aria-hidden=true>#</a></h2><p>首先需要浏览器主动发起一个 HTTP 请求，每一个响应头之间用 <code>\r\n</code> 间隔，最后再放一个 <code>\r\n</code> 空行，请求内容大致如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GET /YOUR/URI HTTP/1.1
</span></span><span class=line><span class=cl>Host: localhost:9999
</span></span><span class=line><span class=cl>Connection: Upgrade
</span></span><span class=line><span class=cl>Upgrade: websocket
</span></span><span class=line><span class=cl>Sec-WebSocket-Version: 13
</span></span><span class=line><span class=cl>Sec-WebSocket-Key: UjxPJpGjxC4JH5+0znrYBg==
</span></span><span class=line><span class=cl>Sec-WebSocket-Protocol: chat, superchat
</span></span></code></pre></div><p>其中包含了几个关键的字段：</p><ul><li><code>Upgrade</code> 内容为 websocket，该字段标示改变 HTTP 协议版本或换用其他协议，这里是换用了 websocket 协议。</li><li><code>Sec-WebSocket-Key</code> 一个随机经过 Base64 编码字符串 (16字节)，像密钥一样用于服务器和客户端的握手过程。</li></ul><p>当服务器接收到来自客户端的 upgrade 请求，就将请求头中的 <code>Sec-WebSocket-Key</code> 字段提取出来，追加一个固定的 <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 字符串，并进行 <code>SHA-1</code> 加密，然后再次经过 Base64 编码生成一个新的 key，作为响应头中的 <code>Sec-WebSocket-Accept</code> 字段的内容返回给浏览器。</p><p>浏览器接收到来自服务器的响应，便会解析响应中的 <code>Sec-WebSocket-Accept</code> 字段，与自己加密编码后的串进行匹配，一旦匹配成功，便可以准备建立 WebSocket 链接了。</p><p>然后服务器响应类似如下的 HTTP 报文。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>HTTP/1.1 101 Switching Protocols
</span></span><span class=line><span class=cl>Upgrade: websocket
</span></span><span class=line><span class=cl>Connection: Upgrade
</span></span><span class=line><span class=cl>Sec-WebSocket-Accept: 4O33ZinyFxWKCaxf7T4yCA==
</span></span></code></pre></div><p>另外，客户端向服务器发起握手请求的 header 中，可以通过 <code>Sec-WebSocket-Protocol</code> 字段指定一个子协议，服务器在建立连接的响应头中包含同样的字段，内容就是选择的子协议之一。</p><p>还可以使用 <code>Sec-WebSocket-Extensions</code> 头部进行扩展。</p><a class=anchor id=协议></a><h1>协议 <a href=#%e5%8d%8f%e8%ae%ae aria-hidden=true>#</a></h1><p>接下来的所有数据传输就是通过 WebSocket 协议了，传输数据都以 Frame 形式实现，类似于 TCP/UDP 协议中的报文段 Segment ，也就是将数据进行了分割。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>  0                   1                   2                   3
</span></span><span class=line><span class=cl>  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span></span><span class=line><span class=cl> +-+-+-+-+-------+-+-------------+-------------------------------+
</span></span><span class=line><span class=cl> |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
</span></span><span class=line><span class=cl> |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
</span></span><span class=line><span class=cl> |N|V|V|V|       |S|             |   (if payload len==126/127)   |
</span></span><span class=line><span class=cl> | |1|2|3|       |K|             |                               |
</span></span><span class=line><span class=cl> +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
</span></span><span class=line><span class=cl> |     Extended payload length continued, if payload len == 127  |
</span></span><span class=line><span class=cl> + - - - - - - - - - - - - - - - +-------------------------------+
</span></span><span class=line><span class=cl> |                               |Masking-key, if MASK set to 1  |
</span></span><span class=line><span class=cl> +-------------------------------+-------------------------------+
</span></span><span class=line><span class=cl> | Masking-key (continued)       |          Payload Data         |
</span></span><span class=line><span class=cl> +-------------------------------- - - - - - - - - - - - - - - - +
</span></span><span class=line><span class=cl> :                     Payload Data continued ...                :
</span></span><span class=line><span class=cl> + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
</span></span><span class=line><span class=cl> |                     Payload Data continued ...                |
</span></span><span class=line><span class=cl> +---------------------------------------------------------------+
</span></span></code></pre></div><p>如下简单介绍各个字段的含义。</p><a class=anchor id=flag></a><h2>Flag <a href=#flag aria-hidden=true>#</a></h2><p>目前只包含了一个 FIN 标志位，标识是否为最后一个报文，一般只有数据报文分片之后，该位才可能是 1 。</p><a class=anchor id=opcode></a><h2>OpCode <a href=#opcode aria-hidden=true>#</a></h2><p>操作码，该值决定了数据报文的格式，如果非合法的操作码，那么应该断开连接，操作码包括了：</p><ul><li><code>%x00</code> 数据延续帧，表示数据传输采用了分片，当前收到的是其中一个分片，可能是中间分片也可能是最后一片。</li><li><code>%x01</code> 文本帧，采用的是 UTF-8 编码。</li><li><code>%x02</code> 二进制帧，具体含义由应用层定义。</li><li><code>0x08</code> 连接断开。</li><li><code>%x09</code> PING 操作。</li><li><code>%x0A</code> PONG 操作。</li></ul><p>其中 <code>0x00</code> 到 <code>0x07</code> 是数据帧，<code>0x03</code> 到 <code>0x07</code> 目前保留，暂时没有用到；而 <code>0x08</code> 到 <code>0x0A</code> 为控制帧，其 Payload 长度限制为 125 字节，而且不允许数据分片。</p><a class=anchor id=payload-length></a><h2>Payload Length <a href=#payload-length aria-hidden=true>#</a></h2><p>根据第二个字节决定了长度对应不同的大小。</p><ul><li><code>0~125</code> 直接对应了具体的长度。</li><li><code>126</code> 接下来 2 字节无符号整数才是该帧的长度</li><li><code>127</code> 接下来 8 字节无符号整数才是该帧的长度，高位必须为 0 。</li></ul><p>也就是说，数据 PayLoad 的长度是通过一个变长的表示方式表示。</p><a class=anchor id=掩码></a><h2>掩码 <a href=#%e6%8e%a9%e7%a0%81 aria-hidden=true>#</a></h2><p>当设置了 <code>mask</code> 标志位时，对应的 <code>payload-data</code> 字段需要经这个掩码 (4Bytes 整形) 进行处理，否则，可以直接使用数据。一般，从客户端发送到服务器的数据需要强制掩码操作，而从服务端发送的数据无需掩码操作。</p><p>至于原因下面再详细介绍。</p><a class=anchor id=数据传输></a><h1>数据传输 <a href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93 aria-hidden=true>#</a></h1><p>当建立好 WebSocket 连接之后，后续的操作基本都是基于数据帧的传递，也就是说 opcode 为 <code>0x00~0x02</code>，不过此时可能会发生数据分片，需要通过 FIN 的值来判断是否结束，当为 1 时已经结束，可以对消息进行处理了，否则需要继续等待。</p><p>其中 opcode 为 <code>0x01</code> 表示消息是文本，<code>0x02</code> 为二进制，而 <code>0x00</code> 表示为延续帧，也就是完整消息的数据帧还没有接收完，如下是一个简单示例。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Client: FIN=1, opcode=0x1, msg=&#34;Hello&#34;
</span></span><span class=line><span class=cl>Server: (process complete message immediately) Hi.
</span></span><span class=line><span class=cl>Client: FIN=0, opcode=0x1, msg=&#34;and a&#34;
</span></span><span class=line><span class=cl>Server: (listening, new message containing text started)
</span></span><span class=line><span class=cl>Client: FIN=0, opcode=0x0, msg=&#34;happy new&#34;
</span></span><span class=line><span class=cl>Server: (listening, payload concatenated to previous message)
</span></span><span class=line><span class=cl>Client: FIN=1, opcode=0x0, msg=&#34;year!&#34;
</span></span><span class=line><span class=cl>Server: (process complete message) Happy new year to you too!
</span></span></code></pre></div><p>也就是客户端发送了 <code>Hello</code> ，然后服务端立即响应 <code>Hi</code> ，接着服务端发送 <code>and a happy new year!</code> ，最后服务端收到完整消息后响应 <code>Happy new year to you too!</code> 。</p><a class=anchor id=关闭连接></a><h1>关闭连接 <a href=#%e5%85%b3%e9%97%ad%e8%bf%9e%e6%8e%a5 aria-hidden=true>#</a></h1><p>正常关闭 WebSocket 连接就是发送 opcode 为 <code>0x08</code> 的报文，可以包含具体关闭连接的原因，一旦一端接收到了 Close 报文，那么就开始了 Close HandShake ，并进入到 Closing 状态。</p><p>关闭帧前两个字节为错误码，详见如下，按照大端发送；接着，可选择发送关闭连接的具体原因 (UTF-8 编码)。</p><p>当收到 Close 帧之后，如果之前没有向对方发送过 Close 帧，那么就需要发送一个错误码相同的帧，一般来说会立即发送错误帧，当然，也可以将当前正在发送的帧发送完成后再发送。</p><p>Close 消息发送完之后，服务端会立即关闭 Socket 连接，而客户端一般来说需要等待服务端关闭连接，也就是说，大部分场景是服务端主动关闭连接，但客户端也可以主动关闭，例如发送 Close 帧之后一直没有收到连接关闭信息。</p><a class=anchor id=异常码></a><h2>异常码 <a href=#%e5%bc%82%e5%b8%b8%e7%a0%81 aria-hidden=true>#</a></h2><p>详细可以参考 <a href=https://tools.ietf.org/html/rfc6455#section-7.4>RFC6455 7.4. Status Codes</a> 中的介绍，简单整理如下。</p><table><thead><tr><th style=text-align:center>代号</th><th style=text-align:left>描述</th><th style=text-align:left>使用场景</th></tr></thead><tbody><tr><td style=text-align:center>1000</td><td style=text-align:left>正常关闭</td><td style=text-align:left>应用完成数据处理，会话正常关闭</td></tr><tr><td style=text-align:center>1001</td><td style=text-align:left>离开</td><td style=text-align:left>应用离开且不期望后续连接的尝试而关闭连接时</td></tr><tr><td style=text-align:center>1002</td><td style=text-align:left>协议错误</td><td style=text-align:left>因协议错误而关闭连接时</td></tr><tr><td style=text-align:center>1003</td><td style=text-align:left>不可接受的数据类型</td><td style=text-align:left>非二进制或文本类型时</td></tr><tr><td style=text-align:center>1007</td><td style=text-align:left>无效数据</td><td style=text-align:left>文本格式错误，如编码错误</td></tr><tr><td style=text-align:center>1008</td><td style=text-align:left>消息违反政策</td><td style=text-align:left>当应用程序由于其他代号不包含的原因时</td></tr><tr><td style=text-align:center>1009</td><td style=text-align:left>消息过大</td><td style=text-align:left>当接收的消息太大，应用程序无法处理时（帧的载荷最大为64字节）</td></tr><tr><td style=text-align:center>1010</td><td style=text-align:left>需要拓展</td><td style=text-align:left></td></tr><tr><td style=text-align:center>1011</td><td style=text-align:left>意外情况</td><td style=text-align:left></td></tr></tbody></table><p>其中 <code>4000 ~ 4999</code> 可以由应用层使用。</p><a class=anchor id=掩码-1></a><h1>掩码 <a href=#%e6%8e%a9%e7%a0%81-1 aria-hidden=true>#</a></h1><p>简单来说，就是当报文中的 mask 字段的值为 1 时，payload 字段的数据需要通过这个掩码进行计算，而且这个 mask 是 32bit 的值，每次由客户端发送给服务端的时候，都需要通过 Mask 计算，而服务端发送给客户端时是不需要计算的。</p><p>当发送数据的时候，每次都需要获取一个最新的 mask ，然后将数据通过如下方式计算。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for (i = 0; i &lt; len; i++) {
</span></span><span class=line><span class=cl>	data[offset + i] ^= mask[i % 4];
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>当到达服务器之后，同样以上述的方式计算即可。</p><a class=anchor id=原因></a><h2>原因 <a href=#%e5%8e%9f%e5%9b%a0 aria-hidden=true>#</a></h2><p>这里主要是考虑到网络安全而设置，但显然无法做到加密，因为算法公开的而且很容易解密，实际上，主要是为了防止早期版本协议中存在的代理缓存污染攻击，详细可以参考 <a href=https://tools.ietf.org/html/rfc6455#section-10.3>RFC6455 10.3. Attacks On Infrastructure (Masking)</a> 中的介绍。</p><p>这种方案是无法完全避免的，只是缓解。</p><a class=anchor id=faq></a><h1>FAQ <a href=#faq aria-hidden=true>#</a></h1><a class=anchor id=pingpong-能否携带数据></a><h3>PING/PONG 能否携带数据？ <a href=#pingpong-%e8%83%bd%e5%90%a6%e6%90%ba%e5%b8%a6%e6%95%b0%e6%8d%ae aria-hidden=true>#</a></h3><p>可以携带一部分数据，但是作为控制帧，协议规定消息体的长度不应该超过 125 字节，这也就导致实际可以携带的消息有限，所以不建议使用。</p><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>类似 CGI ，通过标准输入输出作为 WebSocket 的输入输出，很特别但是实用的服务器 <a href=http://websocketd.com/>http://websocketd.com/</a> ，一个通过前端显示 vmstats 的工程实现，详见 <a href=https://github.com/joewalnes/web-vmstats>Github web-vmstats</a> 。</p><p>基于 <a href=https://github.com/warmcat/libwebsockets>libwebsockets</a> 实现的工程，包括：数据展示 <a href=https://github.com/acooks/jittertrap>JitterTrap</a>、共享终端 <a href=https://github.com/tsl0922/ttyd>ttyd</a> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#控制帧-vs-数据帧>控制帧 VS. 数据帧</a></li><li><a href=#服务器握手响应>服务器握手响应</a></li></ul></li><li><a href=#协议>协议</a><ul><li><a href=#flag>Flag</a></li><li><a href=#opcode>OpCode</a></li><li><a href=#payload-length>Payload Length</a></li><li><a href=#掩码>掩码</a></li></ul></li><li><a href=#数据传输>数据传输</a></li><li><a href=#关闭连接>关闭连接</a><ul><li><a href=#异常码>异常码</a></li></ul></li><li><a href=#掩码-1>掩码</a><ul><li><a href=#原因>原因</a></li></ul></li><li><a href=#faq>FAQ</a><ul><li></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>