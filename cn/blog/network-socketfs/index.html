<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux 中的 socketfs | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="BSD socket 是用户程序与网络协议栈之间的接口层，用户通过调用 socket API 将报文传给协议栈，以及从协议栈读取报文。实际上，Linux 对于网络提供了一个与虚拟文件系统相似的接口，也就是可以通过 socket 接口打开一个类似的文件，而内核中实际是通过 sockfs 文件系统实现的。
接下来我们就在这篇文章中查看下与 socketfs 相关的内容。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux 中的 socketfs</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-02-10</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/network/ role=button>network</a></div></div><hr><div class=content><p>BSD socket 是用户程序与网络协议栈之间的接口层，用户通过调用 socket API 将报文传给协议栈，以及从协议栈读取报文。实际上，Linux 对于网络提供了一个与虚拟文件系统相似的接口，也就是可以通过 socket 接口打开一个类似的文件，而内核中实际是通过 sockfs 文件系统实现的。</p><p>接下来我们就在这篇文章中查看下与 socketfs 相关的内容。</p><a class=anchor id=socket层系统调用></a><h1>Socket层，系统调用 <a href=#socket%e5%b1%82%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8 aria-hidden=true>#</a></h1><p>系统调用 socket()、bind()、connect()、accept()、send()、release() 等都是在 net/socket.c 实现的，下面介绍通过 socket 层和用户的衔接。</p><p>对于这么多的协议，都是通过 socket() 向用户提供统一的接口，下面是一个典型的 TCP 协议通讯。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># 服务端
</span></span><span class=line><span class=cl>listenfd = socket(AF_INET, SOCK_STREAM, 0);                 # 新建socket
</span></span><span class=line><span class=cl>bind(sock_descriptor, servaddr, size);                      # 绑定端口
</span></span><span class=line><span class=cl>listen(listenfd, 5);                                        # 开始监听端口
</span></span><span class=line><span class=cl>accept(listenfd, cliaddr, clilen);                          # 接收新请求
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 客户端
</span></span><span class=line><span class=cl>sock_descriptor = socket(AF_INET, SOCK_STREAM, 0);          # 新建socket
</span></span><span class=line><span class=cl>connect(sock_descriptor, sockaddr, size);                   # 与服务端建立链接
</span></span><span class=line><span class=cl>send(sock_descriptor, &#34;hello world&#34;);                       # 发送数据
</span></span><span class=line><span class=cl>recv(sock_descriptor, buffer, 1024, 0);                     # 接收数据
</span></span></code></pre></div><p>socket() 的声明和实现如下，三个参数分别为协议族、协议类型 (面向连接或无连接) 以及协议。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>int socket(int domain, int type, int protocol);
</span></span></code></pre></div><a class=anchor id=socketfs-初始化></a><h1>socketfs 初始化 <a href=#socketfs-%e5%88%9d%e5%a7%8b%e5%8c%96 aria-hidden=true>#</a></h1><p>对于用户态而言, 返回的 socket 就是一个特殊的已经打开的文件，为了对 socket 抽像出文件的概念，内核中为 socket 定义了一个专门的文件系统类型 sockfs 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>vfsmount</span> <span class=o>*</span><span class=n>sock_mnt</span> <span class=n>__read_mostly</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>file_system_type</span> <span class=n>sock_fs_type</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>name</span>     <span class=o>=</span> <span class=s>&#34;sockfs&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>get_sb</span>   <span class=o>=</span> <span class=n>sockfs_get_sb</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>kill_sb</span>  <span class=o>=</span> <span class=n>kill_anon_super</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>socket 系统的初始化通过 sock_init() 函数完成，通过如下程序实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>core_initcall</span><span class=p>(</span><span class=n>sock_init</span><span class=p>);</span>
</span></span></code></pre></div><p>通过 core_initcall() 宏实现，其中定义的函数会在系统初始化时调用，通过 sock_init() 模块初始化的时候，会安装该文件系统。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sock_init()
</span></span><span class=line><span class=cl>  |-net_sysctl_init()
</span></span><span class=line><span class=cl>  |-skb_init()
</span></span><span class=line><span class=cl>  |-init_inodecache()
</span></span><span class=line><span class=cl>  |-register_filesystem()             # 将文件系统添加到一个列表中
</span></span><span class=line><span class=cl>  |-kern_mount()                      # 挂载文件系统
</span></span><span class=line><span class=cl>    |-kern_mount_data()
</span></span><span class=line><span class=cl>      |-vfs_kern_mount()
</span></span><span class=line><span class=cl>        |-alloc_vfsmnt()
</span></span><span class=line><span class=cl>        |-mount_fs()                  # 返回root dentry
</span></span></code></pre></div><p>在 vfs_kern_mount() 中，会申请文件系统 mnt 结构，调用之前注册的 sock_fs_type 的 get_sb()，获取相应的超级块，并将 mnt->mnt_sb 指向 sock_fs_type 中的超级块。</p><p>这里就是先获取/分配一个超级块，然后初始化超级块的各成员，包括 s_op，它封装了对应的功能函数表。s_op 自然就指向了 sockfs_ops，那前面提到的 new_inode() 函数分配 inode 时调用的，这个函数实际对应 sock_alloc_inode() 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>sock_mnt</span><span class=o>-&gt;</span><span class=n>mnt_sb</span><span class=o>-&gt;</span><span class=n>s_op</span><span class=o>-&gt;</span><span class=nf>alloc_inode</span><span class=p>(</span><span class=n>sock_mnt</span><span class=o>-&gt;</span><span class=n>mnt_sb</span><span class=p>);</span>
</span></span></code></pre></div><p>可以看到 sock_alloc_inode() 是如何分配一个 inode 节点的，函数先分配了一个用于封装 socket 和 inode 的 ei，然后在高速缓存中为之申请了一块空间，这样 inode 和 socket 就同时都被分配了。</p><p>至目前为止，分配 inode、socket 以及两者如何关联，都已一一分析了。最后一个关键问题，就是如何把 socket 与一个已打开的文件，建立映射关系。</p><p>sys_socketcall() 包含了所有 socket API 的入口。</p><a class=anchor id=socket></a><h1>socket() <a href=#socket aria-hidden=true>#</a></h1><p>有了文件系统后，对内核而言，创建一个 socket，就是在 sockfs 文件系统中创建一个文件节点(inode)，并建立起为了实现 socket 功能所需的一整套数据结构，包括 struct inode 和 struct socket。而 struct socket 结构在内核中就代表了一个 socket，然后再将其与一个已打开的文件 &ldquo;建立映射关系&rdquo;，这样，用户态就可以用抽像的文件的概念来操作 socket 了。</p><p>而用户看到的是一个类似于文件描述符的 int 类型。在内核中 struct task_struct current 用来表示当前进程，用 struct file 描述一个已经打开的文件，当然一个进程可以打开多个文件，所以通过 struct file *fd_array[] 表示，文件描述符即对应该数组的下标。</p><p>通过文件描述符即可以找到对应内核中的 struct file 结构。</p><p>因此，对于网络编程需要做的是将 socket 与一个已经打开的文件建立映射，也就是为 socket 分配一个 struct file 以及相应的文件描述符 fd 。</p><p>如前所述，一个 socket 总是与一个 inode 密切相关的，为此内核引入了一个 socket_alloc 结构，当已知一个 inode 可以通过宏 SOCKET_I() 获取对应的 socket 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>socket_alloc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>socket</span> <span class=n>socket</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>inode</span> <span class=n>vfs_inode</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>sock</span> <span class=o>=</span> <span class=nf>SOCKET_I</span><span class=p>(</span><span class=n>inode</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kr>inline</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=nf>SOCKET_I</span><span class=p>(</span><span class=k>struct</span> <span class=n>inode</span> <span class=o>*</span><span class=n>inode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nf>container_of</span><span class=p>(</span><span class=n>inode</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket_alloc</span><span class=p>,</span> <span class=n>vfs_inode</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>socket</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这也同时意味着在正常分配一个 inode 后，必须再分配一个 socket_alloc 结构，并实现对应的封装。</p><p>接着申请分配一个相应的文件描述符 fd，因为 socket 并不支持 open() 方法，所以不能期望用户通过调用 open() API 分配一个 struct file，而是 sock_alloc_file() 获取，并通过让 current 的 files 指针的 fd 数组的 fd 索引项指向该 file 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sys_socket(family, type, protocol)
</span></span><span class=line><span class=cl>  |-sock_create()                         # 分配inode和socket_alloc
</span></span><span class=line><span class=cl>  | |-__sock_create()
</span></span><span class=line><span class=cl>  |   |-security_socket_create()          # 调用安全接口，一般是selinux，可忽略
</span></span><span class=line><span class=cl>  |   |-socket *sock=sock_alloc()         # 主要的分配函数，分配一个struct socket
</span></span><span class=line><span class=cl>  |   | |-new_inode_pseudo()              # 通过sock_mnt-&gt;mnt_sb生成一个inode
</span></span><span class=line><span class=cl>  |   | | |-alloc_inode()                 # 新建inode，并添加到sb.s_inodes链表中
</span></span><span class=line><span class=cl>  |   | |-socket *sock=SOCKET_I(inode)    # 根据上述的inode，获取sock
</span></span><span class=line><span class=cl>  |   |
</span></span><span class=line><span class=cl>  |   |-sock-&gt;type=type
</span></span><span class=line><span class=cl>  |   |-pf=net_families[family]
</span></span><span class=line><span class=cl>  |   |-pf-&gt;create(..., protocol, ...)    # 其中TCP对应了inet_create()函数
</span></span><span class=line><span class=cl>  |   | |-inetsw[sock-&gt;type]              # 遍厉该数组的对象
</span></span><span class=line><span class=cl>  |   | |-sock-&gt;ops=answer-&gt;ops           ### struct proto_ops类型，后续收发操作的主要函数
</span></span><span class=line><span class=cl>  |   | |-sock *sk=sk_alloc()             # 分配sock结构体
</span></span><span class=line><span class=cl>  |   |
</span></span><span class=line><span class=cl>  |   |-security_socket_post_create()
</span></span><span class=line><span class=cl>  |
</span></span><span class=line><span class=cl>  |-sock_map_fd()
</span></span><span class=line><span class=cl>    |-get_unused_fd_flags()               # 获取未使用的fd
</span></span><span class=line><span class=cl>    |-sock_alloc_file()                   # 分配一个struct file
</span></span><span class=line><span class=cl>    |-fd_install()
</span></span></code></pre></div><p>在 alloc_inode() 函数中，会调用 sock_mnt->mnt_sb->s_op->alloc_inode(sock_mnt->mnt_sb) 返回一个 inode 结构体，而该 alloc_inode() 函数实际对应的是 sockfs_ops 中的成员变量。</p><p>在 Linux 中，通过 net_families[] 数组标示不同的 family 类型，对于 TCP/IP 采用的是 AF_INET 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define PF_UNIX     AF_UNIX
</span></span></span><span class=line><span class=cl><span class=cp>#define PF_INET     AF_INET
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>net_proto_family</span> <span class=n>__rcu</span> <span class=o>*</span><span class=n>net_families</span><span class=p>[</span><span class=n>NPROTO</span><span class=p>]</span> <span class=n>__read_mostly</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>net_proto_family</span> <span class=n>inet_family_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>family</span> <span class=o>=</span> <span class=n>PF_INET</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>create</span> <span class=o>=</span> <span class=n>inet_create</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>owner</span>  <span class=o>=</span> <span class=n>THIS_MODULE</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>其中，仍以 TCP 为例，其中入参采用 SOCK_STREAM，其中的 inetsw_array[] 会在 inet_init() 函数中通过 inet_register_protosw() 函数注册到 static struct list_head inetsw[SOCK_MAX] 中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>const</span> <span class=k>struct</span> <span class=n>proto_ops</span> <span class=n>inet_stream_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>family</span>        <span class=o>=</span> <span class=n>PF_INET</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>owner</span>         <span class=o>=</span> <span class=n>THIS_MODULE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>sendmsg</span>       <span class=o>=</span> <span class=n>inet_sendmsg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>recvmsg</span>       <span class=o>=</span> <span class=n>inet_recvmsg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>struct</span> <span class=n>inet_protosw</span> <span class=n>inetsw_array</span><span class=p>[]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>type</span> <span class=o>=</span>       <span class=n>SOCK_STREAM</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>protocol</span> <span class=o>=</span>   <span class=n>IPPROTO_TCP</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>prot</span> <span class=o>=</span>       <span class=o>&amp;</span><span class=n>tcp_prot</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>ops</span> <span class=o>=</span>        <span class=o>&amp;</span><span class=n>inet_stream_ops</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>flags</span> <span class=o>=</span>      <span class=n>INET_PROTOSW_PERMANENT</span> <span class=o>|</span> <span class=n>INET_PROTOSW_ICSK</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>__init</span> <span class=nf>inet_init</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>q</span> <span class=o>=</span> <span class=n>inetsw_array</span><span class=p>;</span> <span class=n>q</span> <span class=o>&lt;</span> <span class=o>&amp;</span><span class=n>inetsw_array</span><span class=p>[</span><span class=n>INETSW_ARRAY_LEN</span><span class=p>];</span> <span class=o>++</span><span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nf>inet_register_protosw</span><span class=p>(</span><span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>那么，在 sys_socket() 函数中就会根据 family、type 的参数，通过 sock->ops=answer->ops 进行赋值，后面包括报文的收发操作等，都是根据该结构体进行操作。</p><a class=anchor id=小结></a><h2>小结 <a href=#%e5%b0%8f%e7%bb%93 aria-hidden=true>#</a></h2><p>上面已经介绍了在协议栈中是如何选择相关操作函数的，在此仍然一步步查看下具体的排查过程。</p><p>首先，socket() 系统调用会传入三个参数，接口如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>SYSCALL_DEFINE3</span><span class=p>(</span><span class=n>socket</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>family</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>type</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=n>protocol</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>retval</span> <span class=o>=</span> <span class=nf>sock_create</span><span class=p>(</span><span class=n>family</span><span class=p>,</span> <span class=n>type</span><span class=p>,</span> <span class=n>protocol</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>实际最终会调用如下的函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>__sock_create</span><span class=p>(...,</span> <span class=kt>int</span> <span class=n>family</span><span class=p>,</span> <span class=kt>int</span> <span class=n>type</span><span class=p>,</span> <span class=kt>int</span> <span class=n>protocol</span><span class=p>,</span> <span class=p>...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span> <span class=o>=</span> <span class=nf>sock_alloc</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>sokc</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>=</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>net_proto_family</span> <span class=o>*</span><span class=n>pf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pf</span> <span class=o>=</span> <span class=nf>rcu_dereference</span><span class=p>(</span><span class=n>net_families</span><span class=p>[</span><span class=n>family</span><span class=p>]);</span>   <span class=c1>//## 关系到如下函数的调用
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>err</span> <span class=o>=</span> <span class=n>pf</span><span class=o>-&gt;</span><span class=nf>create</span><span class=p>(</span><span class=n>net</span><span class=p>,</span> <span class=n>sock</span><span class=p>,</span> <span class=n>protocol</span><span class=p>,</span> <span class=n>kern</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>其中 net_families[] 数组通过 sock_register() 函数进行注册，通过如下命令看到所有注册的协议，在此以 AF_INET 或者 PF_INET 为例，注册的是 inet_family_ops 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cd net &amp;&amp; grep -rne &#39;\&lt;sock_register(&#39;
</span></span><span class=line><span class=cl>... ...
</span></span><span class=line><span class=cl>ipv4/af_inet.c:1704:    (void)sock_register(&amp;inet_family_ops);
</span></span><span class=line><span class=cl>... ...
</span></span></code></pre></div><p>而对应的结构体定义为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>net_proto_family</span> <span class=n>inet_family_ops</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>family</span> <span class=o>=</span> <span class=n>PF_INET</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>create</span> <span class=o>=</span> <span class=n>inet_create</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>.</span><span class=n>owner</span>  <span class=o>=</span> <span class=n>THIS_MODULE</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>也就是接下来实际调用的函数是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=nf>inet_create</span><span class=p>(</span><span class=k>struct</span> <span class=n>net</span> <span class=o>*</span><span class=n>net</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=kt>int</span> <span class=n>protocol</span><span class=p>,</span> <span class=kt>int</span> <span class=n>kern</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>err</span> <span class=o>=</span> <span class=o>-</span><span class=n>ESOCKTNOSUPPORT</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>rcu_read_lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=nf>list_for_each_entry_rcu</span><span class=p>(</span><span class=n>answer</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>inetsw</span><span class=p>[</span><span class=n>sock</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>],</span> <span class=n>list</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>err</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Check the non-wild match. */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>protocol</span> <span class=o>==</span> <span class=n>answer</span><span class=o>-&gt;</span><span class=n>protocol</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>protocol</span> <span class=o>!=</span> <span class=n>IPPROTO_IP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>sock</span><span class=o>-&gt;</span><span class=n>ops</span> <span class=o>=</span> <span class=n>answer</span><span class=o>-&gt;</span><span class=n>ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>而其中 inetsw[] 数组实际是通过 inetsw_array[] 注册的结果。</p><a class=anchor id=send></a><h1>send() <a href=#send aria-hidden=true>#</a></h1><p>在 Linux 中，应用层可以使用以下 socket 函数来发送数据：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>write</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>count</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>send</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>sendto</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>to</span><span class=p>,</span> <span class=kt>socklen_t</span> <span class=n>tolen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>ssize_t</span> <span class=nf>sendmsg</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>msghdr</span> <span class=o>*</span><span class=n>msg</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sendmmsg</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>,</span> <span class=k>struct</span> <span class=n>mmsghdr</span> <span class=o>*</span><span class=n>msgvec</span><span class=p>,</span>  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>vlen</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span></code></pre></div><p>当 flags 为 0 时，send() 和 write() 功能相同；而 sendto(&mldr;, NULL, 0) 功能与 send() 的功能相同；write() 和 send() 在套接字处于连接状态时可以使用，而 sendto()、sendmsg() 和 sendmmsg() 在任何时候都可用。</p><p>对于 send() 而言，其入口函数就是 sys_send() 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sys_send()
</span></span><span class=line><span class=cl>  |-sys_sendto()
</span></span><span class=line><span class=cl>    |-sockfd_lookup_light()         # 通过文件描述符fd，找到对应的socket实例
</span></span><span class=line><span class=cl>    |-... ...                       # 初始化消息头信息
</span></span><span class=line><span class=cl>    |-move_addr_to_kernel()         # 把套接字地址从用户空间拷贝到内核空间
</span></span><span class=line><span class=cl>    |-sock_sendmsg()                # 调用统一的发送入口函数
</span></span><span class=line><span class=cl>    | |-__sock_sendmsg()
</span></span><span class=line><span class=cl>    |   |-__sock_sendmsg_nosec()
</span></span><span class=line><span class=cl>    |     |-sock-&gt;ops-&gt;sendmsg()
</span></span><span class=line><span class=cl>    |
</span></span><span class=line><span class=cl>    |-fput_light()
</span></span></code></pre></div><p>在 sockfd_lookup_light() 函数中，以 fd 为索引从当前进程的文件描述符表 files_struct 实例中找到对应的 file 实例，然后从 file 实例的 private_data 成员中获取 socket 实例。</p><p>其中 sock->ops->sendmsg() 操作相关的结构体如下，其中 sock->ops 在 sys_socket() 中初始化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>socket</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>proto_ops</span>  <span class=o>*</span><span class=n>ops</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>proto_ops</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=n>family</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>module</span>   <span class=o>*</span><span class=n>owner</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>release</span><span class=p>)</span>   <span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>bind</span><span class=p>)</span>      <span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>myaddr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sockaddr_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>connect</span><span class=p>)</span>   <span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=k>struct</span> <span class=n>sockaddr</span> <span class=o>*</span><span class=n>vaddr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>sockaddr_len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>socketpair</span><span class=p>)(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock1</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>accept</span><span class=p>)</span>    <span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>newsock</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>listen</span><span class=p>)</span>    <span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>shutdown</span><span class=p>)</span>  <span class=p>(</span><span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>sendmsg</span><span class=p>)</span>   <span class=p>(</span><span class=k>struct</span> <span class=n>kiocb</span> <span class=o>*</span><span class=n>iocb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=k>struct</span> <span class=n>msghdr</span> <span class=o>*</span><span class=n>m</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>total_len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>     <span class=p>(</span><span class=o>*</span><span class=n>recvmsg</span><span class=p>)</span>   <span class=p>(</span><span class=k>struct</span> <span class=n>kiocb</span> <span class=o>*</span><span class=n>iocb</span><span class=p>,</span> <span class=k>struct</span> <span class=n>socket</span> <span class=o>*</span><span class=n>sock</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=k>struct</span> <span class=n>msghdr</span> <span class=o>*</span><span class=n>m</span><span class=p>,</span> <span class=kt>size_t</span> <span class=n>total_len</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>其中 socket(AF_INET, SOCK_STREAM, 0) 会将 sock->ops 设置为 inet_stream_ops 变量，那么后续的所有操作都会使用该结构体定义的函数进行操作。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#socket层系统调用>Socket层，系统调用</a></li><li><a href=#socketfs-初始化>socketfs 初始化</a></li><li><a href=#socket>socket()</a><ul><li><a href=#小结>小结</a></li></ul></li><li><a href=#send>send()</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>