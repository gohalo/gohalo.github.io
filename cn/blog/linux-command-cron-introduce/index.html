<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>你所不知道的 Linux 定时任务 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="在 Linux 中，我们经常使用 cron 执行一些定时任务，只需要配置一下时间，它就可以周期的执行一些任务。
不知道你是否清楚它的详细用法？是否发现，脚本单独运行时是好好的，放到 cron 任务里却挂了！！！一个部署了 crond 的服务器，系统资源却被莫名其妙的被占满了，Why？？？
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>你所不知道的 Linux 定时任务</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2017-11-25</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>在 Linux 中，我们经常使用 cron 执行一些定时任务，只需要配置一下时间，它就可以周期的执行一些任务。</p><p>不知道你是否清楚它的详细用法？是否发现，脚本单独运行时是好好的，放到 cron 任务里却挂了！！！一个部署了 crond 的服务器，系统资源却被莫名其妙的被占满了，Why？？？</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>在 Linux 平台上如果需要实现定时或者周期执行某一个任务，可以通过编写 cron 脚本来实现。Linux 默认会在开机时启动 crond 进程，该进程负责读取调度任务并执行，用户只需要将相应的调度脚本写入 cron 的调度配置文件中。</p><p>另外，需要注意的是，cron 采用的是分钟级的调度，如果要更高精度的，只能用其它方法。</p><p>而且，<strong>每次执行时都是并发执行</strong>，而非串行。</p><a class=anchor id=安装启动></a><h2>安装、启动 <a href=#%e5%ae%89%e8%a3%85%e5%90%af%e5%8a%a8 aria-hidden=true>#</a></h2><p>在很多的发行版本中，cron 是默认安装的，包括了 crond+crontab 两个主要命令。前者是后台任务，用于调度执行；后者用来编译、查看、管理定时任务。</p><p>在 CentOS 7 中，该服务是默认安装的，如果没有，则可以安装 cronie 包，然后通过如下命令启动 crond 服务。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># systemctl start crond
</span></span></code></pre></div><p>其它的相关操作与 <code>systemctl</code> 指令相同，如 status、restart、stop 等操作。</p><a class=anchor id=相关配置文件></a><h2>相关配置文件 <a href=#%e7%9b%b8%e5%85%b3%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 aria-hidden=true>#</a></h2><p>与 cron 相关的有如下的几个文件，其中前几个是调度相关的文件：</p><ul><li><code>/etc/crontab</code> 全局配置文件；同时每个用户有自己的 cron 配置文件，这些文件在 <code>/var/spool/cron</code> 目录下。</li><li><code>/etc/cron.deny</code> <code>/etc/cron.allow</code> 用来控制可以使用 crontab 命令的用户，如果两个文件同时存在，那么 <code>/etc/cron.allow</code> 优先；如果两个文件都不存在，那么只有超级用户可以安排作业。</li><li><code>/etc/cron.d/</code> <code>/etc/{cron.daily,cron.hourly,cron.monthly,cron.weekly}</code> 保存的配置文件，后面详解。</li><li><code>/var/log/cron</code> 默认的日志文件。如果配置使用了 <code>syslog</code>，那么日志会发送到 <code>/var/log/messages</code> 文件中。</li></ul><p>对于 CentOS 7 来说，有 <code>cron.deny</code> 文件，但是为空，而且没有 <code>cron.allow</code> 文件，这也就意味着所有的用户都可以创建 cron 任务。</p><a class=anchor id=配置定时任务></a><h2>配置定时任务 <a href=#%e9%85%8d%e7%bd%ae%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1 aria-hidden=true>#</a></h2><p>定时任务包括了两类：</p><ul><li>系统级任务 <code>/etc/crontab</code> 需要 root 权限，其中第六部分指定了用户名，也就是说能以任意用户执行命令；通常用于系统服务或者一些重要的任务。</li><li>用户级任务 <code>/var/spool/cron/</code> 注意，此时的第六部分为用户需要执行的命令，而且只能以创建任务的用户身份执行。</li></ul><p>如果用的任务不是以 <code>hourly</code> <code>monthly</code> <code>weekly</code> 方式执行，则可以将相应的 <code>crontab</code> 写入到 <code>crontab</code> 或 <code>cron.d</code> 目录中。如，可以在 <code>cron.d</code> 目录下新建脚本 <code>echo-date.sh</code>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># .---------------- minute (0 - 59)
</span></span><span class=line><span class=cl># |  .------------- hour (0 - 23)
</span></span><span class=line><span class=cl># |  |  .---------- day of month (1 - 31)
</span></span><span class=line><span class=cl># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
</span></span><span class=line><span class=cl># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
</span></span><span class=line><span class=cl># |  |  |  |  |
</span></span><span class=line><span class=cl># *  *  *  *  * user-name  command to be executed
</span></span></code></pre></div><p>通常来说，我们是通过 crontab 命令来管理定时任务，常用的参数有：</p><ul><li><code>-e</code> 编辑 <code>crontab</code> 任务，默认使用当前用户。</li><li><code>-l</code> 列出用户所有的定时任务；注意，不会显示 <code>/etc</code> 目录下的配置任务。</li><li><code>-r</code> 删除所有的定时任务。</li><li><code>-u</code> 指定用户名。</li></ul><p>最常见的是通过 <code>crontab -e</code> 编辑 crontab 任务，此时会通过环境变量 <code>$EDITOR</code> 定义的值，调用相应的编辑器，例如 <code>export EDITOR="/usr/bin/vim"</code>，通过 vim 进行编辑。此时会在 <code>/tmp</code> 目录下生成一个临时文件，当编辑完成后替换掉 <code>/var/spool/cron/</code> 中对应用户的文件。</p><p>另外，也可以编辑一个临时文件如 <code>contabs.tmp</code>，编辑后通过 <code>contab contabs.tmp</code> 命令导入新的配置。一般不建议直接修改 <code>/etc/</code> 下的相关配置文件。</p><p>通常来说，需要检查 <code>/etc/crontab</code> 文件、<code>/etc/cron.*/</code> 目录，以及 <code>/var/spool/cron/</code> 目录。</p><a class=anchor id=anacron></a><h1>Anacron <a href=#anacron aria-hidden=true>#</a></h1><p>其实在官方的源码中，还包括了一个 anacron 指令，而 CentOS 7 中是包含在 anaconda-core 包中的；所以，如果使用 anacron 命令，必须安装该包。</p><a class=anchor id=简介-1></a><h2>简介 <a href=#%e7%ae%80%e4%bb%8b-1 aria-hidden=true>#</a></h2><p>像服务器来说，Linux 主机通常是 24 全天全年的处于开机状态，此时只需要 atd 与 crond 这两个服务即可；而对于像我们自己的电脑，经常关机，那么我们就需要 anacron 的帮助了。</p><p>anacron 并不能取代 cron，而是以天为单位或者是在启动后立刻进行 anacron 的动作。它会去侦测停机期间该执行但未执行的 crontab 任务，并将该任务运行一遍后，anacron 就会自动停止。</p><p>通过 anacron 命令，我们可以选择串行执行（默认）、强制执行（不判断时间戳）、立即执行未执行任务（不延迟等待）等操作。其配置文件是 <code>/etc/anacrontab</code>，每次执行完成会在 <code>/var/spool/anacron/</code> 目录下保存运行的时间点。</p><a class=anchor id=任务配置></a><h2>任务配置 <a href=#%e4%bb%bb%e5%8a%a1%e9%85%8d%e7%bd%ae aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>SHELL=/bin/sh
</span></span><span class=line><span class=cl>PATH=/sbin:/bin:/usr/sbin:/usr/bin
</span></span><span class=line><span class=cl>MAILTO=root
</span></span><span class=line><span class=cl># the maximal random delay added to the base delay of the jobs
</span></span><span class=line><span class=cl>RANDOM_DELAY=45
</span></span><span class=line><span class=cl># the jobs will be started during the following hours only
</span></span><span class=line><span class=cl>START_HOURS_RANGE=3-22
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>#period in days   delay in minutes   job-identifier   command
</span></span><span class=line><span class=cl>1                 5                  cron.daily       nice run-parts /etc/cron.daily
</span></span><span class=line><span class=cl>7                 25                 cron.weekly      nice run-parts /etc/cron.weekly
</span></span><span class=line><span class=cl>@monthly          45                 cron.monthly     nice run-parts /etc/cron.monthly
</span></span></code></pre></div><p>其中开头定义了一些环境变量等信息，而配置项的含义如下：</p><ul><li><code>period in days</code> 指定指令执行的周期，即指定任务在多少天内执行一次，也可以使用宏定义，如 <code>@day</code>、<code>@weekly</code>、<code>@monthly</code>。</li><li><code>delay in minutes</code> 当命令已经就绪后，并非立即执行，而是要延迟等待一段时间。</li><li><code>job-identifier</code> 每次启动时都会在 <code>/var/spool/anacron</code> 里面建立一个以 <code>job-identifier</code> 为文件名的文件，记录着任务完成的时间。</li><li><code>command</code> 要运行的命令，其中 <code>run-parts</code> 用来运行整个目录的可执行程序。</li></ul><a class=anchor id=命令详解></a><h2>命令详解 <a href=#%e5%91%bd%e4%bb%a4%e8%af%a6%e8%a7%a3 aria-hidden=true>#</a></h2><p>实际上，anacron 也是一个 cron 任务，可以通过 <code>ls /etc/cron*/*anacron</code> 查看。通常是通过 <code>anacron -s</code> 执行，以 <code>anacron -s cron.daily</code> 为例，会有如下的步骤：</p><ul><li>由配置文件 <code>/etc/anacrontab</code> 解析到 <code>cron.daily</code> 这项工作名称的执行周期为一天。</li><li>从 <code>/var/spool/anacron/cron.daily</code> 取出最近一次运行 anacron 的时间戳。</li><li>把取出的时间戳与当前的时间戳相比较，如果差异超过了一天，那么就准备进行命令。</li><li>若准备执行命令，根据 <code>/etc/anacrontab</code> 的配置，计算延迟的时间。</li><li>延迟时间后，开始运行后续命令，也就是 <code>run-parts /etc/cron.daily</code> 这串命令。</li><li>运行完毕后，anacron 程序结束。</li></ul><p>另外，需要注意的是，命令执行通常为串行执行。</p><a class=anchor id=示例></a><h1>示例 <a href=#%e7%a4%ba%e4%be%8b aria-hidden=true>#</a></h1><p>在配置 crontab 任务时，有几个特殊的符号：A) <code>*</code> 所有的取值范围内的数字；B) <code>/</code> 每的意思，如 <code>*/5</code> 表示每 5 个单位；C) <code>-</code> 从某个数字到某个数字；D) <code>,</code> 用来分开几个离散的数字。</p><p>以下举几个例子说明问题：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>*/10 * * * *     echo &#34;Ten minutes ago.&#34; &gt;&gt; /tmp/foo.txt    // 每十分钟执行一次
</span></span><span class=line><span class=cl>0 6 * * *        echo &#34;Good morning.&#34; &gt;&gt; /tmp/foo.txt       // 每天早上6点
</span></span><span class=line><span class=cl>0 */2 * * *      echo &#34;Have a break now.&#34; &gt;&gt; /tmp/foo.txt   // 每两个小时
</span></span><span class=line><span class=cl>45 4 1,10,22 * * echo &#34;Restart server.&#34; &gt;&gt; /tmp/foo.txt     // 每月1、10、22日的4:45
</span></span><span class=line><span class=cl>0 23-7/2,8 * * * echo &#34;Have a good dream.&#34; &gt;&gt; /tmp/foo.txt  // 晚上11点到早上8点之间每两个小时，早上八点
</span></span><span class=line><span class=cl>0 11 4 * 1-3     echo &#34;Just kidding.&#34; &gt;&gt; /tmp/foo.txt       // 每月4号和每周的周一到周三的早上11点
</span></span><span class=line><span class=cl>45 11 * * 0,6    echo &#34;Have a good lunch.&#34; &gt;&gt; /tmp/foo.txt  // 每周六、周日的11点45分
</span></span><span class=line><span class=cl>0 9 * * 1-5      echo &#34;Work hard.&#34; &gt;&gt; /tmp/foo.txt          // 从周一到周五的9点
</span></span><span class=line><span class=cl>2 8-16/3 * * *   echo &#34;Some examples.&#34; &gt;&gt; /tmp/foo.txt      // 8:02、11:02、14:02执行
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0,30 18-23 * * *    echo &#34;Same.&#34; &gt;&gt; /tmp/foo.txt            // 每天18:00到23:00之间每隔30分钟
</span></span><span class=line><span class=cl>0-59/30 18-23 * * * echo &#34;Same.&#34; &gt;&gt; /tmp/foo.txt            // 同上
</span></span><span class=line><span class=cl>*/30 18-23 * * *    echo &#34;Same.&#34; &gt;&gt; /tmp/foo.txt            // 同上
</span></span></code></pre></div><p>另外，需要注意的几点：</p><ol><li>可以在 crontab 的命令中使用环境变量，如：<code>*/1 * * * * echo $HOME</code> 。</li><li>第三个域和第五个域是 &ldquo;或&rdquo; 操作。</li></ol><p>通常，使用 <code>crontab -e</code> 进行的配置是针对某个用户的，而编辑 <code>/etc/crontab</code> 是针对系统的任务。</p><a class=anchor id=特殊用法></a><h2>特殊用法 <a href=#%e7%89%b9%e6%ae%8a%e7%94%a8%e6%b3%95 aria-hidden=true>#</a></h2><p>除了上述的写法外，crontab 提供了一些简单的时间定义方法，如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>@daily         echo &#34;Hi&#34; &gt;&gt; /tmp/foo.txt
</span></span></code></pre></div><p>除此之外还有如下类似的类型，可以通过 <code>man 5 crontab</code> 查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>@reboot    :    Run once after reboot.
</span></span><span class=line><span class=cl>@yearly    :    Run once a year, ie.  &#34;0 0 1 1 *&#34;.
</span></span><span class=line><span class=cl>@annually  :    Run once a year, ie.  &#34;0 0 1 1 *&#34;.
</span></span><span class=line><span class=cl>@monthly   :    Run once a month, ie. &#34;0 0 1 * *&#34;.
</span></span><span class=line><span class=cl>@weekly    :    Run once a week, ie.  &#34;0 0 * * 0&#34;.
</span></span><span class=line><span class=cl>@daily     :    Run once a day, ie.   &#34;0 0 * * *&#34;.
</span></span><span class=line><span class=cl>@hourly    :    Run once an hour, ie. &#34;0 * * * *&#34;.
</span></span></code></pre></div><a class=anchor id=常用技巧></a><h2>常用技巧 <a href=#%e5%b8%b8%e7%94%a8%e6%8a%80%e5%b7%a7 aria-hidden=true>#</a></h2><p>可以通过如下命令查看所有用户的 cron 定时任务，注意需要使用 root 权限。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for user in $(cut -f1 -d: /etc/passwd); do echo &#34;### Crontabs for $user ####&#34;; crontab -u $user -l; done
</span></span></code></pre></div><p>需要注意的是，上述脚本只能显示 user 的 crontabs，如果要查看所有的还需要解析 <code>/etc/crontab</code>、<code>/etc/crontab.d</code>、<code>/etc/cron.daily</code> 等配置文件中的任务。</p><a class=anchor id=常见问题></a><h1>常见问题 <a href=#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98 aria-hidden=true>#</a></h1><p>简单记录在使用 crontab 时遇到的问题。</p><a class=anchor id=-导致的问题></a><h2>% 导致的问题 <a href=#-%e5%af%bc%e8%87%b4%e7%9a%84%e9%97%ae%e9%a2%98 aria-hidden=true>#</a></h2><p>例如写个了一个 shell 脚本，其中参数中使用了 <code>%</code>，那么在 cron 任务中就可能会执行错误，或者与预期的不符。为简单起见只是将传入的参数保存在 <code>/tmp/foobar.log</code> 中，脚本文件为 <code>/tmp/foobar.sh</code>，其内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nb>echo</span> <span class=nv>$1</span> &gt;&gt; /tmp/foobar.log
</span></span></code></pre></div><p>然后我们新建一个 cron 任务，内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>*/1 * * * * /tmp/foobar.sh &#34;`date &#39;+%Y-%m-%d %H:%M:%S&#39;`&#34; &gt; /dev/null 2&gt;&amp;1
</span></span></code></pre></div><p>正常来说在 <code>/tmp/foobar.log</code> 中会每隔 1 分钟打印一条日志，而实际上却没有。查看 <code>/var/log/cron</code> 日志可以发现，是没有完整执行上述命令的。</p><p>实际上，在 cron 任务中，<code>%</code> 是有特殊意义的，在这里需要转义，通过 <code>man 5 crontab</code> 查看帮助，可以看到如下内容：</p><blockquote><p>A &ldquo;%&rdquo; character in the command, unless escaped with a backslash (\), will be changed into newline characters, and all data after the first % will be sent to the command as standard input.</p></blockquote><p>也就是说，如果 <code>%</code> 没有通过 <code>\</code> 转义，那么就会被替换成换行，上述命令的正确打开姿势是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>*/1 * * * * /tmp/foobar.sh &#34;`date &#39;+\%Y-\%m-\%d \%H:\%M:\%S&#39;`&#34; &gt; /dev/null 2&gt;&amp;1
</span></span></code></pre></div><a class=anchor id=输出字符引发的血案></a><h2>输出字符引发的血案 <a href=#%e8%be%93%e5%87%ba%e5%ad%97%e7%ac%a6%e5%bc%95%e5%8f%91%e7%9a%84%e8%a1%80%e6%a1%88 aria-hidden=true>#</a></h2><p>现象是，登陆一台公用的跳板机时，当尝试从个人帐号切换到公用帐号时发现报错，是由于进程数超过了最大限制 <code>ulimit -u</code>，然后通过 <code>ps aux</code> 发现有很多进程，其中比较多的是如下的两条命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/usr/sbin/postdrop -r
</span></span><span class=line><span class=cl>/usr/sbin/sendmail -FCronDaemon -i -odi -oem -oi -t -f root
</span></span></code></pre></div><p>基本可以确定是邮件的发送服务导致的，那么是什么程序调用的呢？通过 pstree 发现，其父进程为 crond 。</p><p>然后，通过 <code>du -i</code> 查看，发现 <code>/var</code> 的 inode 数目使用了 <code>100%</code>，通过如下命令查看根目录下的文件数目，也就是大约每个子目录中 inode 的数目。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ for dir in `ls -1Ad /*`; do echo -e &#34;${dir} \t\t `find ${dir} | wc -l`&#34;; done
</span></span></code></pre></div><p>然后，可以逐层向下查找，最后可以发现是 <code>/var/spool/postfix/maildrop</code> 目录下有大量的文件。通过 file 命令查看是 data 类型，实际上该目录下的文件可以通过 strings 命令查看，其内容为 crond 发送的邮件。</p><p>大概定位到了原因，先恢复掉。kill 掉所有 postdrop、sendmail 进程，然后清空 maildrop 目录下的文件。此时如果直接通过 <code>rm * -f</code> 删除，会由于文件过多而报错，可以通过如下两种方式进行删除。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># find /tmp -type f -exec rm {} \;
</span></span><span class=line><span class=cl># ls | xargs rm -vf
</span></span></code></pre></div><p>OK，环境已经恢复，那么具体是什么原因导致的呢？</p><p>查看 cronie 的源码可以发现，crond 会 fork 一个子进程去执行任务，而该进程有会再 fork 一个孙子进程执行真正的命令，代码的调用逻辑如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>main()                       # C入口函数
</span></span><span class=line><span class=cl> |-job_runqueue()            # 执行队列中的命令
</span></span><span class=line><span class=cl>   |-do_command()            # 此时会fork一个子进程执行，主进程继续工作
</span></span><span class=line><span class=cl>     |-child_process()       # 再fork一个进程，通过execle执行shell命令
</span></span><span class=line><span class=cl>       |-execle()            # 执行真正的shell指令，在孙子进程中执行
</span></span></code></pre></div><p>在 <code>child_process()</code> 函数中通过 <code>fork()</code> 子进程前，会创建两个管道 (stdin+stdout) 用来与子进程通讯，分别表示输入和输出。默认情况下，crontab 会将命令执行的输出，通过邮件发送给用户。</p><p>而在查看 <code>/var/log/maillog</code> 日志发现，是由于 pickup 管道不存在，导致邮件一直在积压。</p><p>通常来说，我们不需要发送邮件，为了防止上述问题的发生，可以配置运行脚本输出为 <code>>/dev/null 2>&amp;1</code>，来避免 crontab 运行中有内容输出。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0 * * * * /path/to/script.sh    &gt; /dev/null
</span></span><span class=line><span class=cl>0 * * * * /path/to/script.sh    &gt; /dev/null 2&gt;&amp;1
</span></span><span class=line><span class=cl>0 * * * * /path/to/command arg1 &gt; /dev/null 2&gt;&amp;1 || true
</span></span></code></pre></div><p>或者直接在 crontab 文件的顶部设置 MAILTO 变量为空，也就是 <code>MAILTO=""</code> 。</p><p>当然，如果有必要，可以将输出发送到指定邮箱，但是需要首先确保邮件服务是正常的，然后添加如下配置项：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>MAILTO=&#34;ooops@foobar.com&#34;
</span></span><span class=line><span class=cl>0 3 * * * echo &#34;Helloooo!&#34;
</span></span></code></pre></div><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><ul><li>源码可以从 <a href=https://fedorahosted.org/cronie/>cronie project</a> 官方网站下载，相关的帮助可以查看 man 1 crontab (命令行语法相关)、man 5 crontab (配置文件相关)。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#安装启动>安装、启动</a></li><li><a href=#相关配置文件>相关配置文件</a></li><li><a href=#配置定时任务>配置定时任务</a></li></ul></li><li><a href=#anacron>Anacron</a><ul><li><a href=#简介-1>简介</a></li><li><a href=#任务配置>任务配置</a></li><li><a href=#命令详解>命令详解</a></li></ul></li><li><a href=#示例>示例</a><ul><li><a href=#特殊用法>特殊用法</a></li><li><a href=#常用技巧>常用技巧</a></li></ul></li><li><a href=#常见问题>常见问题</a><ul><li><a href=#-导致的问题>% 导致的问题</a></li><li><a href=#输出字符引发的血案>输出字符引发的血案</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>