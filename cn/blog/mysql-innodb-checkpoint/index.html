<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>InnoDB Checkpoint | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="如果 redo log 可以无限地增大，同时缓冲池也足够大，是不是就意味着可以不将缓冲池中的脏页刷新回磁盘上？宕机时，完全可以通过 redo log 来恢复整个数据库系统中的数据。
显然，上述的前提条件是不满足的，这也就引入了 checkpoint 技术。
在这篇文章里，就简单介绍下 MySQL 中的实现。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>InnoDB Checkpoint</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2019-02-22</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/database/ role=button>database</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/mysql/ role=button>mysql</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/innodb/ role=button>innodb</a></div></div><hr><div class=content><p>如果 redo log 可以无限地增大，同时缓冲池也足够大，是不是就意味着可以不将缓冲池中的脏页刷新回磁盘上？宕机时，完全可以通过 redo log 来恢复整个数据库系统中的数据。</p><p>显然，上述的前提条件是不满足的，这也就引入了 checkpoint 技术。</p><p>在这篇文章里，就简单介绍下 MySQL 中的实现。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>Checkpoint (检查点) 的目的是为了解决以下几个问题：1、缩短数据库的恢复时间；2、缓冲池不够用时，将脏页刷新到磁盘；3、重做日志不可用时，刷新脏页。</p><ul><li>数据库宕机时，不需要重做所有的日志，因为 Checkpoint 之前的脏页都已经刷新回磁盘，只需对 Checkpoint 后的 redo log 进行恢复即可，这样大大缩短恢复时间。</li><li>当缓冲池不够用时，根据 LRU 算法淘汰最近最少使用页，若此页为脏页，那么需要强制执行 Checkpoint，将脏页刷回磁盘。</li><li>当前数据库对 redo log 的设计都是循环使用的，为了防止被覆盖，必须强制 Checkpoint，将缓冲池中的页至少刷新到当前 redo log 的位置。</li></ul><p>InnoDB 通过 Log Sequence Number, LSN 来标记版本，这是 8 字节的数字，每个页有 LSN，重做日志中也有 LSN，Checkpoint 也有 LSN，这个是联系三者的关键变量。</p><p>LSN 当前状态可以通过如下命令查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mysql&gt; SHOW ENGINE INNODB STATUS\G
</span></span><span class=line><span class=cl>---
</span></span><span class=line><span class=cl>LOG
</span></span><span class=line><span class=cl>---
</span></span><span class=line><span class=cl>Log sequence number 293590838           LSN1事务创建时一条日志
</span></span><span class=line><span class=cl>Log flushed up to   293590838
</span></span><span class=line><span class=cl>Pages flushed up to 293590838
</span></span><span class=line><span class=cl>Last checkpoint at  293590829
</span></span><span class=line><span class=cl>0 pending log flushes, 0 pending chkp writes
</span></span><span class=line><span class=cl>1139 log i/o&#39;s done, 0.00 log i/o&#39;s/second
</span></span></code></pre></div><a class=anchor id=分类></a><h2>分类 <a href=#%e5%88%86%e7%b1%bb aria-hidden=true>#</a></h2><p>通常有两种 Checkpoint，分别为：Sharp Checkpoint、Fuzzy Checkpoint；前者在正常关闭数据库时使用，会将所有脏页刷回磁盘；后者，会在运行时使用，用于部分脏页的刷新。</p><p>Checkpoint 所做的事情无外乎是将缓冲池中的脏页刷回到磁盘，不同之处在于每次刷新多少页到磁盘，每次从哪里取脏页，以及什么时间触发 Checkpoint。</p><a class=anchor id=master-thread-checkpoint></a><h3>Master Thread Checkpoint <a href=#master-thread-checkpoint aria-hidden=true>#</a></h3><p>InnoDB 的主线程以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘，这个过程是异步的，此时 InnoDB 可以进行其他的操作，用户查询线程不会阻塞。</p><a class=anchor id=flush_lru_list-checkpoint></a><h3>FLUSH_LRU_LIST Checkpoint <a href=#flush_lru_list-checkpoint aria-hidden=true>#</a></h3><p>InnoDB 要保证 BP 中有足够空闲页，在 1.1.x 之前，该操作发生在用户查询线程中，显然这会阻塞用户的查询。如果没有足够空闲页，需要将 LRU 列表尾端的页移除，如果有脏页，那么就需要进行 Checkpoint，因为这些页来自 LRU 列表，所以称为 FLUSH_LRU_LIST Checkpoint 。</p><p>MySQL-5.6 (InnoDB-1.2.x) 版本开始，这个检查被放在了一个单独的 Page Cleaner 线程中进行，而且用户可以通过参数 <code>innodb_lru_scan_depth</code> 控制 LRU 列表中可用页的数量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mysql&gt;  SHOW GLOBAL VARIABLES LIKE &#39;innodb_lru_scan_depth&#39;;
</span></span><span class=line><span class=cl>+-----------------------+-------+
</span></span><span class=line><span class=cl>| Variable_name         | Value |
</span></span><span class=line><span class=cl>+-----------------------+-------+
</span></span><span class=line><span class=cl>| innodb_lru_scan_depth | 1024  |
</span></span><span class=line><span class=cl>+-----------------------+-------+
</span></span><span class=line><span class=cl>1 row in set (0.01 sec)
</span></span></code></pre></div><a class=anchor id=asyncsync-flush-checkpoint></a><h3>Async/Sync Flush Checkpoint <a href=#asyncsync-flush-checkpoint aria-hidden=true>#</a></h3><p>是指重做日志文件不可用时，需要强制将脏页列表中的一些页刷新回磁盘，而此时脏页是从脏页列表中选取的，这可以保证重做日志文件可循环使用。</p><p>在 InnoDB 1.2.X 版本之前，Async Flush Checkpoint 会阻塞发现问题的用户查询线程，Sync Flush Checkpoint 会阻塞所有查询线程；InnoDB 1.2.X 之后放到单独的 Page Cleaner Thread。</p><a class=anchor id=dirty-page-too-much-checkpoint></a><h3>Dirty Page too much Checkpoint <a href=#dirty-page-too-much-checkpoint aria-hidden=true>#</a></h3><p>即脏页数量太多时，InnoDB 会强制进行 Checkpoint 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mysql&gt; SHOW GLOBAL VARIABLES LIKE &#39;innodb_max_dirty_pages_pct&#39;;
</span></span><span class=line><span class=cl>+----------------------------+-----------+
</span></span><span class=line><span class=cl>| Variable_name              | Value     |
</span></span><span class=line><span class=cl>+----------------------------+-----------+
</span></span><span class=line><span class=cl>| innodb_max_dirty_pages_pct | 75.000000 |
</span></span><span class=line><span class=cl>+----------------------------+-----------+
</span></span><span class=line><span class=cl>1 row in set (0.03 sec)
</span></span></code></pre></div><p>也即当缓冲池中脏页的数量占据 75% 时，强制进行 Checkpoint，刷新一部分的脏页到磁盘，其目的还是为了保证缓冲池中有足够可用的空闲页。</p><a class=anchor id=checkpoint-机制></a><h2>CheckPoint 机制 <a href=#checkpoint-%e6%9c%ba%e5%88%b6 aria-hidden=true>#</a></h2><p>在 Innodb 每次都取最老的 modified page 对应的 LSN，并将此脏页的 LSN 作为 Checkpoint 点记录到日志文件，意思就是 &ldquo;此 LSN 之前对应的日志和数据都已经刷新到磁盘&rdquo; 。</p><p>当 MySQL 启动做崩溃恢复时，会从 last checkpoint 对应的 LSN 开始扫描 redo log ，并将其应用到 buffer pool，直到 last checkpoint 对应的 LSN 等于 log flushed up to 对应的 LSN，则恢复完成。</p><p>如下是整个 redo log 的生命周期。</p><p><img alt="innodb checkpoint lsn" src=images/checkpoint-lsn.png class="mx-auto d-block"></p><p>InnoDB 的一条事务日志共经历 4 个阶段：</p><ol><li>创建阶段 (log sequence number, LSN1)：事务创建一条日志，当前系统 LSN 最大值，新的事务日志 LSN 将在此基础上生成，也就是 LSN1+新日志的大小；</li><li>日志刷盘 (log flushed up to, LSN2)：当前已经写入日志文件做持久化的 LSN；</li><li>数据刷盘 (oldest modified data log, LSN3)：当前最旧的脏页数据对应的 LSN，写 Checkpoint 的时候直接将此 LSN 写入到日志文件；</li><li>写CKP (last checkpoint at, LSN4)：当前已经写入 Checkpoint 的 LSN，也就是上次的写入；</li></ol><p>对于系统来说，以上 4 个 LSN 是递减的，即： <code>LSN1>=LSN2>=LSN3>=LSN4</code>。如上所述，LSN 当前状态可以通过如下命令查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>mysql&gt; SHOW ENGINE INNODB STATUS\G
</span></span><span class=line><span class=cl>---
</span></span><span class=line><span class=cl>LOG
</span></span><span class=line><span class=cl>---
</span></span><span class=line><span class=cl>Log sequence number 293590838           LSN1事务创建时一条日志
</span></span><span class=line><span class=cl>Log flushed up to   293590838
</span></span><span class=line><span class=cl>Pages flushed up to 293590838
</span></span><span class=line><span class=cl>Last checkpoint at  293590829
</span></span><span class=line><span class=cl>0 pending log flushes, 0 pending chkp writes
</span></span><span class=line><span class=cl>1139 log i/o&#39;s done, 0.00 log i/o&#39;s/second
</span></span></code></pre></div><p>如上的信息是在 <code>log_print()</code> 函数中打印。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void log_print( FILE* file)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    ... ...
</span></span><span class=line><span class=cl>    fprintf(file,
</span></span><span class=line><span class=cl>        &#34;Log sequence number &#34; LSN_PF &#34;\n&#34;
</span></span><span class=line><span class=cl>        &#34;Log flushed up to   &#34; LSN_PF &#34;\n&#34;
</span></span><span class=line><span class=cl>        &#34;Pages flushed up to &#34; LSN_PF &#34;\n&#34;
</span></span><span class=line><span class=cl>        &#34;Last checkpoint at  &#34; LSN_PF &#34;\n&#34;,
</span></span><span class=line><span class=cl>        log_sys-&gt;lsn,
</span></span><span class=line><span class=cl>        log_sys-&gt;flushed_to_disk_lsn,
</span></span><span class=line><span class=cl>        log_buf_pool_get_oldest_modification(),
</span></span><span class=line><span class=cl>        log_sys-&gt;last_checkpoint_lsn);
</span></span><span class=line><span class=cl>    ... ...
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><a class=anchor id=日志保护机制></a><h2>日志保护机制 <a href=#%e6%97%a5%e5%bf%97%e4%bf%9d%e6%8a%a4%e6%9c%ba%e5%88%b6 aria-hidden=true>#</a></h2><p>InnoDB 中 LSN 是单调递增的，而日志文件大小却是固定的，所以在写入的时候通过取余来计算偏移量，这样存在两个 LSN 写入到同一位置的可能，如果日志被覆盖，而数据也没有刷盘，一旦宕机，数据就丢失了。</p><p>为此，InnoDB 实现了一套日志保护机制，详细实现如下。</p><p><img alt="checkpoint redo buffer protect" src=images/checkpoint-redo-buffer-protect.png class="mx-auto d-block"></p><p>首先，明确下概念，上述的 buf 是指 redo log buffer，而 ckp 实际上与 buffer pool 相关，也就是脏页的刷脏。上述直线表示 redo log 的空间，会乘 0.9 的安全系数。</p><ul><li>Ckp age (LSN1- LSN4) 还没有做 Checkpoint 的日志范围，若超过日志空间，说明被覆盖的日志可能还没有刷到磁盘，而其 BP 中对应的数据 (脏页) 肯定没有刷到磁盘上；</li><li>Buf age (LSN1- LSN3) 脏页对应的日志还没有刷盘的范围，若超过日志空间，说明被覆盖的日志及其 BP 中对应数据肯定还没有刷到磁盘；</li></ul><p>当事务执行速度大于刷脏速度时，Ckp age 和 Buf age (innodb_flush_log_at_trx_commit!=1时) 都会逐步增长，当达到 async 点的时候，强制进行写 redo-log 或者写 Checkpoint，如果这样做还是赶不上事务执行的速度，则为了避免数据丢失，到达 sync 点的时候，会阻塞其它所有的事务，专门进行 redo-log 刷盘或者写 Checkpoint。</p><p>也就是说，只要事务执行速度大于脏页刷盘速度，最终都会触发日志保护机制，进而将事务阻塞，导致 MySQL 操作挂起。</p><a class=anchor id=源码解析></a><h1>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h1><a class=anchor id=临界范围计算></a><h2>临界范围计算 <a href=#%e4%b8%b4%e7%95%8c%e8%8c%83%e5%9b%b4%e8%ae%a1%e7%ae%97 aria-hidden=true>#</a></h2><p>如下是相关的变量以及临界值的计算函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 相关变量
</span></span><span class=line><span class=cl>innodb_log_buffer_size         = 16777216 = 16M
</span></span><span class=line><span class=cl>innodb_log_file_size           = 50331648 = 48M
</span></span><span class=line><span class=cl>innodb_log_files_in_group      = 2
</span></span><span class=line><span class=cl>innodb_flush_log_at_trx_commit = 1
</span></span><span class=line><span class=cl>innodb_thread_concurrency      = 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 计算临界函数调用栈
</span></span><span class=line><span class=cl>innobase_start_or_create_for_mysql()
</span></span><span class=line><span class=cl> |-log_group_init()
</span></span><span class=line><span class=cl>   |-log_calc_max_ages()                计算临界范围
</span></span></code></pre></div><p>接下来看看临界值是如何计算的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>log_calc_max_ages</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>log_mutex_enter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>group</span> <span class=o>=</span> <span class=n>UT_LIST_GET_FIRST</span><span class=p>(</span><span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>log_groups</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 设置redo-log的最大磁盘空间，也就是64-bits正整数的最大值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smallest_capacity</span> <span class=o>=</span> <span class=n>LSN_MAX</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 5.7实际只支持一个分组，获取的是除了头(LOG_FILE_HDR_SIZE)之外的总redo-log空间大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>group</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>log_group_get_capacity</span><span class=p>(</span><span class=n>group</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>smallest_capacity</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>smallest_capacity</span> <span class=o>=</span> <span class=n>log_group_get_capacity</span><span class=p>(</span><span class=n>group</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>group</span> <span class=o>=</span> <span class=n>UT_LIST_GET_NEXT</span><span class=p>(</span><span class=n>log_groups</span><span class=p>,</span> <span class=n>group</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 实际真正可以使用的空间需要乘以一个安全系数0.9
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>smallest_capacity</span> <span class=o>=</span> <span class=n>smallest_capacity</span> <span class=o>-</span> <span class=n>smallest_capacity</span> <span class=o>/</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 为每个OS线程预留一部分存储空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>free</span> <span class=o>=</span> <span class=n>LOG_CHECKPOINT_FREE_PER_THREAD</span> <span class=o>*</span> <span class=p>(</span><span class=mi>10</span> <span class=o>+</span> <span class=n>srv_thread_concurrency</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>+</span> <span class=n>LOG_CHECKPOINT_EXTRA_FREE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>free</span> <span class=o>&gt;=</span> <span class=n>smallest_capacity</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>  <span class=c1>// 需要预留足够的内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>success</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>failure</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>margin</span> <span class=o>=</span> <span class=n>smallest_capacity</span> <span class=o>-</span> <span class=n>free</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 好吧，再预留一部分内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>margin</span> <span class=o>=</span> <span class=n>margin</span> <span class=o>-</span> <span class=n>margin</span> <span class=o>/</span> <span class=mi>10</span><span class=p>;</span>  <span class=cm>/* Add still some extra safety */</span>
</span></span><span class=line><span class=cl>    <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>log_group_capacity</span> <span class=o>=</span> <span class=n>smallest_capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1-1/8=7/8=0.875
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>max_modified_age_async</span> <span class=o>=</span> <span class=n>margin</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span> <span class=n>margin</span> <span class=o>/</span> <span class=n>LOG_POOL_PREFLUSH_RATIO_ASYNC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1-1/16=15/16=0.9375
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>max_modified_age_sync</span> <span class=o>=</span> <span class=n>margin</span>
</span></span><span class=line><span class=cl>        <span class=o>-</span> <span class=n>margin</span> <span class=o>/</span> <span class=n>LOG_POOL_PREFLUSH_RATIO_SYNC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1-1/32=31/32=0.96875
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>max_checkpoint_age_async</span> <span class=o>=</span> <span class=n>margin</span> <span class=o>-</span> <span class=n>margin</span>
</span></span><span class=line><span class=cl>        <span class=o>/</span> <span class=n>LOG_POOL_CHECKPOINT_RATIO_ASYNC</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>max_checkpoint_age</span> <span class=o>=</span> <span class=n>margin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>failure</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>log_mutex_exit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>(</span><span class=n>success</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>关于边界划分可以简单查看下图。</p><p><img alt="checkpoint max ages" src=images/innodb-checkpoint-max-ages.png class="mx-auto d-block"></p><a class=anchor id=边界检查></a><h2>边界检查 <a href=#%e8%be%b9%e7%95%8c%e6%a3%80%e6%9f%a5 aria-hidden=true>#</a></h2><p>对于 <code>max_modified_age_async</code> 变量，也就是异步刷新，会在 page cleaner 线程中检查。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#define PCT_IO(p) ((ulong) (srv_io_capacity * ((double) (p) / 100.0)))
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>buf_flush_page_cleaner_coordinator()            ← 该函数基本上每秒调用一次
</span></span><span class=line><span class=cl> |-buf_flush_page_cleaner_coordinator()
</span></span><span class=line><span class=cl>   |-page_cleaner_flush_pages_recommendation()
</span></span><span class=line><span class=cl>     |-log_get_lsn()                            ← 获取当前lsn，也就是log_sys-&gt;lsn
</span></span><span class=line><span class=cl>     |-af_get_pct_for_dirty()                   ← 是否需要刷新多个页，返回IO-Capacity的百分比
</span></span><span class=line><span class=cl>     | |-buf_get_modified_ratio_pct()
</span></span><span class=line><span class=cl>     |   |-buf_get_total_list_len()
</span></span><span class=line><span class=cl>     |
</span></span><span class=line><span class=cl>     |-af_get_pct_for_lsn()                     ← 计算是否需要进行异步刷redo-log，返回IO-Capacity的百分比
</span></span><span class=line><span class=cl>     | |-log_get_max_modified_age_async()       ← 获取max_modified_age_async
</span></span><span class=line><span class=cl>     |
</span></span><span class=line><span class=cl>     |-ut_max()                                 ← 获取上述两个返回值的最大值
</span></span></code></pre></div><p>除了 <code>max_modified_age_async</code> 变量之外，其它相关的变量都会在 <code>log_checkpoint_margin()</code> 函数中进行比较，详细内容可以直接查看如下函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>log_checkpoint_margin</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>log_t</span><span class=o>*</span>      <span class=n>log</span>     <span class=o>=</span> <span class=n>log_sys</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lsn_t</span>       <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lsn_t</span>       <span class=n>checkpoint_age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ib_uint64_t</span> <span class=n>advance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>lsn_t</span>       <span class=n>oldest_lsn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span>        <span class=n>success</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nl>loop</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>advance</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>log_mutex_enter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>ut_ad</span><span class=p>(</span><span class=o>!</span><span class=n>recv_no_log_write</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 判断是否需要执行flush或者checkpoint，不需要则直接返回
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>log</span><span class=o>-&gt;</span><span class=n>check_flush_or_checkpoint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log_mutex_exit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 找出当前所有buffer pool实例中最老的LSN，实际上直接读取每个flush_list的尾部即可
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>oldest_lsn</span> <span class=o>=</span> <span class=n>log_buf_pool_get_oldest_modification</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 如果计算的age大于max_modified_age_sync，则需要做一次同步刷新
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>age</span> <span class=o>=</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>lsn</span> <span class=o>-</span> <span class=n>oldest_lsn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>age</span> <span class=o>&gt;</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>max_modified_age_sync</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* A flush is urgent: we have to do a synchronous preflush */</span>
</span></span><span class=line><span class=cl>        <span class=n>advance</span> <span class=o>=</span> <span class=n>age</span> <span class=o>-</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>max_modified_age_sync</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 计算checkpoint_age，并判断是否需要做checkpoint以及是否需要同步
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>checkpoint_age</span> <span class=o>=</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>lsn</span> <span class=o>-</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>last_checkpoint_lsn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>checkpoint_age</span> <span class=o>&gt;</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>max_checkpoint_age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* A checkpoint is urgent: we do it synchronously */</span>
</span></span><span class=line><span class=cl>        <span class=n>checkpoint_sync</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>do_checkpoint</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>checkpoint_age</span> <span class=o>&gt;</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>max_checkpoint_age_async</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* A checkpoint is not urgent: do it asynchronously */</span>
</span></span><span class=line><span class=cl>        <span class=n>do_checkpoint</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>checkpoint_sync</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>-&gt;</span><span class=n>check_flush_or_checkpoint</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>do_checkpoint</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>checkpoint_sync</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>-&gt;</span><span class=n>check_flush_or_checkpoint</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>log_mutex_exit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>advance</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lsn_t</span>   <span class=n>new_oldest</span> <span class=o>=</span> <span class=n>oldest_lsn</span> <span class=o>+</span> <span class=n>advance</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 需要同步刷新，则将LSN推进到新的LSN位置
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>success</span> <span class=o>=</span> <span class=n>log_preflush_pool_modified_pages</span><span class=p>(</span><span class=n>new_oldest</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 如果失败说明有其它的线程在处理
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=cm>/* If the flush succeeded, this thread has done its part
</span></span></span><span class=line><span class=cl><span class=cm>        and can proceed. If it did not succeed, there was another
</span></span></span><span class=line><span class=cl><span class=cm>        thread doing a flush at the same time. */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>success</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>log_mutex_enter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>log</span><span class=o>-&gt;</span><span class=n>check_flush_or_checkpoint</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>log_mutex_exit</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>do_checkpoint</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log_checkpoint</span><span class=p>(</span><span class=n>checkpoint_sync</span><span class=p>,</span> <span class=n>FALSE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>checkpoint_sync</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>goto</span> <span class=n>loop</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在用户线程中，会调用 <code>log_free_check()</code> 函数检查是否需要将日志刷新到磁盘。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>log_free_check()
</span></span><span class=line><span class=cl> |-log_check_margins()
</span></span><span class=line><span class=cl>   |-log_write_up_to()
</span></span></code></pre></div><p>在 <code>log_check_margins()</code> 函数中，会检查 <code>log_sys->buf_free > log->max_buf_free</code>，如果成立则会执行日志刷盘操作。</p><a class=anchor id=检查点写入></a><h2>检查点写入 <a href=#%e6%a3%80%e6%9f%a5%e7%82%b9%e5%86%99%e5%85%a5 aria-hidden=true>#</a></h2><p>一般会通过调用 <code>log_checkpoint()</code> 函数完成 checkpoint 的写入，需要注意的是，该函数中只会完成 checkpoint 的写入，并不会刷脏页。</p><p>当然也可以调用 <code>log_make_checkpoint_at()</code> 完成刷脏以及 checkpoint 的写入。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>log_make_checkpoint_at()
</span></span><span class=line><span class=cl> |-log_preflush_pool_modified_pages()
</span></span><span class=line><span class=cl> |-log_checkpoint()                         ← 并不从BP中刷脏页，只检查BP中的最大LSN，然后刷新到磁盘
</span></span><span class=line><span class=cl>   |-log_mutex_enter()                      ← 持有log_sys-&gt;mutex锁
</span></span><span class=line><span class=cl>   |-log_buf_pool_get_oldest_modification()
</span></span><span class=line><span class=cl>   | |-buf_pool_get_oldest_modification()   ← 遍厉所有BP实例，获取最大lsn，之前都已经写入磁盘
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   |-fil_names_clear()
</span></span><span class=line><span class=cl>   | |-mtr_t::commit_checkpoint()
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   |-log_write_up_to()
</span></span><span class=line><span class=cl>   |
</span></span><span class=line><span class=cl>   |-log_write_checkpoint_info()
</span></span><span class=line><span class=cl>     |-log_group_checkpoint()               ← 将checkpoint信息写入redolog头部，两个写入点轮流写入
</span></span></code></pre></div><p>checkpoint 信息分别保存在 ib_logfile0 的 512 字节和 1536(3*512) 字节处，每个 checkpoint 默认大小为 512 字节，当然，其中很大一部分是空白，详细可以参考如下函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>log_group_checkpoint</span><span class=p>(</span><span class=n>log_group_t</span><span class=o>*</span> <span class=n>group</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span> <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>buf</span> <span class=o>=</span> <span class=n>group</span><span class=o>-&gt;</span><span class=n>checkpoint_buf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>memset</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>OS_FILE_LOG_BLOCK_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>mach_write_to_8</span><span class=p>(</span><span class=n>buf</span> <span class=o>+</span> <span class=n>LOG_CHECKPOINT_NO</span><span class=p>,</span> <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>next_checkpoint_no</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mach_write_to_8</span><span class=p>(</span><span class=n>buf</span> <span class=o>+</span> <span class=n>LOG_CHECKPOINT_LSN</span><span class=p>,</span> <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>next_checkpoint_lsn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>lsn_offset</span> <span class=o>=</span> <span class=n>log_group_calc_lsn_offset</span><span class=p>(</span><span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>next_checkpoint_lsn</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                           <span class=n>group</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mach_write_to_8</span><span class=p>(</span><span class=n>buf</span> <span class=o>+</span> <span class=n>LOG_CHECKPOINT_OFFSET</span><span class=p>,</span> <span class=n>lsn_offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mach_write_to_8</span><span class=p>(</span><span class=n>buf</span> <span class=o>+</span> <span class=n>LOG_CHECKPOINT_LOG_BUF_SIZE</span><span class=p>,</span> <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>buf_size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>log_block_set_checksum</span><span class=p>(</span><span class=n>buf</span><span class=p>,</span> <span class=n>log_block_calc_checksum_crc32</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>MONITOR_INC</span><span class=p>(</span><span class=n>MONITOR_PENDING_CHECKPOINT_WRITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>n_log_ios</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>MONITOR_INC</span><span class=p>(</span><span class=n>MONITOR_LOG_IO</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ut_ad</span><span class=p>(</span><span class=n>LOG_CHECKPOINT_1</span> <span class=o>&lt;</span> <span class=n>univ_page_size</span><span class=p>.</span><span class=n>physical</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>ut_ad</span><span class=p>(</span><span class=n>LOG_CHECKPOINT_2</span> <span class=o>&lt;</span> <span class=n>univ_page_size</span><span class=p>.</span><span class=n>physical</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>n_pending_checkpoint_writes</span><span class=o>++</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>rw_lock_x_lock_gen</span><span class=p>(</span><span class=o>&amp;</span><span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>checkpoint_lock</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>LOG_CHECKPOINT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Note: We alternate the physical place of the checkpoint info.
</span></span></span><span class=line><span class=cl><span class=cm>    See the (next_checkpoint_no &amp; 1) below. */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* We send as the last parameter the group machine address
</span></span></span><span class=line><span class=cl><span class=cm>    added with 1, as we want to distinguish between a normal log
</span></span></span><span class=line><span class=cl><span class=cm>    file write and a checkpoint field write */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>fil_io</span><span class=p>(</span><span class=n>IORequestLogWrite</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=n>page_id_t</span><span class=p>(</span><span class=n>group</span><span class=o>-&gt;</span><span class=n>space_id</span><span class=p>,</span> <span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>           <span class=n>univ_page_size</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=p>(</span><span class=n>log_sys</span><span class=o>-&gt;</span><span class=n>next_checkpoint_no</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           <span class=o>?</span> <span class=nl>LOG_CHECKPOINT_2</span> <span class=p>:</span> <span class=n>LOG_CHECKPOINT_1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=n>OS_FILE_LOG_BLOCK_SIZE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=n>buf</span><span class=p>,</span> <span class=p>(</span><span class=n>byte</span><span class=o>*</span><span class=p>)</span> <span class=n>group</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>ut_ad</span><span class=p>(((</span><span class=n>ulint</span><span class=p>)</span> <span class=n>group</span> <span class=o>&amp;</span> <span class=mh>0x1UL</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>InnoDB 的 checkpoint 主要有 3 部分信息组成：</p><ul><li><code>checkpoint no</code> 每次写入都会递增，用于轮流写入 redo log 的头部的两部分，可以通过该值判断那个比较新；</li><li><code>checkpoint lsn</code> 记录了产生该 checkpoint 时 <code>log_sys->next_checkpoint_lsn</code> 是 flush 的 LSN，确保在该 LSN 前面的数据页都已经落盘，不再需要通过 redo log 进行恢复；</li><li><code>checkpoint offset</code> 记录了该 checkpoint 产生时，redo log 在 ib_logfile 中的偏移量，通过该值就可以找到需要恢复的 redo log 开始位置。</li></ul><p>每次在启动时，都会尝试读取两个值，并比较两者，获取较大的值。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#分类>分类</a></li><li><a href=#checkpoint-机制>CheckPoint 机制</a></li><li><a href=#日志保护机制>日志保护机制</a></li></ul></li><li><a href=#源码解析>源码解析</a><ul><li><a href=#临界范围计算>临界范围计算</a></li><li><a href=#边界检查>边界检查</a></li><li><a href=#检查点写入>检查点写入</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>