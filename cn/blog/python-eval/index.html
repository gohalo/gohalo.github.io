<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Python 动态执行 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="在 Python 中，允许通过 exec 和 eval 执行以字符串形式表示的代码片段，这体现了动态语言的特性，可以让代码变得更灵活。实际上，在使用 exec 和 eval 时，也是需要进行编译的，没错是 &amp;ldquo;编译&amp;rdquo;。
只是与 C 需要编译成机器码不同，CPython 需要编译成字节码 (ByteCode) 。
接下来，我们看看 Python 的动态执行相关内容。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Python 动态执行</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2015-06-16</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/python/ role=button>python</a></div></div><hr><div class=content><p>在 Python 中，允许通过 exec 和 eval 执行以字符串形式表示的代码片段，这体现了动态语言的特性，可以让代码变得更灵活。实际上，在使用 exec 和 eval 时，也是需要进行编译的，没错是 &ldquo;编译&rdquo;。</p><p>只是与 C 需要编译成机器码不同，CPython 需要编译成字节码 (ByteCode) 。</p><p>接下来，我们看看 Python 的动态执行相关内容。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>在采用了这种 &ldquo;动态&rdquo; 的用法后，让代码引入了某些不安定因素，例如，这些代码片段执行后可能对全局造成影响，尤其是当使用全局名称空间时，它的作用范围难以控制。</p><p>另外，对执行的效率也有影响，如上所述，Python 在执行代码之前也是要预编译的，因此这些字符串形式的代码片段在执行的时候，需要编译的过程，哪怕是使用 compile 编译后重复使用，第一次的编译是难以避免的。</p><p>当然，一般来说，一个 Python 源码都是需要进行编译的，只是有些通过 import 的模块已经是编译之后的了，实际上加载的是 pyc 的格式，此时省去了编译的过程。</p><a class=anchor id=import-过程></a><h2>import 过程 <a href=#import-%e8%bf%87%e7%a8%8b aria-hidden=true>#</a></h2><p>接下来我们看看 import 的导入过程。</p><ol><li>首先找到相应的模块，实际上就是查找 <code>builtin</code> 的模块，然后遍历 <code>sys.path</code> 的目录。</li><li>加载 pyc 或者 py 文件。<br>如果存在字节码文件，且 checksum 与当前解析器匹配，除非部分在 <code>.py</code> 文件，否则 <code>.pyc</code> 的时间戳要等于或者新于 <code>.py</code> 文件，此时会加载 <code>.pyc</code> 文件。<br>如果不满足上述条件，则会编译 <code>.py</code> 源码。</li><li>如果从文件加载，在执行代码前，会设置 <code>__file__</code>、<code>__package__</code>、<code>__path__</code> 等变量。</li><li>解析器执行模块中的代码。</li><li>将该模块插入到 <code>sys.modules</code> 中。</li></ol><p>上述是 Python 解析器加载过程，在这一过程中肯定不会使用到类似 exec 的加载方法，如果在 Python 中要进行编译加载可以通过如下方式实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; code = compile(&#39;a = 1 + 2&#39;, &#39;&lt;string&gt;&#39;, &#39;exec&#39;)
</span></span><span class=line><span class=cl>&gt;&gt;&gt; type(code)
</span></span><span class=line><span class=cl>&lt;type &#39;code&#39;&gt;
</span></span><span class=line><span class=cl>&gt;&gt;&gt; exec code
</span></span><span class=line><span class=cl>&gt;&gt;&gt; print a
</span></span><span class=line><span class=cl>3
</span></span></code></pre></div><p>上述是执行编译后的字节码，当然编译后的类型是 code，接下来看看 compile() 使用方式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>compile(source, filename, mode[, flags[, dont_inherit]])
</span></span></code></pre></div><p>该函数将 source 代码编译成字节码，然后可以通过 exec 或者 eval() 执行；filename 指定文件标示 (hits)，用来打印运行期间出错时的文件；mode 为如下的三种类型之一：</p><ul><li>eval: 配合 eval() 使用，不过只能为表达式 (expression)，表达式是由表示符 (identifiers)、常量内建类型 (literals)、数学操作符+布尔操作符 (operators)、函数调用()、下标操作[]；</li><li>exec: 配合多语句的 exec 使用，可以使用声明 (statements)，可以有 for、if 等声明语句，可以是单行或多行，当然，表达式也是声明的一种；</li><li>single: 配合单一语句的 exec 使用，常为 print、raw_input 等交互式操作。</li></ul><p>如下是表达式和声明的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1>#----- eval，表达式</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>x</span><span class=p>:</span> <span class=n>do_y</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>return</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>7</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#----- exec，声明</span>
</span></span><span class=line><span class=cl><span class=mi>3</span> <span class=o>+</span> <span class=mi>5</span>
</span></span><span class=line><span class=cl><span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>a</span><span class=o>.</span><span class=n>x</span> <span class=k>for</span> <span class=n>a</span> <span class=ow>in</span> <span class=n>some_iterable</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>yield</span> <span class=mi>7</span>
</span></span></code></pre></div><p>可以参考如下的一些与 compile() 相关的常见示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python</span>
</span></span><span class=line><span class=cl><span class=n>exec_code</span> <span class=o>=</span> <span class=nb>compile</span><span class=p>(</span> <span class=s2>&#34;&#34;&#34;for i in range(5): print &#34;iter time: </span><span class=si>%d</span><span class=s2>&#34; </span><span class=si>% i</span><span class=s2>&#34;&#34;&#34;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>,</span> <span class=s1>&#39;exec&#39;</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>exec</span><span class=p>(</span><span class=n>exec_code</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>eval_code</span> <span class=o>=</span> <span class=nb>compile</span><span class=p>(</span> <span class=s1>&#39;1+2&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;string&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;eval&#39;</span><span class=p>)</span>  <span class=c1># &#39;&lt;string&gt;&#39; or &#39;&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=nb>eval</span><span class=p>(</span><span class=n>eval_code</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>single_code</span> <span class=o>=</span> <span class=nb>compile</span><span class=p>(</span> <span class=s1>&#39;print &#34;pythoner.com&#34;; a = raw_input(&#34;input:&#34;); print a&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>,</span> <span class=s1>&#39;single&#39;</span> <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>exec</span><span class=p>(</span><span class=n>single_code</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=n>a</span>
</span></span></code></pre></div><p>当然，在通过 exec 执行的时候，也可以使用命名空间直接访问，示例如下，详细的内容后面介绍。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python</span>
</span></span><span class=line><span class=cl><span class=n>code</span> <span class=o>=</span> <span class=nb>compile</span><span class=p>(</span><span class=s1>&#39;a = 1 + 2&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;string&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;exec&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ns</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=n>exec</span> <span class=n>code</span> <span class=ow>in</span> <span class=n>ns</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=n>ns</span><span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>]</span>
</span></span></code></pre></div><a class=anchor id=使用></a><h1>使用 <a href=#%e4%bd%bf%e7%94%a8 aria-hidden=true>#</a></h1><p>包括上述的 <code>compile()</code> 函数，可以通过 <code>exec</code>、<code>execfile()</code>、<code>eval()</code>、<code>compile()</code> 动态执行一段 Python 代码。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>execfile</span><span class=p>(</span><span class=n>filename</span><span class=p>[,</span> <span class=nb>globals</span><span class=p>[,</span> <span class=nb>locals</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=nb>eval</span><span class=p>(</span><span class=n>expression</span><span class=p>[,</span> <span class=nb>globals</span><span class=p>[,</span> <span class=nb>locals</span><span class=p>]])</span>
</span></span><span class=line><span class=cl><span class=nb>compile</span><span class=p>(</span><span class=n>source</span><span class=p>,</span> <span class=n>filename</span><span class=p>,</span> <span class=n>mode</span><span class=p>[,</span> <span class=n>flags</span><span class=p>[,</span> <span class=n>dont_inherit</span><span class=p>]])</span>
</span></span></code></pre></div><p>exec 在 Python2 中是一个语法声明 (statement)，类似于 if where；在 Python3 中是一个内建函数。在 Python2 中，可以跟代码字符串、文件名、代码对象(通过compile()编译后)、元组，因为可以跟元组，导致使其看起来很像一个函数，不过该方式与 Python3 兼容。</p><p>execfile() 与 exec 相似，不过执行的是文件，与 import 的区别是：不会调用模块管理部分的代码，不会创建新的模块(module)。</p><p>eval() 是内建函数，它会解析 (parsed) 并对表达式求值 (evaluated)。与 exec 的主要区别是：eval 会返回计算结果，而 exec 只是执行；exec 可以执行很多语句，而 eval 只能进行估值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl><span class=n>exec</span><span class=p>(</span><span class=s2>&#34;a + 10&#34;</span><span class=p>)</span>               <span class=c1># works</span>
</span></span><span class=line><span class=cl><span class=c1># ret = exec(&#34;a + 10&#34;)       # error</span>
</span></span><span class=line><span class=cl><span class=n>ret</span> <span class=o>=</span> <span class=nb>eval</span><span class=p>(</span><span class=s2>&#34;a + 10&#34;</span><span class=p>)</span>         <span class=c1># works</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=n>ret</span>
</span></span></code></pre></div><p>上述两个函数均可以指定作用域。</p><a class=anchor id=作用域></a><h2>作用域 <a href=#%e4%bd%9c%e7%94%a8%e5%9f%9f aria-hidden=true>#</a></h2><p>也就是命名空间 (namespace)，包括了 local + global 。注意：对于非执行脚本的 local 空间，是不能直接通过字典修改的，所谓的 locals() 返回的字典值，实际上是从本地栈帧中提取出来的字典格式。</p><p>可以参考如下的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=nb>locals</span><span class=p>()[</span><span class=s1>&#39;a&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>23</span>             <span class=c1># try to modify a local var.</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=n>a</span>                        <span class=c1># oops, this is 23 instead of 42.</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=p>(</span><span class=nb>globals</span><span class=p>()</span> <span class=ow>is</span> <span class=nb>locals</span><span class=p>())</span>  <span class=c1># this is true.</span>
</span></span></code></pre></div><p>对于一个可执行的 python 文件，由于 locals 等价于 globals，也就导致 locals 特性与 globals 相同，可以通过字典进行修改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=ch>#!/usr/bin/env python</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>foobar</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=nb>locals</span><span class=p>()[</span><span class=s1>&#39;a&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>8</span>               <span class=c1># try to modify a local var.</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span> <span class=n>a</span>                         <span class=c1># OK, still 2</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span> <span class=p>(</span><span class=nb>globals</span><span class=p>()</span> <span class=ow>is</span> <span class=nb>locals</span><span class=p>())</span>   <span class=c1># false.</span>
</span></span><span class=line><span class=cl>    <span class=nb>globals</span><span class=p>()[</span><span class=s1>&#39;a&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>9</span>              <span class=c1># this works.</span>
</span></span><span class=line><span class=cl><span class=n>foobar</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span> <span class=n>a</span>                             <span class=c1># 9</span>
</span></span></code></pre></div><p>上述的示例是符合之前的原理的，也就是不能通过 locals() 来修改局部变量，当然也有一些方法去修改局部变量，在此就不再讨论了，可以查看 <a href>Be careful with exec and eval in Python</a>。另外需要注意的是，局部变量可以在编译时直接通过 index 定位，所以访问速度也比全局变量要快的多。</p><p>那么，在动态执行的时候，该如何指定命名空间呢？上述的 execfile()、eval() 都可以在参数中指定，当然，在 Python3 中，exec 也是个函数，所以也可以通过参数指定。</p><p>而对于 Python2 中的 exec，如果没有通过 in 指定，则使用当前域；后跟 in 选项指定一个字典时，该字典将作为 local 和 global 变量作用域；如果跟两个则分别指定 global 和 local 。</p><a class=anchor id=执行速度></a><h2>执行速度 <a href=#%e6%89%a7%e8%a1%8c%e9%80%9f%e5%ba%a6 aria-hidden=true>#</a></h2><p>编译+运行远大于直接运行的速度，这是因为解析源码然后转换为字节码的过程非常的耗时，可以通过如下的代码进行测试。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ python -s -mtimeit &#39;code = &#34;a = 2; b = 3; c = a * b&#34;&#39; &#39;exec code&#39;               # 耗时，编译+运行
</span></span><span class=line><span class=cl>$ python -s -mtimeit &#39;code = compile(&#34;a = 2; b = 3; c = a * b&#34;, &#34;&amp;lt;string&amp;gt;&#34;, &#34;exec&#34;)&#39; &#39;exec code&#39;
</span></span></code></pre></div><a class=anchor id=总结></a><h2>总结 <a href=#%e6%80%bb%e7%bb%93 aria-hidden=true>#</a></h2><p>如果一段动态代码需要执行多次，那么最好先通过 compile() 编译，然后采用空的字典作为 namespace 。</p><a class=anchor id=eval的安全性></a><h2>eval()的安全性 <a href=#eval%e7%9a%84%e5%ae%89%e5%85%a8%e6%80%a7 aria-hidden=true>#</a></h2><p>假设通过如下的脚本动态执行一个表达式，然后返回结果，我们希望用户输入的是类似 1+2 这样的表达式，但是用户可以通过如下的方式直接删掉一个数据。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat test.py
</span></span><span class=line><span class=cl>#!/usr/bin/env python
</span></span><span class=line><span class=cl>def foo():
</span></span><span class=line><span class=cl>    print &#39;this can be a dangerous function&#39;
</span></span><span class=line><span class=cl>while True:
</span></span><span class=line><span class=cl>    s = raw_input(&#34;Input expression: &#34;)
</span></span><span class=line><span class=cl>    if s == &#39;quit&#39;:
</span></span><span class=line><span class=cl>        break
</span></span><span class=line><span class=cl>    print &#34;Result is:&#34;, eval(s)
</span></span><span class=line><span class=cl>    #print &#34;Result is:&#34;, eval(s, {}, {})                                  # safer
</span></span><span class=line><span class=cl>    #print &#34;Result is:&#34;, eval(s, {&#34;__builtins__&#34;: None}, {&#34;abs&#34;: abs})    # safest
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./test.py
</span></span><span class=line><span class=cl>Input expression: __import__(&#39;os&#39;).system(&#39;dir&#39;)     # 可以执行系统命令，包括rm
</span></span><span class=line><span class=cl>Input expression: open(&#39;foobar&#39;).read()              # 可以读取文件
</span></span><span class=line><span class=cl>Input expression: globals()                          # 查看可以执行的函数，或者执行globals()
</span></span><span class=line><span class=cl>Input expression: foo()                              # 可以直接执行刚才查看到的函数
</span></span></code></pre></div><p>解决方法是在使用 <code>eval()</code> 时设置全局和局部作用域为空 <code>eval(s, {}, {})</code> ，但是此时仍然可以执行内建的函数，包括 <code>abs()</code>、<code>__import__</code>、<code>open()</code> 等。</p><p>更严厉的方法是在 globals 参数中将 <code>__builtins__</code> 设置为 None，可以使用的函数在 locals 中设置。需要注意的是，此时自定义的函数仍然可以使用通用的函数，例如上述的 foo() 还可以调用系统函数，所以同样要对参数进行检查。</p><p>详细可以参考 <a href=http://lybniz2.sourceforge.net/safeeval.html>Using eval() safely in python</a>，还可以参考 <a href=http://code.activestate.com/recipes/496746-restricted-safe-/>Restricted &ldquo;safe&rdquo; eval (Python recipe)</a> 。</p><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><p>在 <a href>Be careful with exec and eval in Python</a> 这篇文章中指出，在使用 eval 等可能会导致一些问题。</p><a class=anchor id=导致一些模块不可用></a><h2>导致一些模块不可用 <a href=#%e5%af%bc%e8%87%b4%e4%b8%80%e4%ba%9b%e6%a8%a1%e5%9d%97%e4%b8%8d%e5%8f%af%e7%94%a8 aria-hidden=true>#</a></h2><p>正常来说，函数、类是从模块中导入的，那么相应模块就会保存 <code>__module__</code> 变量，而有些模块是依赖于这一模式的，如：pickle, inspect, pkgutil, pydoc。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt;&gt;&gt; from xml.sax.saxutils import quoteattr
</span></span><span class=line><span class=cl>&gt;&gt;&gt; quoteattr.__module__
</span></span><span class=line><span class=cl>&#39;xml.sax.saxutils&#39;
</span></span><span class=line><span class=cl>&gt;&gt;&gt; pickle.loads(pickle.dumps(quoteattr))
</span></span><span class=line><span class=cl>&lt;function quoteattr at 0x1005349b0&gt;
</span></span><span class=line><span class=cl>&gt;&gt;&gt; quoteattr.__module__ = &#39;fake&#39;
</span></span><span class=line><span class=cl>&gt;&gt;&gt; pickle.loads(pickle.dumps(quoteattr))
</span></span><span class=line><span class=cl>Traceback (most recent call last):
</span></span><span class=line><span class=cl>  ..
</span></span><span class=line><span class=cl>pickle.PicklingError: Can&#39;t pickle quoteattr: it&#39;s not found as fake.quoteattr
</span></span></code></pre></div><p>现在不太确定什么场景下会触发这种情况。</p><a class=anchor id=导致对象不能回收></a><h2>导致对象不能回收 <a href=#%e5%af%bc%e8%87%b4%e5%af%b9%e8%b1%a1%e4%b8%8d%e8%83%bd%e5%9b%9e%e6%94%b6 aria-hidden=true>#</a></h2><p>在一些场景下可能会导致内存泄露。这与 Python 的垃圾回收机制有关，正常采用的是引用计数，为了解决循环引用，引入了 gc 模块，但是如果对于对象中存在 <code>__del__()</code> 方法，那么将导致对象不能回收。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat test.py
</span></span><span class=line><span class=cl>class Foo(object):
</span></span><span class=line><span class=cl>    def __del__(self):
</span></span><span class=line><span class=cl>        print &#39;Deleted&#39;
</span></span><span class=line><span class=cl>foo = Foo()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ python test.py                        # 正常执行没有问题
</span></span><span class=line><span class=cl>Deleted
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ python
</span></span><span class=line><span class=cl>&gt;&gt;&gt; execfile(&#34;test.py&#34;, {})
</span></span><span class=line><span class=cl>&gt;&gt;&gt; import gc
</span></span><span class=line><span class=cl>&gt;&gt;&gt; gc.collect()
</span></span><span class=line><span class=cl>&gt;&gt;&gt; gc.garbage                              # 会回收垃圾
</span></span></code></pre></div><p>实际上，如果通过 <code>execfile("test.py")</code> <code>execfile("test.py", {}, {})</code> 执行可以工作，其中前者采用的是当前的命名空间，但是当前的 local 和 global 是相同的；后者则分别是不同的对象。那么上述的方式是如何产生的循环依赖？估计后面可以拿工具看下。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#import-过程>import 过程</a></li></ul></li><li><a href=#使用>使用</a><ul><li><a href=#作用域>作用域</a></li><li><a href=#执行速度>执行速度</a></li><li><a href=#总结>总结</a></li><li><a href=#eval的安全性>eval()的安全性</a></li></ul></li><li><a href=#其它>其它</a><ul><li><a href=#导致一些模块不可用>导致一些模块不可用</a></li><li><a href=#导致对象不能回收>导致对象不能回收</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>