<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux 内存-用户空间 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="简单介绍下 Linux 中用户空间的内存管理，包括了内存的布局、内存申请等操作。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux 内存-用户空间</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-09-27</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/kernel/ role=button>kernel</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>简单介绍下 Linux 中用户空间的内存管理，包括了内存的布局、内存申请等操作。</p><a class=anchor id=内存布局></a><h1>内存布局 <a href=#%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80 aria-hidden=true>#</a></h1><p>关于 Linux 的内存分布可以查看内核文档 <a href=https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt>x86/x86_64/mm.txt</a>，也就是低 128T 为用户空间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0000000000000000 - 00007fffffffffff (=47 bits) user space, different per mm
</span></span></code></pre></div><p>在内核中通过 <code>TASK_SIZE_MAX</code> 宏定义，同时还减去了一个页面的大小做为保护。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define TASK_SIZE_MAX   ((1UL &lt;&lt; 47) - PAGE_SIZE)
</span></span></span></code></pre></div><p>而 <code>0xffff,8000,0000,0000</code> 以上为系统空间地址；注意：该地址的高 16bits 是 <code>0xffff</code>，这是因为目前实际上只用了 64 位地址中的 48 位，也就是高 16 位没有使用，而从地址 <code>0x0000,7fff,ffff,ffff</code> 到 <code>0xffff,8000,0000,0000</code> 中间是一个巨大的空洞，是为以后的扩展预留的。</p><p>而真正的系统空间的起始地址，是从 <code>0xffff,8800,0000,0000</code> 开始的，参见：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#define __PAGE_OFFSET     _AC(0xffff,8800,0000,0000, UL)
</span></span></span></code></pre></div><p>而 32 位地址时系统空间的起始地址为 <code>0xC000,0000</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ffff800000000000 - ffff87ffffffffff (=43 bits) guard hole, reserved for hypervisor
</span></span><span class=line><span class=cl>ffff880000000000 - ffffc7ffffffffff (=64 TB) direct mapping of all phys. memory
</span></span><span class=line><span class=cl>ffffc80000000000 - ffffc8ffffffffff (=40 bits) hole
</span></span><span class=line><span class=cl>ffffc90000000000 - ffffe8ffffffffff (=45 bits) vmalloc/ioremap space
</span></span></code></pre></div><a class=anchor id=布局详解></a><h2>布局详解 <a href=#%e5%b8%83%e5%b1%80%e8%af%a6%e8%a7%a3 aria-hidden=true>#</a></h2><p>内核中有两个参数影响了内存的布局，如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 查看当前配置
</span></span><span class=line><span class=cl>$ cat /proc/sys/vm/legacy_va_layout
</span></span><span class=line><span class=cl>$ cat /proc/sys/kernel/randomize_va_space
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 配置参数
</span></span><span class=line><span class=cl># sysctl -w vm.legacy_va_layout=0
</span></span><span class=line><span class=cl># sysctl -w kernel.randomize_va_space=2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 可以修改参数后通过如下方式测试
</span></span><span class=line><span class=cl>$ cat /proc/self/maps
</span></span><span class=line><span class=cl>00400000-0040b000 r-xp 00000000 08:07 786680                 /usr/bin/cat
</span></span><span class=line><span class=cl>0060b000-0060c000 r--p 0000b000 08:07 786680                 /usr/bin/cat
</span></span><span class=line><span class=cl>0060c000-0060d000 rw-p 0000c000 08:07 786680                 /usr/bin/cat
</span></span><span class=line><span class=cl>011ed000-0120e000 rw-p 00000000 00:00 0                      [heap]
</span></span><span class=line><span class=cl>7f924042c000-7f9246955000 r--p 00000000 08:07 793717         /usr/lib/locale/locale-archive
</span></span><span class=line><span class=cl>7f9246955000-7f9246b0c000 r-xp 00000000 08:07 793610         /usr/lib64/libc-2.17.so
</span></span><span class=line><span class=cl>7f9246b0c000-7f9246d0b000 ---p 001b7000 08:07 793610         /usr/lib64/libc-2.17.so
</span></span><span class=line><span class=cl>7f9246d0b000-7f9246d0f000 r--p 001b6000 08:07 793610         /usr/lib64/libc-2.17.so
</span></span><span class=line><span class=cl>7f9246d0f000-7f9246d11000 rw-p 001ba000 08:07 793610         /usr/lib64/libc-2.17.so
</span></span><span class=line><span class=cl>7f9246d11000-7f9246d16000 rw-p 00000000 00:00 0
</span></span><span class=line><span class=cl>7f9246d16000-7f9246d36000 r-xp 00000000 08:07 793718         /usr/lib64/ld-2.17.so
</span></span><span class=line><span class=cl>7f9246f19000-7f9246f1c000 rw-p 00000000 00:00 0
</span></span><span class=line><span class=cl>7f9246f34000-7f9246f35000 rw-p 00000000 00:00 0
</span></span><span class=line><span class=cl>7f9246f35000-7f9246f36000 r--p 0001f000 08:07 793718         /usr/lib64/ld-2.17.so
</span></span><span class=line><span class=cl>7f9246f36000-7f9246f37000 rw-p 00020000 08:07 793718         /usr/lib64/ld-2.17.so
</span></span><span class=line><span class=cl>7f9246f37000-7f9246f38000 rw-p 00000000 00:00 0
</span></span><span class=line><span class=cl>7ffd158bf000-7ffd158e0000 rw-p 00000000 00:00 0              [stack]
</span></span><span class=line><span class=cl>7ffd15945000-7ffd15947000 r-xp 00000000 00:00 0              [vdso]
</span></span><span class=line><span class=cl>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0      [vsyscall]
</span></span></code></pre></div><a class=anchor id=新旧布局></a><h3>新旧布局 <a href=#%e6%96%b0%e6%97%a7%e5%b8%83%e5%b1%80 aria-hidden=true>#</a></h3><p>不同之处在于 MMAP 区域的增长方向，新布局导致了栈空间的固定，而堆区域和 MMAP 区域公用一个空间，这在很大程度上增长了堆区域的大小。</p><p>Linux 传统内存布局如下。</p><p><img alt="memory userspace layout" src=images/memory-userspace-layout-lagency.jpg class="mx-auto d-block"></p><p>现在用户空间的内存空间布局如下。</p><p><img alt="memory userspace layout" src=images/memory-userspace-layout.jpg class="mx-auto d-block"></p><p>从上图可以看到，mmap 映射区域至顶向下扩展，mmap 映射区域和堆相对扩展，直至耗尽虚拟地址空间中的剩余区域，弥补了经典内存布局方式的不足。</p><p>为了使用此新的内存布局，执行命令 <code>sysctl -w vm.legacy_va_layout=0</code>，然后重新编译运行程序并查看其输出及 maps 文件内容。</p><a class=anchor id=内核相关></a><h2>内核相关 <a href=#%e5%86%85%e6%a0%b8%e7%9b%b8%e5%85%b3 aria-hidden=true>#</a></h2><p>利用虚拟内存，每个进程相当于占用了全部的内存空间，所有和进程相关的信息都保存在内存描述符 (memory descriptor) 中，也就是 <code>struct mm_struct *mm</code>；在进程的进程描述符 <code>struct task_struct</code> 中的 mm 域记录该进程使用的内存描述符，也就是说 <code>current->mm</code> 代表当前进程的内存描述符。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>mm_struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>vm_area_struct</span> <span class=o>*</span><span class=n>mmap</span><span class=p>;</span>            <span class=c1>// 指向内存区域对象，链表形式存放，利于高效地遍历所有元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>rb_root</span> <span class=n>mm_rb</span><span class=p>;</span>                   <span class=c1>// 与mmap表示相同，以红黑树形式存放，适合搜索指定元素
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>pgd_t</span>                 <span class=o>*</span><span class=n>pgd</span><span class=p>;</span>             <span class=c1>// 指向页目录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>atomic_t</span>               <span class=n>mm_count</span><span class=p>;</span>        <span class=c1>// 主引用计数，为0时结构体会被撤销
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>atomic_t</span>               <span class=n>mm_users</span><span class=p>;</span>        <span class=c1>// 从计数器，代表正在使用该地址的进程数目
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span>                    <span class=n>map_count</span><span class=p>;</span>       <span class=c1>// vma的数目
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>list_head</span> <span class=n>mmlist</span><span class=p>;</span>                <span class=c1>// 所有mm_struct都通过mmlist连接在一个双向链表中，
</span></span></span><span class=line><span class=cl><span class=c1></span>                                            <span class=c1>// 该链表的首元素是init_mm内存描述符，代表init进程的地址空间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><p>剩下字段中包含了该进程的代码段、数据段、堆栈、命令行参数、环境变量的起始地址和终止地址；内存描述符在系统中通过 <code>mmlist</code> 组织成了一个双向链表，这个链表的首元素是 <code>init_mm.mmlist</code> 。</p><p>其中 mm_count 和 mm_users 用来表示是否还有进程在使用该内存，这两个是比较重要的字段，决定了该进程空间是否仍被使用。</p><p>一个进程的内存空间如上图所示，其中各个内存区域通过 <code>vm_area_struct</code> 表示，类似如下所示。</p><p><img alt=memory_process_vma_lists src=images/memory_process_vma_lists.png class="mx-auto d-block"></p><p>用户进程的虚拟地址空间包含了若干区域，这些区域的分布方式是特定于体系结构的，不过所有的方式都包含下列成分：</p><ul><li>可执行文件的二进制代码，也就是程序的代码段；</li><li>存储全局变量的数据段；</li><li>用于保存局部变量和实现函数调用的栈；</li><li>环境变量和命令行参数；</li><li>程序使用的动态库的代码；</li><li>用于映射文件内容的区域。</li></ul><p>内核中的伙伴系统、SLAB 分配器都是尽快响应内核请求，而对于用户空间的请求略有不同。</p><p>用户空间动态申请内存时，往往只是获得一块线性地址的使用权，而并没有将这块线性地址区域与实际的物理内存对应上，只有当用户空间真正操作申请的内存时，才会触发一次缺页异常，这时内核才会分配实际的物理内存给用户空间。</p><a class=anchor id=结构体></a><h3>结构体 <a href=#%e7%bb%93%e6%9e%84%e4%bd%93 aria-hidden=true>#</a></h3><p>Linux 内核中，关于虚存管理的最基本的管理单元是虚拟内存区域 (Virtual Memory Areas, vma)，通过 <code>struct vm_area_struct</code> 表示，它描述了一段连续的、具有相同访问属性 (可读、可写、可执行等等) 的虚存空间，该虚存空间的大小为物理内存页面的整数倍。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>vm_area_struct</span> <span class=p>{</span>   <span class=c1>// include/linux/mm_types.h
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>mm_struct</span> <span class=o>*</span> <span class=n>vm_mm</span><span class=p>;</span>                   <span class=c1>// 反向指向该进程所属的内存描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_start</span><span class=p>,</span> <span class=n>vm_end</span><span class=p>;</span>             <span class=c1>// 虚存空间的首地址，末地址后第一个字节的地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>vm_area_struct</span> <span class=o>*</span><span class=n>vm_next</span><span class=p>,</span> <span class=o>*</span><span class=n>vm_prev</span><span class=p>;</span>   <span class=c1>// 每个进程的VM空间链表，按地址排序，用于遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>rb_node</span> <span class=n>vm_rb</span><span class=p>;</span>                       <span class=c1>// 红黑树中对应的节点，用于快速定位
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>pgprot_t</span> <span class=n>vm_page_prot</span><span class=p>;</span>                      <span class=c1>// vma的访问控制权限
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_flags</span><span class=p>;</span>                     <span class=c1>// 保护标志位和属性标志位，共享(0)还是独有(1)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=k>struct</span> <span class=n>vm_operations_struct</span> <span class=o>*</span><span class=n>vm_ops</span><span class=p>;</span>  <span class=c1>// 该vma上的各种标准操作函数指针集
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>vm_pgoff</span><span class=p>;</span>                     <span class=c1>// 文件映射偏移，以PAGE_SIZE为单位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>struct</span> <span class=n>file</span> <span class=o>*</span> <span class=n>vm_file</span><span class=p>;</span>                      <span class=c1>// 如果是文件映射，则指向文件描述符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span> <span class=n>vm_private_data</span><span class=p>;</span>                     <span class=c1>// 设备驱动私有数据，与内存管理无关
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>该结构体描述了 <code>[vm_start, vm_end)</code> 的内存空间，以字节为单位。通常，进程所使用到的虚存空间不连续，且各部分虚存空间的访问属性也可能不同，所以一个进程的虚存空间需要多个 <code>vm_area_struct</code> 结构来描述。</p><p>在 <code>vm_area_struct</code> 较少时，各个结构体按照升序排序，通过 <code>vm_next</code>、<code>vm_prev</code> 以链表的形式组织数据；但当数据较多时，实现了 AVL 树，以提高 <code>vm_area_struct</code> 的搜索速度。</p><a class=anchor id=查看进程内存空间></a><h3>查看进程内存空间 <a href=#%e6%9f%a5%e7%9c%8b%e8%bf%9b%e7%a8%8b%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4 aria-hidden=true>#</a></h3><p>可以通过 <code>cat /proc/&lt;pid>/maps</code> 或者 <code>pmap &lt;pid></code> 查看。</p><a class=anchor id=内存申请></a><h1>内存申请 <a href=#%e5%86%85%e5%ad%98%e7%94%b3%e8%af%b7 aria-hidden=true>#</a></h1><p>在用户空间中会通过 <code>malloc()</code> 动态申请内存，而实际上，在用户空间中对应了不同的实现方式，包括了 <code>ptmalloc</code> (glibc)、<code>tcmalloc</code> (Google) 以及 <code>jemalloc</code>，接下来简单介绍这三种内存分配方式。</p><p><code>ptmalloc</code> 的早期版本是由 Doug Lea 实现的，它有一个重要问题就是无法保证线程安全，Wolfram Gloger 改进了其实现从而支持多线程；TCMalloc (Thread-Caching Malloc) 是 google 开发的开源工具 <code>google-perftools</code> 之一。</p><a class=anchor id=简介></a><h2>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h2><p>从操作系统角度来看，进程分配内存有两种方式，分别由系统调用 brk() 和 mmap() 完成：</p><ol><li>brk() 是将数据段 (<code>.data</code>) 的最高地址指针 <code>_edata</code> 往高地址推；</li><li>mmap() 是在进程的虚拟地址空间中，也就是堆和栈中间 (文件映射区域) 的一块空闲虚拟内存。</li></ol><p>如上所述，这两种方式分配的都是虚拟内存，没有分配物理内存，只有在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。</p><p>在标准 C 库中，提供了 <code>malloc()</code> <code>free()</code> 分配释放内存，而这两个函数的底层是由 <code>brk()</code> <code>mmap()</code> <code>munmap()</code> 这些系统调用实现的。</p><a class=anchor id=brk-sbrk></a><h2>brk() sbrk() <a href=#brk-sbrk aria-hidden=true>#</a></h2><p>如下是两个函数的声明。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &lt;unistd.h&gt;
</span></span><span class=line><span class=cl>int brk(void *addr);
</span></span><span class=line><span class=cl>void *sbrk(intptr_t increment);
</span></span></code></pre></div><p>这两个函数都用来改变 &ldquo;program break&rdquo; 的位置，如下图所示：</p><p><img alt="memory userspace layout" src=images/memory-userspace-layout.jpg class="mx-auto d-block"></p><p>sbrk/brk 是从堆中分配空间，实际上就是移动一个位置，也就是 <code>Program Break</code>，这个位置定义了进程数据段的终止处，增大就是分配空间，减小就是释放空间。</p><p>sbrk 用相对的整数值确定位置，如果这个整数是正数，会从当前位置向后移若干字节，如果为负数就向前若干字节，为 0 时获取当前位置；而 brk 则使用绝对地址。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>**</span><span class=n>argv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>p0</span> <span class=o>=</span> <span class=nf>sbrk</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=o>*</span><span class=n>p1</span><span class=p>,</span> <span class=o>*</span><span class=n>p2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;P0 %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>brk</span><span class=p>(</span><span class=n>p0</span> <span class=o>+</span> <span class=mi>4</span><span class=p>);</span>     <span class=c1>// 分配4字节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>p1</span> <span class=o>=</span> <span class=nf>sbrk</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;P1 %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p2</span> <span class=o>=</span> <span class=nf>sbrk</span><span class=p>(</span><span class=mi>4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;P2=%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>p2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=进程加载></a><h1>进程加载 <a href=#%e8%bf%9b%e7%a8%8b%e5%8a%a0%e8%bd%bd aria-hidden=true>#</a></h1><p><code>execve()</code> 系统调用可用于加载一个可执行文件并代替当前的进程，它在 <code>libc</code> 库中有几个 API 封装：<code>execl()</code>、<code>execve()</code>、<code>execlp()</code>、<code>execvp()</code>。这几个函数的功能相同，只是参数不同，在内核中统一调用 <code>sys_execve()</code> 。</p><p>以 <code>execve()</code> 函数为例，创建一个进程，参考如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#include &lt;stdio.h&gt;
</span></span><span class=line><span class=cl>#include &lt;unistd.h&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int main(int arg,char **args)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    char *argv[]={&#34;ls&#34;, &#34;-l&#34;, &#34;/tmp&#34;, NULL};
</span></span><span class=line><span class=cl>    char *envp[]={0, NULL};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    execve(&#34;/bin/ls&#34;, argv, envp);
</span></span><span class=line><span class=cl>    return 0;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>系统为进程运行初始化环境，无非就是完成内存分配和映射以及参数和数据段、代码段和 bss 等的载入，以及对调用 exec 的旧进程进行回收。</p><p>其中有两个可执行文件相关的数据结构，分别是 <code>linux_binprm</code> 和 <code>linux_binfmt</code>，内核中为可执行程序的装入定义了一个数据结构 <code>linux_binprm</code>，以便将运行一个可执行文件时所需的信息组织在一起。</p><p>而 <code>linux_binfmt</code> 用表示每一个加载模块，这个结构在系统中组成了一个链表结构。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-v data-lang=v><span class=line><span class=cl><span class=kd>struct</span> <span class=nv>linux_binprm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>char</span> <span class=nv>buf</span><span class=p>[</span><span class=nc>BINPRM_BUF_SIZE</span><span class=p>];</span>                <span class=c1>// 保存可执行文件的头部
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>struct</span> <span class=nv>page</span> <span class=o>*</span><span class=nv>page</span><span class=p>[</span><span class=nc>MAX_ARG_PAGES</span><span class=p>];</span>         <span class=c1>// 每个参数最大使用一个物理页来存储，最大为32个页面
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>struct</span> <span class=nv>mm_struct</span> <span class=o>*</span><span class=nv>mm</span><span class=p>;</span>                     <span class=c1>// 暂时存储新进程的可执行文件名、环境变量等
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>unsigned</span> <span class=nv>long</span> <span class=nv>p</span><span class=p>;</span>                          <span class=c1>// 当前内存的起始地址
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nv>argc</span><span class=p>,</span> <span class=nv>envc</span><span class=p>;</span>                           <span class=c1>// 参数变量和环境变量的数目
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>const</span> <span class=nv>char</span> <span class=o>*</span> <span class=nv>filename</span><span class=p>;</span>                    <span class=c1>// procps查看到的名称
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nv>linux_binfmt</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>struct</span> <span class=nv>list_head</span> <span class=nv>lh</span><span class=p>;</span>                                 <span class=c1>// 用于形成一个列表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>struct</span> <span class=kn>module</span> <span class=o>*</span><span class=kn>module</span><span class=p>;</span>                               <span class=c1>// 定义该函数所属的模块
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=nv>load_binary</span><span class=p>)(</span><span class=kd>struct</span> <span class=nv>linux_binprm</span> <span class=o>*</span><span class=p>);</span>           <span class=c1>// 加载可执行文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=nv>load_shlib</span><span class=p>)(</span><span class=kd>struct</span> <span class=nv>file</span> <span class=o>*</span><span class=p>);</span>                    <span class=c1>// 加载共享库
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=nv>core_dump</span><span class=p>)(</span><span class=kd>struct</span> <span class=nv>coredump_params</span> <span class=o>*</span><span class=nv>cprm</span><span class=p>);</span>      <span class=c1>// core dump
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nv>unsigned</span> <span class=nv>long</span> <span class=nv>min_coredump</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>程序的加载主要分为两步：A) 准备阶段，将参数读如内核空间、判断可执行文件的格式、并选择相应的加载器；B) 载入阶段，完成对新进程代码段、数据段、BSS 等信息的载入。</p><a class=anchor id=进程创建></a><h2>进程创建 <a href=#%e8%bf%9b%e7%a8%8b%e5%88%9b%e5%bb%ba aria-hidden=true>#</a></h2><p>如上所述，实际调用的是内核中的 <code>sys_execve()</code> 函数，简单介绍如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>sys_execve()         @ fs/exec.c
</span></span><span class=line><span class=cl>  |-getname()                               将文件名从用户空间复制到内核空间
</span></span><span class=line><span class=cl>  | |-getname_flags()
</span></span><span class=line><span class=cl>  |  |-__getname()                          为文件名分配一个缓冲区
</span></span><span class=line><span class=cl>  |  |-strncpy_from_user()
</span></span><span class=line><span class=cl>  |   |-do_strncpy_from_user()
</span></span><span class=line><span class=cl>  |-do_execve()
</span></span><span class=line><span class=cl>    |-do_execve_common()
</span></span><span class=line><span class=cl>      |-unshare_files()
</span></span><span class=line><span class=cl>      |-do_open_exec()
</span></span><span class=line><span class=cl>      | |-do_filp_open()
</span></span><span class=line><span class=cl>      |-bprm_mm_init()                      bprm初始化，主要是bprm-&gt;mm
</span></span><span class=line><span class=cl>      | |-mm_alloc()
</span></span><span class=line><span class=cl>      | |-init_new_context()
</span></span><span class=line><span class=cl>      | |-__bprm_mm_init()
</span></span><span class=line><span class=cl>      |  |-kmem_cache_zalloc()              分配一个vma
</span></span><span class=line><span class=cl>      |  |-... ...                          设置用户空间对应的栈顶STACK_TOP_MAX
</span></span><span class=line><span class=cl>      |  |-insert_vm_struct()               将vma插入mm表示的进程空间结构
</span></span><span class=line><span class=cl>      |-count() ... ...                     计算参数个数、环境变量个数
</span></span><span class=line><span class=cl>      |-prepare_binprm()                    查看权限并加载128(BINPRM_BUF_SIZE)个字节
</span></span><span class=line><span class=cl>      | |-kernel_read()                     读取128字节
</span></span><span class=line><span class=cl>      |-search_binary_handler()             整个函数的处理核心
</span></span><span class=line><span class=cl>        |-security_bprm_check()             SELinux检查函数
</span></span><span class=line><span class=cl>        |-fmt-&gt;load_binary()                加载二进制文件，不同二进制格式对应了不同回调函数
</span></span><span class=line><span class=cl>        |-load_elf_binary()                 elf对应load_elf_binary
</span></span><span class=line><span class=cl>          |-start_thread()                  不同平台如x86会调用不同的函数
</span></span><span class=line><span class=cl>            |-start_thread_common()         主要是设置寄存器的值
</span></span></code></pre></div><p>其中有个全局变量 <code>formats</code> 作为链头，可以通过 <code>register_binfmt()</code> 注册一个可执行文件的加载模块，该模块一般在 <code>fs/binfmt_xxx.c</code> 文件中，每次加载可执行文件时只需要遍历 formats 变量即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static LIST_HEAD(formats);
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void __register_binfmt(struct linux_binfmt * fmt, int insert)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    BUG_ON(!fmt);
</span></span><span class=line><span class=cl>    if (WARN_ON(!fmt-&gt;load_binary))
</span></span><span class=line><span class=cl>        return;
</span></span><span class=line><span class=cl>    write_lock(&amp;binfmt_lock);
</span></span><span class=line><span class=cl>    insert ? list_add(&amp;fmt-&gt;lh, &amp;formats) :
</span></span><span class=line><span class=cl>         list_add_tail(&amp;fmt-&gt;lh, &amp;formats);
</span></span><span class=line><span class=cl>    write_unlock(&amp;binfmt_lock);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>static inline void register_binfmt(struct linux_binfmt *fmt)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    __register_binfmt(fmt, 0);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>在 Linux 中最常用的是 ELF 为例，启动时通过 <code>core_initcall(init_elf_binfmt)</code> 初始化。</p><a class=anchor id=内存复制></a><h2>内存复制 <a href=#%e5%86%85%e5%ad%98%e5%a4%8d%e5%88%b6 aria-hidden=true>#</a></h2><p>在调用 <code>fork()</code> 函数时，会通过 <code>copy_mm()</code> 复制父进程的内存描述符，子进程通过 <code>allcote_mm()</code> 从高速缓存中分配 <code>struct mm_struct</code> 得到。通常，每个进程都有唯一的 <code>struct mm_struct</code>，即唯一的进程地址空间。</p><p>当子进程与父进程是共享地址空间，可调用 <code>clone()</code> 此时不再调用 <code>allcote_mm()</code>，而是仅仅是将 mm 域指向父进程的 mm ，即 <code>task->mm = current->mm</code> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#内存布局>内存布局</a><ul><li><a href=#布局详解>布局详解</a></li><li><a href=#内核相关>内核相关</a></li></ul></li><li><a href=#内存申请>内存申请</a><ul><li><a href=#简介>简介</a></li><li><a href=#brk-sbrk>brk() sbrk()</a></li></ul></li><li><a href=#进程加载>进程加载</a><ul><li><a href=#进程创建>进程创建</a></li><li><a href=#内存复制>内存复制</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>