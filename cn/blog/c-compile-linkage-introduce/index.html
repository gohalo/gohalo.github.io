<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>C 编译链接 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="详细介绍下与 C 语言相关的概念。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>C 编译链接</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2016-10-23</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/c/cpp/ role=button>c/cpp</a></div></div><hr><div class=content><p>详细介绍下与 C 语言相关的概念。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>在程序由源码到可执行文件的编译过程实际有预处理 (Propressing)、编译 (Compilation)、汇编 (Assembly) 和链接 (Linking) 四步，在 <code>gcc</code> 中分别通过 <code>ccp</code> <code>cc1</code> <code>as</code> <code>ld</code> 四个命令来完成。</p><p><img alt="compile link gcc details" src=images/compile-link-gcc-details.jpg class="mx-auto d-block"></p><p>如下详细介绍编译连接的过程。</p><a class=anchor id=预编译></a><h2>预编译 <a href=#%e9%a2%84%e7%bc%96%e8%af%91 aria-hidden=true>#</a></h2><p>将源代码和头文件通过预编译成一个 <code>.i</code> 文件，相当与如下命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -E main.c -o main.i          # C
</span></span><span class=line><span class=cl>$ cpp main.c &gt; main.i              # CPP
</span></span></code></pre></div><p>与编译主要是处理源码中以 <code>"#"</code> 开始的与编译指令，主要的处理规则是：</p><ul><li>删除所有的 <code>"#define"</code> ，并且展开所有的宏定义。</li><li>处理所有条件预编译指令，比如 <code>"#if"</code>、<code>"#ifdef"</code>、<code>"#elif"</code>、<code>"#else"</code>、<code>"#endif"</code> 。</li><li>处理 <code>"#include"</code> ，将被包含的文件插入到该预编译指令的位置，该过程是递归的。</li><li>删除多有的注释 <code>"//"</code> 和 <code>"/* */"</code> 。</li><li>添加行号和文件名标识，如 <code>#2 "main.c" 2</code> ，用于编译时产生调试用的行号以及在编译时产生错误或警告时显示行号。</li><li>保留所有的 <code>"#pragma"</code> 编译器指令，因为编译器需要使用它们。</li></ul><p>经过预编译后的 <code>.i</code> 文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 <code>.i</code> 文件中。所以，当无法判断宏定义是否正确或头文件包含是否正确时，可以查看该文件。</p><a class=anchor id=编译></a><h2>编译 <a href=#%e7%bc%96%e8%af%91 aria-hidden=true>#</a></h2><p>编译过程就是把预处理后的文件进行一系列的词法分析、语法分析、语义分析以及优化后生成相应的汇编代码文件，这个是核心部分，也是最复杂的部分。</p><p>gcc 把预编译和编译合并成一个步骤，对于 C 语言使用的是 <code>cc1</code> ，C++ 使用的是 <code>cc1obj</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -S hello.i -o hello.s
</span></span><span class=line><span class=cl>$ gcc -S main.c -o main.s
</span></span></code></pre></div><a class=anchor id=汇编></a><h2>汇编 <a href=#%e6%b1%87%e7%bc%96 aria-hidden=true>#</a></h2><p>汇编器是将汇编代码转化成机器码，每条汇编语句几乎都对应一条机器指令。汇编器不需要复杂的语法语义，也不用进行指令优化，只是根据汇编指令和机器指令的对照表一一翻译即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -c hello.s -o hello.o
</span></span><span class=line><span class=cl>$ as main.s -o main.o
</span></span><span class=line><span class=cl>$ gcc -c main.s -o main.o
</span></span><span class=line><span class=cl>$ gcc -c main.c -o main.o
</span></span></code></pre></div><a class=anchor id=链接></a><h2>链接 <a href=#%e9%93%be%e6%8e%a5 aria-hidden=true>#</a></h2><p>可以通过 <code>gcc hello.c -o hello -v</code> 查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc hello.o -o hello.exe
</span></span></code></pre></div><p>尽量不要直接使用 <code>ld</code> 命令，如果通过 <code>-v</code> 参数查看详细的命令，可以看到最终链接是通过 <code>collect2</code> 完成的 (是对 <code>ld</code>x 的封装)，而且包含了很多类似 <code>crt1.o</code> <code>crti.o</code> 这类的依赖。</p><a class=anchor id=静态链接库></a><h1>静态链接库 <a href=#%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%ba%93 aria-hidden=true>#</a></h1><p>库有动态与静态两种，Linux 中动态通常用 <code>.so</code> 为后缀，静态用 <code>.a</code> 为后缀，如：<code>libhello.so</code> <code>libhello.a</code>，静态链接库实际上就是将各个 <code>.o</code> 文件打包合并。</p><p>使用静态链接库时，连接器会找出程序所需的函数，然后将它们拷贝到执行文件，一旦连接成功，静态程序库也就不再需要了，缺点是占用的空间比较大，但是执行速度要快一些。</p><a class=anchor id=示例></a><h2>示例 <a href=#%e7%a4%ba%e4%be%8b aria-hidden=true>#</a></h2><p>如果编译时使用静态库，那么所有依赖的基础库都需要安装静态版本，否则链接会失败，例如对于 <code>libc</code> 基础库，在 CentOS 中可以通过 <code>yum install glibc-static</code> 命令安装。</p><p>现在假设有一个 hello 程序开发包，它提供一个静态库 <code>libhello.a</code>，一个动态库 <code>libhello.so</code>，一个头文件 <code>hello.h</code>，头文件中提供 <code>foobar()</code> 这个函数的声明。</p><p>下面这段程序 <code>main.c</code> 使用 hello 库中的 <code>foobar()</code> 函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename: foobar.c */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;hello.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foobar</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>puts</span><span class=p>(</span><span class=s>&#34;FooBar!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename: hello.c */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;hello.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>hello</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>puts</span><span class=p>(</span><span class=s>&#34;Hello world!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename: hello.h */</span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef _HELLO_H__
</span></span></span><span class=line><span class=cl><span class=cp>#define _HELLO_H__
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>hello</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foobar</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* filename: main.c */</span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;hello.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>foobar</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=nf>hello</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当生成静态库时，需要先对源文件进行编译，然后使用 <code>ar(archive)</code> 命令连接成静态库。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -c hello.c -o hello.o
</span></span><span class=line><span class=cl>$ gcc -c foobar.c -o foobar.o
</span></span><span class=line><span class=cl>$ ar crv libhello.a hello.o foobar.o
</span></span><span class=line><span class=cl>$ ar -t libhello.a                              // 查看打包的文件
</span></span></code></pre></div><p><code>ar</code> 实际是一个打包工具，可以用来打包常见文件，不过现在被 <code>tar</code> 替代，目前主要是用于生成静态库，详细格式可以参考 <a href=http://en.wikipedia.org/wiki/Ar_(Unix)>ar(Unix) wiki</a> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ echo &#34;hello&#34; &gt; a.txt &amp;&amp; echo &#34;world&#34; &gt; b.txt
</span></span><span class=line><span class=cl>$ ar crv text.a a.txt b.txt
</span></span><span class=line><span class=cl>$ cat text.a
</span></span></code></pre></div><p>在与静态库连接时，需要指定库的路径，默认不会将当前目录添加到搜索目录中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc main.c -o test -lhello                    // 库在默认路径下，如/usr/lib
</span></span><span class=line><span class=cl>$ gcc main.c -lhello -L. -static -o main        // 通过-L指定库的路径
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ gcc main.o -o main -WI,-Bstatic -lhello       // 报错，显示找不到-lgcc_s
</span></span></code></pre></div><p>注意：这个特别的 <code>"-WI,-Bstatic"</code> 参数，实际上是传给了连接器 <code>ld</code>，指示它与静态库连接，如果系统中只有静态库可以不需要这个参数； 如果要和多个库相连接，而每个库的连接方式不一样，比如上面的程序既要和 <code>libhello</code> 进行静态连接，又要和 <code>libbye</code> 进行动态连接，其命令应为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc testlib.o -o test -WI,-Bstatic -lhello -WI,-Bdynamic -lbye
</span></span></code></pre></div><p>最好不要进行分别编译、链接，因为在生成可执行文件时往往需要很多的其他文件，可以通过 <code>-v</code> 选项进行查看，如果通过如下方式进行编译通常会出现错误。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -c main.c
</span></span><span class=line><span class=cl>$ ld main.o -L. -lhello
</span></span></code></pre></div><a class=anchor id=命令行参数></a><h2>命令行参数 <a href=#%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%8f%82%e6%95%b0 aria-hidden=true>#</a></h2><p>相关的参数如下：</p><ul><li><code>x</code> 拆解静态库，也就是将 <code>*.a</code> 拆解为 <code>*.o</code> 文件。</li><li><code>c</code> 封装创建静态库。</li><li><code>r</code> 覆盖或者新建静态库。</li><li><code>s</code> 相当于对结果执行一次 ranlib 操作，添加索引提高访问效率。</li><li><code>T</code> 是 <code>--thin</code> 别名，对应的是文件链接，从而可以减小文件大小，也就是 Thin Archive。</li></ul><p>正常通过上述的 <code>ar crv libhello.a hello.o foobar.o</code> 命令会将所有的 <code>*.o</code> 文件打包，此时文件会比较大，还可以通过 <code>ar crvT</code> 保存的会是文件链接信息，从而文件要小很多。</p><p>注意，例如 <a href=/cn/blog/rust-ffi-rust-invoke-c/>Rust 调用 C</a> 是无法支持 <code>Thin Archive</code> 的。</p><a class=anchor id=链接顺序></a><h2>链接顺序 <a href=#%e9%93%be%e6%8e%a5%e9%a1%ba%e5%ba%8f aria-hidden=true>#</a></h2><p>当一个项目中有多个静态库时，就可能会由于链接顺序不同导致 <code>undefined reference</code> 的报错，而实际上符号是有定义的，其根本原因是由于符号的查找算法引起的。</p><p>链接器查找符号针对的是单个目标文件 <code>.o</code> ，而非整个静态库，如果在某个目标文件中找到了所需的符号，那么就会将整个目标文件单独从静态库中提取出来，而非将整个链接库添加。</p><p>链接器在工作过程中，维护 3 个列表：A) 需要参与连接的目标文件列表 E；B) 一个未解析符号列表 U；C) 一个在 E 中所有目标文件定义过的所有符号列表 D 。</p><a class=anchor id=动态链接库></a><h1>动态链接库 <a href=#%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e5%ba%93 aria-hidden=true>#</a></h1><p>动态链接就是在程序运行时对符号进行重定位，确定符号对应的内存地址的过程，默认采用的是 Lazy Mode ，只解析那些用得到的符号，如果不需要就不会查找。</p><a class=anchor id=依赖库></a><h2>依赖库 <a href=#%e4%be%9d%e8%b5%96%e5%ba%93 aria-hidden=true>#</a></h2><p>ELF 文件有一个特别的 Section <code>.dynamic</code>，存放了和动态链接相关的很多信息，例如动态链接器通过它找到该文件使用的动态链接库。</p><p>通过 <code>readelf -d | grep NEEDED</code> 可以找到该文件直接依赖的库，如果要查看所有依赖的库，那么可以通过 <code>ldd</code> 命令查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ readelf -d /bin/bash | grep NEED
</span></span><span class=line><span class=cl> 0x0000000000000001 (NEEDED)             Shared library: [libtinfo.so.6]
</span></span><span class=line><span class=cl> 0x0000000000000001 (NEEDED)             Shared library: [libdl.so.2]
</span></span><span class=line><span class=cl> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ldd /bin/bash
</span></span><span class=line><span class=cl>        linux-vdso.so.1 (0x00007ffd2438a000)
</span></span><span class=line><span class=cl>        libtinfo.so.6 =&gt; /lib64/libtinfo.so.6 (0x00007fe7d3745000)
</span></span><span class=line><span class=cl>        libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007fe7d3541000)
</span></span><span class=line><span class=cl>        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007fe7d317e000)
</span></span><span class=line><span class=cl>        /lib64/ld-linux-x86-64.so.2 (0x00007fe7d3c90000)
</span></span></code></pre></div><p>其中 <code>linux-vdso.so.1</code> 是一个虚拟的动态链接库，对应进程内存映像的内核部分，而 <code>/lib/ld-linux-x86_64.so.2</code> 正好是动态链接器，系统需要用它来进行符号重定位。</p><p>而链接器实际上是在 <code>.interp</code> 中指定的，使用的是绝对路径，会先被装载到内存中，然后由该文件再加载其它动态库。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ readelf -p .interp /bin/bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>String dump of section &#39;.interp&#39;:
</span></span><span class=line><span class=cl>  [     0]  /lib64/ld-linux-x86-64.so.2
</span></span></code></pre></div><a class=anchor id=路径问题></a><h2>路径问题 <a href=#%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98 aria-hidden=true>#</a></h2><p>如果动态库不在搜索路径中，则会报 <code>cannot open shared object file: No such file or directory</code> 的错误。可以通过 <code>gcc --print-search-dirs</code> 命令查看默认的搜索路径。</p><p>查找顺序通常为：</p><ol><li>查找程序编译指定的路径，保存在 <code>.dynstr</code> 段，其中包含了一个以冒号分割的目录搜索列表。</li><li>查找环境变量 <code>LD_LIBRARY_PATH</code>，以冒号分割的目录搜索列表。</li><li>查找 <code>/etc/ld.so.conf</code> 。</li><li>默认路径 <code>/lib</code> 和 <code>/usr/lib</code> 。</li></ol><p>为了让执行程序顺利找到动态库，有三种方法：</p><a class=anchor id=1-复制到指定路径></a><h4>1. 复制到指定路径 <a href=#1-%e5%a4%8d%e5%88%b6%e5%88%b0%e6%8c%87%e5%ae%9a%e8%b7%af%e5%be%84 aria-hidden=true>#</a></h4><p>把库拷贝到查找路径下，通常为 <code>/usr/lib</code> 和 <code>/lib</code> 目录下，或者通过 <code>gcc --print-search-dirs</code> 查看动态库的搜索路径。</p><a class=anchor id=2-添加链接选项></a><h4>2. 添加链接选项 <a href=#2-%e6%b7%bb%e5%8a%a0%e9%93%be%e6%8e%a5%e9%80%89%e9%a1%b9 aria-hidden=true>#</a></h4><p>编译时添加链接选项，指定链接库的目录，此时会将该路径保存在二进制文件中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -o test test.o -L. -lhello -Wl,-rpath,/home/lib:.
</span></span><span class=line><span class=cl>$ readelf -d test | grep RPATH
</span></span><span class=line><span class=cl>$ objdump -s -j .dynstr test                     // 查看.dynstr段的内容
</span></span></code></pre></div><a class=anchor id=3-设置环境变量></a><h4>3. 设置环境变量 <a href=#3-%e8%ae%be%e7%bd%ae%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f aria-hidden=true>#</a></h4><p>执行时在 <code>LD_LIBRARY_PATH</code> 环境变量中加上库所在路径，例如动态库 <code>libhello.so</code> 在 <code>/home/test/lib</code> 目录下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/test/lib
</span></span></code></pre></div><a class=anchor id=4-修改配置文件></a><h4>4. 修改配置文件 <a href=#4-%e4%bf%ae%e6%94%b9%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 aria-hidden=true>#</a></h4><p>修改 <code>/etc/ld.so.conf</code> 文件，把库所在的路径加到文件中，并执行 <code>ldconfig</code> 刷新配置。动态链接库通常保存在 <code>/etc/ld.so.cache</code> 文件中，执行 <code>ldconfig</code> 可以对其进行刷新。</p><a class=anchor id=版本管理></a><h2>版本管理 <a href=#%e7%89%88%e6%9c%ac%e7%ae%a1%e7%90%86 aria-hidden=true>#</a></h2><p>对于共享库更新时通常会有兼容更新和不兼容更新，其实指的是二进制接口 (Application Binary Interface, ABI)，为了保证共享库的兼容性， Linux 采用一套规则来命名系统中的共享库。</p><p>实际上就是语意版本，其规则如下 <code>libname.so.x.y.z</code>，<code>name</code> 库名称，<code>x</code> <code>y</code> <code>z</code> 含义如下：</p><ul><li><code>x</code> 主版本号(Major Version Number)，重大升级，不同主版本不兼容。</li><li><code>y</code> 次版本号(Minor Version Number)，增量升级，增加了新接口，且保持原符号不变。</li><li><code>z</code> 发布版本号(Release Version Number)，错误修正、性能改进等，不添加、不修改接口。</li></ul><p>由于历史的原因最基本的 C 语言库 glibc 动态链接库不使用这种规则，如 <code>libc-x.y.z.so</code> 、<code>ld-x.y.z.so</code> ，在 <a href=https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/browndavid/browndavid_html/>Library Interface Versioning in Solaris and Linux</a> 中，对 Salaris 和 Linux 的共享库版本机制和符号版本机制做了非常详细的介绍。</p><p>在 Linux 中采用 SO-NAME 的命名机制，每个库会对应一个 SO-NAME ，这个 SO-NAME 只保留主版本号，也即 SO-NAME 规定了共享库的接口。为了在同一系统中使用不同版本的库，可以在库文件名后加上版本号为后缀，例如：<code>libhello.so.1.0</code>，然后，使用时通过符号链接指向不同版本。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># ln -s libhello.so.1.0 libhello.so.1
</span></span><span class=line><span class=cl># ln -s libhello.so.1 libhello.so
</span></span></code></pre></div><a class=anchor id=示例程序></a><h2>示例程序 <a href=#%e7%a4%ba%e4%be%8b%e7%a8%8b%e5%ba%8f aria-hidden=true>#</a></h2><p>通过 <code>-fPIC</code> 参数生成与位置无关的代码，这样允许在任何地址被连接和装载。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -c -fPIC hello.c -o hello.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ gcc -shared -Wl,-soname,libhello.so.1 -o libhello.so.1.0 hello.o // 生成动态库，可能存在多个版本，通常指定版本号
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ln -s libhello.so.1.0 libhello.so.1                           // 另外再建立两个符号连接
</span></span><span class=line><span class=cl>$ ln -s libhello.so.1 libhello.so
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ gcc -fPIC -shared -o libhello.so hello.c                         // 当然对于上述的步骤可以通过一步完成
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ readelf -d libhello.so.1.0 | grep SONAME                         // 查看对应的soname
</span></span><span class=line><span class=cl>$ nm -D libhello.so                                                // 查看符号
</span></span></code></pre></div><p>最重要的是传 <code>-shared</code> 参数使其生成是动态库而不是普通执行程序； <code>-Wl</code> 表示后面的参数也就是 <code>-soname,libhello.so.1</code> 直接传给连接器 <code>ld</code> 进行处理。</p><p>实际上，每一个库都有一个 <code>soname</code> ，当连接器发现它正在查找的程序库中有这样一个名称，连接器便会将 <code>soname</code> 嵌入连结中的二进制文件内，而不是它正在运行的实际文件名，在程序执行期间，程序会查找拥有 <code>soname</code> 名字的文件，而不是库的文件名，换句话说，<code>soname</code> 是库的区分标志。</p><p>其目的主要是允许系统中多个版本的库文件共存，习惯上在命名库文件的时候通常与 <code>soname</code> 相同 <code>libxxxx.so.major.minor</code> 其中，<code>xxxx</code> 是库的名字， <code>major</code> 是主版本号， <code>minor</code> 是次版本号。</p><a class=anchor id=动态库加载api></a><h1>动态库加载API <a href=#%e5%8a%a8%e6%80%81%e5%ba%93%e5%8a%a0%e8%bd%bdapi aria-hidden=true>#</a></h1><p>对于 Linux 下的可执行文件 ELF 使用如下命令查看，可以发现其中有一个 <code>.interp</code> 段，它指明了将要被使用的动态链接器 (<code>/lib/ld-linux.so</code>)。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ readelf -l EXECUTABLE
</span></span></code></pre></div><p>动态加载函数主要包括了下面的四个，依赖 <code>dlfcn.h</code> 头文件，定义在 <code>libdl.so</code> 库中。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>void *dlopen( const char *file, int mode );
</span></span><span class=line><span class=cl>  用来打开一个文件，使对象文件可被程序访问，同时还会自动解析共享库中的依赖项，这样，如果打开了一个
</span></span><span class=line><span class=cl>    依赖于其他共享库的对象，它就会自动加载它们，该函数返回一个句柄，该句柄用于后续的 API 调用。
</span></span><span class=line><span class=cl>  mode 参数通知动态链接器何时执行再定位，有两个可能的值：
</span></span><span class=line><span class=cl>    A) RTLD_NOW，表明动态链接器将会在调用 dlopen 时完成所有必要的再定位；
</span></span><span class=line><span class=cl>    B) RTLD_LAZY，只在需要时执行再定位。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void *dlsym( void *restrict handle, const char *restrict name );
</span></span><span class=line><span class=cl>  通过句柄和连接符名称获取函数名或者变量名。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>char *dlerror();
</span></span><span class=line><span class=cl>  返回一个可读的错误字符串，该函数没有参数，它会在发生前面的错误时返回一个字符串，在没有错误发生时返回NULL。
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>char *dlclose( void *handle ); 
</span></span><span class=line><span class=cl>  通知操作系统不再需要句柄和对象引用了。它完全是按引用来计数的，所以同一个共享对象的多个用户相互间
</span></span><span class=line><span class=cl>    不会发生冲突（只要还有一个用户在使用它，它就会待在内存中）。
</span></span><span class=line><span class=cl>    任何通过已关闭的对象的 dlsym 解析的符号都将不再可用。
</span></span></code></pre></div><p>有了 ELF 对象的句柄，就可以通过调用 dlsym 来识别这个对象内的符号的地址了。该函数采用一个符号名称，如对象内的一个函数的名称，返回值为对象符号的解析地址。</p><a class=anchor id=示例-1></a><h2>示例 <a href=#%e7%a4%ba%e4%be%8b-1 aria-hidden=true>#</a></h2><p>下面是一个动态加载的示例 [github libdl.c]({{ site.example_repository }}/c_cpp/c/libdl.c)，通过如下的命令进行编译，其中选项 <code>-rdynamic</code> 用来通知链接器将所有符号添加到动态符号表中（目的是能够通过使用 dlopen 来实现向后跟踪）。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ gcc -rdynamic -o dl library_libdl.c -ldl        # 编译
</span></span><span class=line><span class=cl>$ ./dl                                            # 测试
</span></span><span class=line><span class=cl>&gt; libm.so cosf 0.0
</span></span><span class=line><span class=cl>   1.000000
</span></span><span class=line><span class=cl>&gt; libm.so sinf 0.0
</span></span><span class=line><span class=cl>   0.000000
</span></span><span class=line><span class=cl>&gt; libm.so tanf 1.0
</span></span><span class=line><span class=cl>   1.557408
</span></span><span class=line><span class=cl>&gt; bye
</span></span></code></pre></div><p>另外，可以通过如下方式简单使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ cat caculate.c                                     # 查看动态库源码
</span></span><span class=line><span class=cl>int add(int a, int b) {
</span></span><span class=line><span class=cl>    return (a + b);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>int sub(int a, int b) {
</span></span><span class=line><span class=cl>    return (a - b);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>$ gcc -fPIC -shared caculate.c -o libcaculate.so     # 生成动态库
</span></span><span class=line><span class=cl>$ cat foobar.c                                       # 测试源码
</span></span><span class=line><span class=cl>#include &lt;stdio.h&gt;
</span></span><span class=line><span class=cl>#include &lt;dlfcn.h&gt;
</span></span><span class=line><span class=cl>#include &lt;stdlib.h&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>typedef int (*CAC_FUNC)(int, int);                           // 定义函数指针类型
</span></span><span class=line><span class=cl>int main(int argc, char** argv) {
</span></span><span class=line><span class=cl>    void *handle;
</span></span><span class=line><span class=cl>    char *error;
</span></span><span class=line><span class=cl>    CAC_FUNC cac_func = NULL;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    if ( !(handle=dlopen(&#34;./libcaculate.so&#34;, RTLD_LAZY)) ) { // 打开动态链接库
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;!!! %s\n&#34;, dlerror());
</span></span><span class=line><span class=cl>        exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    cac_func = dlsym(handle, &#34;add&#34;);                         // 获取一个函数
</span></span><span class=line><span class=cl>    if ((error = dlerror()) != NULL)  {
</span></span><span class=line><span class=cl>        fprintf(stderr, &#34;!!! %s\n&#34;, error);
</span></span><span class=line><span class=cl>        exit(EXIT_FAILURE);
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>    printf(&#34;add: %d\n&#34;, (cac_func)(2,7));
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    dlclose(handle);                                         // 关闭动态链接库
</span></span><span class=line><span class=cl>    exit(EXIT_SUCCESS);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>$ gcc -rdynamic -o foobar foobar.c -ldl              # 编译测试
</span></span></code></pre></div><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><a class=anchor id=not-a-dynamic-executable></a><h2>not a dynamic executable <a href=#not-a-dynamic-executable aria-hidden=true>#</a></h2><p>一般是由于不同的平台导致，例如在 x86 上查看 arm，或者在 64 位机器上查看 32 位。</p><p><code>ldd</code> 命令会通过默认的解析器进行解析，一般来说为 <code>ld-linux-aarch64.so.1</code> 或者 <code>ld-linux-x86-64.so.2</code> 。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ readelf -l &lt;EXEC_FILE&gt; | grep &#39;program interpreter&#39;
</span></span></code></pre></div><p>如果存在 <code>locate</code> 命令，可以直接通过 <code>locate ld-linux</code> 查找当前机器所有类似文件。注意，可以通过 <code>updatedb</code> 更新。</p><p>而这个二进制文件所支持的平台可以通过 <code>file &lt;EXEC_FILE></code> 或者 <code>readelf -h &lt;EXEC_FILE></code> 命令查看。</p><a class=anchor id=库版本></a><h2>库版本 <a href=#%e5%ba%93%e7%89%88%e6%9c%ac aria-hidden=true>#</a></h2><p>如果在高版本机器上编译二进制文件，然后复制到低版本 (主要是动态库) 上执行，那么就可能会出现类似 <code>version 'GLIBC_2.12' not found</code> 的报错，完整报错信息如下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt;EXEC_NAME&gt;: /lib64/libpthread.so.0: version `GLIBC_2.12&#39; not found (required by &lt;EXEC_NAME&gt;)
</span></span></code></pre></div><p>这里就是因为依赖的 glibc 版本太低导致，通过 <code>strings /lib64/libc.so.6 | grep GLIBC</code> 查看当前库支持版本号，最高版本可以通过 <code>ldd --verion</code> 或者 <code>/lib64/libc.so.6</code> 查看。</p><p>最简单的，就是在编译的时候只依赖低版本的 glibc ，这样在高版本上也可以使用。</p><a class=anchor id=原因></a><h3>原因 <a href=#%e5%8e%9f%e5%9b%a0 aria-hidden=true>#</a></h3><p>从 <code>glibc 2.1</code> 开始，引入了 <a href=https://akkadia.org/drepper/symbol-versioning>Symbol Versioning</a> 的机制，每个符号都会对应一个版本号，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ nm /lib64/libc.so.6 | grep &#34; memcpy&#34;
</span></span></code></pre></div><p>当前二进制文件所有依赖的版本号，可以通过如下命令查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ nm &lt;exec file&gt; | awk -F &#39;@&#39; &#39;/@@GLIBC/{ print $3}&#39; | sort -t. -k 2 -nur
</span></span></code></pre></div><p>当在一台高版本 glibc 上编译包是无法在一个低版本 glibc 的机器上运行的，通常有几种办法：A) 升级 glibc 库；B) 重新在低版本 glibc 上编译；C) 修改二进制文件；</p><a class=anchor id=杂项></a><h2>杂项 <a href=#%e6%9d%82%e9%a1%b9 aria-hidden=true>#</a></h2><a class=anchor id=1-静态库生成动态库></a><h3>1. 静态库生成动态库 <a href=#1-%e9%9d%99%e6%80%81%e5%ba%93%e7%94%9f%e6%88%90%e5%8a%a8%e6%80%81%e5%ba%93 aria-hidden=true>#</a></h3><p>可以通过多个静态库生成动态库，而实际上静态库是一堆 <code>.o</code> 库的压缩集合，而生成动态库需要保证 <code>.o</code> 编译后是与地址无关的，也就是添加 <code>-fPIC</code> 参数。</p><a class=anchor id=2-关于-preload></a><h3>2. 关于 PreLoad <a href=#2-%e5%85%b3%e4%ba%8e-preload aria-hidden=true>#</a></h3><p>正常来说 <code>ld-linux(8)</code> 会查找一个程序需要加载的库，然后解析执行，通过 <code>LD_PRELOAD</code> 或者 <code>/etc/ld.so.preload</code> 可以提前加载一些动态库。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#预编译>预编译</a></li><li><a href=#编译>编译</a></li><li><a href=#汇编>汇编</a></li><li><a href=#链接>链接</a></li></ul></li><li><a href=#静态链接库>静态链接库</a><ul><li><a href=#示例>示例</a></li><li><a href=#命令行参数>命令行参数</a></li><li><a href=#链接顺序>链接顺序</a></li></ul></li><li><a href=#动态链接库>动态链接库</a><ul><li><a href=#依赖库>依赖库</a></li><li><a href=#路径问题>路径问题</a></li><li><a href=#版本管理>版本管理</a></li><li><a href=#示例程序>示例程序</a></li></ul></li><li><a href=#动态库加载api>动态库加载API</a><ul><li><a href=#示例-1>示例</a></li></ul></li><li><a href=#其它>其它</a><ul><li><a href=#not-a-dynamic-executable>not a dynamic executable</a></li><li><a href=#库版本>库版本</a></li><li><a href=#杂项>杂项</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>