<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>通过 OpenSSL 制作自签名证书 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="一般来说，在互联网上使用 HTTPS 时，需要向一些官方的 CA 中心申请证书，不过一般来说比较贵。如果只是公司内部使用，那么就可以自己制作证书，当然也可以模拟 CA 的方式管理证书。
这里详细介绍如何使用 OpenSSL 制作自签名证书，包括了自建 CA 的方式。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>通过 OpenSSL 制作自签名证书</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2020-09-12</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/security/ role=button>security</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/tls/ssl/ role=button>tls/ssl</a></div></div><hr><div class=content><p>一般来说，在互联网上使用 HTTPS 时，需要向一些官方的 CA 中心申请证书，不过一般来说比较贵。如果只是公司内部使用，那么就可以自己制作证书，当然也可以模拟 CA 的方式管理证书。</p><p>这里详细介绍如何使用 OpenSSL 制作自签名证书，包括了自建 CA 的方式。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>使用自签名证书的时候，有两种方式：A) 直接生成证书；B) 自建 CA 的根证书，并以此颁发证书。一般建议使用后者，因为前者颁发完之后无法撤销，所以就只能坐等过期了，而后者可以进行撤销。</p><p>在制作证书时，基本上会分成三类操作：</p><ol><li>创建私钥 (可选)，需要严格保存，建议使用密码进行保护，尤其是根证书、中间证书。</li><li>创建证书请求文件 CSR ，用来构建中间证书以及服务器证书请求，然后再通过上级证书签名等。</li><li>使用证书对请求颁发证书，一般是作签名。</li></ol><p>上述的操作会在不同的步骤中执行，而其中创建私钥一般会和其它两步配合执行，而且可以省略。</p><a class=anchor id=查看证书></a><h2>查看证书 <a href=#%e6%9f%a5%e7%9c%8b%e8%af%81%e4%b9%a6 aria-hidden=true>#</a></h2><p>制作证书之前，先看看通过 OpenSSL 的命令如何查看证书信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 查看证书请求文件CSR，对于PEM格式以-----BEGIN CERTIFICATE REQUEST-----开头
</span></span><span class=line><span class=cl>openssl req -noout -text -in cert.csr
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 查看x509格式的证书信息，对于PEM格式以-----BEGIN CERTIFICATE-----开头
</span></span><span class=line><span class=cl>openssl x509 -noout -text -in selfsign.crt
</span></span></code></pre></div><p>在打印时，也可以将 <code>-text</code> 参数替换掉，查看具体的信息，例如 <code>-dates</code> 过期时间，<code>-serial</code> 证书序列号，<code>-subject</code> 拥有者信息等等，详细的查看 <code>man openssl-x509</code> 信息。</p><a class=anchor id=配置文件></a><h1>配置文件 <a href=#%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 aria-hidden=true>#</a></h1><p>在后面使用命令时，除了直接使用命令行参数外，还可以指定配置文件。</p><p>OpenSSL 的配置文件以 INI 格式保存，也就是通过 <code>[Section Name]</code> 标识段的名称，各个配置项通过 <code>Key=Value</code> 的格式保存，注释为 <code>#</code> 开头的行。在 CentOS 中，默认的 OpenSSL 配置文件路径为 <code>/etc/pki/tls/openssl.cnf</code> 。</p><p>配置文件包括了证书请求、签名等相关的设置，主要用于子命令 <code>ca</code> <code>req</code>，而 <code>x509</code> 子命令不会使用配置文件。</p><p>该文件从功能上来看，主要是针对 <code>ca</code> 和 <code>req</code> 子命令的配置段，另外，配置中的段可以被引用，所以对于没有被引用的段可以被忽略，不会起任何作用。而各个配置名称可以通过 <code>man ca</code> 或者 <code>man req</code> 类似的命令查看。</p><p>如下简单介绍相关的配置，阅读时可以忽略，以后用到再来查看细节。</p><a class=anchor id=req></a><h2>REQ <a href=#req aria-hidden=true>#</a></h2><p>针对的时 <code>req</code> 子命令。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[ req ]
</span></span><span class=line><span class=cl>default_bits    = 2048         # 私钥的密钥长度
</span></span><span class=line><span class=cl>default_keyfile = privkey.pem  # 私钥保存位置，使用-newkey或者有-new但无-key参数时
</span></span><span class=line><span class=cl>x509_extensions = v3_ca        # 加入到证书中的扩展项
</span></span><span class=line><span class=cl>req_extensions = v3_req        # 加入到证书请求中的扩展项
</span></span><span class=line><span class=cl>distinguished_name  = req_distinguished_name # 也就是类似C ST L O 类似的配置
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[ req_distinguished_name ]     # 这里没有指定，使用命令行传入参数
</span></span><span class=line><span class=cl>#countryName             = CN
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[ v3_req ]
</span></span><span class=line><span class=cl>basicConstraints = CA:FALSE
</span></span><span class=line><span class=cl>keyUsage = nonRepudiation, digitalSignature, keyEncipherment
</span></span></code></pre></div><a class=anchor id=自签名证书></a><h1>自签名证书 <a href=#%e8%87%aa%e7%ad%be%e5%90%8d%e8%af%81%e4%b9%a6 aria-hidden=true>#</a></h1><p>也就是自己给自己签发，如果通过上述的命令查看，可以看到 <code>Issuer</code> 与 <code>Subject</code> 的内容相同，而且会自动设置 <code>Basic Constraints</code> 中的 <code>CA:True</code> 配置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- STEP1 生成证书私钥
</span></span><span class=line><span class=cl>openssl genrsa -aes128 -out key.pem -passout &#39;pass:YourPassHere&#39; 4096
</span></span><span class=line><span class=cl>----- STEP2 根据私钥生成证书申请文件
</span></span><span class=line><span class=cl>openssl req -new -passin &#39;pass:YourPassHere&#39; -key key.pem -out cert.csr    \
</span></span><span class=line><span class=cl>	-subj &#34;/C=CN/ST=MyProvince/L=MyCity/O=MyOrganization/CN=MyDomain.com&#34;
</span></span><span class=line><span class=cl>----- STEP3 使用私钥对证书申请进行签名从而生成证书
</span></span><span class=line><span class=cl>openssl x509 -req -days 3650 -in cert.csr -signkey key.pem -out selfsign.crt
</span></span></code></pre></div><p>注意，上述的 Common Name, CN 需要指定具体的网站名，例如 <code>www.domain.com</code> ，否则不匹配浏览器会报错，当然，也可以输入 <code>*.domain.com</code> 以生成通配符域名证书。</p><p>也可以将上述的最后两步合成一步完成，不过没有看到如何指定私钥的加密算法，所以，如果需要加密，那么还是分成两步好了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 根据私钥生成自签名证书
</span></span><span class=line><span class=cl>openssl req -x509 -nodes -days 3650 -newkey rsa:4096 -keyout key.pem -out selfsign.crt \
</span></span><span class=line><span class=cl>	-subj &#34;/C=CN/ST=MyProvince/L=MyCity/O=MyOrganization/CN=MyDomain.com&#34;
</span></span></code></pre></div><p>也可以通过 <code>-config openssl.conf</code> 参数指定配置文件。</p><a class=anchor id=自建-root-ca></a><h1>自建 Root CA <a href=#%e8%87%aa%e5%bb%ba-root-ca aria-hidden=true>#</a></h1><p>类似于模拟一个 Certificate Authority, CA 中心，在公司内部可以由 CA 颁发证书，方便统一进行管理，在使用时证书链一般至少会包含三层，而且上两层的 <code>Common Name</code> 信息可以是非域名，根证书和中间证书不要相同。</p><a class=anchor id=生成-root-ca-配置></a><h2>生成 Root-CA 配置 <a href=#%e7%94%9f%e6%88%90-root-ca-%e9%85%8d%e7%bd%ae aria-hidden=true>#</a></h2><p>这里生成证书的步骤根上面生成自签名证书的步骤基本相同。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>openssl req -x509 -nodes -days 3650 -newkey rsa:4096 -keyout root-ca.key \
</span></span><span class=line><span class=cl>	-out root-ca.pem -subj &#34;/OU=MyRootCA R2/O=MyRootCA/CN=MyRootCA&#34;
</span></span></code></pre></div><p>这里可通过 <code>-set_serial 1</code> 手动指定序列号，当过期或者失效后可以修改，默认会自动生成 (不确定是随机还是 Hash 值)。</p><a class=anchor id=创建中间证书></a><h2>创建中间证书 <a href=#%e5%88%9b%e5%bb%ba%e4%b8%ad%e9%97%b4%e8%af%81%e4%b9%a6 aria-hidden=true>#</a></h2><p>中间证书 (Intermediate) 同样由 CA 中心颁发，需要先创建申请 CSR 文件，然后利用上述的根证书进行签署，注意 <strong>Common Name 不要与 Root-CA 的一样</strong>。</p><p>首先需要生成中间证书请求文件，可以分成两步，也可以一步生成私钥和 CSR 文件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- STEP1 使用生成私钥文件，4096位强度，也可以指定算法，例如-des3
</span></span><span class=line><span class=cl>openssl genrsa -out inter-key.pem -passout &#39;pass:YourPassHere&#39; 4096
</span></span><span class=line><span class=cl>----- STEP2 根据私钥生成证书申请文件
</span></span><span class=line><span class=cl>openssl req -new -passin &#39;pass:YourPassHere&#39; -key inter-key.pem -out inter-cert.csr \
</span></span><span class=line><span class=cl>	-subj &#34;/C=CN/O=MyInterCA/CN=MyInterCA&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 一步生成私钥文件以及证书请求文件
</span></span><span class=line><span class=cl>openssl req -passout &#39;pass:YourPassHere&#39; -newkey rsa:4096 -keyout inter-key.pem \
</span></span><span class=line><span class=cl>	-out inter-cert.csr -subj &#34;/C=CN/O=MyInterCA/CN=MyInterCA&#34;
</span></span></code></pre></div><p>然后通过根证书对中间证书进行签名，因为是中间证书，对于 V3 版本来说需要添加扩展选项，其中配置文件 <code>inter_ext.cnf</code> 中的内容为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>basicConstraints=critical,CA:TRUE
</span></span></code></pre></div><p>然后通过如下命令生成。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>openssl x509 -req -days 3650 -CAcreateserial -CA root-ca.pem -CAkey root-ca.key \
</span></span><span class=line><span class=cl>	-in inter-cert.csr -out inter-cert.pem -extfile inter_ext.cnf
</span></span></code></pre></div><p>最后可以检查中间证书是否合法，此时需要指定根证书的信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>openssl verify -CAfile root-ca.pem inter-cert.pem
</span></span></code></pre></div><a class=anchor id=创建服务器证书></a><h2>创建服务器证书 <a href=#%e5%88%9b%e5%bb%ba%e6%9c%8d%e5%8a%a1%e5%99%a8%e8%af%81%e4%b9%a6 aria-hidden=true>#</a></h2><p>正常来说 Root 和 Intermediate 的证书都是使用 4096 位的加密方式，而服务器证书通常时效为一年，可以用 2048 位加密。操作步骤与上述创建中间证书的方式类似，也是 1) 创建证书请求文件 CSR；2) 通过中间证书对服务器证书进行签名。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 创建CSR文件
</span></span><span class=line><span class=cl>openssl req -passout &#39;pass:YourPassHere&#39; -newkey rsa:2048 -keyout domain-key.pem \
</span></span><span class=line><span class=cl>	-out domain-cert.csr                                                     \
</span></span><span class=line><span class=cl>	-subj &#34;/C=CN/ST=MyProvince/L=MyCity/O=MyOrganization/OU=MyGroup/CN=*.foobar.com&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 生成证书文件
</span></span><span class=line><span class=cl>openssl x509 -req -passin &#39;pass:YourPassHere&#39; -CAcreateserial -days 365 \
</span></span><span class=line><span class=cl>	-CA inter-cert.pem -CAkey inter-key.pem                         \
</span></span><span class=line><span class=cl>	-in domain-cert.csr -out domain-cert.pem
</span></span></code></pre></div><p>另外，目前通常使用的是 Subject Alternative Names, SAN ，那么可以通过配置文件设置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[req]
</span></span><span class=line><span class=cl>req_extensions = v3_req
</span></span><span class=line><span class=cl>distinguished_name = req_distinguished_name
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[req_distinguished_name]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[v3_req]
</span></span><span class=line><span class=cl>basicConstraints = CA:FALSE
</span></span><span class=line><span class=cl>keyUsage = digitalSignature, keyEncipherment
</span></span><span class=line><span class=cl>subjectAltName = @alt_names
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[alt_names]
</span></span><span class=line><span class=cl>IP.1 = 127.0.0.1
</span></span><span class=line><span class=cl>DNS.1 = www.foobar.com
</span></span><span class=line><span class=cl>DNS.2 = files.foobar.com
</span></span></code></pre></div><p>然后在生成 CSR 文件时，需要通过 <code>-config</code> 参数指定。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>openssl req -new -passin &#39;pass:YourPassHere&#39; -key domain-key.pem \
</span></span><span class=line><span class=cl>	-config domain.cnf -out domain-cert.csr \
</span></span><span class=line><span class=cl>	-subj &#34;/C=CN/ST=MyProvince/L=MyCity/O=MyOrganization/OU=MyGroup/CN=*.foobar.com&#34;
</span></span><span class=line><span class=cl>openssl x509 -req -passin &#39;pass:YourPassHere&#39; -CAcreateserial -days 365 \
</span></span><span class=line><span class=cl>	-extfile domain.cnf -extensions v3_req \
</span></span><span class=line><span class=cl>	-CA inter-cert.pem -CAkey inter-key.pem \
</span></span><span class=line><span class=cl>	-in domain-cert.csr -out domain-cert.pem
</span></span></code></pre></div><a class=anchor id=证书验证></a><h1>证书验证 <a href=#%e8%af%81%e4%b9%a6%e9%aa%8c%e8%af%81 aria-hidden=true>#</a></h1><p>有几种方式可以验证。</p><a class=anchor id=ca-证书合并></a><h2>CA 证书合并 <a href=#ca-%e8%af%81%e4%b9%a6%e5%90%88%e5%b9%b6 aria-hidden=true>#</a></h2><p>对于上述生成的两个证书文件可以合并成一个文件，然后进行验证，这也是类似 OS 的保存方式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 将根证书和中间证书合并
</span></span><span class=line><span class=cl>cat root-ca.pem inter-cert.pem &gt; cert.pem
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 验证生成的证书
</span></span><span class=line><span class=cl>openssl verify -CAfile cert.pem domain-cert.pem
</span></span></code></pre></div><p>注意，当合并为一个文件后，无法直接通过 <code>openssl x509</code> 命令读取全部证书，实际只会读取第一个证书，为此，可以使用如下命令读取全部证书信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>openssl crl2pkcs7 -nocrl -certfile cert.pem | openssl pkcs7 -print_certs -noout
</span></span></code></pre></div><a class=anchor id=使用-untrusted-参数></a><h2>使用 untrusted 参数 <a href=#%e4%bd%bf%e7%94%a8-untrusted-%e5%8f%82%e6%95%b0 aria-hidden=true>#</a></h2><p>可以通过 <code>-CAfile</code> 指定根证书文件，然后用 <code>-untrusted</code> 指定中间证书文件，而且可以指定多次。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>openssl verify -CAfile root-ca.pem -untrusted inter-cert.pem domain-cert.pem
</span></span></code></pre></div><a class=anchor id=常见错误></a><h2>常见错误 <a href=#%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af aria-hidden=true>#</a></h2><p>在创建中间证书时，通过 <code>openssl verify</code> 命令检查可能会出现类似 <code>error 24 at 1 depth lookup: invalid CA certificate</code> 的报错，此时可能是由于没有设置 Basic Constraints 导致的，可以通过如下命令查看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ openssl x509 -noout -in root-ca.pem -ext basicConstraints
</span></span><span class=line><span class=cl>X509v3 Basic Constraints: critical
</span></span><span class=line><span class=cl>	CA:TRUE
</span></span></code></pre></div><p>OpenSSL 工具在检查时会校验该参数，对于 Root CA 的证书来说，会自动添加，而中间证书需要使用配置文件生成。</p><a class=anchor id=证书更新></a><h1>证书更新 <a href=#%e8%af%81%e4%b9%a6%e6%9b%b4%e6%96%b0 aria-hidden=true>#</a></h1><p>如果服务器的证书过期了，那么重新申请替换即可，如果根证书或者中间证书过期如何处理？</p><p>简单来说，只要保证根证书的私钥不变 (意味着公钥也不变)，利用私钥重新签发新证书即可，这样原有的中间证书、服务证书可以正常使用。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 生成根证书
</span></span><span class=line><span class=cl>openssl req -x509 -nodes -days 3650 -newkey rsa:4096 -keyout root.key \
</span></span><span class=line><span class=cl>	-out root-orig.pem -subj &#34;/CN=MyRootCA&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 创建服务器证书
</span></span><span class=line><span class=cl>openssl genrsa -out cert.key 1024
</span></span><span class=line><span class=cl>openssl req -new -key cert.key -out cert.csr -subj &#34;/C=CN/CN=*.foobar.com&#34;
</span></span><span class=line><span class=cl>openssl x509 -req -in cert.csr -CA root-orig.pem -CAkey root.key \
</span></span><span class=line><span class=cl>	-CAcreateserial -out cert.pem
</span></span><span class=line><span class=cl>----- 验证正常
</span></span><span class=line><span class=cl>openssl verify -CAfile root-orig.pem -verbose cert.pem
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 利用根证书重新生成，注意，这里是通过请求生成的
</span></span><span class=line><span class=cl>openssl req -new -key root.key -out newcsr.csr -subj &#34;/CN=MyRootCA&#34;
</span></span><span class=line><span class=cl>openssl x509 -req -days 3650 -in newcsr.csr -signkey root.key -out root-new.pem
</span></span><span class=line><span class=cl>----- 再次验证，仍然正常
</span></span><span class=line><span class=cl>openssl verify -CAfile root-new.pem -verbose cert.pem
</span></span></code></pre></div><p>注意，新生成证书时，需要保证 Subject 相同。</p><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><a class=anchor id=证书请求文件注意事项></a><h2>证书请求文件注意事项 <a href=#%e8%af%81%e4%b9%a6%e8%af%b7%e6%b1%82%e6%96%87%e4%bb%b6%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-hidden=true>#</a></h2><p>在生成 KEY 以及 CSR 时，如果不想加密 KEY 可以设置 <code>-nodeps</code> 参数，不过建议添加密码。</p><p>创建 CSR 文件时需要注意，不要出现特殊字符 (例如 <code>(@#&!</code> 等) 否则可能会报错；保管好私钥，私钥和证书密不可分，一旦丢失只能重新生成；CommonName 需要与服务器的名称相同，或者使用通配符，例如 <code>www.foobar.com</code> 或者 <code>*.foobar.com</code>。</p><a class=anchor id=序列号></a><h2>序列号 <a href=#%e5%ba%8f%e5%88%97%e5%8f%b7 aria-hidden=true>#</a></h2><p>X509 证书标准中对证书序列号 Serial Number 进行了定义，详细可以查看 <a href=https://www.ietf.org/rfc/rfc2459.txt>RFC2459 4.1.2.2 Serial Number</a> 中的内容。</p><p>简单来说，序列号对于某个 CA 来说是唯一的，这样就意味着单纯使用序列号不能作为证书的唯一 ID ，两个不同的 CA 之间可能会出现相同的序列号，所以，应该通过 <code>Issuer</code> 和 <code>SerialNumber</code> 组合使用。</p><p>另外，CA 可以自己选择如何生成序列号，可以是递增，也可以是随机，只需要保证在 CA 唯一即可。</p><a class=anchor id=openssl></a><h3>OpenSSL <a href=#openssl aria-hidden=true>#</a></h3><p>在使用 OpenSSL 的命令行创建证书时，有几种方式指定序列号：A) 设置与 <code>-CA</code> 文件名相同但后缀为 <code>.srl</code> 的文件；B) 使用 <code>-set_serial</code> 参数；C) 通过 <code>-CAcreateserial</code> 自动创建；D) 使用 <code>-CAserial</code> 指定文件。</p><p>通过 <code>-CA</code> 参数指定签署时所用证书，如果没有使用 <code>-set_serial XXX</code> 参数，那么 OpenSSL 默认会读取与 <code>-CA</code> 同名但是后缀改为 <code>.srl</code> 的文件，例如指定 <code>-CA cert.pem</code> 那会尝试读取 <code>cert.srl</code> 文件，该文件只需要一行十六进制数字即可。</p><p>如果使用了 <code>-CAcreateserial</code> 参数，那么 OpenSSL 会自动生成一个，而且会保存在后缀为 <code>.srl</code> 的文件中。</p><a class=anchor id=指定参数></a><h2>指定参数 <a href=#%e6%8c%87%e5%ae%9a%e5%8f%82%e6%95%b0 aria-hidden=true>#</a></h2><p>再强调下，通过 <code>openssl x509</code> 命令是无法指定配置文件的，但可以通过 <code>-extfile</code> 配置项指定扩展项。也可以使用 <code>ca</code> 子命令创建，不过需要使用配置文件指定参数。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#查看证书>查看证书</a></li></ul></li><li><a href=#配置文件>配置文件</a><ul><li><a href=#req>REQ</a></li></ul></li><li><a href=#自签名证书>自签名证书</a></li><li><a href=#自建-root-ca>自建 Root CA</a><ul><li><a href=#生成-root-ca-配置>生成 Root-CA 配置</a></li><li><a href=#创建中间证书>创建中间证书</a></li><li><a href=#创建服务器证书>创建服务器证书</a></li></ul></li><li><a href=#证书验证>证书验证</a><ul><li><a href=#ca-证书合并>CA 证书合并</a></li><li><a href=#使用-untrusted-参数>使用 untrusted 参数</a></li><li><a href=#常见错误>常见错误</a></li></ul></li><li><a href=#证书更新>证书更新</a></li><li><a href=#其它>其它</a><ul><li><a href=#证书请求文件注意事项>证书请求文件注意事项</a></li><li><a href=#序列号>序列号</a></li><li><a href=#指定参数>指定参数</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>