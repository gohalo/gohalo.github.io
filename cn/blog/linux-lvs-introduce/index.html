<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Linux LVS | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="LVS 通常用于四层的网络服务器做负载均衡，其工作在内核层，而且效率非常高；部署时还会使用 heartbeat 以及 keepalived 做高可用。
在本文中，我们对其做些介绍。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Linux LVS</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2013-03-15</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a></div></div><hr><div class=content><p>LVS 通常用于四层的网络服务器做负载均衡，其工作在内核层，而且效率非常高；部署时还会使用 heartbeat 以及 keepalived 做高可用。</p><p>在本文中，我们对其做些介绍。</p><a class=anchor id=linux-virtual-server-project></a><h1>Linux Virtual Server Project <a href=#linux-virtual-server-project aria-hidden=true>#</a></h1><p>负载均衡设备通常作为应用服务器的入口，简单来说就是对于一个请求，如何选择其中的一个服务器去处理该请求，如下是 Google SRE 中的定义。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Traffic load balancing is how we decide which of the many, many machines
</span></span><span class=line><span class=cl>in our datacenters will serve a particular request.
</span></span></code></pre></div><p>LVS 工作在内核层，可以处理 TCP 以及 UDP 连接，也就是是说，只要是基于这两个协议的都支持，包括了 email、http、https 等服务，甚至包括 X-Windows 。</p><p>仍然以 Amazon 为例。</p><p><img alt="network interface" src=images/lb-overview.png class="mx-auto d-block"></p><p>性能好的是商用硬件负载设备，但是成本通常很高，一台能达到几十万甚至上百万，所以通常使用的是软负载均衡，而软负载的两个核心问题是：选谁、转发，其中最著名的是 LVS (Linux Virtual Server Project)。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>实际上很多层都可以做负载均衡，例如网卡的 Bond、ECMP、DNS 等等，而针对 VIP 的通常工作在网络模型的第四层和第七层。</p><p><img alt="network interface" src=images/network-introduce-OSI-TCP-IP.png class="mx-auto d-block"></p><p>软负载均衡面向的是一个已经建立连接的会话，而非单独的 IP 报文，也就是说用户访问需要 TCP 协议与服务器建立连接传输数据，而 TCP 是在第四层实现的，如果在第三层做负载均衡，那么将会丢失四层的 &ldquo;连接&rdquo;，导致出错。</p><p>LVS 工作在网络模型中的第四层，不同于 HAProxy、Nginx 等七层软负载均衡可以面向 HTTP 包，从而七层可以做 URL 的解析工作，而 LVS 无法完成。</p><a class=anchor id=报文转发></a><h1>报文转发 <a href=#%e6%8a%a5%e6%96%87%e8%bd%ac%e5%8f%91 aria-hidden=true>#</a></h1><p>首先负载均衡中包括了 Director (提供 LVS 服务的机器)、Real Server (真正提供服务的机器) 。LVS 支持三种报文的转发方式 NAT、tunneling、direct routing，分别介绍如下：</p><a class=anchor id=network-address-translation-nat></a><h2>Network Address Translation (NAT) <a href=#network-address-translation-nat aria-hidden=true>#</a></h2><p>NAT 也就是修改报文的源或者目的地址以及端口号，是一种外网和内网的地址映射技术，对于这种模式，报文的进出都要经过 LVS 服务器，也就意味这 RS 需要将 RS 作为网关。</p><p><img alt="network interface" src=images/lvs-nat-example-2.png class="mx-auto d-block"></p><p>一个报文的处理过程大致经过了如下的三个步骤：</p><ol><li>Director 收到报文后会做 DNAT，也就是修改目的地址以及端口号为真正的服务器，然后发送到 RS；</li><li>RS 接收包后，会像客户端直接发给它的一样，不会感知 LVS 存在。响应报文的源 IP 是 RS IP，目标 IP 是客户端的 IP。</li><li>响应报文通过 LVS 中转，会做 SNAT，将包的源地址改为 VIP，这样对客户端来说，看起来就像是 LVS 直接返回给它的，客户端无法感知到后端 RS 的存在。</li></ol><p>下图是数据流的流动过程。</p><p><img alt="network interface" src=images/lvs-nat.png class="mx-auto d-block"></p><p>这是最见的配置方式了，假设有如下环境。</p><p><img alt="network interface" src=images/lvs-nat-example.png class="mx-auto d-block"></p><p>只需要做如下的配置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 首先配置 Linux Director，其中VIP为172.17.60.201
</span></span><span class=line><span class=cl>---++ 在/etc/sysctl.conf中设置IP转发
</span></span><span class=line><span class=cl>net.ipv4.ip_forward = 1
</span></span><span class=line><span class=cl>---++ 设置虚拟IP地址
</span></span><span class=line><span class=cl># ifconfig eth0:0 172.17.60.201 netmask 255.255.0.0 broadcast 172.17.255.255
</span></span><span class=line><span class=cl>---++ 配置LVS
</span></span><span class=line><span class=cl># ipvsadm -A -t 172.17.60.201:80
</span></span><span class=line><span class=cl># ipvsadm -a -t 172.17.60.201:80 -r 192.168.6.4:80 -m
</span></span><span class=line><span class=cl># ipvsadm -a -t 172.17.60.201:80 -r 192.168.6.5:80 -m
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 然后配置Real Servers，只需要将默认的gateway设置为VIP即可
</span></span></code></pre></div><p>然后可以通过如下方法查看当前的统计值。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl># ipvsadm -L -n              # 查看当前活动的连接
</span></span><span class=line><span class=cl># ipvsadm -L -n --stats      # 每秒收发的报文数
</span></span><span class=line><span class=cl># ipvsadm -L -n --rate       # 每秒的报文的收发速度
</span></span><span class=line><span class=cl># ipvsadm -L --zero          # 清空报文内容
</span></span></code></pre></div><a class=anchor id=direct-routing></a><h2>Direct Routing <a href=#direct-routing aria-hidden=true>#</a></h2><p>此时请求由 LVS 接受，然后报文会直接通过修改目的 MAC 发送给 RealServer，其中 IP 报文不会修改，而响应报文则会由 RS 直接返回给用户，不会经过 LVS，这是性能最好的一种模式。</p><p>这种方式同时这也就意味着 RS 必须也配置为 VIP，通常是通过 loopback 设备绑定。</p><p>简单来说，一个请求总共分为如下三步：</p><ol><li>LVS 接收请求，将接收到报文的 MAC 地址修改为某台 RS 的 MAC，该包就会在 LAN 中被转发到相应的 RS 处理，而此时的源 IP 和目标 IP 都没变。</li><li>RS 收到 LVS 转发来的包，链路层通过 MAC 识别到是发送给自己的，然后传递到上面的网络层，发现 IP 同样是自己的，那么报文就继续向上传递，这个包被合法地接受，RS 并没有感知到 LVS 的存在。</li><li>RS 返回响应报文时，直接向源 IP 返回即可，此时不再经过 LVS，从而降低 LVS 服务器的压力。</li></ol><p>基本操作如下图所示。</p><p><img alt="network interface" src=images/lvs-direct-routing.png class="mx-auto d-block"></p><p>对于 DR 模式，需要注意如下几点：</p><ol><li>LVS 的 VIP 和 realserver 必须在同一个网段。</li><li>所有的 realserver 都必须绑定 VIP 的 IP 地址，否则 realserver 收到报文后发现目的 IP 不是自己，将会把报文丢掉。</li><li>realserver 处理完包后直接把报文发送给客户端，从而不需要再经过 LVS 服务器，进而提高效率，不过同时会将 realserver 的 IP 暴漏给外界。</li></ol><p>假设有如下的网络结构。</p><p><img alt="network interface" src=images/lvs-direct-routing-example.png class="mx-auto d-block"></p><p><img alt="network interface" src=images/lvs-direct-routing-example-2.png class="mx-auto d-block"></p><p>配置方法如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 首先配置 Linux Director，其中VIP为172.17.60.201
</span></span><span class=line><span class=cl>---++ 在/etc/sysctl.conf中设置IP转发
</span></span><span class=line><span class=cl>net.ipv4.ip_forward = 1
</span></span><span class=line><span class=cl>---++ 设置虚拟IP地址
</span></span><span class=line><span class=cl># ifconfig eth0:0 172.17.60.201 netmask 255.255.0.0 broadcast 172.17.255.255
</span></span><span class=line><span class=cl>---++ 配置LVS
</span></span><span class=line><span class=cl># ipvsadm -A -t 172.17.60.201:80
</span></span><span class=line><span class=cl># ipvsadm -a -t 172.17.60.201:80 -r 172.17.60.199:80 -g
</span></span><span class=line><span class=cl># ipvsadm -a -t 172.17.60.201:80 -r 172.17.60.200:80 -g
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 在真正服务器上执行如下命令
</span></span><span class=line><span class=cl>---++ 需要注意netmask
</span></span><span class=line><span class=cl># ifconfig lo:0 172.17.60.201 netmask 255.255.255.255
</span></span><span class=line><span class=cl>---++ 隐藏loopback，从而防止相应对VIP的ARP请求
</span></span><span class=line><span class=cl># Enable configuration of hidden devices
</span></span><span class=line><span class=cl>net.ipv4.conf.all.hidden = 1
</span></span><span class=line><span class=cl># Make the loopback interface hidden
</span></span><span class=line><span class=cl>net.ipv4.conf.lo.hidden = 1
</span></span></code></pre></div><a class=anchor id=ip-ip-encapsulation-tunnelling></a><h2>IP-IP Encapsulation (Tunnelling) <a href=#ip-ip-encapsulation-tunnelling aria-hidden=true>#</a></h2><p>这种方法可以将报文发送到不同的子网内，同 DR 类似，返回的报文不需要经过 director 。示例仍然采用与 DR 相同的结构。</p><p><img alt="network interface" src=images/lvs-direct-routing-example.png class="mx-auto d-block"></p><p>然后通过如下方式进行配置。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 首先配置Linux Director
</span></span><span class=line><span class=cl>---++ 在/etc/sysctl.conf中设置IP转发
</span></span><span class=line><span class=cl>net.ipv4.ip_forward = 1
</span></span><span class=line><span class=cl>---++ 设置虚拟IP地址
</span></span><span class=line><span class=cl># ifconfig eth0:0 172.17.60.201 netmask 255.255.0.0 broadcast 172.17.255.255
</span></span><span class=line><span class=cl>---++ 配置LVS
</span></span><span class=line><span class=cl># ipvsadm -A -t 172.17.60.201:80
</span></span><span class=line><span class=cl># ipvsadm -a -t 172.17.60.201:80 -r 172.17.60.199:80 -i
</span></span><span class=line><span class=cl># ipvsadm -a -t 172.17.60.201:80 -r 172.17.60.200:80 -i
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 配置Real Servers
</span></span><span class=line><span class=cl>---++ 配置tunl0
</span></span><span class=line><span class=cl># ifconfig tunl0 172.17.60.201 netmask 255.255.255.255
</span></span><span class=line><span class=cl>---++ 同样打开转发，并隐藏loopback
</span></span><span class=line><span class=cl>net.ipv4.ip_forward = 1
</span></span><span class=line><span class=cl># Enable configuration of hidden devices
</span></span><span class=line><span class=cl>net.ipv4.conf.all.hidden = 1
</span></span><span class=line><span class=cl># Make the tunl0 interface hidden
</span></span><span class=line><span class=cl>net.ipv4.conf.tunl0.hidden = 1
</span></span></code></pre></div><a class=anchor id=full-nat></a><h2>Full NAT <a href=#full-nat aria-hidden=true>#</a></h2><p>除了上述的 IP-IP Tunnelling 方式，LVS 和 RS 必须在同一个 LAN 或者 VLAN 下，否则 LVS 无法作为 RS 的网关。这将导致：A) 运维不方便，跨 VLAN 的 RS 无法接入；B) 水平扩展受限制。</p><p>Full-NAT 是为了解决此问题，他在 SNAT/DNAT 的基础上，加上另一种转换，过程如下。</p><p><img alt="network interface" src=images/lvs-full-nat-example.png class="mx-auto d-block"></p><p>大致的执行过程如下：</p><ol><li>包从 LVS 转到 RS 时，源地址从客户端 IP 被替换成了 LVS 的内网 IP；利用内网 IP，可以通过多个交换机跨 VLAN 通信。</li><li>当 RS 返回响应包时，会将这个包返回给 LVS 的内网 IP，这一步也不受限于 VLAN。</li><li>LVS 收到包后，在修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内网 IP 改为客户端的 IP。</li></ol><p>采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的便利性。</p><a class=anchor id=负载均衡算法></a><h1>负载均衡算法 <a href=#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%ae%97%e6%b3%95 aria-hidden=true>#</a></h1><p>针对不同的网络服务需求和服务器配置，IPVS 调度器实现了如下八种负载调度算法：</p><p>以及八种负载均衡的算法 (round robin、weighted round robin、least-connection、weighted least-connection、locality-based least-connection、locality-based least-connection with replication、destination-hashing、source-hashing)。</p><a class=anchor id=轮询-round-robin></a><h4>轮询 (Round Robin) <a href=#%e8%bd%ae%e8%af%a2-round-robin aria-hidden=true>#</a></h4><p>调度器将外部请求按顺序轮流分配到集群中的真实服务器上，该算法平等地对待每一台服务器，而不管服务器上实际的连接数和系统负载。</p><a class=anchor id=加权轮询-weighted-round-robin></a><h4>加权轮询 (Weighted Round Robin) <a href=#%e5%8a%a0%e6%9d%83%e8%bd%ae%e8%af%a2-weighted-round-robin aria-hidden=true>#</a></h4><p>该算法可以根据真实服务器的不同处理能力来调度访问请求，从而可以保证处理能力强的服务器处理更多的访问流量，而调度器可以自动查询真实服务器的负载情况，并动态地调整其权值。</p><a class=anchor id=最少链接-least-connections></a><h4>最少链接 (Least Connections) <a href=#%e6%9c%80%e5%b0%91%e9%93%be%e6%8e%a5-least-connections aria-hidden=true>#</a></h4><p>调度器动态地将网络请求调度到已建立的链接数最少的服务器上，如果集群系统的真实服务器具有相近的系统性能，采用 &ldquo;最小连接&rdquo; 调度算法可以较好地均衡负载。</p><a class=anchor id=加权最少链接-weighted-least-connections></a><h4>加权最少链接 (Weighted Least Connections) <a href=#%e5%8a%a0%e6%9d%83%e6%9c%80%e5%b0%91%e9%93%be%e6%8e%a5-weighted-least-connections aria-hidden=true>#</a></h4><p>在集群系统中的服务器性能差异较大的情况下，调度器采用 &ldquo;加权最少链接&rdquo; 调度算法优化负载均衡性能，具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。</p><a class=anchor id=基于局部性的最少链接-locality-based-least-connections></a><h4>基于局部性的最少链接 (Locality-Based Least Connections) <a href=#%e5%9f%ba%e4%ba%8e%e5%b1%80%e9%83%a8%e6%80%a7%e7%9a%84%e6%9c%80%e5%b0%91%e9%93%be%e6%8e%a5-locality-based-least-connections aria-hidden=true>#</a></h4><p>针对目标 IP 地址的负载均衡，目前主要用于 Cache 集群系统。该算法根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用"最少链接"的原则选出一个可用的服务器，将请求发送到该服务器。</p><a class=anchor id=带复制的基于局部性最少链接-locality-based-least-connections-with-replication></a><h4>带复制的基于局部性最少链接 (Locality-Based Least Connections with Replication) <a href=#%e5%b8%a6%e5%a4%8d%e5%88%b6%e7%9a%84%e5%9f%ba%e4%ba%8e%e5%b1%80%e9%83%a8%e6%80%a7%e6%9c%80%e5%b0%91%e9%93%be%e6%8e%a5-locality-based-least-connections-with-replication aria-hidden=true>#</a></h4><p>&ldquo;带复制的基于局部性最少链接"调度算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统。它与LBLC算法的不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按"最小连接"原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器，若服务器超载；则按"最小连接"原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。 7.目标地址散列（Destination Hashing）</p><p>&ldquo;目标地址散列"调度算法根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><a class=anchor id=源地址散列-source-hashing></a><h4>源地址散列 (Source Hashing) <a href=#%e6%ba%90%e5%9c%b0%e5%9d%80%e6%95%a3%e5%88%97-source-hashing aria-hidden=true>#</a></h4><p>&ldquo;源地址散列"调度算法根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p><a class=anchor id=ipvsadm></a><h1>ipvsadm <a href=#ipvsadm aria-hidden=true>#</a></h1><p>ipvsadm 是用户层管理 LVS 的程序，</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ipvsadm -A|E -t|u|f service-address [-s scheduler] [-p [timeout]] [-M netmask]
</span></span><span class=line><span class=cl>ipvsadm -D -t|u|f service-address
</span></span><span class=line><span class=cl>ipvsadm -C
</span></span><span class=line><span class=cl>ipvsadm -R
</span></span><span class=line><span class=cl>ipvsadm -S [-n]
</span></span><span class=line><span class=cl>ipvsadm -a|e -t|u|f service-address -r RS-address [-g|i|m] [-w weight] [-x upper] [-y lower]
</span></span><span class=line><span class=cl>ipvsadm -d -t|u|f service-address -r RS-address
</span></span><span class=line><span class=cl>ipvsadm -L|l [options]
</span></span><span class=line><span class=cl>ipvsadm -Z [-t|u|f service-address]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>常见选项如下：
</span></span><span class=line><span class=cl>    -A    添加一个新的集群服务；
</span></span><span class=line><span class=cl>    -E    修改一个己有的集群服务；
</span></span><span class=line><span class=cl>    -D    删除指定的集群服务；
</span></span><span class=line><span class=cl>    -a    向指定的集群服务中添加real server及属性；
</span></span><span class=line><span class=cl>    -e    修改real server属性；
</span></span><span class=line><span class=cl>    -r    指定real server的地址；
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    -t    指定为tcp协议；
</span></span><span class=line><span class=cl>    -u    指定为udp协议；
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    -g    Gateway, DR模型；
</span></span><span class=line><span class=cl>    -i    ipip, TUN模型；
</span></span><span class=line><span class=cl>    -m    masquerade, NAT模型；
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    -f    指定防火墙标记码，通常用于将两个或以上的服务绑定为一个服务进行处理时使用；
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    -s    调度方法，默认为wlc；
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    -w    指定权重，默认为1；
</span></span><span class=line><span class=cl>    -p timeout   persistent connection, 持久连接超时时长；
</span></span><span class=line><span class=cl>    -S    保存ipvsadm设定的规则策略，默认保存在/etc/sysconfig/ipvsadm中；
</span></span><span class=line><span class=cl>    -R    载入己保存的规则策略，默认加载/etc/sysconfig/ipvsadm；
</span></span><span class=line><span class=cl>    -C    清除所有集群服务；
</span></span><span class=line><span class=cl>    -Z    清除所有记数器；
</span></span><span class=line><span class=cl>    -L    显示当前己有集群服务，能通过相应的options查看不同状态信息；
</span></span><span class=line><span class=cl>        -n: 数字格式显示IP地址；
</span></span><span class=line><span class=cl>        -c: 显示连接数相关信息；
</span></span><span class=line><span class=cl>        --stats: 显示统计数据；
</span></span><span class=line><span class=cl>        --rate: 速率；
</span></span><span class=line><span class=cl>        --exact：显示统计数据的精确值；
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ipvsadm -A -t 192.168.132.254:80 -s rr -p 120
</span></span><span class=line><span class=cl>ipvsadm -a -t 192.168.132.254:80 -r 192.168.132.64:80 -g
</span></span><span class=line><span class=cl>ipvsadm -a -t 192.168.132.254:80 -r 192.168.132.68:80 -g
</span></span></code></pre></div><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><p>有两篇不错的文章 <a href=http://www.ultramonkey.org/papers/lvs_tutorial/html/>Linux Virtual Server Tutorial</a>、<a href=http://www.austintek.com/LVS/LVS-HOWTO/HOWTO/index.html>LVS - HOWTO</a>，比较老的文章，前者相比简单些。另外 <a href=http://ja.ssi.bg/>ja.ssi.bg</a> 中很多不错的相关补丁，以及文章。</p><p>在 <a href=http://zh.linuxvirtualserver.org/>LVS 中文网站</a> 中有几篇比较经典的文章 <a href=http://www.linuxvirtualserver.org/zh/lvs1.html>Linux服务器集群系统</a> 。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#linux-virtual-server-project>Linux Virtual Server Project</a></li><li><a href=#简介>简介</a></li><li><a href=#报文转发>报文转发</a><ul><li><a href=#network-address-translation-nat>Network Address Translation (NAT)</a></li><li><a href=#direct-routing>Direct Routing</a></li><li><a href=#ip-ip-encapsulation-tunnelling>IP-IP Encapsulation (Tunnelling)</a></li><li><a href=#full-nat>Full NAT</a></li></ul></li><li><a href=#负载均衡算法>负载均衡算法</a><ul><li></li></ul></li><li><a href=#ipvsadm>ipvsadm</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>