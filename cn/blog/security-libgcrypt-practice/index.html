<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>libgcrypt 使用 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="libgcrypt 是一个非常成熟的加密算法库，也是著名的开源加密软件 GnuPG 的底层库，支持多种对称、非对称加密算法，以及多种 Hash 算法。
接下来，看看该库的使用方式。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>libgcrypt 使用</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2014-07-16</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/security/ role=button>security</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/language/ role=button>language</a></div></div><hr><div class=content><p>libgcrypt 是一个非常成熟的加密算法库，也是著名的开源加密软件 GnuPG 的底层库，支持多种对称、非对称加密算法，以及多种 Hash 算法。</p><p>接下来，看看该库的使用方式。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>现代加密算法中，对称密钥算法通常被分为 <code>Stream Ciphers</code> 和 <code>Block Ciphers</code> 。</p><p>分组密码也被称分块密码，是一种对称密钥密码，会将明文分成多个等长的分组 (其中常见的有64 bits、128 bits、256 bits)，并用相同的密码算法和密钥对每组分别进行加密和解密，常见的有 DES、3DES、AES、IDEA、Blowfish、Twofish 。</p><p>分块密码加密以 bit 为单位，用来处理固定长度的字符串，需要加密的比特长度必须和分块大小一样长，或者是分块的整数倍，而且输入 (明文) 和输出 (密文) 都是同样长度的。</p><p>之所以输出不能比输入短，是遵循 <code>Pigeonhole Principle</code> (鸽巢原理) 和密码必须是可逆的事实，然而，输出比输入更长又是不可取的。</p><p>流加密算法每次对 1bit 或者 1byte 进行加密，通过无线循环的伪随机数生成器 (PRG，pseudo-random generator) 作为 key ，所以需要保证 PRG 的不可预测性，不过其生成的密钥本身可能会比要加密的数据大，常见的有 RC4 ，不过一些块加密模式 CTR、OFB 有类似流加密的功能。</p><a class=anchor id=对称加密></a><h1>对称加密 <a href=#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86 aria-hidden=true>#</a></h1><p>简单介绍下常见的对称加密算法。</p><a class=anchor id=xor></a><h2>XOR <a href=#xor aria-hidden=true>#</a></h2><p>简单的异或就是对称加密最基本的操作。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>01100001 --- a
</span></span><span class=line><span class=cl>01100010 --- b
</span></span><span class=line><span class=cl>------------ XOR
</span></span><span class=line><span class=cl>00000011
</span></span></code></pre></div><p>如果把 <code>a</code> 称作明文，<code>b</code> 称作密钥，<code>XOR</code> 则为加密，得到的结果是密文。</p><p>将明文与一串等长的随机比特序列进行XOR运算，则密码被称为一次性密码。</p><p>一次性密码是由 <code>G.S.Vernam</code> 与 1917 年提出的，因此又称维纳密码 (Vernam Cipher)；1949 年香农 (C.E.Shannon) 通过数学方法证明一次性密码无法破解。</p><p>为什么说一次性密码无法破解？假设我们对其进行暴力破解，遍历所有可能的密钥只是时间问题，然而即使可以遍历所有密钥，你也无法判断解密出的数据哪个是正确的明文。</p><p>拿上文中的异或例子来说，遍历所有可能的 <code>b</code> 一共有 256 种可能，例如，通过暴力破解结果可能是 <code>00000011</code>、<code>00000010</code>、<code>00000110</code> 等等，那么哪个是正确的呢？</p><p>之所以一次性密码并没有被使用，主要有两个原因：A) 只用一次的密钥如何配送；B) 密钥必须与明文等长。</p><a class=anchor id=rc4></a><h2>RC4 <a href=#rc4 aria-hidden=true>#</a></h2><p>Rivest Cipher 4, RC4 由美国密码学家罗纳德·李维斯特 (Ron Rivest) 在 1987 年设计，是一种流加密算法，密钥长度可变，它加解密使用相同的密钥，因此也属于对称加密算法。</p><p>RC4 是有线等效加密 (WEP) 中采用的加密算法，也曾经是 TLS 可采用的算法之一，由于 RC4 算法存在弱点，2015.02 所发布的 RFC 7465 规定禁止在 TLS 中使用 RC4 加密算法。</p><a class=anchor id=des></a><h2>DES <a href=#des aria-hidden=true>#</a></h2><p>Data Encryption Standard, DES 是一种对称密钥分组加密算法，1976 年被美国联邦政府的国家标准局确定为联邦资料处理标准 (FIPS)，它基于 56 位密钥的对称算法。</p><p>DES 现在已经不再是一种安全的加密方法，主要因为它使用的 56 位密钥过短，而且在 1999.01 时，distributed.net 与电子前哨基金会合作，在 22 小时 15 分钟内即公开破解了一个 DES 密钥。</p><p>DES 是一种分组加密算法，一组长度为 64 位，不过只有 56 位被实际用于算法，其余 8 位可以被用于校验，并在算法中被丢弃，也就是说 DES 的有效密钥长度仅为 56 位。</p><a class=anchor id=blowfish></a><h2>Blowfish <a href=#blowfish aria-hidden=true>#</a></h2><p>Blowfish 是 1993 年布鲁斯·施奈尔 (Bruce Schneier) 开发的对称密钥区块加密算法，区块长为 64 位，密钥为 1 至 448 位的可变长度，是 <a href=https://en.wikipedia.org/wiki/Feistel_cipher>Feistel Cipher</a> 的一种，与 DES 等算法相比，其处理速度较快，而且可以免费使用。</p><p><img alt="cipher ecb mode encrypt" src=images/cipher-feistel-diagram.png class="mx-auto d-block"></p><a class=anchor id=工作模式></a><h1>工作模式 <a href=#%e5%b7%a5%e4%bd%9c%e6%a8%a1%e5%bc%8f aria-hidden=true>#</a></h1><p>前面说的 DES、AES 等分组密码，都只能加密固定长度的明文，例如 AES 输入是 128bit，而实际使用时明文长度不确定，那么此时如何加密呢？</p><p>工作模式本质上是分组密码迭代方式，如果模式选择不恰当，那么可能会带来安全隐患。我们需要寻找一种模式，至少得满足：A) 相同的明文分组加密后密文不同；B) 明文微小变化都能造成密文有很大变化。</p><p>详细可以查看 <a href=https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation>Block cipher mode of operation</a> 中的介绍。</p><a class=anchor id=ecb-模式></a><h2>ECB 模式 <a href=#ecb-%e6%a8%a1%e5%bc%8f aria-hidden=true>#</a></h2><p>也就是电子密码本模式 (Electronic CodeBook, ECB)，这是最简单的块密码加密模式，加密前根据加密块大小 (如 AES 为 128 bit) 分成若干块，之后将每块使用相同的密钥单独加密，解密同理。</p><p><img alt="cipher ecb mode encrypt" src=images/cipher-ecb-mode-encrypt.png class="mx-auto d-block"></p><p><img alt="cipher ecb mode decrypt" src=images/cipher-ecb-mode-decrypt.png class="mx-auto d-block"></p><p>ECB 模式是最简单的一种，好处是每块数据的加解密可以并行计算；但是也有很严重的问题，就是相同的明文会得到同样的密文，在某些环境下不能提供严格的数据保密性。</p><a class=anchor id=cbc-模式></a><h2>CBC 模式 <a href=#cbc-%e6%a8%a1%e5%bc%8f aria-hidden=true>#</a></h2><p>密码分组链接 (Cipher-Block Chaining, CBC)，由 IBM 在 1976 年发明，每个明文块先与前一个密文块进行异或后，再进行加密，其中第一个明文块需要与一个叫初始化向量的数据块异或，一般来说初始化向量采用随机值。</p><p><img alt="cipher cbc mode encrypt" src=images/cipher-cbc-mode-encrypt.png class="mx-auto d-block"></p><p><img alt="cipher cbc mode decrypt" src=images/cipher-cbc-mode-decrypt.png class="mx-auto d-block"></p><p>CBC 相比 ECB 有更高的保密性，但由于对每个数据块的加密依赖与前一个数据块的加密，所以加密无法并行。而且与 ECB 一样在加密前可能需要对数据进行填充，不适合对流数据进行加密。</p><a class=anchor id=cfb-模式></a><h2>CFB 模式 <a href=#cfb-%e6%a8%a1%e5%bc%8f aria-hidden=true>#</a></h2><p>密文反馈模式 (Cipher FeedBack, CFB)，前一个密文分组会被送入密码算法的输入端，再将输出的结果与明文做异或。</p><p>与 ECB 和 CBC 模式只能够加密块数据不同，CFB 能够将块密文 (Block Cipher) 转换为流密文 (Stream Cipher)。CFB 的加密工作分为两部分：A) 将一前段加密得到的密文再加密；B) 将第 A 步加密得到的数据与当前段的明文异或。</p><p><img alt="cipher cfb mode encrypt" src=images/cipher-cfb-mode-encrypt.png class="mx-auto d-block"></p><p><img alt="cipher cfb mode decrypt" src=images/cipher-cfb-mode-decrypt.png class="mx-auto d-block"></p><p>注意：CFB、OFB 和 CTR 模式中解密也都是用的加密器而非解密器。</p><a class=anchor id=ofb-模式></a><h2>OFB 模式 <a href=#ofb-%e6%a8%a1%e5%bc%8f aria-hidden=true>#</a></h2><p>输出反馈模式 (Output Feedback, OFB)，前一组密码算法输出会输入到下一组密码算法输入。</p><p><img alt="cipher ofb mode encrypt" src=images/cipher-ofb-mode-encrypt.png class="mx-auto d-block"></p><p><img alt="cipher ofb mode decrypt" src=images/cipher-ofb-mode-decrypt.png class="mx-auto d-block"></p><a class=anchor id=ctr-模式></a><h2>CTR 模式 <a href=#ctr-%e6%a8%a1%e5%bc%8f aria-hidden=true>#</a></h2><p>计数器模式 (Counter, CTR)，每个分组对应一个累加的计数器，并通过计数器来生成加密密钥流。</p><p><img alt="cipher ctr mode encrypt" src=images/cipher-ctr-mode-encrypt.png class="mx-auto d-block"></p><p><img alt="cipher ctr mode decrypt" src=images/cipher-ctr-mode-decrypt.png class="mx-auto d-block"></p><p>图中 <code>Nonce+Counter</code> 是一个计数器，Nonce 和前面几种模式的 IV 类似，每次加密都需要随机生成，而计数器 Counter 是累加的。CTR 模式特点是每组加密都是独立的，不依赖前一组，这就意味着在生成计数器后，每个分组可以并行计算。</p><a class=anchor id=模式选择></a><h2>模式选择 <a href=#%e6%a8%a1%e5%bc%8f%e9%80%89%e6%8b%a9 aria-hidden=true>#</a></h2><p>简单介绍下各个模式的有缺点。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt;&lt;&lt;&lt;&lt; ECB
</span></span><span class=line><span class=cl>优点
</span></span><span class=line><span class=cl>    简单
</span></span><span class=line><span class=cl>    快速
</span></span><span class=line><span class=cl>    支持并行计算（加密、解密）
</span></span><span class=line><span class=cl>缺点
</span></span><span class=line><span class=cl>    明文中的重复排列会反映在密文中
</span></span><span class=line><span class=cl>    通过删除、替换密文分组可以对明文进行操作
</span></span><span class=line><span class=cl>备注：不应使用
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;&lt;&lt;&lt;&lt; CBC
</span></span><span class=line><span class=cl>优点
</span></span><span class=line><span class=cl>    明文的重复排列不会反映在密文中
</span></span><span class=line><span class=cl>    支持并行计算（解密）
</span></span><span class=line><span class=cl>缺点
</span></span><span class=line><span class=cl>    加密不支持并行计算
</span></span><span class=line><span class=cl>备注：推荐使用
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;&lt;&lt;&lt;&lt; CFB
</span></span><span class=line><span class=cl>优点
</span></span><span class=line><span class=cl>    不需要填充
</span></span><span class=line><span class=cl>    支持并行计算（解密）
</span></span><span class=line><span class=cl>缺点
</span></span><span class=line><span class=cl>    加密不支持并行
</span></span><span class=line><span class=cl>备注：推荐使用CTR模式代替
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;&lt;&lt;&lt;&lt; OFB
</span></span><span class=line><span class=cl>优点
</span></span><span class=line><span class=cl>    不需要填充
</span></span><span class=line><span class=cl>    可事先进行加密、解密准备
</span></span><span class=line><span class=cl>    加解密使用相同结构
</span></span><span class=line><span class=cl>缺点
</span></span><span class=line><span class=cl>    不支持并行
</span></span><span class=line><span class=cl>备注：推荐使用CTR模式代替
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;&lt;&lt;&lt;&lt; CTR
</span></span><span class=line><span class=cl>优点
</span></span><span class=line><span class=cl>    不需要填充
</span></span><span class=line><span class=cl>    可事先进行加密、解密准备
</span></span><span class=line><span class=cl>    加解密使用相同结构
</span></span><span class=line><span class=cl>    支持并行计算（加密、解密）
</span></span><span class=line><span class=cl>备注：推荐使用
</span></span></code></pre></div><a class=anchor id=填充></a><h1>填充 <a href=#%e5%a1%ab%e5%85%85 aria-hidden=true>#</a></h1><p>对称加密要求输入明文长度必须是块长度的整数倍，当长度不满足的时候需要进行填充，其中使用比较多的有 <code>PKCS</code> <code>ISO10126</code> <code>Zero</code> 几种方式。</p><a class=anchor id=pkcs></a><h2>PKCS <a href=#pkcs aria-hidden=true>#</a></h2><p>一般使用的是 <code>PKCS#5</code> 和 <code>PKCS#7</code>，两者是同种填充算法，只是前者要求块大小是确定的 (16字节)，而后者不确定 (1~256)。</p><p>如果需要加密明文为块的整数倍，那么仍然需要填充一个完整的块，否则解密时会无法获取到实际 Padding 的长度。</p><p>例如，对于 <code>PKCS#5</code> 来说，现有 10 个字节，需要填充 (16-10=6) 个字节，而这 6 个字节填充的值，也就是其长度 <code>0x06</code> 。</p><a class=anchor id=iso-10126></a><h2>ISO 10126 <a href=#iso-10126 aria-hidden=true>#</a></h2><p>通过最后一个字节标示需要填充数据的长度，中间的都是随机数，这样的话加密更加具备迷惑性，这样也导致了如果是加密块整数倍的话需要多出来一个块。</p><a class=anchor id=zero-padding></a><h2>Zero-Padding <a href=#zero-padding aria-hidden=true>#</a></h2><p>这种方式比较适合于字符串的解密方式，获取的字符串不需要再进行 Padding 的逆向处理。</p><p>注意，如果是字符串，那么在计算长度时应该加上终止字符 <code>\0</code> 。</p><a class=anchor id=libgcrypt-编程></a><h1>libgcrypt 编程 <a href=#libgcrypt-%e7%bc%96%e7%a8%8b aria-hidden=true>#</a></h1><p>简单介绍常见的编程方式，详细内容可以参考官方文档 <a href=https://www.gnupg.org/documentation/manuals/gcrypt/index.html>The Libgcrypt Reference Manual</a>。</p><a class=anchor id=常用概念></a><h2>常用概念 <a href=#%e5%b8%b8%e7%94%a8%e6%a6%82%e5%bf%b5 aria-hidden=true>#</a></h2><a class=anchor id=初始化向量></a><h4>初始化向量 <a href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%90%91%e9%87%8f aria-hidden=true>#</a></h4><p><code>Initialization Vector, IV</code> 也就是用于开始随机化加密的一块数据，因此可以由相同的明文，相同的密钥产生不同的密文，而无需重新产生密钥。</p><p>一般来说 IV 无需保密，而且在同一密钥的情况下不要使用相同的 IV ，否则可能会导致不安全。</p><a class=anchor id=填充-1></a><h4>填充 <a href=#%e5%a1%ab%e5%85%85-1 aria-hidden=true>#</a></h4><p>块密码只能对指定长度的数据块进行处理，而消息的长度通常是可变的，因此部分模式 (ECB、CBC) 需要将最后一块在加密前进行填充，以满足特定长度的需求。</p><a class=anchor id=对称加密-1></a><h2>对称加密 <a href=#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86-1 aria-hidden=true>#</a></h2><p>也就是直接使用 libgcrypt 对称加密。</p><a class=anchor id=1-传入密钥></a><h4>1. 传入密钥 <a href=#1-%e4%bc%a0%e5%85%a5%e5%af%86%e9%92%a5 aria-hidden=true>#</a></h4><p>一般不会直接使用用户的输入直接作为密钥，而是通过一个密钥导出函数 (如PBKDF2) 生成，入参中有两个比较重要的函数：A) 输入密码，用户输入；B) 初始化向量，程序提供。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gpg_error_t gcry_kdf_derive ( const void *passphrase, size_t passphraselen,
</span></span><span class=line><span class=cl>        int algo, int subalgo, const void *salt, size_t saltlen,
</span></span><span class=line><span class=cl>        unsigned long iterations, size_t keysize, void *keybuffer );
</span></span><span class=line><span class=cl>参数主要包括四部分：
</span></span><span class=line><span class=cl>  1. passphrase, passphraselen  传入的密钥明文和长度
</span></span><span class=line><span class=cl>  2. algo, subalgo, iterations 使用的 Key Derivation Function (KDF) 算法，及其迭代次数
</span></span><span class=line><span class=cl>  3. salt, saltlen 加盐的盐串和长度
</span></span><span class=line><span class=cl>  4. keysize, keybuffer 用于保存生成密钥的缓存长度，以及返回密钥内容
</span></span></code></pre></div><a class=anchor id=2-初始化加密句柄></a><h4>2. 初始化加密句柄 <a href=#2-%e5%88%9d%e5%a7%8b%e5%8c%96%e5%8a%a0%e5%af%86%e5%8f%a5%e6%9f%84 aria-hidden=true>#</a></h4><p>在获得密钥之后，就需要对加密的句柄进行设置，在后续的所有操作中都会使用该句柄操作。</p><p>接着，需要选定加密算法，以及加密模式，在 libgcrypt 中，加密算法用宏来标识，需要传递指定的宏，来告知它想用哪种加密算法。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>size_t gcry_cipher_get_algo_keylen (int algo);
</span></span><span class=line><span class=cl>size_t gcry_cipher_get_algo_blklen (int algo);
</span></span><span class=line><span class=cl>gcry_error_t gcry_cipher_open (gcry_cipher_hd_t *hd, int algo, int mode, unsigned int flags);
</span></span><span class=line><span class=cl>gcry_error_t gcry_cipher_setkey (gcry_cipher_hd_t h, const void *k, size_t l);
</span></span><span class=line><span class=cl>gcry_error_t gcry_cipher_setiv (gcry_cipher_hd_t h, const void *k, size_t l);
</span></span></code></pre></div><p>这里需要注意的是，初始化向量一般是一个 Block Size，而后续准备加密的数据需要保证是 Block Size 的整数倍，否则会报错。</p><a class=anchor id=3-加解密></a><h4>3. 加解密 <a href=#3-%e5%8a%a0%e8%a7%a3%e5%af%86 aria-hidden=true>#</a></h4><p>接着就是通过如下函数加解密了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcry_error_t gcry_cipher_encrypt (gcry_cipher_hd_t h, unsigned char *out, size_t outsize,
</span></span><span class=line><span class=cl>             const unsigned char *in, size_t inlen)
</span></span><span class=line><span class=cl>gcry_error_t gcry_cipher_decrypt (gcry_cipher_hd_t h, unsigned char *out, size_t outsize,
</span></span><span class=line><span class=cl>             const unsigned char *in, size_t inlen)
</span></span></code></pre></div><a class=anchor id=其它></a><h1>其它 <a href=#%e5%85%b6%e5%ae%83 aria-hidden=true>#</a></h1><a class=anchor id=hmac></a><h2>HMAC <a href=#hmac aria-hidden=true>#</a></h2><p>HMAC 是密钥相关的哈希运算消息认证码，HMAC 运算时利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。</p><p>HMAC 的一个典型应用是用在 <code>Challenge/Response</code> 身份认证中，一般的处理流程如下：</p><ol><li>客户端向服务器发出一个验证请求。</li><li>服务器接到此请求后生成一个随机数并通过网络传输给客户端 (Challenge)。</li><li>客户端将收到的随机数与客户保存的密码做 HMAC-MD5 计算，并将结果作为认证证据传给服务器 (Response)。</li><li>服务器同样执行 HMSC-MD5 运算，与客户端传回的响应结果比较，如果相同则认为客户端是一个合法用户。</li></ol><a class=anchor id=参考></a><h1>参考 <a href=#%e5%8f%82%e8%80%83 aria-hidden=true>#</a></h1><ul><li>对各种密码保存方案的评估，例如安全性，可以直接参考 <a href=https://www.cs.ox.ac.uk/files/6487/pwvault.pdf>On The Security of Password Manager Database Formats</a> 。</li><li>Padding 标准 <a href=https://tools.ietf.org/html/rfc2898>PKCS #5</a> <a href=https://tools.ietf.org/html/rfc2315>PKCS #7</a> <a href=https://tools.ietf.org/html/rfc2313>PKCS #1: RSA Encryption</a> 。</li></ul></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#对称加密>对称加密</a><ul><li><a href=#xor>XOR</a></li><li><a href=#rc4>RC4</a></li><li><a href=#des>DES</a></li><li><a href=#blowfish>Blowfish</a></li></ul></li><li><a href=#工作模式>工作模式</a><ul><li><a href=#ecb-模式>ECB 模式</a></li><li><a href=#cbc-模式>CBC 模式</a></li><li><a href=#cfb-模式>CFB 模式</a></li><li><a href=#ofb-模式>OFB 模式</a></li><li><a href=#ctr-模式>CTR 模式</a></li><li><a href=#模式选择>模式选择</a></li></ul></li><li><a href=#填充>填充</a><ul><li><a href=#pkcs>PKCS</a></li><li><a href=#iso-10126>ISO 10126</a></li><li><a href=#zero-padding>Zero-Padding</a></li></ul></li><li><a href=#libgcrypt-编程>libgcrypt 编程</a><ul><li><a href=#常用概念>常用概念</a></li><li><a href=#对称加密-1>对称加密</a></li></ul></li><li><a href=#其它>其它</a><ul><li><a href=#hmac>HMAC</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>