<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Nginx 日志解析 | GoHalo</title><link rel=apple-touch-icon sizes=180x180 href=https://gohalo.github.io/favicon/apple-touch-icon.png><link rel=icon href=https://gohalo.github.io/favicon/favicon.ico sizes=any><link rel=icon type=image/png sizes=32x32 href=https://gohalo.github.io/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://gohalo.github.io/favicon/favicon-16x16.png><link rel=manifest crossorigin=use-credentials href=https://gohalo.github.io/favicon/site.webmanifest><meta name=robots content="index, follow"><meta name=googlebot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=bingbot content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1"><meta name=google-site-verification content="p7jJ5d3kF9yxRhpIo5GgHXAZ1ATKVyZhV2kf6mEGOv0"><meta name=description content="在 Nginx 的统计排错过程中，通常要依赖日志，Nginx 有非常灵活的日志记录模式，每个级别的配置可以有各自独立的访问日志。
"><link rel=stylesheet href=https://gohalo.github.io/font-awesome/css/font-awesome.min.css><link rel=stylesheet href=/css/syntax.min.c70103877c799b924f50023b6b01eca010d7e2808885a74f9ea662cc47379ae1.css integrity="sha256-xwEDh3x5m5JPUAI7awHsoBDX4oCIhadPnqZizEc3muE=" crossorigin=anonymous><link rel=stylesheet href=/css/main.min.c4814ac9dc5fab259f313a787ded4f8e.css integrity="md5-xIFKydxfqyWfMTp4fe1Pjg==" crossorigin=anonymous><style type=text/css>.main p{text-indent:2em}.main li p{text-indent:0}</style><noscript><style>img.lazyload{display:none}</style></noscript></head><body><div class=sticky-top><div class=header-bar></div><nav class="navbar navbar-expand-lg navbar-light bg-light"><div class="container-xxl flex-wrap flex-lg-nowrap" aria-label="Main navigation"><a class="navbar-brand order-0" href=/cn aria-label=GoHalo>GoHalo</a>
<button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav me-auto mb-2 mb-lg-0"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-bs-toggle=dropdown aria-expanded=false>项目</a><ul class=dropdown-menu aria-labelledby=navbarDropdown><li><a class=dropdown-item href=/cn/project/bastion/>Bastion</a></li><li><a class="dropdown-item disabled" href=/cn/project/bootserver/>BootServer</a></li></ul></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/>博客</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/archives/>归档</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/blog/tags/>标签</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/slide/>幻灯片</a></li><li class=nav-item><a class=nav-link aria-current=page href=/cn/docs/>文档</a></li></ul><hr class="text-black-50 my-4 d-lg-none"><div class=dropdown><button class="btn dropdown-toggle" id=header-languages data-bs-toggle=dropdown aria-expanded=false data-bs-display=static>
中文</button><ul class="dropdown-menu dropdown-menu-lg-end me-lg-2 shadow rounded border-0" aria-labelledby=header-languages><li><a class=dropdown-item rel=alternate href=https://gohalo.github.io/en hreflang=en lang=en>English</a></li></ul></div><ul class="nav flex-column flex-lg-row"><li class=nav-item><a class="nav-link social-link" href=/cn/about><i class="fa fa-user" aria-hidden=true></i></a></li><li class=nav-item><a class="nav-link social-link" href=https://github.com/gohalo title=GitHub><i class="fa fa-github-alt" aria-hidden=true></i></a></li><li class=nav-item><button id=mode class="btn nav-link social-link" type=button aria-label="Toggle user interface mode">
<span class=toggle-dark><i class="fa fa-star" aria-hidden=true></i></span>
<span class=toggle-light><i class="fa fa-cog" aria-hidden=true></i></span></button></li></ul></div></div></nav></div><div class="main container-xxl" role=document><div class="blog row"><div class="col-md-12 col-xl-9 mt-4"><div class=header><h1>Nginx 日志解析</h1><div class="meta mb-3"><i class="fa fa-calendar" aria-hidden=true></i>
<span class=mx-2>2016-04-27</span>
<i class="fa fa-tags" aria-hidden=true></i>
<a class=text-body href=https://gohalo.github.io/cn/tags/linux/ role=button>linux</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/web/ role=button>web</a>
<a class=text-body href=https://gohalo.github.io/cn/tags/software/ role=button>software</a></div></div><hr><div class=content><p>在 Nginx 的统计排错过程中，通常要依赖日志，Nginx 有非常灵活的日志记录模式，每个级别的配置可以有各自独立的访问日志。</p><a class=anchor id=简介></a><h1>简介 <a href=#%e7%ae%80%e4%bb%8b aria-hidden=true>#</a></h1><p>其中与日志模块相关的参数如下，在 CentOS 中，日志默认保存在 <code>/usr/local/nginx/logs</code> 目录下。</p><a class=anchor id=访问日志></a><h2>访问日志 <a href=#%e8%ae%bf%e9%97%ae%e6%97%a5%e5%bf%97 aria-hidden=true>#</a></h2><p>实际上这里的配置通过 <a href=http://nginx.org/en/docs/http/ngx_http_log_module.html>ngx_http_log_module</a> 实现，记录了哪些用户，哪些页面以及用户浏览器、IP 和其他的访问信息。</p><p>常见的配置项包括了 <code>access_log</code>、<code>log_format</code>、<code>open_log_file_cache</code> 。</p><p>其中 <code>log_format</code> 记录了日志的记录格式；<code>access_log</code> 用于设置保存的路径、是否压缩、缓冲的大小等信息；而最后一个其实是对写入日志的优化。</p><a class=anchor id=access_log></a><h3>access_log <a href=#access_log aria-hidden=true>#</a></h3><p>可以将 path 设置为 syslog 将日志保存到系统日志中，不过其默认是保存到单独的日志文件中，默认的配置如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>----- 语法格式如下
</span></span><span class=line><span class=cl>access_log path format gzip[=level] [buffer=size] [flush=time];
</span></span><span class=line><span class=cl>access_log syslog:server=address[,parameter=value] [format];
</span></span><span class=line><span class=cl>access_log off;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 默认配置为
</span></span><span class=line><span class=cl>access_log logs/access.log combined;
</span></span></code></pre></div><p>其中 gzip 表示压缩等级；buffer 用来设置内存缓存区大小；flush 为保存在缓存区中的最长时间。</p><a class=anchor id=log_format></a><h3>log_format <a href=#log_format aria-hidden=true>#</a></h3><p>其配置格式为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>log_format name string;
</span></span></code></pre></div><p>其中，name 表示该配置格式的名称；string 表示定义格式的内容。其中该模块中有一个默认的无需配置名称为 combined 的日志格式，相当于 apache 的 combined 日志格式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>log_format combined &#39;$remote_addr - $remote_user  [$time_local]  &#39;
</span></span><span class=line><span class=cl>                    &#39; &#34;$request&#34;  $status  $body_bytes_sent  &#39;
</span></span><span class=line><span class=cl>                    &#39; &#34;$http_referer&#34;  &#34;$http_user_agent&#34; &#39;;
</span></span></code></pre></div><p>如果 Nginx 位于负载均衡器 squid，或者 Nginx 反向代理之后，那么 web 服务器中的 $remote_addr 实际上获取的是反向代理的 IP 地址，将无法直接获取到客户端真实的 IP 地址。</p><p>为此，反向代理服务器在转发请求的 http 头信息中，可以增加 X-Forwarded-For 信息，用来记录客户端 IP 地址和客户端请求的服务器地址。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>log_format  porxy  &#39;$http_x_forwarded_for - $remote_user  [$time_local]  &#39;
</span></span><span class=line><span class=cl>                   &#39; &#34;$request&#34;  $status $body_bytes_sent &#39;
</span></span><span class=line><span class=cl>                   &#39; &#34;$http_referer&#34;  &#34;$http_user_agent&#34; &#39;;
</span></span></code></pre></div><p>其中对应各个参数分别代表的值可以参考 <a href=http://nginx.org/en/docs/http/ngx_http_log_module.html>ngx_http_log_module</a> 中的介绍。</p><a class=anchor id=open_log_file_cache></a><h3>open_log_file_cache <a href=#open_log_file_cache aria-hidden=true>#</a></h3><p>对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭；这样就会导致文件被频繁的打开关闭，可以使用 open_log_file_cache 设置日志文件缓存。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];
</span></span><span class=line><span class=cl>open_log_file_cache off;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>----- 示例
</span></span><span class=line><span class=cl>open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
</span></span></code></pre></div><a class=anchor id=错误日志></a><h2>错误日志 <a href=#%e9%94%99%e8%af%af%e6%97%a5%e5%bf%97 aria-hidden=true>#</a></h2><p><code>error_log</code> 则是记录服务器错误日志。</p><a class=anchor id=源码解析></a><h1>源码解析 <a href=#%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90 aria-hidden=true>#</a></h1><p>在 nginx 中，会通过 <code>ngx_errlog_module</code> 模块用于处理 nginx 日志信息，这也是 nginx 的 core 模块之一。</p><p>在配置文件中，会通过解析 <code>error_log</code> 配置项将不同等级的日志信息输出到指定的文件中，当遇到该配置项是，就调用 errlog 模块的 <code>ngx_error_log()</code> 来解析。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ngx_error_log()
</span></span></code></pre></div><p>上述函数会将 <code>error_log</code> 配置项的值保存在 <code>ngx_cycle->new_log</code> 成员中，当配置文件中有多条 <code>error_log</code> 配置项生效时，会通过 <code>ngx_cycle->new_log.next</code> 成员将它们组织起来。</p><p>如果配置文件中没有 <code>error_log</code> 配置项，在配置文件解析完后调用 <code>errlog</code> 模块的 <code>ngx_log_open_default()</code> 将日志等级默认置为 <code>NGX_LOG_ERR</code>，日志文件设置为 <code>NGX_ERROR_LOG_PATH</code> (编译时指定)。</p><a class=anchor id=日志结构体></a><h2>日志结构体 <a href=#%e6%97%a5%e5%bf%97%e7%bb%93%e6%9e%84%e4%bd%93 aria-hidden=true>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>ngx_log_s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>ngx_uint_t</span>           <span class=n>log_level</span><span class=p>;</span>          <span class=c1>// 日志等级
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>ngx_open_file_t</span>     <span class=o>*</span><span class=n>file</span><span class=p>;</span>               <span class=c1>// 记录日志文件信息
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>ngx_atomic_uint_t</span>    <span class=n>connection</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>time_t</span>               <span class=n>disk_full_time</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ngx_log_handler_pt</span>   <span class=n>handler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span>                <span class=o>*</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ngx_log_writer_pt</span>    <span class=n>writer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span>                <span class=o>*</span><span class=n>wdata</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>                <span class=o>*</span><span class=n>action</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>ngx_log_t</span>           <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>一般通过 <code>ngx_log_error()</code> 函数输出日志信息。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=n>ngx_cdecl</span> <span class=nf>ngx_log_error</span><span class=p>(</span><span class=kt>ngx_uint_t</span> <span class=n>level</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=kt>ngx_log_t</span> <span class=o>*</span><span class=n>log</span><span class=p>,</span> <span class=kt>ngx_err_t</span> <span class=n>err</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>fmt</span><span class=p>,</span> <span class=p>...)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>va_list</span>  <span class=n>args</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>log</span><span class=o>-&gt;</span><span class=n>log_level</span> <span class=o>&gt;=</span> <span class=n>level</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// 根据日志等级判断是否需要输出
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>va_start</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=n>fmt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>ngx_log_error_core</span><span class=p>(</span><span class=n>level</span><span class=p>,</span> <span class=n>log</span><span class=p>,</span> <span class=n>err</span><span class=p>,</span> <span class=n>fmt</span><span class=p>,</span> <span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=nf>va_end</span><span class=p>(</span><span class=n>args</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ngx_log_error_core</span><span class=p>(</span><span class=kt>ngx_uint_t</span> <span class=n>level</span><span class=p>,</span> <span class=kt>ngx_log_t</span> <span class=o>*</span><span class=n>log</span><span class=p>,</span> <span class=kt>ngx_err_t</span> <span class=n>err</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>fmt</span><span class=p>,</span> <span class=n>va_list</span> <span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=cm>/* ... ... */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* 格式化日志内容 */</span>
</span></span><span class=line><span class=cl>	<span class=n>last</span> <span class=o>=</span> <span class=n>errstr</span> <span class=o>+</span> <span class=n>NGX_MAX_ERROR_STR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>p</span> <span class=o>=</span> <span class=nf>ngx_cpymem</span><span class=p>(</span><span class=n>errstr</span><span class=p>,</span> <span class=n>ngx_cached_err_log_time</span><span class=p>.</span><span class=n>data</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		       <span class=n>ngx_cached_err_log_time</span><span class=p>.</span><span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>p</span> <span class=o>=</span> <span class=nf>ngx_slprintf</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>last</span><span class=p>,</span> <span class=s>&#34; [%V] &#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>err_levels</span><span class=p>[</span><span class=n>level</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=cm>/* 写入日志 */</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=p>(</span><span class=n>log</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>log</span><span class=o>-&gt;</span><span class=n>log_level</span> <span class=o>&lt;</span> <span class=n>level</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>debug_connection</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>log</span><span class=o>-&gt;</span><span class=n>writer</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>log</span><span class=o>-&gt;</span><span class=nf>writer</span><span class=p>(</span><span class=n>log</span><span class=p>,</span> <span class=n>level</span><span class=p>,</span> <span class=n>errstr</span><span class=p>,</span> <span class=n>p</span> <span class=o>-</span> <span class=n>errstr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=k>goto</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=nf>ngx_time</span><span class=p>()</span> <span class=o>==</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>disk_full_time</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>			 * on FreeBSD writing to a full filesystem with enabled softupdates
</span></span></span><span class=line><span class=cl><span class=cm>			 * may block process for much longer time than writing to non-full
</span></span></span><span class=line><span class=cl><span class=cm>			 * filesystem, so we skip writing to a log for one second
</span></span></span><span class=line><span class=cl><span class=cm>			 */</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>goto</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>n</span> <span class=o>=</span> <span class=nf>ngx_write_fd</span><span class=p>(</span><span class=n>log</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>fd</span><span class=p>,</span> <span class=n>errstr</span><span class=p>,</span> <span class=n>p</span> <span class=o>-</span> <span class=n>errstr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>ngx_errno</span> <span class=o>==</span> <span class=n>NGX_ENOSPC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>log</span><span class=o>-&gt;</span><span class=n>disk_full_time</span> <span class=o>=</span> <span class=nf>ngx_time</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span> <span class=p>(</span><span class=n>log</span><span class=o>-&gt;</span><span class=n>file</span><span class=o>-&gt;</span><span class=n>fd</span> <span class=o>==</span> <span class=n>ngx_stderr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>wrote_stderr</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>next</span><span class=p>:</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>log</span> <span class=o>=</span> <span class=n>log</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><a class=anchor id=原子写入></a><h1>原子写入 <a href=#%e5%8e%9f%e5%ad%90%e5%86%99%e5%85%a5 aria-hidden=true>#</a></h1><p>实际上，这里会存在一个疑问，多进程的 nginx 模型是怎么保证多个进程同时写入一个文件不发生数据交错呢？</p><p>一般来说，主要有如下的几种解决方案：</p><ul><li>通过锁保证只有一个进程写入，其他进程等待，但是这种情况效率太低。</li><li>写日志前查看锁状态，如果已经锁定，则写入进程自己的缓冲区中，等待下次调用时同步缓冲区，这样做的好处是无需阻塞，提高了效率，但是就无法做到 log 的实时了，这样做工程中也是绝对无法接受的，一旦发生问题，将无法保证 log 是否已经被写入，因此很难定位。</li><li>一个进程专门负责写 log，其他进程通过套接字或者管道将 log 内容发送给他，持续阻塞在 epoll_wait 上，直到收到信息，立即写入，但是众所周知，nginx 是调用同一个函数启动所有进程的，并没有专门调用函数启动所谓的 log 进程，除了 master 和 worker，nginx 也确实没有 log 进程存在。</li><li>进程启动后，全部去竞争某个锁，竞争到该锁的 worker 执行 log worker 的代码，其余的 worker 继续运行相应程序，这个方案看上去是一个不错的方案，如果是单 worker 的话，那么就无需去使用该锁即可。</li></ul><p>阅读源码可以发现 nginx 只有一把互斥锁，即用来避免惊群现象的 <code>ngx_accept_mutex</code> 锁，其余地方完全没有用到锁机制，这么做原因很简单，在工程化的代码中，盲目使用锁会造成性能的下降，这是不可以接受的。</p><p>如上，最终写入日志的是通过 <code>ngx_log_error_core()</code> 函数，这个函数正是用来打印错误日志的，而最终调用的实际上就是：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static ngx_inline ssize_t ngx_write_fd(ngx_fd_t fd, void *buf, size_t n)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    return write(fd, buf, n);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><a class=anchor id=写入原理></a><h2>写入原理 <a href=#%e5%86%99%e5%85%a5%e5%8e%9f%e7%90%86 aria-hidden=true>#</a></h2><p>如果多个进程都需要将数据添加到某一文件，那么为了保证定位和写数据这两步是一个原子操作，需要在打开文件时设置 <code>O_APPEND</code> 标志。</p><p>Single UNIX Specification 标准对此进行了详细的说明，内核在调用 write 前会对文件进行加锁，在调用 write 后会对文件进行解锁，这样保证了文件写入的原子性，也就无需担心数据交错的发生了。</p><p>实际上，对于不同类型的文件实现方式会有所区别。</p><a class=anchor id=普通文件></a><h3>普通文件 <a href=#%e6%99%ae%e9%80%9a%e6%96%87%e4%bb%b6 aria-hidden=true>#</a></h3><p>有三种情况可能导致文件写入失败：</p><ul><li>磁盘已满</li><li>写入文件大小超出系统限制</li><li>内核高速缓存区已满</li></ul><p>遇到这三种情况怎么处理呢？</p><p>如果是使用 <code>O_NONBLOCK</code> 标识打开文件的话，write 会立即返回，返回值小于写入字符数这个参数，虽然写入了不完整数据，但是内核保证其写入过程的原子性，否则内核会让调用进程睡眠，直到文件重新可写，这样内核保证了写入数据的完整性，但是不保证写入的原子性。</p><p>也即，如果在打开文件时设置了 <code>O_NONBLOCK</code> 标识，则虽然可能写入部分数据，但是写入过程是原子性的。</p><p>Linux 系统默认使用 <code>O_NONBLOCK</code> 标识打开文件，而 BSD 等 unix 系统则恰恰相反。</p><a class=anchor id=总结></a><h2>总结 <a href=#%e6%80%bb%e7%bb%93 aria-hidden=true>#</a></h2><p>对于写入普通文件，只要文件是使用 <code>O_NONBLOCK</code> 标识打开的，那么就可以保证其写入的原子性，也就是说这样写入是可以接受的，但是这并不意味着这样做是靠谱的，这样做依然可能无法成功写入全部数据。</p><p>然而，nginx 并没有对返回结果进行判断，他并不关心是否写入成功，这显然是不严谨的，但是作为一个工程化项目，这是不得不进行的妥协。</p></div></div><div class="sidebar col-xl-3 mt-2"><div id=toc class=position-fixed><nav id=TableOfContents><ul><li><a href=#简介>简介</a><ul><li><a href=#访问日志>访问日志</a></li><li><a href=#错误日志>错误日志</a></li></ul></li><li><a href=#源码解析>源码解析</a><ul><li><a href=#日志结构体>日志结构体</a></li></ul></li><li><a href=#原子写入>原子写入</a><ul><li><a href=#写入原理>写入原理</a></li><li><a href=#总结>总结</a></li></ul></li></ul></nav></div></div></div></div><footer class="footer text-muted"><div class=container-xxl><div class=row><div class=text-center>Built by GoHalo, generated with <a class=text-muted href=https://gohugo.io>Hugo</a>, and hosted on GitHub Pages</div></div><div class=row><div class=text-center>Copyright © 2013-2025 GoHalo. All Rights Reserved.</div></div></div></footer><script src=https://gohalo.github.io/bootstrap/js/bootstrap.bundle.min.js></script>
<script src=/main.b9cbcb174709877512d64e24f297f66a40c8d91c9a81128cb04bdd7b10247df8.js integrity="sha256-ucvLF0cJh3US1k4k8pf2akDI2RyagRKMsEvdexAkffg=" crossorigin=anonymous></script>
<a href=# class="btn btn-light btn-lg backtop" title=返回顶部><i class="fa fa-angle-double-up" aria-hidden=true></i></a></body></html>